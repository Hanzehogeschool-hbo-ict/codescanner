import { PluginKey, Plugin } from 'prosemirror-state';
import { uniqueArray, includes } from '@remirror/core-helpers';

var trailingNodePluginKey = new PluginKey('trailingNode');
/**
 * This creates the plugin for trailing node.
 *
 * ```ts
 * import { schema } from 'prosemirror-schema-basic';
 * import { trailingNode } from 'prosemirror-trailing-node';
 *
 * // Include the plugin in the created editor state.
 * const state = EditorState.create({
 *   schema,
 *   plugins: [trailingNode({ ignoredNodes: [], nodeName: 'paragraph' })],
 * });
 * ```
 *
 * @param options - the options that can be provided to this plugin.
 */

function trailingNode(options) {
  var _ref = options !== null && options !== void 0 ? options : {},
      _ref$ignoredNodes = _ref.ignoredNodes,
      ignoredNodes = _ref$ignoredNodes === void 0 ? [] : _ref$ignoredNodes,
      _ref$nodeName = _ref.nodeName,
      nodeName = _ref$nodeName === void 0 ? 'paragraph' : _ref$nodeName; // The names of the nodes for which this rule should not be applied.


  var ignoredNodeNames = uniqueArray([...ignoredNodes, nodeName]); // The node that will be inserted when the criteria match.

  var type; // The list of nodes for this schema that should have content injected after
  // them.

  var types;
  return new Plugin({
    key: trailingNodePluginKey,

    appendTransaction(_, __, state) {
      var doc = state.doc,
          tr = state.tr;
      var shouldInsertNodeAtEnd = trailingNodePluginKey.getState(state);
      var endPosition = doc.content.size;

      if (!shouldInsertNodeAtEnd) {
        return;
      }

      return tr.insert(endPosition, type.create());
    },

    state: {
      init: (_, _ref2) => {
        var _doc$lastChild;

        var doc = _ref2.doc,
            schema = _ref2.schema;
        var nodeType = schema.nodes[nodeName];

        if (!nodeType) {
          throw new Error("Invalid node being used for trailing node extension: '".concat(nodeName, "'"));
        } // Save the type for continued use.


        type = nodeType;
        types = Object.values(schema.nodes).map(node => node).filter(node => !ignoredNodeNames.includes(node.name));
        return includes(types, (_doc$lastChild = doc.lastChild) === null || _doc$lastChild === void 0 ? void 0 : _doc$lastChild.type);
      },
      apply: (tr, value) => {
        var _tr$doc$lastChild;

        if (!tr.docChanged) {
          return value;
        }

        return includes(types, (_tr$doc$lastChild = tr.doc.lastChild) === null || _tr$doc$lastChild === void 0 ? void 0 : _tr$doc$lastChild.type);
      }
    }
  });
}

export { trailingNode };
