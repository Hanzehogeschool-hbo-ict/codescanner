'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var coreConstants = require('@remirror/core-constants');
var coreHelpers = require('@remirror/core-helpers');

var _excluded = ["state", "dispatch", "view", "tr"];

/**
 * Creates a fake state that can be used on ProseMirror library commands to make
 * them chainable. The provided Transaction `tr` can be a shared one.
 *
 * @param tr - the chainable transaction that should be amended.
 * @param state - the state of the editor (available via `view.state`).
 *
 * This should not be used other than for passing to `prosemirror-*` library
 * commands.
 */
function chainableEditorState(tr, state) {
  // Get the prototype of the state which is used to allow this chainable editor
  // state to pass `instanceof` checks.
  var proto = Object.getPrototypeOf(state); // Every time the `state.tr` property is accessed these values are updated to
  // reflect the current `transaction` value for the doc, selection and
  // storedMarks. This way they can be mostly be constant within the scope of
  // the command this state is used in.

  var selection = tr.selection;
  var doc = tr.doc;
  var storedMarks = tr.storedMarks; // Container for the enumerable properties on the current state object.

  var properties = coreHelpers.object();

  for (var _i = 0, _Object$entries = Object.entries(state); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    // Store the enumerable state value.
    properties[key] = {
      value
    };
  }

  return Object.create(proto, _objectSpread(_objectSpread({}, properties), {}, {
    storedMarks: {
      get() {
        return storedMarks;
      }

    },
    selection: {
      get() {
        return selection;
      }

    },
    doc: {
      get() {
        return doc;
      }

    },
    tr: {
      get() {
        selection = tr.selection;
        doc = tr.doc;
        storedMarks = tr.storedMarks;
        return tr;
      }

    }
  }));
}
/**
 * Wraps the default [[ProsemirrorCommandFunction]] and makes it compatible with
 * the default **remirror** [[CommandFunction]] call signature.
 *
 * It extracts all the public APIs of the state object and assigns the
 * chainable transaction to the `state.tr` property to support chaining.
 */

function convertCommand(commandFunction) {
  return _ref => {
    var state = _ref.state,
        dispatch = _ref.dispatch,
        view = _ref.view,
        tr = _ref.tr;
    return commandFunction(chainableEditorState(tr, state), dispatch, view);
  };
}
/**
 * Marks a command function as non chainable. It will throw an error when
 * chaining is attempted.
 *
 * @remarks
 *
 * ```ts
 * const command = nonChainable(({ state, dispatch }) => {...});
 * ```
 */

function nonChainable(commandFunction) {
  return props => {
    var _props$view;

    !(props.dispatch === undefined || props.dispatch === ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch)) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.NON_CHAINABLE_COMMAND
    }) : coreHelpers.invariant(false) : void 0;
    return commandFunction(props);
  };
}
/**
 * Similar to the chainCommands from the `prosemirror-commands` library. Allows
 * multiple commands to be chained together and runs until one of them returns
 * true.
 */

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return _ref2 => {
    var state = _ref2.state,
        dispatch = _ref2.dispatch,
        view = _ref2.view,
        tr = _ref2.tr,
        rest = _objectWithoutProperties(_ref2, _excluded);

    var _iterator = _createForOfIteratorHelper(commands),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;

        if (element(_objectSpread({
          state,
          dispatch,
          view,
          tr
        }, rest))) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  };
}

exports.chainCommands = chainCommands;
exports.chainableEditorState = chainableEditorState;
exports.convertCommand = convertCommand;
exports.nonChainable = nonChainable;
