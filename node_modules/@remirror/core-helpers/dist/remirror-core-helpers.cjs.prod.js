'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var makeError = require('make-error');
var coreConstants = require('@remirror/core-constants');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var core = require('@linaria/core');
var deepmerge = require('deepmerge');
var fastDeepEqual = require('fast-deep-equal');
var omit = require('object.omit');
var object_pick = require('object.pick');
var caseAnything = require('case-anything');
var throttleDebounce = require('throttle-debounce');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var deepmerge__default = /*#__PURE__*/_interopDefault(deepmerge);
var fastDeepEqual__default = /*#__PURE__*/_interopDefault(fastDeepEqual);
var omit__default = /*#__PURE__*/_interopDefault(omit);
var object_pick__default = /*#__PURE__*/_interopDefault(object_pick);

/**
 * Type cast an argument. If no type is provided it will default to any.
 *
 * @param arg - the arg to typecast
 */
function Cast(value) {
  return value;
}
/**
 * Get the key from a given value. Throw an error if the referenced property is
 * `undefined`.
 */

function assertGet(value, key, message) {
  var prop = value[key];
  assert(!isUndefined(prop), message);
  return prop;
}
/**
 * Assert the value is `truthy`. Good for defensive programming, especially
 * after enabling `noUncheckedIndexedAccess` in the tsconfig `compilerOptions`.
 */

function assert(testValue, message) {
  if (!testValue) {
    throw new AssertionError(message);
  }
}

class AssertionError extends makeError.BaseError {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'AssertionError');
  }

}
/**
 * A typesafe implementation of `Object.entries()`
 *
 * Taken from
 * https://github.com/biggyspender/ts-entries/blob/master/src/ts-entries.ts
 */


function entries(value) {
  return Object.entries(value);
}
/**
 * A typesafe implementation of `Object.keys()`
 */

function keys(value) {
  return Object.keys(value);
}
/**
 * A typesafe implementation of `Object.values()`
 */

function values(value) {
  return Object.values(value);
}
/**
 * A more lenient typed version of `Array.prototype.includes` which allow less
 * specific types to be checked.
 */

function includes(array, item, fromIndex) {
  return array.includes(item, fromIndex);
}
/**
 * Creates an object with the null prototype.
 *
 * @param value - the object to create
 */

function object(value) {
  return Object.assign(Object.create(null), value);
}
/**
 * A type name matcher for object types.
 *
 * @private
 */

var TypeName;
/**
 * Alias of toString for non-dom environments.
 *
 * This is a safe way of calling `toString` on objects created with
 * `Object.create(null)`.
 */

(function (TypeName) {
  TypeName["Object"] = "Object";
  TypeName["RegExp"] = "RegExp";
  TypeName["Date"] = "Date";
  TypeName["Promise"] = "Promise";
  TypeName["Error"] = "Error";
  TypeName["Map"] = "Map";
  TypeName["Set"] = "Set";
})(TypeName || (TypeName = {}));

function toString(value) {
  return Object.prototype.toString.call(value);
}
/**
 * Retrieve the object type of a value via it's string reference. This is safer
 * than relying on instanceof checks which fail on cross-frame values.
 *
 * @param value - the object to inspect
 */

function getObjectType(value) {
  var objectName = toString(value).slice(8, -1);
  return objectName;
}
/**
 * A helper for building type predicates
 *
 * @param type -  the name of the type to check for
 * @returns a predicate function for checking the value type
 */


function isOfType(type, predicate) {
  return value => {
    if (typeof value !== type) {
      return false;
    }

    return predicate ? predicate(value) : true;
  };
}
/**
 * Get the object type of passed in value. This avoids the reliance on
 * `instanceof` checks which are subject to cross frame issues as outlined in
 * this link https://bit.ly/1Qds27W
 *
 * @param type - the name of the object type to check for
 *
 * @private
 */


function isObjectOfType(type) {
  return value => getObjectType(value) === type;
}
/**
 * Check if an instance is the direct instance of the provided class.
 */


function isDirectInstanceOf(instance, Constructor) {
  return Object.getPrototypeOf(instance) === Constructor.prototype;
}
/**
 * Predicate check that value is undefined
 *
 * @param value - the value to check
 *
 */

var isUndefined = isOfType('undefined');
/**
 * Predicate check that value is a string
 *
 * @param value - the value to check
 *
 */

var isString = isOfType('string');
/**
 * Predicate check that value is a number.
 *
 * Also by default doesn't include NaN as a valid number.
 *
 * @param value - the value to check
 *
 */

var isNumber = isOfType('number', value => {
  return !Number.isNaN(value);
});
/**
 * Predicate check that value is a function
 *
 * @param value - the value to check
 *
 */

var isFunction = isOfType('function');
/**
 * Predicate check that value is null
 *
 * @param value - the value to check
 *
 */

function isNull(value) {
  return value === null;
}
/**
 * Predicate check that value is a class
 *
 * @deprecated Due to the current build process stripping out classes
 *
 * @param value - the value to check
 *
 */

function isClass(value) {
  return isFunction(value) && value.toString().startsWith('class ');
}
/**
 * Predicate check that value is boolean
 *
 * @param value - the value to check
 *
 */

function isBoolean(value) {
  return value === true || value === false;
}
/**
 * Predicate check that value is a symbol
 *
 * @param value - the value to check
 *
 */

var isSymbol = isOfType('symbol');
/**
 * Helper function for Number.isInteger check allowing non numbers to be tested
 *
 * @param value - the value to check
 *
 */

function isInteger(value) {
  return Number.isInteger(value);
}
/**
 * Helper function for Number.isSafeInteger allowing for unknown values to be
 * tested
 *
 * @param value - the value to check
 *
 */

function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
/**
 * Predicate check for whether passed in value is a plain object
 *
 * @param value - the value to check
 *
 */

function isPlainObject(value) {
  if (getObjectType(value) !== TypeName.Object) {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
}
/**
 * Predicate check for whether passed in value is a primitive value
 */

function isPrimitive(value) {
  return value == null || /^[bns]/.test(typeof value);
}
/**
 * Predicate check for whether passed in value is a JSON primitive value
 */

function isJSONPrimitive(value) {
  return value === null || ['boolean', 'number', 'string'].includes(typeof value);
}
/**
 * Utility predicate check that value is either null or undefined
 *
 * @param value - the value to check
 *
 */

function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
/**
 * Predicate check that value is an object.
 *
 * @param value - the value to check
 *
 */

function isObject(value) {
  return !isNullOrUndefined(value) && (isFunction(value) || isOfType('object')(value));
}
/**
 * A shorthand method for creating instance of checks.
 */

function isInstanceOf(Constructor) {
  return value => isObject(value) && value instanceof Constructor;
}
/**
 * Predicate check that value is a native promise
 *
 * @param value - the value to check
 *
 */

function isNativePromise(value) {
  return isObjectOfType(TypeName.Promise)(value);
}
/**
 * Check to see if a value has the built in promise API.
 *
 * @param value - the value to check
 *
 */

var hasPromiseAPI = value => {
  return !!(!isNull(value) && isObject(value) && isFunction(value.then) && isFunction(value.catch));
};
/**
 * Predicate check that value has the promise api implemented
 *
 * @param value - the value to check
 *
 */


function isPromise(value) {
  return isNativePromise(value) || hasPromiseAPI(value);
}
/**
 * Predicate check that value is a RegExp
 *
 * @param value - the value to check
 *
 */

var isRegExp = isObjectOfType(TypeName.RegExp);
/**
 * Predicate check that value is a date
 *
 * @param value - the value to check
 *
 */

var isDate = isObjectOfType(TypeName.Date);
/**
 * Predicate check that value is an error
 *
 * @param value - the value to check
 *
 */

var isError = isObjectOfType(TypeName.Error);
/**
 * Predicate check that value is a `Map`
 *
 * @param value - the value to check
 *
 */

function isMap(value) {
  return isObjectOfType(TypeName.Map)(value);
}
/**
 * Predicate check that value is a `Set`
 *
 * @param value - the value to check
 *
 */

function isSet(value) {
  return isObjectOfType(TypeName.Set)(value);
}
/**
 * Predicate check that value is an empty object
 *
 * @param value - the value to check
 *
 */

function isEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
/**
 * Alias the isArray method.
 */

var isArray = Array.isArray;
/**
 * Predicate check that value is an empty array
 *
 * @param value - the value to check
 *
 */

function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
/**
 * Predicate check that value is a non-empty.
 *
 * @param value - the value to check
 *
 */

function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
/**
 * Capitalizes a string value.
 *
 * @param str - the string to capitalize.
 */

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * Trim and conditionally capitalize string values.
 *
 * @param str - the string to format.
 *
 */

function format(value) {
  value = value.trim();
  return /^(?:webOS|i(?:OS|P))/.test(value) ? value : capitalize(value);
}
/**
 * Calls a function if defined and provides compile time type checking for the
 * passed in parameters.
 *
 * @param fn - the function to call if it exists
 * @param args - the rest of the parameters with types
 */

function callIfDefined(fn) {
  if (isFunction(fn)) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn(...args);
  }
}
/**
 * Finds all the regex matches for a string
 *
 * @param text - the text to check against
 * @param regexp - the regex (which should include a 'g' flag)
 *
 */

function findMatches(text, regexp) {
  var runWhile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : match => !!match;
  regexp.lastIndex = 0;
  var results = [];
  var flags = regexp.flags;
  var match;

  if (!flags.includes('g')) {
    regexp = new RegExp(regexp.source, "g".concat(flags));
  }

  do {
    match = regexp.exec(text);

    if (match) {
      results.push(match);
    }
  } while (runWhile(match));

  regexp.lastIndex = 0;
  return results;
}
/**
 * A utility function to clean up the Operating System name.
 *
 * @param os - the OS name to clean up.
 * @param pattern - a `RegExp` pattern matching the OS name.
 * @param label - a label for the OS.
 * @returns a cleaned up Operating System name
 */

function cleanupOS(os, pattern, label) {
  var _os$replace$replace$r;

  if (pattern && label) {
    os = os.replace(new RegExp(pattern, 'i'), label);
  }

  return format((_os$replace$replace$r = os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_powerpc\b/i, ' OS').replace(/\b(os x) [^\d ]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: bepc|[ .]*fc[\d .]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1').split(' on ')[0]) !== null && _os$replace$replace$r !== void 0 ? _os$replace$replace$r : '');
}
/**
 * A utility function to check whether the current browser is running on the
 * android platform.
 */

function isAndroidOS() {
  var _match$;

  var ua = navigator.userAgent;
  var match = new RegExp('\\b' + 'Android' + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua);

  if (!match) {
    return false;
  }

  return cleanupOS((_match$ = match[0]) !== null && _match$ !== void 0 ? _match$ : '', 'Android', 'Android').includes('Android');
}
/**
 * Generate a random float between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomFloat(min, max) {
  if (!max) {
    max = min;
    min = 0;
  }

  return Math.random() * (max - min + 1) + min;
}
/**
 * Generate a random integer between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomInt(min, max) {
  return Math.floor(randomFloat(min, max));
}
/**
 * Converts a string, including strings in camelCase or snake_case, into Start
 * Case (a variant of Title case where all words start with a capital letter),
 * it keeps original single quote and hyphen in the word.
 *
 *   'management_companies' to 'Management Companies' 'managementCompanies' to
 *   'Management Companies' `hell's kitchen` to `Hell's Kitchen` `co-op` to
 *   `Co-op`
 *
 * @param str - the string to examine
 */

function startCase(string) {
  return string.replace(/_/g, ' ').replace(/([a-z])([A-Z])/g, (_, $1, $2) => "".concat($1, " ").concat($2)).replace(/(\s|^)(\w)/g, (_, $1, $2) => "".concat($1).concat($2.toUpperCase()));
}
/**
 * Returns a number that is unique during the runtime of this code.
 */

function n() {
  var time = Date.now();
  var last = n.last || time;
  return n.last = time > last ? time : last + 1;
}

n.last = 0;
/**
 * Generate a unique id
 *
 * @param prefix - a prefix for the generated id.
 * @returns a unique string of specified length
 *
 */

function uniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix).concat(n().toString(36));
}
/**
 * Takes a number of elements from the provided array starting from the
 * zero-index
 *
 * @param arr - the array to take from
 * @param num - the number of items to take
 *
 */

function take(array, number) {
  number = Math.max(Math.min(0, number), number);
  return array.slice(0, number);
}
/**
 * Remove the undefined values from an object.
 */

function omitUndefined(object) {
  return omit__default["default"](object, value => !isUndefined(value));
}
/**
 * Clones a plain object using object spread notation
 *
 * @param value - the value to check
 *
 */

function clone(value) {
  if (!isPlainObject(value)) {
    throw new Error('An invalid value was passed into this clone utility. Expected a plain object');
  }

  return _objectSpread({}, value);
}
/**
 * Shallow clone an object while preserving it's getters and setters. This is a
 * an alternative to the spread clone.
 */

function shallowClone(value) {
  var clone = Object.create(Object.getPrototypeOf(value));
  var descriptors = Object.getOwnPropertyDescriptors(value);
  Object.defineProperties(clone, descriptors);
  return clone;
}
/**
 * Alias for fast deep equal
 */

var isEqual = fastDeepEqual__default["default"];
/**
 * Create a unique array in a non-mutating manner
 *
 * @param array - the array which will be reduced to its unique elements
 * @param fromStart - when set to true the duplicates will be removed from the
 * beginning of the array. This defaults to false.
 *
 * @returns a new array containing only unique elements (by reference)
 *
 */

function uniqueArray(array) {
  var fromStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var array_ = fromStart ? [...array].reverse() : array;
  var set = new Set(array_);
  return fromStart ? [...set].reverse() : [...set];
}
/**
 * Flattens an array.
 *
 * @param array
 *
 */

function flattenArray(array) {
  var flattened = [];

  var _iterator = _createForOfIteratorHelper(array),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;
      var itemsToInsert = isArray(_item) ? flattenArray(_item) : [_item];
      flattened.push(...itemsToInsert);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return flattened;
}
/**
 * noop is a shorthand way of saying `No Operation` and is a function that does
 * nothing.
 *
 * And Sometimes doing nothing is the best policy.
 */

function noop() {
  return;
}
/**
 * A deep merge which only merges plain objects and Arrays. It clones the object
 * before the merge so will not mutate any of the passed in values.
 *
 * To completely remove a key you can use the `Merge` helper class which
 * replaces it's key with a completely new object
 */

function deepMerge() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  return deepmerge__default["default"].all(objects, {
    isMergeableObject: isPlainObject
  });
}

/**
 * Clamps the value to the provided range.
 */
function clamp(_ref) {
  var min = _ref.min,
      max = _ref.max,
      value = _ref.value;

  if (value < min) {
    return min;
  }

  return value > max ? max : value;
}
/**
 * Get the last element of the array.
 */

function last(array) {
  return array[array.length - 1];
}
/**
 * Sorts an array while retaining the original order when the compare method
 * identifies the items as equal.
 *
 * `Array.prototype.sort()` is unstable and so values that are the same will
 * jump around in a non deterministic manner. Here I'm using the index as a
 * fallback. If two elements have the same priority the element with the lower
 * index is placed first hence retaining the original order.
 *
 * @param array - the array to sort
 * @param compareFn - compare the two value arguments `a` and `z` - return 0 for
 *                  equal - return number > 0 for a > z - return number < 0 for
 *                  z > a
 */

function sort(array, compareFn) {
  return [...array].map((value, index) => ({
    value,
    index
  })).sort((a, z) => compareFn(a.value, z.value) || a.index - z.index).map(_ref2 => {
    var value = _ref2.value;
    return value;
  });
}
/**
 * Get a property from an object or array by a string path or an array path.
 *
 * @param obj - object to retrieve property from
 * @param path - path to property
 */

function get(root, path, defaultValue) {
  try {
    if (isString(path) && path in root) {
      return root[path];
    }

    if (isArray(path)) {
      path = "['".concat(path.join("']['"), "']");
    }

    var obj = root;
    path.replace(/\[\s*(["'])(.*?)\1\s*]|^\s*(\w+)\s*(?=\.|\[|$)|\.\s*(\w*)\s*(?=\.|\[|$)|\[\s*(-?\d+)\s*]/g, (_, __, quotedProp, firstLevel, namedProp, index) => {
      obj = obj[quotedProp || firstLevel || namedProp || index];
      return '';
    });
    return obj === undefined ? defaultValue : obj;
  } catch (_unused) {
    return defaultValue;
  }
}

function setPropInternal(path, obj, value, index) {
  if (path.length === index) {
    return value;
  } // Create things as we go down if they don't exist


  obj = obj || {};
  var key = path[index];
  assert(key);
  return setClone(obj, key, setPropInternal(path, obj[key], value, ++index));
}

function setClone(obj, key, value) {
  var newObj = clone(obj);
  newObj[key] = value;
  return newObj;
}
/**
 * Set the value of a given path for the provided object. Does not mutate the
 * original object.
 */


function set(path, obj, value) {
  if (isNumber(path)) {
    return setClone(obj, path, value);
  }

  if (isString(path)) {
    path = path.split('.');
  }

  return setPropInternal(path, obj, value, 0);
}
/**
 * Unset the value of a given path within an object.
 */

function unset(path, target) {
  var clonedObject = clone(target);
  var value = clonedObject;

  var _iterator2 = _createForOfIteratorHelper(path.entries()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          index = _step2$value[0],
          key = _step2$value[1];

      var shouldDelete = index >= path.length - 1;
      var _item2 = value[key];

      if (shouldDelete) {
        if (isArray(value)) {
          var indexKey = Number.parseInt(key.toString(), 10);

          if (isNumber(indexKey)) {
            value.splice(indexKey, 1);
          }
        } else {
          Reflect.deleteProperty(value, key);
        }

        return clonedObject;
      }

      if (isPrimitive(_item2)) {
        return clonedObject;
      }

      _item2 = isArray(_item2) ? [..._item2] : _objectSpread({}, _item2);
      value[key] = _item2;
      value = _item2;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return clonedObject;
}

function makeFunctionForUniqueBy(value) {
  return item => {
    return get(item, value);
  };
}
/**
 * Create a unique array of objects from a getter function or a property list.
 *
 * @param array - the array to extract unique values from
 * @param getValue - a getter function or a string with the path to the item
 * that is being used as a a test for uniqueness.
 * @param fromStart - when true will remove duplicates from the start rather
 * than from the end
 *
 * ```ts
 * import { uniqueBy } from '@remirror/core-helpers';
 *
 * const values = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], item => item.id);
 * log(values) // => [{id: 'a', value: 'Awesome'}]
 *
 * const byKey = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], 'id')
 * // Same as above
 * ```
 */


function uniqueBy(array, getValue) {
  var fromStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var unique = [];
  var found = new Set();
  var getter = isFunction(getValue) ? getValue : makeFunctionForUniqueBy(getValue);
  var list = fromStart ? [...array].reverse() : array;

  var _iterator3 = _createForOfIteratorHelper(list),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _item3 = _step3.value;

      var _value = getter(_item3);

      if (!found.has(_value)) {
        found.add(_value);
        unique.push(_item3);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return fromStart ? unique.reverse() : unique;
}
/**
 * Create a range from start to end.
 *
 * If only start is provided it creates an array of the size provided. if start
 * and end are provided it creates an array who's first position is start and
 * final position is end. i.e. `length = (end - start) + 1`.
 *
 * If you'd like to create a typed tuple of up to `40` items then pass in a
 * `[number]` tuple as the first argument.
 */

function range(start, end) {
  var startValue = isArray(start) ? start[0] : start;

  if (!isNumber(end)) {
    return Array.from({
      length: Math.abs(startValue)
    }, (_, index) => (startValue < 0 ? -1 : 1) * index);
  }

  if (startValue <= end) {
    return Array.from({
      length: end + 1 - startValue
    }, (_, index) => index + startValue);
  }

  return Array.from({
    length: startValue + 1 - end
  }, (_, index) => -1 * index + startValue);
}
/**
 * Check that a number is within the minimum and maximum bounds of a set of
 * numbers.
 *
 * @param value - the number to test
 */

function within(value) {
  for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    rest[_key3 - 1] = arguments[_key3];
  }

  var numbers = rest.filter(isNumber);
  return value >= Math.min(...numbers) && value <= Math.max(...numbers);
}
/**
 * Safe implementation of hasOwnProperty with typechecking.
 *
 * @remarks
 *
 * See {@link https://eslint.org/docs/rules/no-prototype-builtins}
 *
 * @param obj - the object to check
 * @param key - the property to check
 *
 * @template Obj - the object type
 * @template Property - the property which can be a string | number | symbol
 */

function hasOwnProperty(object_, key) {
  return Object.prototype.hasOwnProperty.call(object_, key);
}
/**
 * Helper for getting an array from a function or array.
 */

function getLazyArray(value) {
  if (isFunction(value)) {
    return value();
  }

  return value;
}
function cx() {
  return uniqueArray(core.cx(...arguments).split(' ')).join(' ');
} // The following are forward exports for other libraries. I've structured it

/**
 * Errors have their own URL which will be logged to the console for simpler
 * debugging.
 */

var ERROR_INFORMATION_URL = 'https://remirror.io/docs/errors';
var errorMessageMap = {
  [coreConstants.ErrorConstant.UNKNOWN]: "An error occurred but we're not quite sure why. 🧐",
  [coreConstants.ErrorConstant.INVALID_COMMAND_ARGUMENTS]: 'The arguments passed to the command method were invalid.',
  [coreConstants.ErrorConstant.CUSTOM]: 'This is a custom error, possibly thrown by an external library.',
  [coreConstants.ErrorConstant.CORE_HELPERS]: 'An error occurred in a function called from the `@remirror/core-helpers` library.',
  [coreConstants.ErrorConstant.MUTATION]: 'Mutation of immutable value detected.',
  [coreConstants.ErrorConstant.INTERNAL]: 'This is an error which should not occur and is internal to the remirror codebase.',
  [coreConstants.ErrorConstant.MISSING_REQUIRED_EXTENSION]: 'Your editor is missing a required extension.',
  [coreConstants.ErrorConstant.MANAGER_PHASE_ERROR]: 'This occurs when accessing a method or property before it is available.',
  [coreConstants.ErrorConstant.INVALID_GET_EXTENSION]: 'The user requested an invalid extension from the getExtensions method. Please check the `createExtensions` return method is returning an extension with the defined constructor.',
  [coreConstants.ErrorConstant.INVALID_MANAGER_ARGUMENTS]: 'Invalid value(s) passed into `Manager` constructor. Only `Presets` and `Extensions` are supported.',
  [coreConstants.ErrorConstant.SCHEMA]: "There is a problem with the schema or you are trying to access a node / mark that doesn't exists.",
  [coreConstants.ErrorConstant.HELPERS_CALLED_IN_OUTER_SCOPE]: 'The `helpers` method which is passed into the ``create*` method should only be called within returned method since it relies on an active view (not present in the outer scope).',
  [coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION]: 'You requested an invalid extension from the manager.',
  [coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'Command method names must be unique within the editor.',
  [coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES]: 'Helper method names must be unique within the editor.',
  [coreConstants.ErrorConstant.NON_CHAINABLE_COMMAND]: 'Attempted to chain a non chainable command.',
  [coreConstants.ErrorConstant.INVALID_EXTENSION]: 'The provided extension is invalid.',
  [coreConstants.ErrorConstant.INVALID_CONTENT]: 'The content provided to the editor is not supported.',
  [coreConstants.ErrorConstant.INVALID_NAME]: 'An invalid name was used for the extension.',
  [coreConstants.ErrorConstant.EXTENSION]: 'An error occurred within an extension. More details should be made available.',
  [coreConstants.ErrorConstant.EXTENSION_SPEC]: 'The spec was defined without calling the `defaults`, `parse` or `dom` methods.',
  [coreConstants.ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES]: 'Extra attributes must either be a string or an object.',
  [coreConstants.ErrorConstant.INVALID_SET_EXTENSION_OPTIONS]: 'A call to `extension.setOptions` was made with invalid keys.',
  [coreConstants.ErrorConstant.REACT_PROVIDER_CONTEXT]: '`useRemirrorContext` was called outside of the `remirror` context. It can only be used within an active remirror context created by the `<Remirror />`.',
  [coreConstants.ErrorConstant.REACT_GET_ROOT_PROPS]: '`getRootProps` has been attached to the DOM more than once. It should only be attached to the dom once per editor.',
  [coreConstants.ErrorConstant.REACT_EDITOR_VIEW]: 'A problem occurred adding the editor view to the dom.',
  [coreConstants.ErrorConstant.REACT_CONTROLLED]: 'There is a problem with your controlled editor setup.',
  [coreConstants.ErrorConstant.REACT_NODE_VIEW]: 'Something went wrong with your custom ReactNodeView Component.',
  [coreConstants.ErrorConstant.REACT_GET_CONTEXT]: 'You attempted to call `getContext` provided by the `useRemirror` prop during the first render of the editor. This is not possible and should only be after the editor first mounts.',
  [coreConstants.ErrorConstant.REACT_COMPONENTS]: 'An error occurred within a remirror component.',
  [coreConstants.ErrorConstant.REACT_HOOKS]: 'An error occurred within a remirror hook.',
  [coreConstants.ErrorConstant.I18N_CONTEXT]: 'You called `useI18n()` outside of an `I18nProvider` context.'
};
/**
 * Checks whether the passed code is an `ErrorConstant`.
 */

function isErrorConstant(code) {
  return isString(code) && includes(values(coreConstants.ErrorConstant), code);
}
/**
 * Create an error message from the provided error code.
 */


function createErrorMessage(code, extraMessage) {
  var message = errorMessageMap[code];
  var prefix = message ? "".concat(message, "\n\n") : '';
  var customMessage = extraMessage ? "".concat(extraMessage, "\n\n") : '';
  return "".concat(prefix).concat(customMessage, "For more information visit ").concat(ERROR_INFORMATION_URL, "#").concat(code.toLowerCase());
}
/**
 * This marks the error as a remirror specific error, with enhanced stack
 * tracing capabilities.
 *
 * @remarks
 *
 * Use this when creating your own extensions and notifying the user that
 * something has gone wrong.
 */


class RemirrorError extends makeError.BaseError {
  /**
   * A shorthand way of creating an error message.
   */
  static create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new RemirrorError(options);
  }
  /**
   * The error code used to create this error message.
   */


  /**
   * The constructor is intentionally kept private to prevent being extended from.
   */
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        code = _ref.code,
        message = _ref.message,
        _ref$disableLogging = _ref.disableLogging,
        disableLogging = _ref$disableLogging === void 0 ? false : _ref$disableLogging;

    var errorCode;

    if (isErrorConstant(code)) {
      errorCode = code;
      super(createErrorMessage(errorCode, message));
    } else {
      errorCode = coreConstants.ErrorConstant.CUSTOM;
      super(createErrorMessage(errorCode, message));
    }

    this.errorCode = errorCode;
    this.url = "".concat(ERROR_INFORMATION_URL, "#").concat(errorCode.toLowerCase());

    if (!disableLogging) {
      // Log the error.
      // eslint-disable-next-line no-console
      console.error(this.message);
    }
  }

}
/**
 * Throw an error if the condition fails. Strip out error messages for
 * production. Adapted from `tiny-invariant`.
 */

function invariant(condition, options) {
  if (condition) {
    return;
  }

  throw RemirrorError.create(options);
}
/**
 * The invariant options which only show up during development.
 */

/// <reference types="node" />
/**
 * A freeze method for objects that only runs in development. Helps prevent code
 * that shouldn't be mutated from being mutated during development.
 *
 * @remarks
 *
 * This function passes the value back unchanged when in a production
 * environment. It's purpose is to help prevent bad practice while developing
 * by avoiding mutation of values that shouldn't be mutated.
 */

function freeze(target) {

  {
    return target;
  }
}

Object.defineProperty(exports, 'omit', {
  enumerable: true,
  get: function () { return omit__default["default"]; }
});
Object.defineProperty(exports, 'pick', {
  enumerable: true,
  get: function () { return object_pick__default["default"]; }
});
Object.defineProperty(exports, 'camelCase', {
  enumerable: true,
  get: function () { return caseAnything.camelCase; }
});
Object.defineProperty(exports, 'capitalCase', {
  enumerable: true,
  get: function () { return caseAnything.capitalCase; }
});
Object.defineProperty(exports, 'constantCase', {
  enumerable: true,
  get: function () { return caseAnything.constantCase; }
});
Object.defineProperty(exports, 'kebabCase', {
  enumerable: true,
  get: function () { return caseAnything.kebabCase; }
});
Object.defineProperty(exports, 'pascalCase', {
  enumerable: true,
  get: function () { return caseAnything.pascalCase; }
});
Object.defineProperty(exports, 'pathCase', {
  enumerable: true,
  get: function () { return caseAnything.pathCase; }
});
Object.defineProperty(exports, 'snakeCase', {
  enumerable: true,
  get: function () { return caseAnything.snakeCase; }
});
Object.defineProperty(exports, 'spaceCase', {
  enumerable: true,
  get: function () { return caseAnything.spaceCase; }
});
Object.defineProperty(exports, 'debounce', {
  enumerable: true,
  get: function () { return throttleDebounce.debounce; }
});
Object.defineProperty(exports, 'throttle', {
  enumerable: true,
  get: function () { return throttleDebounce.throttle; }
});
exports.Cast = Cast;
exports.RemirrorError = RemirrorError;
exports.assert = assert;
exports.assertGet = assertGet;
exports.callIfDefined = callIfDefined;
exports.capitalize = capitalize;
exports.clamp = clamp;
exports.cleanupOS = cleanupOS;
exports.clone = clone;
exports.cx = cx;
exports.deepMerge = deepMerge;
exports.entries = entries;
exports.findMatches = findMatches;
exports.flattenArray = flattenArray;
exports.format = format;
exports.freeze = freeze;
exports.get = get;
exports.getLazyArray = getLazyArray;
exports.hasOwnProperty = hasOwnProperty;
exports.includes = includes;
exports.invariant = invariant;
exports.isAndroidOS = isAndroidOS;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isClass = isClass;
exports.isDate = isDate;
exports.isDirectInstanceOf = isDirectInstanceOf;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyObject = isEmptyObject;
exports.isEqual = isEqual;
exports.isError = isError;
exports.isFunction = isFunction;
exports.isInstanceOf = isInstanceOf;
exports.isInteger = isInteger;
exports.isJSONPrimitive = isJSONPrimitive;
exports.isMap = isMap;
exports.isNativePromise = isNativePromise;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isNull = isNull;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPrimitive = isPrimitive;
exports.isPromise = isPromise;
exports.isRegExp = isRegExp;
exports.isSafeInteger = isSafeInteger;
exports.isSet = isSet;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.isUndefined = isUndefined;
exports.keys = keys;
exports.last = last;
exports.noop = noop;
exports.object = object;
exports.omitUndefined = omitUndefined;
exports.randomFloat = randomFloat;
exports.randomInt = randomInt;
exports.range = range;
exports.set = set;
exports.shallowClone = shallowClone;
exports.sort = sort;
exports.startCase = startCase;
exports.take = take;
exports.toString = toString;
exports.uniqueArray = uniqueArray;
exports.uniqueBy = uniqueBy;
exports.uniqueId = uniqueId;
exports.unset = unset;
exports.values = values;
exports.within = within;
