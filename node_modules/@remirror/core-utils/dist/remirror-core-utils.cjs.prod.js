'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var coreConstants = require('@remirror/core-constants');
var coreHelpers = require('@remirror/core-helpers');
var state = require('@remirror/pm/state');
var transform = require('@remirror/pm/transform');
var _objectWithoutProperties = require('@babel/runtime/helpers/objectWithoutProperties');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var cssInJsUtils = require('css-in-js-utils');
var model = require('@remirror/pm/model');
var parse = require('parenthesis');
var messages = require('@remirror/messages');
var inputrules = require('@remirror/pm/inputrules');
var suggest = require('@remirror/pm/suggest');
var pm = require('@remirror/pm');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var parse__default = /*#__PURE__*/_interopDefault(parse);

/// <reference types="node" />

/**
 * A object with flags identifying the current environment.
 */
var environment = {
  /**
   * Verifies that the environment has both a window and window.document
   */
  get isBrowser() {
    return !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && window.navigator && window.navigator.userAgent);
  },

  /**
   * Verifies that the environment is JSDOM
   */
  get isJSDOM() {
    return environment.isBrowser && window.navigator.userAgent.includes('jsdom');
  },

  /**
   * Verifies that the environment has a nodejs process and is therefore a node environment
   */
  get isNode() {
    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
  },

  /**
   * True when on an iOS device.
   */
  get isIos() {
    return environment.isBrowser && /iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * True when running on macOS
   */
  get isMac() {
    return environment.isBrowser && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * Verify that this is an apple device either on the client or server.
   */
  get isApple() {
    return environment.isNode ? process.platform === 'darwin' : environment.isBrowser ? /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) : false;
  },

  /**
   * True when running in DEVELOPMENT environment
   */
  get isDevelopment() {
    return         "production" === 'development';
  },

  /**
   * True when running unit tests
   */
  get isTest() {
    return         "production" === 'test';
  },

  /**
   * True when running in PRODUCTION environment
   */
  get isProduction() {
    return         "production" === 'production';
  }

};

/**
 * Get the styles for a given property of an element.
 */

function getStyle(element, property) {
  var _element$ownerDocumen, _element$ownerDocumen2;

  var view = (_element$ownerDocumen = (_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.defaultView) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : window;
  var style = view.getComputedStyle(element);
  return style.getPropertyValue(property);
}
/**
 * Set more styles to the given element.
 */

function setStyle(target, styles) {
  return Object.assign(target.style, styles);
}
var DOM_SIZE_UNITS = ['px', 'rem', 'em', 'in', 'q', 'mm', 'cm', 'pt', 'pc', 'vh', 'vw', 'vmin', 'vmax'];

/**
 * Matches a CSS dimension returning a group containing the unit name
 * i.e. '10rem' returns the group 'rem'
 */
var CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
/**
 * Parse the font size and font unit from the provided value. When the value
 * type is unsupported it default to `px`.
 */

function parseSizeUnit() {
  var _match$;

  var fontSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
  var length = fontSize || '0';
  var value = Number.parseFloat(length);
  var match = length.match(CSS_DIMENSION_REGEX);
  var unit = ((_match$ = match === null || match === void 0 ? void 0 : match[1]) !== null && _match$ !== void 0 ? _match$ : 'px').toLowerCase(); // Defaults to pixels

  return [value, coreHelpers.includes(DOM_SIZE_UNITS, unit) ? unit : 'px'];
}
var PIXELS_PER_INCH = 96;
var MILLIMETERS_PER_INCH = 25.4;
var POINTS_PER_INCH = 72;
var PICAS_PER_INCH = 6;
function getFontSize(element) {
  return isElementDomNode(element) ? getStyle(element, 'font-size') || getFontSize(element.parentElement) : getStyle(window.document.documentElement, 'font-size');
}

function createUnitConverter(element) {
  var _element$ownerDocumen3, _element$ownerDocumen4;

  var view = (_element$ownerDocumen3 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.defaultView) !== null && _element$ownerDocumen3 !== void 0 ? _element$ownerDocumen3 : window;
  var root = view.document.documentElement || view.document.body;
  return (value, unit) => {
    switch (unit) {
      case 'rem':
        return value * extractPixelSize(getFontSize(root));

      case 'em':
        return value * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

      case 'in':
        return value * PIXELS_PER_INCH;

      case 'q':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH / 4;

      case 'mm':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH;

      case 'cm':
        return value * PIXELS_PER_INCH * 10 / MILLIMETERS_PER_INCH;

      case 'pt':
        return value * PIXELS_PER_INCH / POINTS_PER_INCH;

      case 'pc':
        return value * PIXELS_PER_INCH / PICAS_PER_INCH;

      case 'vh':
        return (value * view.innerHeight || root.clientWidth) / 100;

      case 'vw':
        return (value * view.innerWidth || root.clientHeight) / 100;

      case 'vmin':
        return value * Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      case 'vmax':
        return value * Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      default:
        return value;
    }
  };
}
/**
 * Matches a CSS function returning groups containing the function name and arguments
 * i.e. 'min(10px, 20px)' returns groups 'min' and '10px, 20px'
 */


var CSS_FUNCTION_REGEX = /^([a-z]+)\((.+)\)$/i;
/**
 * Recursively evaluates CSS functions by parsing into bracket groups
 *
 * Does not support the `calc` function
 *
 * @param cssFunc a string matching CSS_FUNCTION_REGEX
 * @param unitConvertor
 */

function parseCSSFunction(cssFunc, unitConvertor) {
  if (!CSS_FUNCTION_REGEX.test(cssFunc)) {
    return Number.NaN;
  }

  var tokens = parse__default["default"](cssFunc, {
    brackets: ['()'],
    escape: '_',
    flat: true
  });

  if (!tokens || tokens.length === 0) {
    return Number.NaN;
  }

  function replaceTokenReferences(str) {
    return str.replace(/_(\d+)_/g, (_, refIndex) => {
      var _tokens$tokenIndex;

      var tokenIndex = Number.parseFloat(refIndex);
      return (_tokens$tokenIndex = tokens[tokenIndex]) !== null && _tokens$tokenIndex !== void 0 ? _tokens$tokenIndex : '';
    });
  }

  var firstToken = getMatchString(tokens, 0);

  var _iterator = _createForOfIteratorHelper(coreHelpers.findMatches(firstToken, CSS_FUNCTION_REGEX)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var match = _step.value;
      var funcName = getMatchString(match, 1);
      var funcArgs = replaceTokenReferences(getMatchString(match, 2));
      var args = funcArgs.split(/\s*,\s*/);
      var values = args.map(arg => {
        if (CSS_FUNCTION_REGEX.test(arg)) {
          var nestedFunction = replaceTokenReferences(arg);
          return parseCSSFunction(nestedFunction, unitConvertor);
        }

        return parseCSSDimension(arg, unitConvertor);
      });

      switch (funcName) {
        case 'min':
          return Math.min(...values);

        case 'max':
          return Math.max(...values);

        case 'clamp':
          {
            var _values = _slicedToArray(values, 3),
                min = _values[0],
                _value = _values[1],
                max = _values[2];

            if (coreHelpers.isNumber(min) && coreHelpers.isNumber(_value) && coreHelpers.isNumber(max)) {
              return coreHelpers.clamp({
                min,
                max,
                value: _value
              });
            }

            break;
          }

        case 'calc':
          // Not practical to implement calc due to the vast amount of operations possible
          return Number.NaN;

        default:
          return Number.NaN;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return Number.NaN;
}

function parseCSSDimension(dimension, unitConvertor) {
  var _parseSizeUnit = parseSizeUnit(dimension),
      _parseSizeUnit2 = _slicedToArray(_parseSizeUnit, 2),
      value = _parseSizeUnit2[0],
      unit = _parseSizeUnit2[1];

  return unitConvertor(value, unit);
}
/**
 * Extract the pixel value from a dimension string or CSS function.
 *
 * Supports the CSS functions `min`, `max` and `clamp` even when nested.
 *
 * Does not support percentage units or the `calc` function.
 *
 * Adapted from https://github.com/PacoteJS/pacote/blob/20cb1e3a999ed47a8d52b03b750290cf36b8e270/packages/pixels/src/index.ts
 */


function extractPixelSize(size, element) {
  var unitConvertor = createUnitConverter(element);
  return CSS_FUNCTION_REGEX.test(size) ? parseCSSFunction(size.toLowerCase(), unitConvertor) : parseCSSDimension(size, unitConvertor);
}
/**
 * Convert the received font size to a valid unit
 */

function convertPixelsToDomUnit(size, to, element) {
  var _element$ownerDocumen5, _element$ownerDocumen6;

  var view = (_element$ownerDocumen5 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.defaultView) !== null && _element$ownerDocumen5 !== void 0 ? _element$ownerDocumen5 : window;
  var root = view.document.documentElement || view.document.body;
  var pixelValue = extractPixelSize(size, element);

  switch (to) {
    case 'px':
      return pixelValue;

    case 'rem':
      return pixelValue / extractPixelSize(getFontSize(root));

    case 'em':
      return pixelValue * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

    case 'in':
      return pixelValue / PIXELS_PER_INCH;

    case 'q':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH * 4;

    case 'mm':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH;

    case 'cm':
      return pixelValue / PIXELS_PER_INCH / 10 * MILLIMETERS_PER_INCH;

    case 'pt':
      return pixelValue / PIXELS_PER_INCH * POINTS_PER_INCH;

    case 'pc':
      return pixelValue / PIXELS_PER_INCH * PICAS_PER_INCH;

    case 'vh':
      return pixelValue / (view.innerHeight || root.clientWidth) * 100;

    case 'vw':
      return pixelValue / (view.innerWidth || root.clientHeight) * 100;

    case 'vmin':
      return pixelValue / Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    case 'vmax':
      return pixelValue / Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    default:
      return pixelValue;
  }
}
/**
 * Checks whether the passed value is a valid dom node
 *
 * @param domNode - the dom node
 */

function isDomNode(domNode) {
  return typeof document !== 'undefined' && (coreHelpers.isObject(Node) ? domNode instanceof Node : coreHelpers.isObject(domNode) && coreHelpers.isNumber(coreHelpers.Cast(domNode).nodeType) && coreHelpers.isString(coreHelpers.Cast(domNode).nodeName));
}
/**
 * Checks for an element node like `<p>` or `<div>`.
 *
 * @param domNode - the dom node
 */

function isElementDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.ELEMENT_NODE;
}
/**
 * Checks for a text node.
 *
 * @param domNode - the dom node
 */

function isTextDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.TEXT_NODE;
}

/**
 * Checks if the type a given `node` has a given `nodeType`.
 */
function isNodeOfType(props) {
  var types = props.types,
      node = props.node;

  if (!node) {
    return false;
  }

  var matches = type => {
    return type === node.type || type === node.type.name;
  };

  if (coreHelpers.isArray(types)) {
    return types.some(matches);
  }

  return matches(types);
}

/**
 * Creates a new transaction object from a given transaction. This is useful
 * when applying changes to a transaction, that you may want to rollback.
 *
 * ```ts
 * function() applyUpdateIfValid(state: EditorState) {
 *   const tr = cloneTransaction(state.tr);
 *
 *   tr.insertText('hello');
 *
 *   if (!checkValid(tr)) {
 *     return;
 *   }
 *
 *   applyClonedTransaction({ clone: tr, tr: state.tr });
 * }
 * ```
 *
 * The above example applies a transaction to the cloned transaction then checks
 * to see if the changes are still valid and if they are applies the mutative
 * changes to the original state transaction.
 *
 * @param tr - the prosemirror transaction
 */
function cloneTransaction(tr) {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
}

/**
 * Get the diff between two ordered arrays with a reference equality check.
 */
function diff(primary, other) {
  return primary.filter((item, index) => item !== other[index]);
}
/**
 * Apply the steps of a cloned transaction to the original transaction `tr`.
 */


function applyClonedTransaction(props) {
  var clone = props.clone,
      tr = props.tr;
  var steps = diff(clone.steps, tr.steps);

  var _iterator = _createForOfIteratorHelper(steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      tr.step(step);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/**
 * Returns a new transaction by combining all steps of the passed transactions onto the previous state
 */

function composeTransactionSteps(transactions, oldState) {
  var tr = oldState.tr;
  transactions.forEach(transaction => {
    transaction.steps.forEach(step => {
      tr.step(step);
    });
  });
  return tr;
}
/**
 * Checks if the type a given `node` has a given `nodeType`.
 */

function markEqualsType(props) {
  var types = props.types,
      mark = props.mark;
  return mark ? Array.isArray(types) && types.includes(mark.type) || mark.type === types : false;
}

/**
 * Performs a `delete` transaction that removes a node at a given position with
 * the given `node`. `position` should point at the position immediately before
 * the node.
 *
 * @param position - the prosemirror position
 */
function removeNodeAtPosition(_ref) {
  var pos = _ref.pos,
      tr = _ref.tr;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.delete(pos, pos + node.nodeSize);
  }

  return tr;
}

/**
 * Replaces the node at the provided position with the provided content.
 */
function replaceNodeAtPosition(_ref2) {
  var pos = _ref2.pos,
      tr = _ref2.tr,
      content = _ref2.content;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.replaceWith(pos, pos + node.nodeSize, content);
  }

  return tr;
}
/**
 * Returns DOM reference of a node at a given `position`.
 *
 * @remarks
 *
 * If the node type is of type `TEXT_NODE` it will return the reference of the
 * parent node.
 *
 * A simple use case
 *
 * ```ts
 * const element = findElementAtPosition($from.pos, view);
 * ```
 *
 * @param position - the prosemirror position
 * @param view - the editor view
 */

function findElementAtPosition(position, view) {
  var dom = view.domAtPos(position);
  var node = dom.node.childNodes[dom.offset];

  if (isTextDomNode(dom.node)) {
    return dom.node.parentNode;
  }

  if (coreHelpers.isNullOrUndefined(node) || isTextDomNode(node)) {
    return dom.node;
  }

  return node;
}
/**
 * Iterates over parent nodes, returning the closest node and its start position
 * that the `predicate` returns truthy for. `start` points to the start position
 * of the node, `pos` points directly before the node.
 *
 * ```ts
 * const predicate = node => node.type === schema.nodes.blockquote;
 * const parent = findParentNode({ predicate, selection });
 * ```
 */

function findParentNode(props) {
  var predicate = props.predicate,
      selection = props.selection;
  var $pos = isEditorState(selection) ? selection.selection.$from : isSelection(selection) ? selection.$from : selection;

  for (var depth = $pos.depth; depth > 0; depth--) {
    var _node = $pos.node(depth);

    var _pos = depth > 0 ? $pos.before(depth) : 0;

    var start = $pos.start(depth);
    var end = _pos + _node.nodeSize;

    if (predicate(_node, _pos)) {
      return {
        pos: _pos,
        depth,
        node: _node,
        start,
        end
      };
    }
  }

  return;
}
/**
 * Finds the node at the resolved position.
 *
 * @param $pos - the resolve position in the document
 */

function findNodeAtPosition($pos) {
  var depth = $pos.depth;
  var pos = depth > 0 ? $pos.before(depth) : 0;
  var node = $pos.node(depth);
  var start = $pos.start(depth);
  var end = pos + node.nodeSize;
  return {
    pos,
    start,
    node,
    end,
    depth
  };
}
/**
 * Finds the node at the passed selection.
 */

function findNodeAtSelection(selection) {
  var parentNode = findParentNode({
    predicate: () => true,
    selection
  });
  !parentNode ? coreHelpers.invariant(false) : void 0;
  return parentNode;
}

/**
 *  Iterates over parent nodes, returning closest node of a given `nodeType`.
 *  `start` points to the start position of the node, `pos` points directly
 *  before the node.
 *
 *  ```ts
 *  const parent = findParentNodeOfType({types: schema.nodes.paragraph, selection});
 *  ```
 */
function findParentNodeOfType(props) {
  var types = props.types,
      selection = props.selection;
  return findParentNode({
    predicate: node => isNodeOfType({
      types,
      node
    }),
    selection
  });
}
/**
 * Returns position of the previous node.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */

function findPositionOfNodeBefore(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeBefore = $pos.nodeBefore;
  var selection = state.Selection.findFrom($pos, -1);

  if (!selection || !nodeBefore) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeBefore.type,
    selection
  });
  return parent ? parent : {
    node: nodeBefore,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Updates the provided transaction to remove the node before.
 *
 * ```ts
 * dispatch(
 *    removeNodeBefore(state.tr)
 * );
 * ```
 *
 * @param tr
 */

function removeNodeBefore(tr) {
  var result = findPositionOfNodeBefore(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}

/**
 * Returns a node of a given `nodeType` if it is selected. `start` points to the
 * start position of the node, `pos` points directly before the node.
 *
 * ```ts
 * const { extension, inlineExtension, bodiedExtension } = schema.nodes;
 *
 * const selectedNode = findSelectedNodeOfType({
 *   types: [extension, inlineExtension, bodiedExtension],
 *   selection,
 * });
 * ```
 */
function findSelectedNodeOfType(props) {
  var types = props.types,
      selection = props.selection;

  if (!isNodeSelection(selection) || !isNodeOfType({
    types,
    node: selection.node
  })) {
    return;
  }

  return {
    pos: selection.$from.pos,
    depth: selection.$from.depth,
    start: selection.$from.start(),
    end: selection.$from.pos + selection.node.nodeSize,
    node: selection.node
  };
}

/**
 * Returns the position of the node after the current position, selection or
 * state.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */
function findPositionOfNodeAfter(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeAfter = $pos.nodeAfter;
  var selection = state.Selection.findFrom($pos, 1);

  if (!selection || !nodeAfter) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeAfter.type,
    selection
  });
  return parent ? parent : {
    node: nodeAfter,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Update the transaction to delete the node after the current selection.
 *
 * ```ts
 * dispatch(removeNodeBefore(state.tr));
 * ```
 *
 * @param tr
 */

function removeNodeAfter(tr) {
  var result = findPositionOfNodeAfter(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}
/**
 * Checks whether the selection or state is currently empty.
 *
 * @param value - the transaction selection or state
 */

function isSelectionEmpty(value) {
  return isSelection(value) ? value.empty : value.selection.empty;
}
/**
 * Check to see if a transaction has changed either the document or the current
 * selection.
 *
 * @param tr - the transaction to check
 */

function hasTransactionChanged(tr) {
  return tr.docChanged || tr.selectionSet;
}
/**
 * Checks whether the node type passed in is active within the region. Used by
 * extensions to implement the `active` method.
 *
 * To ignore `attrs` just leave the attrs object empty or undefined.
 *
 * @param props - see [[`GetActiveAttrsProps`]]
 */

function isNodeActive(props) {
  return !!getActiveNode(props);
}

/**
 * Get node of a provided type with the provided attributes if it exists as a
 * parent. Returns positional data for the node that was found.
 */
function getActiveNode(props) {
  var _findSelectedNodeOfTy;

  var state = props.state,
      type = props.type,
      attrs = props.attrs;
  var selection = state.selection,
      doc = state.doc;
  var nodeType = coreHelpers.isString(type) ? doc.type.schema.nodes[type] : type;
  !nodeType ? coreHelpers.invariant(false) : void 0;
  var active = (_findSelectedNodeOfTy = findSelectedNodeOfType({
    selection,
    types: type
  })) !== null && _findSelectedNodeOfTy !== void 0 ? _findSelectedNodeOfTy : findParentNode({
    predicate: node => node.type === nodeType,
    selection
  });

  if (!attrs || coreHelpers.isEmptyObject(attrs) || !active) {
    return active;
  }

  return active.node.hasMarkup(nodeType, _objectSpread(_objectSpread({}, active.node.attrs), attrs)) ? active : undefined;
}
/**
 * The ProseMirror `Schema` as a JSON object.
 */

/**
 * Converts a `schema` to a JSON compatible object.
 */
function schemaToJSON(schema) {
  var nodes = coreHelpers.object();
  var marks = coreHelpers.object();

  var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(schema.nodes)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          key = _step2$value[0],
          spec = _step2$value[1].spec;

      nodes[key] = spec;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var _iterator3 = _createForOfIteratorHelper(coreHelpers.entries(schema.marks)),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _key = _step3$value[0],
          _spec = _step3$value[1].spec;

      marks[_key] = _spec;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return {
    nodes,
    marks
  };
}
/**
 * Chains together keybindings, allowing for the same key binding to be used
 * across multiple extensions without overriding behavior.
 *
 * @remarks
 *
 * When `next` is called it hands over full control of the keybindings to the
 * function that invokes it.
 */

function chainKeyBindingCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    commands[_key2] = arguments[_key2];
  }

  return props => {
    // When no commands are passed just ignore and continue.
    if (!coreHelpers.isNonEmptyArray(commands)) {
      return false;
    }

    var command = commands[0],
        rest = commands.slice(1); // Keeps track of whether the `next` method has been called. If it has been
    // called we return the result and skip the rest of the downstream commands.

    var calledNext = false;
    /**
     * Create the next function call. Updates the outer closure when the next
     * method has been called.
     */

    var createNext = function createNext() {
      for (var _len2 = arguments.length, nextCommands = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        nextCommands[_key3] = arguments[_key3];
      }

      return () => {
        // If there are no commands then this can be ignored and continued.
        if (!coreHelpers.isNonEmptyArray(nextCommands)) {
          return false;
        } // Update the closure with information that the next method was invoked by
        // this command.


        calledNext = true;
        var nextRest = nextCommands.slice(1); // Recursively call the key bindings method.

        return chainKeyBindingCommands(...nextCommands)(_objectSpread(_objectSpread({}, props), {}, {
          next: createNext(...nextRest)
        }));
      };
    };

    var next = createNext(...rest);
    var exitEarly = command(_objectSpread(_objectSpread({}, props), {}, {
      next
    })); // Exit the chain of commands early if either:
    // - a) next was called
    // - b) the command returned true

    if (calledNext || exitEarly) {
      return exitEarly;
    } // Continue to the next function in the chain of commands.


    return next();
  };
}
/**
 * Used to merge key bindings together in a sensible way. Identical key bindings
 * likely have the same key. as a result a naive merge would result in the
 * binding added later in the merge being the only one the editor sees.
 *
 * This creator is used to create a merge that steps from the highest priority
 * to the lowest priority giving each keybinding in the chain an opportunity to
 * be run, and defer to the next command in the chain or choose not to.
 *
 * - It is used to create the [[`mergeKeyBindings`]] function helper.
 * - It is used to create the [[`mergeProsemirrorKeyBindings`]] function helper.
 *
 * @template [Schema] - the schema that is being used to create this command.
 * @template [Type] - the mapper type signature which is what the `mapper`
 * param transforms the [[`KeyBindingCommandFunction`]]  into.
 *
 * @param extensionKeymaps - the list of extension keymaps similar to the
 * following:
 *   ```ts
 *     [{ Enter: () => false}, { Escape: () => true }, { Enter: () => true }]
 *   ```
 * @param mapper - used to convert the [[`KeyBindingCommandFunction`]] into a
 * function with a different signature. It's application can be seen in
 * [[`mergeKeyBindings`]] and [[`mergeProsemirrorKeyBindings`]].
 *
 */

function mergeKeyBindingCreator(extensionKeymaps, mapper) {
  // Keep track of the previous commands as we loop through the `extensionKeymaps`.
  var previousCommandsMap = new Map(); // This is the combined mapping of commands. Essentially this function turns
  // the `extensionKeymaps` array into a single object `extensionKeymap` which
  // composes each function to give full control to the developer.

  var mappedCommands = coreHelpers.object(); // Outer loop iterates over each object keybinding.

  var _iterator4 = _createForOfIteratorHelper(extensionKeymaps),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var extensionKeymap = _step4.value;

      // Inner loop checks each keybinding on the keybinding object. `key` refers
      // to the name of the keyboard combination, like `Shift-Enter` or
      // `Cmd-Escape`.
      var _iterator5 = _createForOfIteratorHelper(coreHelpers.entries(extensionKeymap)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _previousCommandsMap$;

          var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              newCommand = _step5$value[1];

          // Get the previous commands for this key if it already exists
          var previousCommands = (_previousCommandsMap$ = previousCommandsMap.get(key)) !== null && _previousCommandsMap$ !== void 0 ? _previousCommandsMap$ : []; // Update the commands array. This will be added to the
          // `previousCommandsMap` to track the current keyboard combination.

          var commands = [...previousCommands, newCommand]; // Chain the keyboard binding so that you have all the niceties, like
          // being able to call `next` to run the remaining commands in the chain.

          var _command = chainKeyBindingCommands(...commands); // Update the previous commands with the new commands that are now being used.


          previousCommandsMap.set(key, commands); // Store a copy of the mapped commands. If this was the last time this
          // loop ran, then this is the command that would be called when a users
          // enters the keyboard combination specified by the `key` in this context.

          mappedCommands[key] = mapper(_command);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return mappedCommands;
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This is for use on remirror keybindings. See `mergeProsemirrorKeyBindings`
 * for transforming the methods into `ProsemirrorCommandFunction`'s.
 */


function mergeKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, command => command);
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This supports the [[ProsemirrorCommandFunction]] type signature where the
 * `state`, `dispatch` and `view` are passed as separate arguments.
 */

function mergeProsemirrorKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, // Convert the command to have a signature of the
  // [[`ProsemirrorCommandFunction`]].
  command => (state, dispatch, view) => {
    return command({
      state,
      dispatch,
      view,
      tr: state.tr,
      next: () => false
    });
  });
}
/**
 * Determines if a Node or Mark contains the given attributes in its attributes set
 *
 * @param nodeOrMark - The Node or Mark to check
 * @param attrs - The set of attributes it must contain
 */

function containsAttributes(nodeOrMark, attrs) {
  var _nodeOrMark$attrs;

  var currentAttrs = (_nodeOrMark$attrs = nodeOrMark.attrs) !== null && _nodeOrMark$attrs !== void 0 ? _nodeOrMark$attrs : {};
  return Object.entries(attrs).every(_ref3 => {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        value = _ref4[1];

    return currentAttrs[name] === value;
  });
}

var _excluded$1 = ["content", "schema", "document", "fragment"],
    _excluded2$1 = ["json", "schema"];

function isRangeStep(step) {
  return isValidStep(step, [transform.AddMarkStep, transform.ReplaceAroundStep, transform.ReplaceStep, transform.RemoveMarkStep]);
}
/**
 * Identifies the value as having a remirror identifier. This is the core
 * predicate check for the remirror library.
 *
 * @param value - the value to be checked
 *
 * @internal
 */


function isRemirrorType(value) {
  return coreHelpers.isObject(value);
}
/**
 * Checks that the provided remirror shape is of a given type.
 *
 * @param value - any remirror shape
 * @param type - the remirror identifier type to check for
 *
 * @internal
 */

function isIdentifierOfType(value, type) {
  return coreHelpers.isArray(type) ? coreHelpers.includes(type, value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]) : type === value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__];
}
/**
 * Check to see if the passed value is a NodeType.
 *
 * @param value - the value to check
 */

function isNodeType(value) {
  return coreHelpers.isObject(value) && value instanceof model.NodeType;
}
/**
 * Get the node type from a potential string value.
 */

function getNodeType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.nodes, type) : type;
}
/**
 * Check to see if the passed value is a MarkType.
 *
 * @param value - the value to check
 */

function isMarkType(value) {
  return coreHelpers.isObject(value) && value instanceof model.MarkType;
}
/**
 * Get the mark type from a potential string value.
 */

function getMarkType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.marks, type) : type;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorNode(value) {
  return coreHelpers.isObject(value) && value instanceof model.Node;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorFragment(value) {
  return coreHelpers.isObject(value) && value instanceof model.Fragment;
}
/**
 * Checks to see if the passed value is a ProsemirrorMark
 *
 * @param value - the value to check
 */

function isProsemirrorMark(value) {
  return coreHelpers.isObject(value) && value instanceof model.Mark;
}
/**
 * Checks to see if the passed value is a Prosemirror Editor State
 *
 * @param value - the value to check
 */

function isEditorState(value) {
  return coreHelpers.isObject(value) && value instanceof state.EditorState;
}
/**
 * Checks to see if the passed value is a Prosemirror Transaction
 *
 * @param value - the value to check
 */

function isTransaction(value) {
  return coreHelpers.isObject(value) && value instanceof state.Transaction;
}
/**
 * Checks to see if the passed value is an instance of the editor schema
 *
 * @param value - the value to check
 */

function isEditorSchema(value) {
  return coreHelpers.isObject(value) && value instanceof model.Schema;
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.TextSelection;
}
/**
 * Predicate checking whether the selection is an `AllSelection`.
 *
 * @param value - the value to check
 */

function isAllSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.AllSelection;
}
/**
 * Predicate checking whether the value is a Selection
 *
 * @param value - the value to check
 */

function isSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.Selection;
}
/**
 * Predicate checking whether the value is a ResolvedPosition.
 *
 * @param value - the value to check
 */

function isResolvedPos(value) {
  return coreHelpers.isObject(value) && value instanceof model.ResolvedPos;
}

/**
 * A wrapper for ProsemirrorNode.rangeHasMark that can also compare mark attributes (if supplied)
 *
 * @param props - see [[`RangeHasMarkProps`]] for options
 */
function rangeHasMark(props) {
  var trState = props.trState,
      from = props.from,
      to = props.to,
      type = props.type,
      _props$attrs = props.attrs,
      attrs = _props$attrs === void 0 ? {} : _props$attrs;
  var doc = trState.doc;
  var markType = getMarkType(type, doc.type.schema);

  if (Object.keys(attrs).length === 0) {
    return doc.rangeHasMark(from, to, markType);
  }

  var found = false;

  if (to > from) {
    doc.nodesBetween(from, to, node => {
      var _node$marks;

      if (found) {
        return false;
      }

      var marks = (_node$marks = node.marks) !== null && _node$marks !== void 0 ? _node$marks : [];
      found = marks.some(mark => {
        if (mark.type !== markType) {
          return false;
        }

        return containsAttributes(mark, attrs);
      }); // Don't descend if found

      return !found;
    });
  }

  return found;
}
/**
 * Predicate checking whether the selection is a NodeSelection
 *
 * @param value - the value to check
 */

function isNodeSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.NodeSelection;
}

/**
 * Checks that a mark is active within the selected region, or the current
 * selection point is within a region with the mark active. Used by extensions
 * to implement their active methods.
 *
 * @param props - see [[`IsMarkActiveProps`]] for options
 */
function isMarkActive(props) {
  var trState = props.trState,
      type = props.type,
      _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      from = props.from,
      to = props.to;
  var selection = trState.selection,
      doc = trState.doc,
      storedMarks = trState.storedMarks;
  var markType = coreHelpers.isString(type) ? doc.type.schema.marks[type] : type;
  !markType ? coreHelpers.invariant(false) : void 0;

  if (from && to) {
    try {
      return Math.max(from, to) < doc.nodeSize && rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
        from,
        to
      }));
    } catch (_unused) {
      return false;
    }
  }

  if (selection.empty) {
    var marks = storedMarks !== null && storedMarks !== void 0 ? storedMarks : selection.$from.marks();
    return marks.some(mark => {
      if (mark.type !== type) {
        return false;
      }

      return containsAttributes(mark, attrs !== null && attrs !== void 0 ? attrs : {});
    });
  }

  return rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
    from: selection.from,
    to: selection.to
  }));
}
/**
 * Check if the specified type (NodeType) can be inserted at the current
 * selection point.
 *
 * @param state - the editor state
 * @param type - the node type
 */

function canInsertNode(state, type) {
  var $from = state.selection.$from;

  for (var depth = $from.depth; depth >= 0; depth--) {
    var index = $from.index(depth);

    try {
      if ($from.node(depth).canReplaceWith(index, index, type)) {
        return true;
      }
    } catch (_unused2) {
      return false;
    }
  }

  return false;
}
/**
 * Checks if a node looks like an empty document.
 *
 * @param node - the prosemirror node
 */

function isDocNodeEmpty(node) {
  var nodeChild = node.content.firstChild;

  if (node.childCount !== 1 || !nodeChild) {
    return false;
  }

  return nodeChild.type.isBlock && !nodeChild.childCount && nodeChild.nodeSize === 2 && (coreHelpers.isNullOrUndefined(nodeChild.marks) || nodeChild.marks.length === 0);
}

/**
 * Check whether the provided doc node has the same value as the default empty
 * node for the document. Basically checks that the document is untouched.
 *
 * This is useful for extensions like the placeholder which only should be shown
 * when the document matches the default empty state.
 */
function isDefaultDocNode(doc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaultDoc = getDefaultDocNode(doc.type.schema); // Make sure the `doc` was created.

  if (!defaultDoc) {
    // No default doc exists for the current schema.
    return false;
  }

  var ignoreAttributes = options.ignoreAttributes,
      ignoreDocAttributes = options.ignoreDocAttributes;

  if (ignoreAttributes) {
    return prosemirrorNodeEquals(defaultDoc, doc);
  }

  if (ignoreDocAttributes) {
    return defaultDoc.content.eq(doc.content);
  }

  return defaultDoc.eq(doc);
}
/**
 * Check that two nodes are equal while ignoring all attributes.
 *
 * This is an alternative to the `node.eq()` method.
 */

function prosemirrorNodeEquals(node, other) {
  // The values are equivalent so return `true` early.
  if (node === other) {
    return true;
  } // Check if the markup is the same (ignoring attributes)


  var identicalMarkup = node.type === other.type && model.Mark.sameSet(node.marks, other.marks);

  function contentEquals() {
    if (node.content === other.content) {
      return true;
    }

    if (node.content.size !== other.content.size) {
      return false;
    }

    var nodeChildren = [];
    var otherChildren = [];
    node.content.forEach(node => nodeChildren.push(node));
    other.content.forEach(node => otherChildren.push(node));

    var _iterator = _createForOfIteratorHelper(nodeChildren.entries()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            index = _step$value[0],
            nodeChild = _step$value[1];

        var otherChild = otherChildren[index];

        if (!otherChild) {
          return false;
        }

        if (!prosemirrorNodeEquals(nodeChild, otherChild)) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return identicalMarkup && contentEquals();
}
/**
 * Get the default `doc` node for a given schema.
 */

function getDefaultDocNode(schema) {
  var _schema$nodes$doc$cre, _schema$nodes$doc;

  return (_schema$nodes$doc$cre = (_schema$nodes$doc = schema.nodes.doc) === null || _schema$nodes$doc === void 0 ? void 0 : _schema$nodes$doc.createAndFill()) !== null && _schema$nodes$doc$cre !== void 0 ? _schema$nodes$doc$cre : undefined;
}
/**
 * Get the default block node from the schema.
 */

function getDefaultBlockNode(schema) {
  // Set the default block node from the schema.
  for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
    var type = _Object$values[_i];

    if (type.name === 'doc') {
      continue;
    } // Break as soon as the first non 'doc' block node is encountered.


    if (type.isBlock || type.isTextblock) {
      return type;
    }
  }

  coreHelpers.invariant(false) ;
}
/**
 * Check if the provided node is a default block node.
 */

function isDefaultBlockNode(node) {
  return node.type === getDefaultBlockNode(node.type.schema);
}
/**
 * Checks if the current node is a block node and empty.
 *
 * @param node - the prosemirror node
 */

function isEmptyBlockNode(node) {
  return !!node && node.type.isBlock && !node.textContent && !node.childCount;
}
/**
 * Retrieve the attributes for a mark.
 *
 * @param trState - the editor state or a transaction
 * @param type - the mark type
 */

function getMarkAttributes(trState, type) {
  // Get the current range of the cursor selection.
  var _trState$selection = trState.selection,
      from = _trState$selection.from,
      to = _trState$selection.to; // The container which will be used to store the marks.

  var marks = []; // Find the nodes and add all the marks contained to the above mark container.

  trState.doc.nodesBetween(from, to, node => {
    marks.push(...node.marks);
  }); // Search for the first mark with the same type as requested

  var mark = marks.find(markItem => markItem.type.name === type.name); // Return the mark attrs when found.

  if (mark) {
    return mark.attrs;
  } // Return false to denote the mark could not be found.


  return false;
}

/**
 * Retrieve the `start` and `end` position of a mark. The `$pos` value should be
 * calculated via `tr.doc.resolve(number)`.
 *
 * @remarks
 *
 * @param $pos - the resolved ProseMirror position
 * @param type - the mark type
 * @param $end - the end position to search until. When this is provided the
 * mark will be checked for all point up until the `$end`. The first mark within
 * the range will be returned.
 *
 * To find all marks within a selection use [[`getMarkRanges`]].
 */
function getMarkRange($pos, type, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var typeName = coreHelpers.isString(type) ? type : type.name; // Find the mark if it exists.

  var mark = start.node.marks.find(_ref => {
    var markType = _ref.type;
    return markType.name === typeName;
  });
  var startIndex = $pos.index();
  var startPos = $pos.start() + start.offset;
  var endIndex = startIndex + 1;
  var endPos = startPos + start.node.nodeSize; // If the mark wasn't found then no range can be calculated. Exit early.

  if (!mark) {
    if ($end && endPos < $end.pos) {
      return getMarkRange($pos.doc.resolve(endPos + 1), type, $end);
    }

    return;
  }

  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }

  while (endIndex < $pos.parent.childCount && mark.isInSet($pos.parent.child(endIndex).marks)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }

  var text = $pos.doc.textBetween(startPos, endPos, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from: startPos,
    to: endPos,
    text,
    mark
  };
}
/**
 * Get all the ranges which contain marks for the provided selection.
 */

function getMarkRanges(selection, type) {
  var markRanges = [];
  var $from = selection.$from,
      $to = selection.$to;
  var $pos = $from;

  while (true) {
    var range = getMarkRange($pos, type, $to);

    if (!range) {
      return markRanges;
    }

    markRanges.push(range);

    if (range.to < $to.pos) {
      $pos = $from.doc.resolve(range.to + 1);
      continue;
    }

    return markRanges;
  }
}
/**
 * Return true if the step provided an instance of any of the provided step
 * constructors.
 *
 * @param step - the step to check
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function isValidStep(step, StepTypes) {
  return StepTypes.length === 0 || StepTypes.some(Constructor => step instanceof Constructor);
}

/**
 * Get all the ranges of changes for the provided transaction.
 *
 * This can be used to gather specific parts of the document which require
 * decorations to be recalculated or where nodes should be updated.
 *
 * This is adapted from the answer
 * [here](https://discuss.prosemirror.net/t/find-new-node-instances-and-track-them/96/7)
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */
function getChangedRanges(tr) {
  var StepTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // The holder for the ranges value which will be returned from this function.
  var ranges = [];
  var rawRanges = [];

  var _iterator2 = _createForOfIteratorHelper(tr.steps),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var step = _step2.value;

      if (!isValidStep(step, StepTypes)) {
        continue;
      }

      var stepMap = step.getMap(); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore @see https://github.com/ProseMirror/prosemirror/issues/1075

      if (stepMap.ranges.length === 0 && isRangeStep(step)) {
        var from = step.from,
            to = step.to;

        if (from === undefined || to === undefined) {
          continue;
        }

        rawRanges.push({
          from,
          to
        });
      } else {
        step.getMap().forEach((from, to) => {
          rawRanges.push({
            from,
            to
          });
        });
      }
    } // Sort the ranges.

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var sortedRanges = coreHelpers.sort(rawRanges, (a, z) => a.from - z.from); // Merge sorted ranges into the new range.

  var _iterator3 = _createForOfIteratorHelper(sortedRanges),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          _from = _step3$value.from,
          _to = _step3$value.to;
      // The last item in the accumulated `ranges`.
      var lastRange = ranges[ranges.length - 1]; // True when range added has no overlap with the previous end value.

      var noOverlap = !lastRange || lastRange.to < _from;

      if (noOverlap) {
        // Add the new range when no overlap is found.
        var newFrom = tr.mapping.map(_from, -1);
        var newTo = tr.mapping.map(_to);
        ranges.push({
          from: newFrom,
          to: newTo,
          prevFrom: tr.mapping.invert().map(newFrom, -1),
          prevTo: tr.mapping.invert().map(newTo)
        });
      } else if (lastRange) {
        // Update the lastRange's end value.
        lastRange.to = Math.max(lastRange.from, _to);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return coreHelpers.uniqueBy(ranges, _ref2 => {
    var from = _ref2.from,
        to = _ref2.to,
        prevFrom = _ref2.prevFrom,
        prevTo = _ref2.prevTo;
    return "".concat(from, "_").concat(to, "_").concat(prevFrom, "_").concat(prevTo);
  });
}
/**
 * Get all the changed node ranges for a provided transaction.
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function getChangedNodeRanges(tr, StepTypes) {
  // The container of the ranges to be returned from this function.
  var nodeRanges = [];
  var ranges = getChangedRanges(tr, StepTypes);

  var _iterator4 = _createForOfIteratorHelper(ranges),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var range = _step4.value;

      try {
        var $from = tr.doc.resolve(range.from);
        var $to = tr.doc.resolve(range.to); // Find the node range for this provided range.

        var nodeRange = $from.blockRange($to); // Make sure a valid node is available.

        if (nodeRange) {
          nodeRanges.push(nodeRange);
        }
      } catch (_unused3) {// Changed ranged outside the document
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return nodeRanges;
}
/**
 * Retrieves the text content from a slice
 *
 * @remarks
 * A utility that's useful for pulling text content from a slice which is
 * usually created via `selection.content()`
 *
 * @param slice - the prosemirror slice
 */

function getTextContentFromSlice(slice) {
  var _slice$content$firstC, _slice$content$firstC2;

  return (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
}

/**
 * Takes an empty selection and expands it out to the nearest group not matching
 * the excluded characters.
 *
 * @remarks
 *
 * Can be used to find the nearest selected word. See {@link getSelectedWord}
 *
 * @param state - the editor state or a transaction
 * @param exclude - the regex pattern to exclude
 * @returns false if not a text selection or if no expansion available
 */
function getSelectedGroup(state$1, exclude) {
  if (!isTextSelection(state$1.selection)) {
    return;
  }

  var _state$selection = state$1.selection,
      from = _state$selection.from,
      to = _state$selection.to;

  var getChar = (start, end) => getTextContentFromSlice(state.TextSelection.create(state$1.doc, start, end).content());

  for (var char = getChar(from - 1, from); char && !exclude.test(char); from--, char = getChar(from - 1, from)) {// Step backwards until reaching first excluded character or empty text
    // content.
  }

  for (var _char = getChar(to, to + 1); _char && !exclude.test(_char); to++, _char = getChar(to, to + 1)) {// Step forwards until reaching the first excluded character or empty text
    // content
  }

  if (from === to) {
    return;
  }

  var text = state$1.doc.textBetween(from, to, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from,
    to,
    text
  };
}
/**
 * Retrieves the nearest space separated word from the current selection.
 *
 * @remarks
 *
 * This always expands outward so that given: `The tw<start>o words<end>` The
 * selection would become `The <start>two words<end>`
 *
 * In other words it expands until it meets an invalid character.
 *
 * @param state - the editor state or transaction.
 */

function getSelectedWord(state) {
  return getSelectedGroup(state, /\W/);
}
/**
 * Get matching string from a list or single value
 *
 * @remarks
 * Get attrs can be called with a direct match string or array of string
 * matches. This method should be used to retrieve the required string.
 *
 * The index of the matched array used defaults to 0 but can be updated via the
 * second parameter.
 *
 * @param match - the match(es)
 * @param index - the zero-index point from which to start
 */

function getMatchString(match) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var value = coreHelpers.isArray(match) ? match[index] : match; // Throw an error if value is not defined for the index.

  coreHelpers.assert(coreHelpers.isString(value), "No match string found for match ".concat(match));
  return value !== null && value !== void 0 ? value : '';
}
/**
 * Checks whether the cursor is at the end of the state.doc
 *
 * @param state - the editor state
 */

function atDocEnd(state) {
  return state.doc.nodeSize - state.selection.$to.pos - 2 === state.selection.$to.depth;
}
/**
 * Checks whether the cursor is at the beginning of the state.doc
 *
 * @param state - the editor state
 */

function atDocStart(state) {
  return state.selection.$from.pos === state.selection.$from.depth;
}
/**
 * Get the start position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function startPositionOfParent($pos) {
  return $pos.start($pos.depth);
}
/**
 * Get the end position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function endPositionOfParent($pos) {
  return $pos.end($pos.depth) + 1;
}
/**
 * Retrieve the current position of the cursor
 *
 * @param selection - the editor selection
 * @returns a resolved position only when the selection is a text selection
 */

function getCursor(selection) {
  return isTextSelection(selection) ? selection.$cursor : undefined;
}
/**
 * Checks whether a Prosemirror node is the top level `doc` node
 *
 * @param node - the prosemirror node
 * @param schema - the prosemirror schema to check against
 */

function isDocNode(node, schema) {
  if (!isProsemirrorNode(node)) {
    return false;
  }

  if (schema) {
    return node.type === schema.nodes.doc;
  }

  return node.type.name === 'doc';
}
/**
 * Checks whether the passed in JSON is a valid object node
 *
 * @param value - the value to check
 */

function isRemirrorJSON(value) {
  return coreHelpers.isObject(value) && value.type === 'doc' && Array.isArray(value.content);
}
/**
 * This type is the combination of all the registered string handlers for the
 * extension. This is used rather than the `StringHandlers` in order to enforce
 * the type signature of the handler method, which isn't possible with the
 * interface.
 */

/**
 * Return true when the provided value is an anchor / head selection property
 */
function isAnchorHeadObject(value) {
  return coreHelpers.isObject(value) && coreHelpers.isNumber(value.anchor) && coreHelpers.isNumber(value.head);
}
/**
 * Get the nearest valid text selection to the provided selection parameter.
 */

function getTextSelection(selection, doc) {
  var max = doc.nodeSize - 2;
  var min = 0;
  var pos;
  /** Ensure the selection is within the current document range */

  var clampToDocument = value => coreHelpers.clamp({
    min,
    max,
    value
  });

  if (isSelection(selection)) {
    return selection;
  }

  if (selection === 'all') {
    return new state.AllSelection(doc);
  }

  if (selection === 'start') {
    pos = min;
  } else if (selection === 'end') {
    pos = max;
  } else if (isResolvedPos(selection)) {
    pos = selection.pos;
  } else {
    pos = selection;
  }

  if (coreHelpers.isNumber(pos)) {
    pos = clampToDocument(pos);
    return state.TextSelection.near(doc.resolve(pos));
  }

  if (isAnchorHeadObject(pos)) {
    var _anchor = clampToDocument(pos.anchor);

    var _head = clampToDocument(pos.head);

    return state.TextSelection.create(doc, _anchor, _head);
  } // In this case assume that `from` is the fixed anchor and `to` is the movable
  // head.


  var anchor = clampToDocument(pos.from);
  var head = clampToDocument(pos.to);
  return state.TextSelection.create(doc, anchor, head);
}
/**
 * A function that converts a string into a `ProsemirrorNode`.
 */

// The maximum attempts to check invalid content before throwing an an error.
var MAX_ATTEMPTS = 3;
/**
 * Creates a document node from the passed in content and schema.
 *
 * @remirror
 *
 * This supports a primitive form of error handling. When an error occurs, the
 * `onError` handler will be called along with the error produced by the Schema
 * and it is up to you as a developer to decide how to transform the invalid
 * content into valid content.
 *
 * Please note that the `onError` is only called when the content is a JSON
 * object. It is not called for a `string`, the `ProsemirrorNode` or the
 * `EditorState`. The reason for this is that the `string` requires a `stringHandler`
 * which is defined by the developer and transforms the content. That is the
 * point that error's should be handled. The editor state and the
 * `ProsemirrorNode` are similar. They need to be created by the developer and
 * as a result, the errors should be handled at the point of creation rather
 * than when the document is being applied to the editor.
 */

function createDocumentNode(props) {
  var content = props.content,
      schema = props.schema,
      document = props.document,
      stringHandler = props.stringHandler,
      onError = props.onError,
      _props$attempts = props.attempts,
      attempts = _props$attempts === void 0 ? 0 : _props$attempts; // If there is an `onError` handler then check the attempts does not exceed
  // the maximum, otherwise only allow one attempt.

  var attemptsRemaining = onError && attempts <= MAX_ATTEMPTS || attempts === 0;
  !attemptsRemaining ? coreHelpers.invariant(false) : void 0;

  if (coreHelpers.isString(content)) {
    !stringHandler ? coreHelpers.invariant(false) : void 0;
    var options = {
      document,
      content,
      schema
    }; // With string content it is up to you the developer to ensure there are no
    // errors in the produced content.

    return stringHandler(options);
  } // If passing in an editor state, it is left to the developer to make sure the
  // state they created is valid.


  if (isEditorState(content)) {
    return content.doc;
  } // When passing the prosemirror no error checking is done. Before creating the
  // node you should manually ensure that it is valid.


  if (isProsemirrorNode(content)) {
    return content;
  } // At this point the only possible solution is that the content is a json
  // object so we try to convert the json to a valid object.


  try {
    // This will throw an error for invalid content.
    return schema.nodeFromJSON(content);
  } catch (error) {
    var details = getInvalidContent({
      schema,
      error,
      json: content
    });
    var transformedContent = onError === null || onError === void 0 ? void 0 : onError(details);
    !transformedContent ? coreHelpers.invariant(false) : void 0;
    return createDocumentNode(_objectSpread(_objectSpread({}, props), {}, {
      content: transformedContent,
      attempts: attempts + 1
    }));
  }
}
/**
 * Checks which environment should be used. Returns true when we are in the dom
 * environment.
 *
 * @param forceEnvironment - force a specific environment to override the
 * outcome
 */

function shouldUseDomEnvironment(forceEnvironment) {
  return forceEnvironment === 'dom' || environment.isBrowser && !forceEnvironment;
}
/**
 * Get the document implementation within a node environment. This is only
 * included in the build when using node.
 */

function getDocumentForNodeEnvironment() {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    var _require = require('jsdom'),
        JSDOM = _require.JSDOM;

    return new JSDOM('').window.document;
  } catch (_unused4) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      return require('domino').createDocument();
    } catch (_unused5) {
      return require('min-document');
    }
  }
}
/**
 * Retrieves the document based on the environment we are currently in.
 *
 * @param forceEnvironment - force a specific environment
 */


function getDocument(forceEnvironment) {
  if (typeof document !== 'undefined') {
    return document;
  }

  return shouldUseDomEnvironment(forceEnvironment) ? document : getDocumentForNodeEnvironment();
}

/**
 * Convert a node into its DOM representative
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 */
function prosemirrorNodeToDom(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var fragment = isDocNode(node, node.type.schema) ? node.content : model.Fragment.from(node);
  return model.DOMSerializer.fromSchema(node.type.schema).serializeFragment(fragment, {
    document
  });
}

function elementFromString(html, document) {
  var _defaultView, _ref3;

  var parser = new ((_defaultView = (_ref3 = document !== null && document !== void 0 ? document : getDocument()) === null || _ref3 === void 0 ? void 0 : _ref3.defaultView) !== null && _defaultView !== void 0 ? _defaultView : window).DOMParser();
  return parser.parseFromString("<body>".concat(html, "</body>"), 'text/html').body;
}
/**
 * Convert the provided `node` to a html string.
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 *
 * ```ts
 * import { EditorState, prosemirrorNodeToHtml } from 'remirror';
 *
 * function convertStateToHtml(state: EditorState): string {
 *   return prosemirrorNodeToHtml(state.doc);
 * }
 * ```
 */


function prosemirrorNodeToHtml(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var element = document.createElement('div');
  element.append(prosemirrorNodeToDom(node, document));
  return element.innerHTML;
}
function htmlToProsemirrorNode(props) {
  var content = props.content,
      schema = props.schema;
      props.document;
      var _props$fragment = props.fragment,
      fragment = _props$fragment === void 0 ? false : _props$fragment,
      parseOptions = _objectWithoutProperties(props, _excluded$1);

  var element = elementFromString(content);
  var parser = model.DOMParser.fromSchema(schema);
  return fragment ? parser.parseSlice(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions)).content : parser.parse(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions));
}
var defaultParseOptions = {
  preserveWhitespace: false
};
/**
 * A wrapper around `state.doc.toJSON` which returns the state as a
 * `RemirrorJSON` object.
 */

function getRemirrorJSON(content) {
  return isProsemirrorNode(content) ? content.toJSON() : content.doc.toJSON();
}

/**
 * Check if two states are equal.
 */
function areStatesEqual(stateA, stateB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // The states are identical, so they're equal.
  if (stateA === stateB) {
    return true;
  } // If the content is different then, no, not equal.


  if (!stateA.doc.eq(stateB.doc)) {
    return false;
  } // If we care about selection and selection is not the same, then not equal.


  if (options.checkSelection && !stateA.selection.eq(stateB.selection)) {
    return false;
  } // If the schema are not compatible then no, not equal.


  if (!areSchemasCompatible(stateA.schema, stateB.schema)) {
    return false;
  }

  return true;
}
/**
 * Check that the nodes and marks present on `schemaA` are also present on
 * `schemaB`.
 */

function areSchemasCompatible(schemaA, schemaB) {
  if (schemaA === schemaB) {
    return true;
  }

  var marksA = coreHelpers.keys(schemaA.marks);
  var marksB = coreHelpers.keys(schemaB.marks);
  var nodesA = coreHelpers.keys(schemaA.nodes);
  var nodesB = coreHelpers.keys(schemaB.nodes);

  if (marksA.length !== marksB.length || nodesA.length !== nodesB.length) {
    return false;
  }

  var _iterator5 = _createForOfIteratorHelper(marksA),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var mark = _step5.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!marksB.includes(mark)) {
        return false;
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  var _iterator6 = _createForOfIteratorHelper(nodesA),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var node = _step6.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!nodesB.includes(node)) {
        return false;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return true;
}
/**
 * Return attributes for a node excluding those that were provided as extra
 * attributes.
 *
 * @param attrs - The source attributes
 * @param extra - The extra attribute schema for this node
 */

function omitExtraAttributes(attrs, extra) {
  var extraAttributeNames = coreHelpers.keys(extra.defaults());
  return coreHelpers.omit(_objectSpread({}, attrs), extraAttributeNames);
}
/**
 * Take the `style` string attribute and combine it with the provided style
 * object.
 */

function joinStyles(styleObject, initialStyles) {
  var start = '';

  if (initialStyles) {
    start = "".concat(initialStyles.trim());
  }

  var end = cssInJsUtils.cssifyObject(styleObject);

  if (!end) {
    return start;
  }

  var separator = start.endsWith(';') ? ' ' : ' ';
  return "".concat(start).concat(separator).concat(end);
}

/**
 * Find the different ranges of text between a provided range with support for
 * traversing multiple nodes.
 */
function textBetween(props) {
  var from = props.from,
      to = props.to,
      doc = props.doc;
  var positions = [];
  doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isText || !node.text) {
      return;
    }

    var offset = Math.max(from, pos) - pos;
    positions.push({
      pos: pos + offset,
      text: node.text.slice(offset, to - pos)
    });
  });
  return positions;
}
/**
 * Get the full range of the selectable content in the ProseMirror `doc`.
 */

function getDocRange(doc) {
  var _AllSelection = new state.AllSelection(doc),
      from = _AllSelection.from,
      to = _AllSelection.to;

  return {
    from,
    to
  };
}
/**
 * A description of an invalid content block (representing a node or a mark).
 */

var transformers = {
  /**
   * Remove every invalid block from the editor. This is a destructive action
   * and should only be applied if you're sure it's the best strategy.
   *
   * @param json - the content as a json object.
   * @param invalidContent - the list of invalid items as passed to the error
   * handler.
   */
  remove(json, invalidContent) {
    var newJSON = json;

    var _iterator7 = _createForOfIteratorHelper(invalidContent),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var block = _step7.value;

        if (block.invalidParentNode) {
          continue;
        }

        newJSON = coreHelpers.unset(block.path, newJSON);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return newJSON;
  }

};

/**
 * Get the invalid parameter which is passed to the `onError` handler.
 */
function getInvalidContent(_ref4) {
  var json = _ref4.json,
      schema = _ref4.schema,
      extra = _objectWithoutProperties(_ref4, _excluded2$1);

  var validMarks = new Set(coreHelpers.keys(schema.marks));
  var validNodes = new Set(coreHelpers.keys(schema.nodes));
  var invalidContent = checkForInvalidContent({
    json,
    path: [],
    validNodes,
    validMarks
  });
  return _objectSpread({
    json,
    invalidContent,
    transformers
  }, extra);
}

/**
 * Get the invalid content from the `RemirrorJSON`.
 */
function checkForInvalidContent(props) {
  var json = props.json,
      validMarks = props.validMarks,
      validNodes = props.validNodes,
      _props$path = props.path,
      path = _props$path === void 0 ? [] : _props$path;
  var valid = {
    validMarks,
    validNodes
  };
  var invalidNodes = [];
  var type = json.type,
      marks = json.marks,
      content = json.content;
  var _props$invalidParentM = props.invalidParentMark,
      invalidParentMark = _props$invalidParentM === void 0 ? false : _props$invalidParentM,
      _props$invalidParentN = props.invalidParentNode,
      invalidParentNode = _props$invalidParentN === void 0 ? false : _props$invalidParentN;

  if (marks) {
    var invalidMarks = [];

    var _iterator8 = _createForOfIteratorHelper(marks.entries()),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _step8$value = _slicedToArray(_step8.value, 2),
            index = _step8$value[0],
            mark = _step8$value[1];

        var name = coreHelpers.isString(mark) ? mark : mark.type;

        if (validMarks.has(name)) {
          continue;
        }

        invalidMarks.unshift({
          name,
          path: [...path, 'marks', "".concat(index)],
          type: 'mark',
          invalidParentMark,
          invalidParentNode
        });
        invalidParentMark = true;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    invalidNodes.push(...invalidMarks);
  }

  if (!validNodes.has(type)) {
    invalidNodes.push({
      name: type,
      type: 'node',
      path,
      invalidParentMark,
      invalidParentNode
    });
    invalidParentNode = true;
  }

  if (content) {
    var invalidContent = [];

    var _iterator9 = _createForOfIteratorHelper(content.entries()),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var _step9$value = _slicedToArray(_step9.value, 2),
            _index = _step9$value[0],
            value = _step9$value[1];

        invalidContent.unshift(...checkForInvalidContent(_objectSpread(_objectSpread({}, valid), {}, {
          json: value,
          path: [...path, 'content', "".concat(_index)],
          invalidParentMark,
          invalidParentNode
        })));
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    invalidNodes.unshift(...invalidContent);
  }

  return invalidNodes;
}
/**
 * Checks that the selection is an empty text selection at the end of its parent
 * node.
 */


function isEndOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset >= selection.$cursor.parent.content.size);
}
/**
 * Checks that the selection is an empty text selection at the start of its
 * parent node.
 */

function isStartOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset <= 0);
}
/**
 * Returns true when the selection is a text selection at the start of the
 * document.
 */

function isStartOfDoc(selection) {
  var selectionAtStart = state.Selection.atStart(selection.$anchor.doc);
  return !!(isStartOfTextBlock(selection) && selectionAtStart.anchor === selection.anchor);
}

/**
 * Update the selection with the provided MarkType.
 *
 * @param props - see [[`UpdateMarkProps`]] for options
 */
function updateMark(props) {
  return _ref => {
    var dispatch = _ref.dispatch,
        tr = _ref.tr;
    var type = props.type,
        _props$attrs = props.attrs,
        attrs = _props$attrs === void 0 ? coreHelpers.object() : _props$attrs,
        appendText = props.appendText,
        range = props.range;
    var selection = range ? state.TextSelection.create(tr.doc, range.from, range.to) : tr.selection;
    var $from = selection.$from,
        from = selection.from,
        to = selection.to;
    var applicable = $from.depth === 0 ? tr.doc.type.allowsMarkType(type) : false;
    tr.doc.nodesBetween(from, to, node => {
      if (applicable) {
        return false;
      }

      if (node.inlineContent && node.type.allowsMarkType(type)) {
        applicable = true;
        return;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, type.create(attrs)) && appendText ? tr.insertText(appendText) : tr);
    return true;
  };
}
/**
 * Lift the selected block, or the closest ancestor block of the selection that
 * can be lifted, out of its parent node.
 *
 * Adapted from
 * https://github.com/ProseMirror/prosemirror-commands/blob/3126d5c625953ba590c5d3a0db7f1009f46f1571/src/commands.js#L212-L221
 */

function lift(_ref2) {
  var tr = _ref2.tr,
      dispatch = _ref2.dispatch;
  var _tr$selection = tr.selection,
      $from = _tr$selection.$from,
      $to = _tr$selection.$to;
  var range = $from.blockRange($to);
  var target = range && transform.liftTarget(range);

  if (!coreHelpers.isNumber(target) || !range) {
    return false;
  }

  dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.lift(range, target).scrollIntoView());
  return true;
}
/**
 * Wrap the selection or the provided text in a node of the given type with the
 * given attributes.
 */

function wrapIn(type) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var nodeType = coreHelpers.isString(type) ? coreHelpers.assertGet(state.schema.nodes, type) : type;

    var _getTextSelection = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection.from,
        to = _getTextSelection.to;

    var $from = tr.doc.resolve(from);
    var $to = tr.doc.resolve(to);
    var blockRange = $from.blockRange($to);
    var wrapping = blockRange && transform.findWrapping(blockRange, nodeType, attrs);

    if (!wrapping || !blockRange) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.wrap(blockRange, wrapping).scrollIntoView());
    return true;
  };
}
/**
 * Toggle between wrapping an inactive node with the provided node type, and
 * lifting it up into it's parent.
 *
 * @param nodeType - the node type to toggle
 * @param attrs - the attrs to use for the node
 */

function toggleWrap(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return props => {
    var tr = props.tr,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });

    if (activeNode) {
      return lift(props);
    }

    return wrapIn(nodeType, attrs, selection)(props);
  };
}
/**
 * Returns a command that tries to set the selected textblocks to the
 * given node type with the given attributes.
 *
 * @param nodeType - the name of the node or the [[`NodeType`]].
 */

function setBlockType(nodeType, attrs, selection) {
  var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;

    var _getTextSelection2 = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection2.from,
        to = _getTextSelection2.to;

    var applicable = false;
    var activeAttrs;
    tr.doc.nodesBetween(from, to, (node, pos) => {
      if (applicable) {
        // Exit early and don't descend.
        return false;
      }

      if (!node.isTextblock || node.hasMarkup(type, attrs)) {
        return;
      }

      if (node.type === type) {
        applicable = true;
        activeAttrs = node.attrs;
        return;
      }

      var $pos = tr.doc.resolve(pos);
      var index = $pos.index();
      applicable = $pos.parent.canReplaceWith(index, index + 1, type);

      if (applicable) {
        activeAttrs = $pos.parent.attrs;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setBlockType(from, to, type, _objectSpread(_objectSpread({}, preserveAttrs ? activeAttrs : {}), attrs)).scrollIntoView());
    return true;
  };
}

/**
 * Toggle a block between the provided type and toggleType.
 *
 * @param toggleProps - see [[`ToggleBlockItemProps`]] for available options
 */
function toggleBlockItem(toggleProps) {
  return props => {
    var _toggleProps$toggleTy;

    var tr = props.tr,
        state = props.state;
    var type = toggleProps.type,
        attrs = toggleProps.attrs,
        _toggleProps$preserve = toggleProps.preserveAttrs,
        preserveAttrs = _toggleProps$preserve === void 0 ? true : _toggleProps$preserve;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });
    var toggleType = (_toggleProps$toggleTy = toggleProps.toggleType) !== null && _toggleProps$toggleTy !== void 0 ? _toggleProps$toggleTy : getDefaultBlockNode(state.schema);

    if (activeNode) {
      return setBlockType(toggleType, _objectSpread(_objectSpread({}, preserveAttrs ? activeNode.node.attrs : {}), attrs))(props);
    }

    var toggleNode = getActiveNode({
      state: tr,
      type: toggleType,
      attrs
    });
    return setBlockType(type, _objectSpread(_objectSpread({}, preserveAttrs ? toggleNode === null || toggleNode === void 0 ? void 0 : toggleNode.node.attrs : {}), attrs))(props);
  };
}

/**
 * Taken from https://stackoverflow.com/a/4900484
 *
 * Check that the browser is chrome. Supports passing a minimum version to check
 * that it is a greater than or equal to this version.
 */
function isChrome() {
  var minVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var parsedAgent = navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./);
  return parsedAgent ? Number.parseInt(coreHelpers.assertGet(parsedAgent, 2), 10) >= minVersion : false;
}
/**
 * Checks the selection for the current state and updates the active transaction
 * to a selection that is consistent with the initial selection.
 *
 * @param state - the editor state before any updates
 * @param tr - the transaction which has been updated and may have impacted the
 * selection.
 */

function preserveSelection(selection, tr) {
  // Get the previous movable part of the cursor selection.
  var head = selection.head,
      empty = selection.empty,
      anchor = selection.anchor; // Map this movable cursor selection through each of the steps that have happened in
  // the transaction.

  var _iterator = _createForOfIteratorHelper(tr.steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      var map = step.getMap();
      head = map.map(head);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (empty) {
    // Update the transaction with the new text selection.
    tr.setSelection(state.TextSelection.create(tr.doc, head));
  } else {
    tr.setSelection(state.TextSelection.create(tr.doc, anchor, head));
  }
}
/**
 * Replaces text with an optional appended string at the end.
 *
 * @param props - see [[`ReplaceTextProps`]]
 */

function replaceText(props) {
  var _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      _props$appendText = props.appendText,
      appendText = _props$appendText === void 0 ? '' : _props$appendText,
      _props$content = props.content,
      content = _props$content === void 0 ? '' : _props$content,
      _props$keepSelection = props.keepSelection,
      keepSelection = _props$keepSelection === void 0 ? false : _props$keepSelection,
      range = props.range;
  return _ref3 => {
    var _ref4, _props$selection, _schema$nodes$props$t;

    var state = _ref3.state,
        tr = _ref3.tr,
        dispatch = _ref3.dispatch;
    var schema = state.schema;
    var selection = getTextSelection((_ref4 = (_props$selection = props.selection) !== null && _props$selection !== void 0 ? _props$selection : range) !== null && _ref4 !== void 0 ? _ref4 : tr.selection, tr.doc);
    var index = selection.$from.index();
    var from = selection.from,
        to = selection.to,
        $from = selection.$from;
    var type = coreHelpers.isString(props.type) ? (_schema$nodes$props$t = schema.nodes[props.type]) !== null && _schema$nodes$props$t !== void 0 ? _schema$nodes$props$t : schema.marks[props.type] : props.type;
    !(coreHelpers.isString(props.type) ? type : true) ? coreHelpers.invariant(false) : void 0;

    if (isNodeType(type)) {
      if (!$from.parent.canReplaceWith(index, index, type)) {
        return false;
      }

      tr.replaceWith(from, to, type.create(attrs, content ? schema.text(content) : undefined));
    } else {
      !content ? coreHelpers.invariant(false) : void 0;
      tr.replaceWith(from, to, schema.text(content, isMarkType(type) ? [type.create(attrs)] : undefined));
    } // Only append the text if text is provided (ignore the empty string).


    if (appendText) {
      tr.insertText(appendText);
    }

    if (keepSelection) {
      preserveSelection(state.selection, tr);
    }

    if (dispatch) {
      // A workaround for a chrome bug
      // https://github.com/ProseMirror/prosemirror/issues/710#issuecomment-338047650
      if (isChrome(60)) {
        var _document$getSelectio;

        (_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.empty();
      }

      dispatch(tr);
    }

    return true;
  };
}
/**
 * Retrieve the first mark at a given resolved position `$pos` or range
 *
 * @remarks
 *
 * If multiple marks are present, the returned mark will be the mark with highest priority.
 *
 * @param $pos - the resolved ProseMirror position
 * @param $end - the end position to search until. When this is provided
 * it will search for a mark until the `$end`. The first mark within
 * the range will be returned.
 */

function getFirstMark($pos, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var _start$node = start.node,
      marks = _start$node.marks,
      nodeSize = _start$node.nodeSize;

  if (marks[0]) {
    return marks[0].type;
  }

  var startPos = $pos.start() + start.offset;
  var endPos = startPos + nodeSize;
  return getFirstMark($pos.doc.resolve(endPos + 1));
}

/**
 * Removes a mark from the current selection or provided range.
 *
 * @param props - see [[`RemoveMarkProps`]] for options
 */
function removeMark(props) {
  return _ref5 => {
    var _ref6, _props$selection2;

    var dispatch = _ref5.dispatch,
        tr = _ref5.tr,
        state = _ref5.state;
    var type = props.type,
        _props$expand = props.expand,
        expand = _props$expand === void 0 ? true : _props$expand,
        range = props.range;
    var selection = getTextSelection((_ref6 = (_props$selection2 = props.selection) !== null && _props$selection2 !== void 0 ? _props$selection2 : range) !== null && _ref6 !== void 0 ? _ref6 : tr.selection, tr.doc);
    var from = selection.from,
        to = selection.to,
        $from = selection.$from,
        $to = selection.$to;
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;

    if (markType !== null) {
      !markType ? coreHelpers.invariant(false) : void 0;
    } // If no mark type was supplied, get the first mark present on this node to determine a mark range


    var rangeMark = markType !== null && markType !== void 0 ? markType : getFirstMark($from);

    if (!rangeMark) {
      return false;
    }

    var markRange = getMarkRange($from, rangeMark, $to);

    if (expand && markRange) {
      // Expand the from position to the mark range (if it is smaller) - keep bound within doc
      from = Math.max(0, Math.min(from, markRange.from)); // Expand the to position to the mark range (if it is larger) - keep bound within doc

      to = Math.min(Math.max(to, markRange.to), tr.doc.nodeSize - 2);
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, coreHelpers.isNumber(to) ? to : from, isMarkType(markType) ? markType : undefined));
    return true;
  };
}

/**
 * Return true when the provided key is the the Command () key. Takes into
 * account the platform.
 */

function isCommandKey(key) {
  var allowedKeys = ['command', 'cmd', 'meta'];

  if (environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}
/**
 * Return true when the provided key is the the Control () key. Takes into
 * account the platform.
 */


function isControlKey(key) {
  var allowedKeys = ['control', 'ctrl'];

  if (!environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}

/**
 * Convert a keyboard shortcut into symbols which and keys.
 */
function getShortcutSymbols(shortcut) {
  var symbols = [];

  var _iterator = _createForOfIteratorHelper(shortcut.split('-')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      key = key.toLowerCase();

      if (isCommandKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '',
          key: 'command',
          i18n: messages.CoreUtilsMessages.COMMAND_KEY
        });
        continue;
      }

      if (isControlKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '',
          key: 'control',
          i18n: messages.CoreUtilsMessages.CONTROL_KEY
        });
        continue;
      }

      switch (key) {
        case 'shift':
          symbols.push({
            type: 'modifier',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.SHIFT_KEY
          });
          continue;

        case 'alt':
          symbols.push({
            type: 'modifier',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ALT_KEY
          });
          continue;

        case '\n':
        case '\r':
        case 'enter':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ENTER_KEY
          });
          continue;

        case 'backspace':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.BACKSPACE_KEY
          });
          continue;

        case 'delete':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.DELETE_KEY
          });
          continue;

        case 'escape':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ESCAPE_KEY
          });
          continue;

        case 'tab':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.TAB_KEY
          });
          continue;

        case 'capslock':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.CAPS_LOCK_KEY
          });
          continue;

        case 'space':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.SPACE_KEY
          });
          continue;

        case 'pageup':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_UP_KEY
          });
          continue;

        case 'pagedown':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_DOWN_KEY
          });
          continue;

        case 'home':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.HOME_KEY
          });
          continue;

        case 'end':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.END_KEY
          });
          continue;

        case 'arrowleft':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_LEFT_KEY
          });
          continue;

        case 'arrowright':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_RIGHT_KEY
          });
          continue;

        case 'arrowup':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_UP_KEY
          });
          continue;

        case 'arrowdown':
          symbols.push({
            type: 'named',
            symbol: '',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_DOWN_KEY
          });
          continue;

        default:
          symbols.push({
            type: 'char',
            key
          });
          continue;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return symbols;
}

var _excluded = ["attrs"],
    _excluded2 = ["type"],
    _excluded3 = ["type"];

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findChildren({
 *   node: state.doc,
 *   predicate: child => child.isText,
 *   descend: false
 * });
 * ```
 */
function findChildren(props) {
  var node = props.node,
      predicate = props.predicate,
      _props$descend = props.descend,
      descend = _props$descend === void 0 ? true : _props$descend,
      action = props.action; // Ensure that the node provided is a `ProsemirrorNode`.

  !isProsemirrorNode(node) ? coreHelpers.invariant(false) : void 0; // Ensure that the predicate is a function.

  !coreHelpers.isFunction(predicate) ? coreHelpers.invariant(false) : void 0; // This is used to keep track of all the node positions.

  var result = []; // Start descending into the provided node. This can be an expensive operation
  // if the document is very large or deeply nested.

  node.descendants((child, pos) => {
    var nodeWithPosition = {
      node: child,
      pos
    }; // True when this call matches the required condition - returns `true`.

    var isMatch = predicate(nodeWithPosition);

    if (!isMatch) {
      // Move onto the next node or descendant depending on the value of
      // `descend`.
      return descend;
    } // Store the result and run the provided action if it exists.


    result.push(nodeWithPosition);
    action === null || action === void 0 ? void 0 : action(nodeWithPosition);
    return descend;
  });
  return result;
}
/**
 * A utility for creating methods that find a node by a specific condition.
 */

function findNodeByPredicate(_ref) {
  var predicate = _ref.predicate;
  return props => findChildren(_objectSpread(_objectSpread({}, props), {}, {
    predicate
  }));
}
/**
 * Returns text nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findTextNodes({ node });
 * ```
 */


var findTextNodes = findNodeByPredicate({
  predicate: child => child.node.isText
});
/**
 * Returns inline nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const inlineNodes = findInlineNodes(node);
 * ```
 */

var findInlineNodes = findNodeByPredicate({
  predicate: child => child.node.isInline
});
/**
 * Returns block descendants of a given `node`.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const blockNodes = findBlockNodes(node);
 * ```
 */

var findBlockNodes = findNodeByPredicate({
  predicate: child => child.node.isBlock
});

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * The following will match any node with an `id` of any value (as long as the
 * attribute exists) and a `colspan` of `2`.
 *
 * ```ts
 * const mergedCells = findChildrenByAttribute({
 *   node: table,
 *   attrs: { colspan: 2, id: (_, exists) => exists }
 * });
 * ```
 */
function findChildrenByAttribute(props) {
  var attrs = props.attrs,
      rest = _objectWithoutProperties(props, _excluded);
  /**
   * The predicate function which loops through the provided attributes check if
   * they are valid.
   */


  function predicate(nodeWithPos) {
    var attributeKeys = new Set(coreHelpers.keys(nodeWithPos.node.attrs));

    var _iterator = _createForOfIteratorHelper(coreHelpers.entries(attrs)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            attr = _step$value[0],
            expectedValue = _step$value[1];

        var value = nodeWithPos.node.attrs[attr];

        if ( // The user has passed in a predicate checking function.
        coreHelpers.isFunction(expectedValue)) {
          var exists = attributeKeys.has(attr);

          if ( // Check if the predicate checker returns false, in which case we can
          // exit early.
          !expectedValue({
            value,
            exists
          })) {
            return false;
          }

          continue;
        }

        if ( // If the value doesn't match the expected value, exit early.
        value !== expectedValue) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes of a given
 * nodeType.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const cells = findChildrenByNode({ node: state.doc, type: state.schema.nodes.tableCell });
 * ```
 */
function findChildrenByNode(props) {
  var type = props.type,
      rest = _objectWithoutProperties(props, _excluded2);

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => child.node.type === type
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes that have
 * a mark of a given markType.
 *
 * @remarks
 *
 * It doesn't descend into a `node` when descend argument is `false` (defaults
 * to `true`).
 *
 * ```ts
 * const nodes = findChildrenByMark({ node: state.doc, type: schema.marks.strong });
 * ```
 */
function findChildrenByMark(paramter) {
  var type = paramter.type,
      rest = _objectWithoutProperties(paramter, _excluded3);

  var markType;
  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => {
      if (!markType) {
        markType = coreHelpers.isString(type) ? child.node.type.schema.marks[type] : type;
        !markType ? coreHelpers.invariant(false) : void 0;
      }

      return !!markType.isInSet(child.node.marks);
    }
  }));
}

/**
 * Returns `true` if a given node contains nodes of a given `nodeType`.
 *
 * @remarks
 *
 * ```ts
 * if (containsNodesOfType({ node: state.doc, type: schema.nodes.listItem })) {
 *   log('contained')
 * }
 * ```
 */
function containsNodesOfType(props) {
  var node = props.node,
      type = props.type;
  return findChildrenByNode({
    node,
    type
  }).length > 0;
}

/**
 * Get all the changed nodes from the provided transaction.
 *
 * The following example will give us all the text nodes in the provided
 * transaction.
 *
 * ```ts
 * import { getChangedNodes } from 'remirror/core';
 *
 * const changedTextNodes = getChangeNodes(tr, { descend: true, predicate: (node) => node.isText });
 * ```
 */
function getChangedNodes(tr) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$descend = options.descend,
      descend = _options$descend === void 0 ? false : _options$descend,
      predicate = options.predicate,
      StepTypes = options.StepTypes;
  var nodeRange = getChangedNodeRanges(tr, StepTypes); // The container for the nodes which have been added..

  var nodes = [];

  var _iterator2 = _createForOfIteratorHelper(nodeRange),
      _step2;

  try {
    var _loop = function _loop() {
      var range = _step2.value;
      var start = range.start,
          end = range.end; // Find all the nodes between the provided node range.

      tr.doc.nodesBetween(start, end, (node, pos) => {
        var _predicate;

        // Check wether this is a node that should be added.
        var shouldAdd = (_predicate = predicate === null || predicate === void 0 ? void 0 : predicate(node, pos, range)) !== null && _predicate !== void 0 ? _predicate : true;

        if (shouldAdd) {
          nodes.push({
            node,
            pos
          });
        }

        return descend;
      });
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return nodes;
}

/**
 * Creates an input rule based on the provided regex for the provided mark type.
 */
function markInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      _props$ignoreWhitespa = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa === void 0 ? false : _props$ignoreWhitespa,
      beforeDispatch = props.beforeDispatch,
      updateCaptured = props.updateCaptured,
      shouldSkip = props.shouldSkip,
      invalidMarks = props.invalidMarks;
  var markType;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var tr = state.tr,
        schema = state.schema;

    if (!markType) {
      markType = coreHelpers.isString(type) ? schema.marks[type] : type;
      !markType ? coreHelpers.invariant(false) : void 0;
    }

    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var markEnd = end;
    var initialStoredMarks = [];

    if (captureGroup) {
      var _tr$storedMarks;

      var startSpaces = fullMatch.search(/\S/);
      var textStart = start + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      initialStoredMarks = (_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : [];

      if (textEnd < end) {
        tr.delete(textEnd, end);
      }

      if (textStart > start) {
        tr.delete(start + startSpaces, textStart);
      }

      markEnd = start + startSpaces + captureGroup.length;
    }

    tr.addMark(start, markEnd, markType.create(attributes)); // Make sure not to reactivate any marks which had previously been
    // deactivated. By keeping track of the initial stored marks we are able to
    // discard any unintended consequences of deleting text and adding it again.

    tr.setStoredMarks(initialStoredMarks); // Allow the caller of this method to update the transaction before it is
    // returned and dispatched by ProseMirror.

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}
/**
 * Creates a node input rule based on the provided regex for the provided node
 * type.
 *
 * Input rules transform content as the user types based on whether a match is
 * found with a sequence of characters.
 */

function nodeInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa2 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa2 === void 0 ? false : _props$ignoreWhitespa2,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var tr = state.tr,
        schema = state.schema;
    var nodeType = coreHelpers.isString(type) ? schema.nodes[type] : type;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    !nodeType ? coreHelpers.invariant(false) : void 0;
    var content = nodeType.createAndFill(attributes);

    if (content) {
      var _captureGroup;

      tr.replaceRangeWith(nodeType.isBlock ? tr.doc.resolve(start).before() : start, end, content);
      beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
        tr,
        match: [fullMatch, (_captureGroup = captureGroup) !== null && _captureGroup !== void 0 ? _captureGroup : ''],
        start,
        end
      });
    }

    return tr;
  });
  return rule;
}
/**
 * Creates a plain rule based on the provided regex. You can see this being used
 * in the `@remirror/extension-emoji` when it is setup to use plain text.
 */

function plainInputRule(props) {
  var regexp = props.regexp,
      transformMatch = props.transformMatch,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa3 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa3 === void 0 ? false : _props$ignoreWhitespa3,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var value = transformMatch(match);

    if (coreHelpers.isNullOrUndefined(value)) {
      return null;
    }

    var tr = state.tr,
        schema = state.schema;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;

    if (value === '') {
      tr.delete(start, end);
    } else {
      tr.replaceWith(start, end, schema.text(value));
    }

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}

/**
 * This is a monster of a function.
 *
 * TODO make it make sense.
 */
function gatherDetails(_ref) {
  var _updateCaptured, _details$captureGroup, _details$fullMatch, _details$start, _details$end, _captureGroup2, _rule$shouldSkip;

  var captureGroup = _ref.captureGroup,
      fullMatch = _ref.fullMatch,
      end = _ref.end,
      start = _ref.start,
      rule = _ref.rule,
      ignoreWhitespace = _ref.ignoreWhitespace,
      shouldSkip = _ref.shouldSkip,
      updateCaptured = _ref.updateCaptured,
      state = _ref.state,
      invalidMarks = _ref.invalidMarks;

  if (fullMatch == null) {
    return null;
  } // Update the internal values with the user provided method.


  var details = (_updateCaptured = updateCaptured === null || updateCaptured === void 0 ? void 0 : updateCaptured({
    captureGroup,
    fullMatch,
    start,
    end
  })) !== null && _updateCaptured !== void 0 ? _updateCaptured : {}; // Store the updated values or the original.

  captureGroup = (_details$captureGroup = details.captureGroup) !== null && _details$captureGroup !== void 0 ? _details$captureGroup : captureGroup;
  fullMatch = (_details$fullMatch = details.fullMatch) !== null && _details$fullMatch !== void 0 ? _details$fullMatch : fullMatch;
  start = (_details$start = details.start) !== null && _details$start !== void 0 ? _details$start : start;
  end = (_details$end = details.end) !== null && _details$end !== void 0 ? _details$end : end;
  var $from = state.doc.resolve(start);
  var $to = state.doc.resolve(end);

  if ( // Skip when the range contains an excluded mark.
  invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, invalidMarks) || rule.invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, rule.invalidMarks) || // Skip pure whitespace updates
  ignoreWhitespace && ((_captureGroup2 = captureGroup) === null || _captureGroup2 === void 0 ? void 0 : _captureGroup2.trim()) === '' || // Skip when configured to do
  shouldSkip !== null && shouldSkip !== void 0 && shouldSkip({
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  }) || (_rule$shouldSkip = rule.shouldSkip) !== null && _rule$shouldSkip !== void 0 && _rule$shouldSkip.call(rule, {
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  })) {
    return null;
  }

  return {
    captureGroup,
    end,
    fullMatch,
    start
  };
}

Object.defineProperty(exports, 'chainCommands', {
  enumerable: true,
  get: function () { return pm.chainCommands; }
});
Object.defineProperty(exports, 'chainableEditorState', {
  enumerable: true,
  get: function () { return pm.chainableEditorState; }
});
Object.defineProperty(exports, 'convertCommand', {
  enumerable: true,
  get: function () { return pm.convertCommand; }
});
Object.defineProperty(exports, 'nonChainable', {
  enumerable: true,
  get: function () { return pm.nonChainable; }
});
exports.DOM_SIZE_UNITS = DOM_SIZE_UNITS;
exports.applyClonedTransaction = applyClonedTransaction;
exports.areSchemasCompatible = areSchemasCompatible;
exports.areStatesEqual = areStatesEqual;
exports.atDocEnd = atDocEnd;
exports.atDocStart = atDocStart;
exports.canInsertNode = canInsertNode;
exports.chainKeyBindingCommands = chainKeyBindingCommands;
exports.cloneTransaction = cloneTransaction;
exports.composeTransactionSteps = composeTransactionSteps;
exports.containsAttributes = containsAttributes;
exports.containsNodesOfType = containsNodesOfType;
exports.convertPixelsToDomUnit = convertPixelsToDomUnit;
exports.createDocumentNode = createDocumentNode;
exports.endPositionOfParent = endPositionOfParent;
exports.environment = environment;
exports.extractPixelSize = extractPixelSize;
exports.findBlockNodes = findBlockNodes;
exports.findChildren = findChildren;
exports.findChildrenByAttribute = findChildrenByAttribute;
exports.findChildrenByMark = findChildrenByMark;
exports.findChildrenByNode = findChildrenByNode;
exports.findElementAtPosition = findElementAtPosition;
exports.findInlineNodes = findInlineNodes;
exports.findNodeAtPosition = findNodeAtPosition;
exports.findNodeAtSelection = findNodeAtSelection;
exports.findParentNode = findParentNode;
exports.findParentNodeOfType = findParentNodeOfType;
exports.findPositionOfNodeAfter = findPositionOfNodeAfter;
exports.findPositionOfNodeBefore = findPositionOfNodeBefore;
exports.findSelectedNodeOfType = findSelectedNodeOfType;
exports.findTextNodes = findTextNodes;
exports.getActiveNode = getActiveNode;
exports.getChangedNodeRanges = getChangedNodeRanges;
exports.getChangedNodes = getChangedNodes;
exports.getChangedRanges = getChangedRanges;
exports.getCursor = getCursor;
exports.getDefaultBlockNode = getDefaultBlockNode;
exports.getDefaultDocNode = getDefaultDocNode;
exports.getDocRange = getDocRange;
exports.getDocument = getDocument;
exports.getFontSize = getFontSize;
exports.getInvalidContent = getInvalidContent;
exports.getMarkAttributes = getMarkAttributes;
exports.getMarkRange = getMarkRange;
exports.getMarkRanges = getMarkRanges;
exports.getMarkType = getMarkType;
exports.getMatchString = getMatchString;
exports.getNodeType = getNodeType;
exports.getRemirrorJSON = getRemirrorJSON;
exports.getSelectedGroup = getSelectedGroup;
exports.getSelectedWord = getSelectedWord;
exports.getShortcutSymbols = getShortcutSymbols;
exports.getStyle = getStyle;
exports.getTextContentFromSlice = getTextContentFromSlice;
exports.getTextSelection = getTextSelection;
exports.hasTransactionChanged = hasTransactionChanged;
exports.htmlToProsemirrorNode = htmlToProsemirrorNode;
exports.isAllSelection = isAllSelection;
exports.isChrome = isChrome;
exports.isDefaultBlockNode = isDefaultBlockNode;
exports.isDefaultDocNode = isDefaultDocNode;
exports.isDocNode = isDocNode;
exports.isDocNodeEmpty = isDocNodeEmpty;
exports.isDomNode = isDomNode;
exports.isEditorSchema = isEditorSchema;
exports.isEditorState = isEditorState;
exports.isElementDomNode = isElementDomNode;
exports.isEmptyBlockNode = isEmptyBlockNode;
exports.isEndOfTextBlock = isEndOfTextBlock;
exports.isIdentifierOfType = isIdentifierOfType;
exports.isMarkActive = isMarkActive;
exports.isMarkType = isMarkType;
exports.isNodeActive = isNodeActive;
exports.isNodeOfType = isNodeOfType;
exports.isNodeSelection = isNodeSelection;
exports.isNodeType = isNodeType;
exports.isProsemirrorFragment = isProsemirrorFragment;
exports.isProsemirrorMark = isProsemirrorMark;
exports.isProsemirrorNode = isProsemirrorNode;
exports.isRemirrorJSON = isRemirrorJSON;
exports.isRemirrorType = isRemirrorType;
exports.isResolvedPos = isResolvedPos;
exports.isSelection = isSelection;
exports.isSelectionEmpty = isSelectionEmpty;
exports.isStartOfDoc = isStartOfDoc;
exports.isStartOfTextBlock = isStartOfTextBlock;
exports.isTextDomNode = isTextDomNode;
exports.isTextSelection = isTextSelection;
exports.isTransaction = isTransaction;
exports.joinStyles = joinStyles;
exports.lift = lift;
exports.markEqualsType = markEqualsType;
exports.markInputRule = markInputRule;
exports.mergeKeyBindings = mergeKeyBindings;
exports.mergeProsemirrorKeyBindings = mergeProsemirrorKeyBindings;
exports.nodeInputRule = nodeInputRule;
exports.omitExtraAttributes = omitExtraAttributes;
exports.parseSizeUnit = parseSizeUnit;
exports.plainInputRule = plainInputRule;
exports.preserveSelection = preserveSelection;
exports.prosemirrorNodeToDom = prosemirrorNodeToDom;
exports.prosemirrorNodeToHtml = prosemirrorNodeToHtml;
exports.rangeHasMark = rangeHasMark;
exports.removeMark = removeMark;
exports.removeNodeAfter = removeNodeAfter;
exports.removeNodeAtPosition = removeNodeAtPosition;
exports.removeNodeBefore = removeNodeBefore;
exports.replaceNodeAtPosition = replaceNodeAtPosition;
exports.replaceText = replaceText;
exports.schemaToJSON = schemaToJSON;
exports.setBlockType = setBlockType;
exports.setStyle = setStyle;
exports.shouldUseDomEnvironment = shouldUseDomEnvironment;
exports.startPositionOfParent = startPositionOfParent;
exports.textBetween = textBetween;
exports.toggleBlockItem = toggleBlockItem;
exports.toggleWrap = toggleWrap;
exports.updateMark = updateMark;
exports.wrapIn = wrapIn;
