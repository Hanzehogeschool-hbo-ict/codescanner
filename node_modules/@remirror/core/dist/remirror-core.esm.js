import _slicedToArray from '@babel/runtime/helpers/esm/slicedToArray';
import _objectSpread from '@babel/runtime/helpers/esm/objectSpread2';
import _createForOfIteratorHelper from '@babel/runtime/helpers/esm/createForOfIteratorHelper';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { ErrorConstant, ExtensionPriority, __INTERNAL_REMIRROR_IDENTIFIER_KEY__, RemirrorIdentifier, NamedShortcut, NULL_CHARACTER, ExtensionTag, ManagerPhase } from '@remirror/core-constants';
export * from '@remirror/core-constants';
import { freeze, object, keys, invariant, deepMerge, isEmptyArray, omit, sort, noop, isFunction, pascalCase, uniqueBy, assertGet, Cast, cx, isPromise, isString, entries, uniqueArray, isEmptyObject, uniqueId, isNumber, isUndefined, isArray, includes, values, isNullOrUndefined, isPlainObject, toString, pick, omitUndefined, getLazyArray } from '@remirror/core-helpers';
export * from '@remirror/core-helpers';
import { isRemirrorType, isIdentifierOfType, getTextSelection, isMarkActive, convertCommand, getCursor, getMarkRange, isTextSelection, isProsemirrorNode, isProsemirrorFragment, isEmptyBlockNode, setBlockType, toggleWrap, toggleBlockItem, wrapIn, removeMark, htmlToProsemirrorNode, replaceText, environment, findNodeAtPosition, isNodeSelection, isNodeActive, getActiveNode, containsAttributes, isSelectionEmpty, prosemirrorNodeToHtml, mergeProsemirrorKeyBindings, chainKeyBindingCommands, isEndOfTextBlock, findParentNodeOfType, isDefaultBlockNode, isStartOfDoc, isStartOfTextBlock, getDefaultBlockNode, isElementDomNode, isProsemirrorMark, getDocument, createDocumentNode } from '@remirror/core-utils';
export * from '@remirror/core-utils';
import { toggleMark as toggleMark$1, baseKeymap, chainCommands, selectParentNode } from '@remirror/pm/commands';
export * from '@remirror/core-types';
import _classPrivateFieldSet from '@babel/runtime/helpers/esm/classPrivateFieldSet';
import _classPrivateFieldGet from '@babel/runtime/helpers/esm/classPrivateFieldGet';
import { createNanoEvents } from 'nanoevents';
import { TextSelection, PluginKey, Plugin, EditorState } from '@remirror/pm/state';
import warning from 'tiny-warning';
import _applyDecoratedDescriptor from '@babel/runtime/helpers/esm/applyDecoratedDescriptor';
import { CoreMessages } from '@remirror/messages';
import { Mark, Schema } from '@remirror/pm/model';
import _objectWithoutProperties from '@babel/runtime/helpers/esm/objectWithoutProperties';
import { DecorationSet, Decoration } from '@remirror/pm/view';
import { inputRules, undoInputRule } from '@remirror/pm/inputrules';
import { keymap } from '@remirror/pm/keymap';
import { pasteRules } from '@remirror/pm/paste-rules';
import { ignoreUpdateForSuggest, addSuggester, removeSuggester, suggest, getSuggestPluginState } from '@remirror/pm/suggest';

function defaultEquals(valueA, valueB) {
  return valueA === valueB;
}
/**
 * Get the property changes and the next value from an update.
 */


function getChangedOptions(props) {
  var previousOptions = props.previousOptions,
      update = props.update,
      _props$equals = props.equals,
      equals = _props$equals === void 0 ? defaultEquals : _props$equals;
  var next = freeze(_objectSpread(_objectSpread({}, previousOptions), update));
  var changes = object();
  var optionKeys = keys(previousOptions);

  var _iterator = _createForOfIteratorHelper(optionKeys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      var previousValue = previousOptions[key];
      var value = next[key];

      if (equals(previousValue, value)) {
        changes[key] = {
          changed: false
        };
        continue;
      }

      changes[key] = {
        changed: true,
        previousValue,
        value
      };
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var pickChanged = keys => {
    var picked = object();

    var _iterator2 = _createForOfIteratorHelper(keys),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var key = _step2.value;
        var item = changes[key];

        if (item !== null && item !== void 0 && item.changed) {
          picked[key] = item.value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return picked;
  };

  return {
    changes: freeze(changes),
    options: next,
    pickChanged
  };
}
var codeLabelMap = {
  [ErrorConstant.DUPLICATE_HELPER_NAMES]: 'helper method',
  [ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'command method'
};
/**
 * Checks whether a given string is unique to the set. Add the name if it
 * doesn't already exist, or throw an error when `shouldThrow` is true.
 *
 * @param props - destructured params
 */

function throwIfNameNotUnique(props) {
  var name = props.name,
      set = props.set,
      code = props.code;
  var label = codeLabelMap[code];
  !!set.has(name) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    code,
    message: "There is a naming conflict for the name: ".concat(name, " used in this '").concat(label, "'. Please rename or remove from the editor to avoid runtime errors.")
  }) : invariant(false) : void 0;
  set.add(name);
}

var IGNORE = '__IGNORE__';
var GENERAL_OPTIONS = '__ALL__';
class BaseClass {
  /**
   * The default options for this extension.
   *
   * TODO see if this can be cast to something other than any and allow
   * composition.
   */

  /**
   * The static keys for this class.
   */

  /**
   * The event handler keys.
   */

  /**
   * Customize the way the handler should behave.
   */

  /**
   * The custom keys.
   */

  /**
   * The unique name of this extension.
   *
   * @remarks
   *
   * Every extension **must** have a name. The name should have a distinct type
   * to allow for better type inference for end users. By convention the name
   * should be `camelCased` and unique within your editor instance.
   *
   * ```ts
   * class SimpleExtension extends Extension {
   *   get name() {
   *     return 'simple' as const;
   *   }
   * }
   * ```
   */

  /**
   * The options for this extension.
   *
   * @remarks
   *
   * Options are composed of Static, Dynamic, Handlers and ObjectHandlers.
   *
   * - `Static` - set at instantiation by the constructor.
   * - `Dynamic` - optionally set at instantiation by the constructor and also
   *   set during the runtime.
   * - `Handlers` - can only be set during the runtime.
   * - `ObjectHandlers` - Can only be set during the runtime of the extension.
   */
  get options() {
    return this._options;
  }
  /**
   * Get the dynamic keys for this extension.
   */


  get dynamicKeys() {
    return this._dynamicKeys;
  }
  /**
   * The options that this instance was created with, merged with all the
   * default options.
   */


  get initialOptions() {
    return this._initialOptions;
  }
  /**
   * The initial options at creation (used to reset).
   */


  constructor(defaultOptions) {
    for (var _len = arguments.length, _ref = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      _ref[_key - 1] = arguments[_key];
    }

    var options = _ref[0];
    this._mappedHandlers = object();
    this.populateMappedHandlers();
    this._options = this._initialOptions = deepMerge(defaultOptions, this.constructor.defaultOptions, options !== null && options !== void 0 ? options : object(), this.createDefaultHandlerOptions());
    this._dynamicKeys = this.getDynamicKeys(); // Triggers the `init` options update for this extension.

    this.init();
  }
  /**
   * This method is called by the extension constructor. It is not strictly a
   * lifecycle method since at this point the manager has not yet been
   * instantiated.
   *
   * @remarks
   *
   * It should be used instead of overriding the constructor which is strongly
   * advised against.
   *
   * There are some limitations when using this method.
   *
   * - Accessing `this.store` will throw an error since the manager hasn't been
   *   created and it hasn't yet been attached to the extensions.
   * - `this.type` in `NodeExtension` and `MarkExtension` will also throw an
   *   error since the schema hasn't been created yet.
   *
   * You should use this to setup any instance properties with the options
   * provided to the extension.
   */


  init() {}
  /**
   * Clone the current instance with the provided options. If nothing is
   * provided it uses the same initial options as the current instance.
   */


  /**
   * Get the dynamic keys for this extension.
   */
  getDynamicKeys() {
    var dynamicKeys = [];
    var _this$constructor = this.constructor,
        customHandlerKeys = _this$constructor.customHandlerKeys,
        handlerKeys = _this$constructor.handlerKeys,
        staticKeys = _this$constructor.staticKeys;

    var _iterator = _createForOfIteratorHelper(keys(this._options)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key2 = _step.value;

        if (staticKeys.includes(_key2) || handlerKeys.includes(_key2) || customHandlerKeys.includes(_key2)) {
          continue;
        }

        dynamicKeys.push(_key2);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return dynamicKeys;
  }
  /**
   * Throw an error if non dynamic keys are updated.
   */


  ensureAllKeysAreDynamic(update) {
    if (process.env.NODE_ENV === 'production') {
      return;
    }

    var invalid = [];

    var _iterator2 = _createForOfIteratorHelper(keys(update)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _key3 = _step2.value;

        if (this._dynamicKeys.includes(_key3)) {
          continue;
        }

        invalid.push(_key3);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    !isEmptyArray(invalid) ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.INVALID_SET_EXTENSION_OPTIONS,
      message: "Invalid properties passed into the 'setOptions()' method: ".concat(JSON.stringify(invalid), ".")
    }) : invariant(false) : void 0;
  }
  /**
   * Update the properties with the provided partial value when changed.
   */


  setOptions(update) {
    var _this$onSetOptions;

    var previousOptions = this.getDynamicOptions();
    this.ensureAllKeysAreDynamic(update);

    var _getChangedOptions = getChangedOptions({
      previousOptions,
      update
    }),
        changes = _getChangedOptions.changes,
        options = _getChangedOptions.options,
        pickChanged = _getChangedOptions.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so the extension can respond to any relevant
    // property updates.

    (_this$onSetOptions = this.onSetOptions) === null || _this$onSetOptions === void 0 ? void 0 : _this$onSetOptions.call(this, {
      reason: 'set',
      changes,
      options,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Reset the extension properties to their default values.
   *
   * @nonVirtual
   */


  resetOptions() {
    var _this$onSetOptions2;

    var previousOptions = this.getDynamicOptions();

    var _getChangedOptions2 = getChangedOptions({
      previousOptions,
      update: this._initialOptions
    }),
        changes = _getChangedOptions2.changes,
        options = _getChangedOptions2.options,
        pickChanged = _getChangedOptions2.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so that child extension properties can also be
    // updated.

    (_this$onSetOptions2 = this.onSetOptions) === null || _this$onSetOptions2 === void 0 ? void 0 : _this$onSetOptions2.call(this, {
      reason: 'reset',
      options,
      changes,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Override this to receive updates whenever the options have been updated on
   * this instance. This method is called after the updates have already been
   * applied to the instance. If you need more control over exactly how the
   * option should be applied you should set the option to be `Custom`.
   *
   * **Please Note**:
   *
   * This must be defined as a instance method and not a property since it is
   * called in the constructor.
   *
   * ```ts
   * class ThisPreset extends Preset {
   *   // GOOD ✅
   *   onSetOptions(props: OnSetOptionsProps<Options>) {}
   *
   *    // BAD ❌
   *   onSetOptions = (props: OnSetOptionsProps<Options>) => {}
   * }
   * ```
   *
   * @abstract
   */


  /**
   * Update the private options.
   */
  getDynamicOptions() {
    return omit(this._options, [...this.constructor.customHandlerKeys, ...this.constructor.handlerKeys]);
  }
  /**
   * Update the dynamic options.
   */


  updateDynamicOptions(options) {
    this._options = _objectSpread(_objectSpread({}, this._options), options);
  }
  /**
   * Set up the mapped handlers object with default values (an empty array);
   */


  populateMappedHandlers() {
    var _iterator3 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _key4 = _step3.value;
        this._mappedHandlers[_key4] = [];
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  /**
   * This is currently fudged together, I'm not sure it will work.
   */


  createDefaultHandlerOptions() {
    var _this = this;

    var methods = object();

    var _iterator4 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step4;

    try {
      var _loop = function _loop() {
        var key = _step4.value;

        methods[key] = function () {
          var _handlerKeyOptions$ke;

          var handlerKeyOptions = _this.constructor.handlerKeyOptions;
          var reducer = (_handlerKeyOptions$ke = handlerKeyOptions[key]) === null || _handlerKeyOptions$ke === void 0 ? void 0 : _handlerKeyOptions$ke.reducer;

          for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var returnValue = reducer === null || reducer === void 0 ? void 0 : reducer.getDefault(...args);

          var _iterator5 = _createForOfIteratorHelper(_this._mappedHandlers[key]),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  handler = _step5$value[1];

              var _value = handler(...args);

              returnValue = reducer ? reducer.accumulator(returnValue, _value, ...args) : _value; // Check if the method should cause an early return, based on the
              // return value.

              if (shouldReturnEarly(handlerKeyOptions, returnValue, key)) {
                return returnValue;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          return returnValue;
        };
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    return methods;
  }
  /**
   * Add a handler to the event handlers so that it is called along with all the
   * other handler methods.
   *
   * This is helpful for integrating react hooks which can be used in multiple
   * places. The original problem with fixed properties is that you can only
   * assign to a method once and it overwrites any other methods. This pattern
   * for adding handlers allows for multiple usages of the same handler in the
   * most relevant part of the code.
   *
   * More to come on this pattern.
   *
   * @nonVirtual
   */


  addHandler(key, method) {
    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ExtensionPriority.Default;

    this._mappedHandlers[key].push([priority, method]);

    this.sortHandlers(key); // Return a method for disposing of the handler.

    return () => this._mappedHandlers[key] = this._mappedHandlers[key].filter(_ref2 => {
      var _ref3 = _slicedToArray(_ref2, 2),
          handler = _ref3[1];

      return handler !== method;
    });
  }
  /**
   * Determines if handlers exist for the given key.
   *
   * Checking the existence of a handler property directly gives wrong results.
   * `this.options.onHandlerName` is always truthy because it is a reference to
   * the wrapper function that calls each handler.
   *
   * ```ts
   *
   * // GOOD ✅
   * if (!this.hasHandlers('onHandlerName')) {
   *   return;
   * }
   *
   * // BAD ❌
   * if (!this.options.onHandlerName) {
   *   return;
   * }
   * ```
   *
   * @param key The handler to test
   */


  hasHandlers(key) {
    var _this$_mappedHandlers;

    return ((_this$_mappedHandlers = this._mappedHandlers[key]) !== null && _this$_mappedHandlers !== void 0 ? _this$_mappedHandlers : []).length > 0;
  }

  sortHandlers(key) {
    this._mappedHandlers[key] = sort(this._mappedHandlers[key], // Sort from highest binding to the lowest.
    (_ref4, _ref5) => {
      var _ref6 = _slicedToArray(_ref4, 1),
          a = _ref6[0];

      var _ref7 = _slicedToArray(_ref5, 1),
          z = _ref7[0];

      return z - a;
    });
  }
  /**
   * A method that can be used to add a custom handler. It is up to the
   * extension creator to manage the handlers and dispose methods.
   */


  addCustomHandler(key, value) {
    var _this$onAddCustomHand, _this$onAddCustomHand2;

    return (_this$onAddCustomHand = (_this$onAddCustomHand2 = this.onAddCustomHandler) === null || _this$onAddCustomHand2 === void 0 ? void 0 : _this$onAddCustomHand2.call(this, {
      [key]: value
    })) !== null && _this$onAddCustomHand !== void 0 ? _this$onAddCustomHand : noop;
  }
  /**
   * Override this method if you want to set custom handlers on your extension.
   *
   * This must return a dispose function.
   */


}

_defineProperty(BaseClass, "defaultOptions", {});

_defineProperty(BaseClass, "staticKeys", []);

_defineProperty(BaseClass, "handlerKeys", []);

_defineProperty(BaseClass, "handlerKeyOptions", {});

_defineProperty(BaseClass, "customHandlerKeys", []);

/**
 * A function used to determine whether the value provided by the handler
 * warrants an early return.
 */
function shouldReturnEarly(handlerKeyOptions, returnValue, handlerKey) {
  var generalOptions = handlerKeyOptions[GENERAL_OPTIONS];
  var handlerOptions = handlerKeyOptions[handlerKey];

  if (!generalOptions && !handlerOptions) {
    return false;
  } // First check if there are options set for the provided handlerKey


  if (handlerOptions && // Only proceed if the value should not be ignored.
  handlerOptions.earlyReturnValue !== IGNORE && (isFunction(handlerOptions.earlyReturnValue) ? handlerOptions.earlyReturnValue(returnValue) === true : returnValue === handlerOptions.earlyReturnValue)) {
    return true;
  }

  if (generalOptions && // Only proceed if they are not ignored.
  generalOptions.earlyReturnValue !== IGNORE && ( // Check whether the `earlyReturnValue` is a predicate check.
  isFunction(generalOptions.earlyReturnValue) ? // If it is a predicate and when called with the current
  // `returnValue` the value is `true` then we should return
  // early.
  generalOptions.earlyReturnValue(returnValue) === true : // Check the actual return value.
  returnValue === generalOptions.earlyReturnValue)) {
    return true;
  }

  return false;
}
/**
 * @internal
 */

/**
 * Auto infers the parameter for the constructor. If there is a required static
 * option then the TypeScript compiler will error if nothing is passed in.
 */

/**
 * Extensions are fundamental to the way that Remirror works by grouping
 * together the functionality and handling the management of similar concerns.
 *
 * @remarks
 *
 *  Extension can adjust editor functionality in any way. Here are some
 *  examples.
 *
 * - How the editor displays certain content, i.e. **bold**, _italic_,
 *   **underline**.
 * - Which commands should be made available e.g. `commands.toggleBold()` to
 *   toggle the weight of the selected text.
 * - Check if a command is currently enabled (i.e a successful dry run) e.g.
 *   `commands.toggleBold.isEnabled()`.
 * - Register Prosemirror `Plugin`s, `keymap`s, `InputRule`s `PasteRule`s,
 *   `Suggestions`, and custom `nodeViews` which affect the behavior of the
 *   editor.
 *
 * There are three types of `Extension`.
 *
 * - `NodeExtension` - For creating Prosemirror nodes in the editor. See
 *   {@link NodeExtension}
 * - `MarkExtension` - For creating Prosemirror marks in the editor. See
 *   {@link MarkExtension}
 * - `PlainExtension` - For behavior which doesn't map to a `ProsemirrorNode` or
 *   `Mark` and as a result doesn't directly affect the Prosemirror `Schema` or
 *   content. See {@link PlainExtension}.
 *
 * This `Extension` is an abstract class that should not be used directly but
 * rather extended to add the intended functionality.
 *
 * ```ts
 * import { PlainExtension, Static } from 'remirror';
 *
 * interface AwesomeExtensionOptions {
 *   isAwesome?: Static<boolean>;
 *   id?: string;
 * }
 *
 * class AwesomeExtension extends PlainExtension<AwesomeExtensionOptions> {
 *   static defaultOptions: DefaultExtensionOptions<AwesomeExtensionOptions> = {
 *     isAwesome: true,
 *     id: '',
 *   }
 *
 *   get name() {
 *     return 'awesome' as const;
 *   }
 * }
 * ```
 */
class Extension extends BaseClass {
  /**
   * The default priority for this family of extensions.
   */

  /**
   * The priority level for this instance of the extension. A higher value
   * corresponds to a higher priority extension
   */
  get priority() {
    var _ref, _this$priorityOverrid;

    return (_ref = (_this$priorityOverrid = this.priorityOverride) !== null && _this$priorityOverrid !== void 0 ? _this$priorityOverrid : this.options.priority) !== null && _ref !== void 0 ? _ref : this.constructor.defaultPriority;
  }
  /**
   * The name that the constructor should have, which doesn't get mangled in
   * production.
   */


  get constructorName() {
    return "".concat(pascalCase(this.name), "Extension");
  }
  /**
   * The store is a shared object that's internal to each extension. It includes
   * often used items like the `view` and `schema` that are added by the
   * extension manager and also the lifecycle extension methods.
   *
   * **NOTE** - The store is not available until the manager has been created
   * and received the extension. As a result trying to access the store during
   * `init` and `constructor` will result in a runtime error.
   *
   * Some properties of the store are available at different phases. You should
   * check the inline documentation to know when a certain property is useable
   * in your extension.
   */


  get store() {
    !this._store ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: "An error occurred while attempting to access the 'extension.store' when the Manager has not yet set created the lifecycle methods."
    }) : invariant(false) : void 0;
    return freeze(this._store, {
      requireKeys: true
    });
  }
  /**
   * The list of extensions added to the editor by this `Preset`.
   */


  get extensions() {
    return this._extensions;
  }
  /**
   * Private list of extension stored within this [[`Preset`]].
   */


  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    super(defaultOptions, ...args); // Create the extension list.

    this._extensions = uniqueBy(this.createExtensions(), // Ensure that all the provided extensions are unique.
    extension => extension.constructor);
    this.extensionMap = new Map(); // Create the extension map for retrieving extensions from the `Preset`

    var _iterator = _createForOfIteratorHelper(this._extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;
        this.extensionMap.set(extension.constructor, extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * When there are duplicate extensions used within the editor the extension
   * manager will call this method and make sure all extension holders are using
   * the same instance of the `ExtensionConstructor`.
   *
   * @internal
   */


  replaceChildExtension(constructor, extension) {
    if (!this.extensionMap.has(constructor)) {
      return;
    }

    this.extensionMap.set(constructor, extension);
    this._extensions = this.extensions.map(currentExtension => extension.constructor === constructor ? extension : currentExtension);
  }
  /**
   * Not for usage. This is purely for types to make it easier to infer
   * available sub extension types.
   *
   * @internal
   */


  /**
   * Create the extensions which will be consumed by the preset. Override this
   * if you would like to make your extension a parent to other (holder)
   * extensions which don't make sense existing outside of the context of this
   * extension.
   *
   * @remarks
   *
   * Since this method is called in the constructor it should always be created
   * as an instance method and not a property. Properties aren't available for
   * the call to the parent class.
   *
   * ```ts
   * class HolderExtension extends PlainExtension {
   *   get name() {
   *     return 'holder'
   *   }
   *
   *   // GOOD ✅
   *   createExtensions() {
   *     return [];
   *   }
   *
   *   // BAD ❌
   *   createExtensions = () => {
   *     return [];
   *   }
   * }
   * ```
   */
  createExtensions() {
    return [];
  }
  /**
   * Get an extension from this holder extension by providing the desired
   * `Constructor`.
   *
   * @param Constructor - the extension constructor to find in the editor.
   *
   * @remarks
   *
   * This method will throw an error if the constructor doesn't exist within the
   * extension created by this extension.
   *
   * It can be used to forward options and attach handlers to the children
   * extensions. It is the spiritual replacement of the `Preset` extension.
   *
   * ```ts
   * import { PlainExtension, OnSetOptionsProps } from 'remirror';
   *
   * interface ParentOptions { weight?: string }
   *
   * class ParentExtension extends PlainExtension<ParentOptions> {
   *   get name() {
   *     return 'parent' as const;
   *   }
   *
   *   createExtensions() {
   *     return [new BoldExtension()]
   *   }
   *
   *   onSetOptions(options: OnSetOptionsProps<ParentOptions>): void {
   *     if (options.changes.weight.changed) {
   *       // Update the value of the provided extension.
   *       this.getExtension(BoldExtension).setOption({ weight: options.changes.weight.value });
   *     }
   *   }
   * }
   * ```
   */


  getExtension(Constructor) {
    var extension = this.extensionMap.get(Constructor); // Throws an error if attempting to get an extension which is not available
    // in this preset.

    !extension ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.INVALID_GET_EXTENSION,
      message: "'".concat(Constructor.name, "' does not exist within the preset: '").concat(this.name, "'")
    }) : invariant(false) : void 0;
    return extension;
  }
  /**
   * Check if the type of this extension's constructor matches the type of the
   * provided constructor.
   */


  isOfType(Constructor) {
    return this.constructor === Constructor;
  }
  /**
   * Pass a reference to the globally shared `ExtensionStore` for this
   * extension.
   *
   * @remarks
   *
   * The extension store allows extensions to access important variables without
   * complicating their creator methods.
   *
   * ```ts
   * import { PlainExtension } from 'remirror';
   *
   * class Awesome extends PlainExtension {
   *   customMethod() {
   *     if (this.store.view.hasFocus()) {
   *       log('dance dance dance');
   *     }
   *   }
   * }
   * ```
   *
   * This should only be called by the `RemirrorManager`.
   *
   * @internal
   * @nonVirtual
   */


  setStore(store) {
    if (this._store) {
      return;
    }

    this._store = store;
  }
  /**
   * Clone an extension.
   */


  clone() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new this.constructor(...args);
  }
  /**
   * Set the priority override for this extension. This is used in the
   * `RemirrorManager` in order to override the priority of an extension.
   *
   * If you set the first parameter to `undefined` it will remove the priority
   * override.
   *
   * @internal
   */


  setPriority(priority) {
    this.priorityOverride = priority;
  }

}
/**
 * Declaration merging since the constructor property can't be defined on the
 * actual class.
 */


_defineProperty(Extension, "defaultPriority", ExtensionPriority.Default);

/**
 * Create a plain extension which doesn't directly map to Prosemirror nodes or
 * marks.
 *
 * Plain extensions are a great way to add custom behavior to your editor.
 */
class PlainExtension extends Extension {
  /** @internal */
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.PlainExtensionConstructor;
  }
  /** @internal */


  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.PlainExtension;
  }

}
/**
 * A mark extension is based on the `Mark` concept from from within prosemirror
 * {@link https://prosemirror.net/docs/guide/#schema.marks}
 *
 * @remarks
 *
 * Marks are used to add extra styling or other information to inline content.
 * Mark types are objects much like node types, used to tag mark objects and
 * provide additional information about them.
 */

class MarkExtension extends Extension {
  /** @internal */
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.MarkExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.MarkExtension;
  }
  /**
   * Provides access to the mark type from the schema.
   *
   * @remarks
   *
   * The type is available as soon as the schema is created by the
   * `SchemaExtension` which has the priority `Highest`. It should be safe to
   * access in any of the lifecycle methods.
   */


  get type() {
    return assertGet(this.store.schema.marks, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `MarkExtension`.
   *
   * @remarks
   *
   * The main difference between the return value of this method and Prosemirror
   * `MarkSpec` is that that the `toDOM` method doesn't allow dom manipulation.
   * You can only return an array or string.
   *
   * For more advanced requirements, it may be possible to create a `nodeView`
   * to manage the dom interactions.
   */


}

_defineProperty(MarkExtension, "disableExtraAttributes", false);

/**
 * Defines the abstract class for extensions which can place nodes into the
 * prosemirror state.
 *
 * @remarks
 *
 * For more information see {@link https://prosemirror.net/docs/ref/#model.Node}
 */
class NodeExtension extends Extension {
  static get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.NodeExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.NodeExtension;
  }
  /**
   * Provides access to the node type from the schema.
   */


  get type() {
    return assertGet(this.store.schema.nodes, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `NodeExtension`.
   *
   * @remarks
   *
   * A node schema defines the behavior of the content within the editor. This
   * is very tied to the prosemirror implementation and the best place to learn
   * more about it is in the
   * {@link https://prosemirror.net/docs/guide/#schema docs}.
   *
   * @params hole - a method that is meant to indicate where extra attributes
   * should be placed (if they exist).
   *
   * The `hole` is a function that augments the passed object adding a special
   * `secret` key which is used to insert the extra attributes setter.
   *
   * ```ts
   * import { NodeExtension, SpecHole } from 'remirror';
   *
   * class AwesomeExtension extends NodeExtension {
   *   get name() { return 'awesome' as const'; }
   *
   *   createNodeSpec() {
   *     return {
   *       toDOM: (node) => {
   *         return ['p', hole(), 0]
   *       }
   *     }
   *   }
   * }
   * ```
   *
   * The above example will have the `hole()` method call replaced with the
   * extra attributes.
   */


}

_defineProperty(NodeExtension, "disableExtraAttributes", false);

/**
 * These are the default options merged into every extension. They can be
 * overridden.
 */
var defaultOptions = {
  priority: undefined,
  extraAttributes: {},
  disableExtraAttributes: false,
  exclude: {}
};
/**
 * Mutate the default extension options.
 *
 * @remarks
 *
 * This is a dangerous method since it allows you to mutate the received object.
 * Don't use it unless you absolutely have to.
 *
 * A potential use case is for adding a new default option to all extensions. It
 * shows an example of how to accomplish this in a typesafe way.
 *
 * ```ts
 * import { mutateDefaultExtensionOptions } from 'remirror';
 *
 * mutateDefaultExtensionOptions((settings) => {
 *   // Set the default value of all extensions to have a property `customSetting` with value `false`.
 *   settings.customSetting = false;
 * })
 *
 * declare global {
 *   namespace Remirror {
 *     interface BaseExtensionOptions {
 *       customSetting?: boolean;
 *     }
 *   }
 * }
 *```
 *
 * The mutation must happen before any extension have been instantiated.
 */

function mutateDefaultExtensionOptions(mutatorMethod) {
  mutatorMethod(defaultOptions);
}
/**
 * Determines if the passed value is an extension.
 *
 * @param value - the value to test
 */

function isExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, [RemirrorIdentifier.PlainExtension, RemirrorIdentifier.MarkExtension, RemirrorIdentifier.NodeExtension]);
}
/**
 * Determines if the passed value is an extension constructor.
 *
 * @param value - the value to test
 */

function isExtensionConstructor(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, [RemirrorIdentifier.PlainExtensionConstructor, RemirrorIdentifier.MarkExtensionConstructor, RemirrorIdentifier.NodeExtensionConstructor]);
}
/**
 * Checks whether the provided value is a plain extension.
 *
 * @param value - the extension to check
 */

function isPlainExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.PlainExtension);
}
/**
 * Determines if the passed in extension is a node extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isNodeExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.NodeExtension);
}
/**
 * Determines if the passed in extension is a mark extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isMarkExtension(value) {
  return isRemirrorType(value) && isIdentifierOfType(value, RemirrorIdentifier.MarkExtension);
}

var _excluded$2 = ["defaultOptions", "customHandlerKeys", "handlerKeys", "staticKeys", "defaultPriority", "handlerKeyOptions"];

/**
 * A decorator for the remirror extension.
 *
 * This adds static properties to the extension constructor.
 */
function extension(options) {
  return ReadonlyConstructor => {
    var _ref, _ref2, _ref3;

    var defaultOptions = options.defaultOptions,
        customHandlerKeys = options.customHandlerKeys,
        handlerKeys = options.handlerKeys,
        staticKeys = options.staticKeys,
        defaultPriority = options.defaultPriority,
        handlerKeyOptions = options.handlerKeyOptions,
        rest = _objectWithoutProperties(options, _excluded$2);

    var Constructor = Cast(ReadonlyConstructor);

    if (defaultOptions) {
      Constructor.defaultOptions = defaultOptions;
    }

    if (defaultPriority) {
      Constructor.defaultPriority = defaultPriority;
    }

    if (handlerKeyOptions) {
      Constructor.handlerKeyOptions = handlerKeyOptions;
    }

    Constructor.staticKeys = (_ref = staticKeys) !== null && _ref !== void 0 ? _ref : [];
    Constructor.handlerKeys = (_ref2 = handlerKeys) !== null && _ref2 !== void 0 ? _ref2 : [];
    Constructor.customHandlerKeys = (_ref3 = customHandlerKeys) !== null && _ref3 !== void 0 ? _ref3 : [];

    for (var _i = 0, _Object$entries = Object.entries(rest); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (Constructor[key]) {
        continue;
      }

      Constructor[key] = value;
    }

    return Cast(Constructor);
  };
}
/**
 * @deprecated use `extension` instead.
 */

var extensionDecorator = extension;

/**
 * This extension allows others extension to add the `createAttributes` method
 * for adding attributes to the prosemirror dom element.
 *
 * @remarks
 *
 * Use this to include all the dynamically generated attributes provided by each
 * extension. High priority extensions have preference over the lower priority
 * extensions.
 *
 * @category Builtin Extension
 */

class AttributesExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "attributeList", []);

    _defineProperty(this, "attributeObject", object());

    _defineProperty(this, "updateAttributes", function () {
      var triggerUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _this.transformAttributes();

      if (triggerUpdate) {
        _this.store.commands.forceUpdate('attributes');
      }
    });
  }

  get name() {
    return 'attributes';
  }

  /**
   * Create the attributes object on initialization.
   *
   * @internal
   */
  onCreate() {
    this.transformAttributes();
    this.store.setExtensionStore('updateAttributes', this.updateAttributes);
  }

  transformAttributes() {
    var _this$store$managerSe;

    this.attributeObject = object(); // Exit early when the manager excludes these settings.

    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.attributes) {
      this.store.setStoreKey('attributes', this.attributeObject);
      return;
    } // Reset this attributes


    this.attributeList = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$options$ex, _extension$createAttr, _extension$classNames;

        var extension = _step.value;

        if ((_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.attributes) {
          continue;
        }

        var createdAttributes = (_extension$createAttr = extension.createAttributes) === null || _extension$createAttr === void 0 ? void 0 : _extension$createAttr.call(extension);

        var attributes = _objectSpread(_objectSpread({}, createdAttributes), {}, {
          class: cx(...((_extension$classNames = extension.classNames) !== null && _extension$classNames !== void 0 ? _extension$classNames : []), createdAttributes === null || createdAttributes === void 0 ? void 0 : createdAttributes.class)
        }); // Inserted at the start of the list so that when combining the full
        // attribute object the higher priority extension attributes are
        // preferred to the lower priority since they merge with the object
        // later.


        this.attributeList.unshift(attributes);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(this.attributeList),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _attributes = _step2.value;
        this.attributeObject = _objectSpread(_objectSpread(_objectSpread({}, this.attributeObject), _attributes), {}, {
          class: cx(this.attributeObject.class, _attributes.class)
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.store.setStoreKey('attributes', this.attributeObject);
  }

}

/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as helpers. This can be used as a replacement for the
 * `createHelpers` method.
 *
 * To allow the TypeScript compiler to automatically infer types, please create
 * your methods with the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { helper, Helper } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @helper()
 *   alwaysTrue(): Helper<boolean> {
 *     return true;
 *   }
 * }
 * ```
 *
 * The above helper can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { helpers } = useRemirrorContext();
 *
 *   return helpers.alwaysTrue() ? <button>My Button</button> : null
 * }
 * ```
 *
 * @category Method Decorator
 */
function helper() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedHelp;

    // Attach the options to the `decoratedCommands` property for this extension.
    ((_target$decoratedHelp = target.decoratedHelpers) !== null && _target$decoratedHelp !== void 0 ? _target$decoratedHelp : target.decoratedHelpers = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as commands. This can be used as a replacement for the
 * `createCommands` method.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createCommands`. Internally the decorators are being used as they are better
 * for documentation purposes.
 *
 * For automated type inference methods that use this decorator must implement
 * the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { command, CommandFunction } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @command() myCommand(text: string): CommandFunction {return ({ tr, dispatch
 *   }) => {dispatch?.(tr.insertText('my command ' + text)); return true;
 *     }
 *   }
 * }
 * ```
 *
 * The above command can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { commands } = useRemirrorContext();
 *
 *   return <button onClick={() => commands.myCommand('hello')}>My Button</button>
 * }
 * ```
 *
 * @category Method Decorator
 */

function command() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedComm;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedComm = target.decoratedCommands) !== null && _target$decoratedComm !== void 0 ? _target$decoratedComm : target.decoratedCommands = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to an extension method to
 * identify as a key binding method. This can be used as a replacement for
 * the `createKeymap` method depending on your preference.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createKeymap`.
 *
 * @category Method Decorator
 */

function keyBinding(options) {
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedKeyb;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedKeyb = target.decoratedKeybindings) !== null && _target$decoratedKeyb !== void 0 ? _target$decoratedKeyb : target.decoratedKeybindings = {})[propertyKey] = options;
  };
}

/**
 * Returns `true` when the provided value is a delayed value.
 */
function isDelayedValue(value) {
  return isFunction(value) || isPromise(value);
}
/**
 * Add tentative support for delayed commands in the editor.
 *
 * Delayed commands are commands that run an immediate action, like adding a
 * tracker to a position in the document. Once the promise that is provided is
 * returned the `onDone` parameter is run with the document in the current
 * state. The tracker that was added can now be used to insert content, delete
 * content or replace content.
 *
 * @experimental This is still being worked on and the API is subject to changes
 * in structure going forward.
 *
 * @deprecated use [[`DelayedCommand`]] instead.
 *
 */

function delayedCommand(_ref) {
  var immediate = _ref.immediate,
      promise = _ref.promise,
      onDone = _ref.onDone,
      onFail = _ref.onFail;
  return props => {
    var view = props.view;

    if ((immediate === null || immediate === void 0 ? void 0 : immediate(props)) === false) {
      return false;
    }

    if (!view) {
      return true;
    }

    var deferred = isFunction(promise) ? promise() : promise;
    deferred.then(value => {
      // Run the command
      onDone({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view,
        value
      });
    }).catch(() => {
      // Run the failure command if it exists.
      onFail === null || onFail === void 0 ? void 0 : onFail({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view
      });
    });
    return true;
  };
}
class DelayedCommand {
  constructor(promiseCreator) {
    _defineProperty(this, "failureHandlers", []);

    _defineProperty(this, "successHandlers", []);

    _defineProperty(this, "validateHandlers", []);

    _defineProperty(this, "generateCommand", () => {
      return props => {
        var isValid = true;
        var view = props.view,
            tr = props.tr,
            dispatch = props.dispatch;

        if (!view) {
          return false;
        }

        var _iterator = _createForOfIteratorHelper(this.validateHandlers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var handler = _step.value;

            if (!handler(_objectSpread(_objectSpread({}, props), {}, {
              dispatch: () => {}
            }))) {
              isValid = false;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (!dispatch || !isValid) {
          return isValid;
        } // Start the promise.


        var deferred = this.promiseCreator(props);
        deferred.then(value => {
          this.runHandlers(this.successHandlers, {
            value,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        }).catch(error => {
          this.runHandlers(this.failureHandlers, {
            error,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        });
        dispatch(tr);
        return true;
      };
    });

    this.promiseCreator = promiseCreator;
  }
  /**
   * The commands that will immediately be run and used to evaluate whether to
   * proceed.
   */


  validate(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.validateHandlers[method](handler);
    return this;
  }
  /**
   * Add a success callback to the handler.
   */


  success(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.successHandlers[method](handler);
    return this;
  }
  /**
   * Add a failure callback to the handler.
   */


  failure(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.failureHandlers[method](handler);
    return this;
  }

  runHandlers(handlers, param) {
    var _param$dispatch;

    var _iterator2 = _createForOfIteratorHelper(handlers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var handler = _step2.value;

        if (!handler(_objectSpread(_objectSpread({}, param), {}, {
          dispatch: () => {}
        }))) {
          break;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    (_param$dispatch = param.dispatch) === null || _param$dispatch === void 0 ? void 0 : _param$dispatch.call(param, param.tr);
  }
  /**
   * Generate the `remirror` command.
   */


}

/**
 * A custom `toggleMark` function that works for the `remirror` codebase.
 *
 * Create a command function that toggles the given mark with the given
 * attributes. Will return `false` when the current selection doesn't support
 * that mark. This will remove the mark if any marks of that type exist in the
 * selection, or add it otherwise. If the selection is empty, this applies to
 * the [stored marks](#state.EditorState.storedMarks) instead of a range of the
 * document.
 *
 * The differences from the `prosemirror-commands` version.
 * - Acts on the transaction rather than the state to allow for commands to be
 *   chained together.
 * - Uses the ONE parameter function signature for compatibility with remirror.
 * - Supports passing a custom range.
 */
function toggleMark(props) {
  var type = props.type,
      attrs = props.attrs,
      range = props.range,
      selection = props.selection;
  return props => {
    var dispatch = props.dispatch,
        tr = props.tr,
        state = props.state;
    var markType = isString(type) ? state.schema.marks[type] : type;
    !markType ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type, " does not exist on the current schema.")
    }) : invariant(false) : void 0;

    if (range || selection) {
      var _ref2;

      var _getTextSelection = getTextSelection((_ref2 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref2 !== void 0 ? _ref2 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to;

      isMarkActive(_objectSpread({
        trState: tr,
        type
      }, range)) ? dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, to, markType)) : dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, markType.create(attrs)));
      return true;
    }

    return convertCommand(toggleMark$1(markType, attrs))(props);
  };
}
/**
 * Verifies that the mark type can be applied to the current document.
 */

function markApplies(type, doc, ranges) {
  var _iterator3 = _createForOfIteratorHelper(ranges),
      _step3;

  try {
    var _loop = function _loop() {
      var _step3$value = _step3.value,
          $from = _step3$value.$from,
          $to = _step3$value.$to;
      var markIsAllowed = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
      doc.nodesBetween($from.pos, $to.pos, node => {
        if (markIsAllowed) {
          // This prevents diving deeper into child nodes.
          return false;
        }

        markIsAllowed = node.inlineContent && node.type.allowsMarkType(type);
        return;
      });

      if (markIsAllowed) {
        return {
          v: true
        };
      }
    };

    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ret = _loop();

      if (typeof _ret === "object") return _ret.v;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return false;
}
/**
 * Apply the provided mark type and attributes.
 *
 * @param markType - the mark to apply.
 * @param attrs - the attributes to set on the applied mark.
 * @param selectionPoint - optionally specify where the mark should be applied.
 * Defaults to the current selection.
 */


function applyMark(type, attrs, selectionPoint) {
  return _ref3 => {
    var tr = _ref3.tr,
        dispatch = _ref3.dispatch,
        state = _ref3.state;
    var selection = getTextSelection(selectionPoint !== null && selectionPoint !== void 0 ? selectionPoint : tr.selection, tr.doc);
    var $cursor = getCursor(selection);
    var markType = isString(type) ? state.schema.marks[type] : type;
    !markType ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type, " does not exist on the current schema.")
    }) : invariant(false) : void 0;

    if (selection.empty && !$cursor || !markApplies(markType, tr.doc, selection.ranges)) {
      return false;
    }

    if (!dispatch) {
      return true;
    }

    if ($cursor) {
      tr.removeStoredMark(markType);

      if (attrs) {
        tr.addStoredMark(markType.create(attrs));
      }

      dispatch(tr);
      return true;
    }

    var containsMark = false;

    var _iterator4 = _createForOfIteratorHelper(selection.ranges),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = _step4.value,
            $from = _step4$value.$from,
            $to = _step4$value.$to;

        if (containsMark) {
          break;
        }

        containsMark = tr.doc.rangeHasMark($from.pos, $to.pos, markType);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var _iterator5 = _createForOfIteratorHelper(selection.ranges),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _step5.value,
            _$from = _step5$value.$from,
            _$to = _step5$value.$to;

        if (containsMark) {
          tr.removeMark(_$from.pos, _$to.pos, markType);
        }

        if (attrs) {
          tr.addMark(_$from.pos, _$to.pos, markType.create(attrs));
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    dispatch(tr);
    return true;
  };
}

/**
 * Insert text into the dom at the current location by default. If a promise is
 * provided then the text will be inserted at the tracked position when the
 * promise is resolved.
 */
function insertText(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _ref4 => {
    var tr = _ref4.tr,
        dispatch = _ref4.dispatch,
        state = _ref4.state;
    var schema = state.schema;
    var selection = tr.selection;
    var _options$from = options.from,
        from = _options$from === void 0 ? selection.from : _options$from,
        _options$to = options.to,
        to = _options$to === void 0 ? from !== null && from !== void 0 ? from : selection.to : _options$to,
        _options$marks = options.marks,
        marks = _options$marks === void 0 ? {} : _options$marks;

    if (!dispatch) {
      return true;
    } // Insert the text


    tr.insertText(text, from, to); // Map the end position after inserting the text to understand what needs to
    // be wrapped with a mark.

    var end = assertGet(tr.steps, tr.steps.length - 1).getMap().map(to); // Loop through the provided marks to add the mark to the selection. This
    // uses the order of the map you created. If any marks are exclusive, they
    // will override the previous.

    var _iterator6 = _createForOfIteratorHelper(entries(marks)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            markName = _step6$value[0],
            attributes = _step6$value[1];

        tr.addMark(from, end, assertGet(schema.marks, markName).create(attributes));
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    dispatch(tr);
    return true;
  };
}

var _dec$a, _dec2$4, _dec3$4, _dec4$4, _dec5$3, _dec6$2, _dec7$2, _dec8$2, _dec9$1, _dec10$1, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$a, _class2$4;
var CommandsExtension = (_dec$a = extension({
  defaultPriority: ExtensionPriority.Highest,
  defaultOptions: {
    trackerClassName: 'remirror-tracker-position',
    trackerNodeName: 'span'
  },
  staticKeys: ['trackerClassName', 'trackerNodeName']
}), _dec2$4 = command(), _dec3$4 = command(), _dec4$4 = command(), _dec5$3 = command(), _dec6$2 = command(), _dec7$2 = command(), _dec8$2 = command(), _dec9$1 = command(), _dec10$1 = command(), _dec11 = command(), _dec12 = command(), _dec13 = command(), _dec14 = command(), _dec15 = command(), _dec16 = command(), _dec17 = command(), _dec18 = command(), _dec19 = command(), _dec20 = command(), _dec21 = command(), _dec22 = command(), _dec23 = command(), _dec24 = command(), _dec25 = command({
  description: _ref => {
    var t = _ref.t;
    return t(CoreMessages.SELECT_ALL_DESCRIPTION);
  },
  label: _ref2 => {
    var t = _ref2.t;
    return t(CoreMessages.SELECT_ALL_LABEL);
  },
  shortcut: NamedShortcut.SelectAll
}), _dec26 = command({
  description: _ref3 => {
    var t = _ref3.t;
    return t(CoreMessages.COPY_DESCRIPTION);
  },
  label: _ref4 => {
    var t = _ref4.t;
    return t(CoreMessages.COPY_LABEL);
  },
  shortcut: NamedShortcut.Copy,
  icon: 'fileCopyLine'
}), _dec27 = command({
  description: _ref5 => {
    var t = _ref5.t;
    return t(CoreMessages.PASTE_DESCRIPTION);
  },
  label: _ref6 => {
    var t = _ref6.t;
    return t(CoreMessages.PASTE_LABEL);
  },
  shortcut: NamedShortcut.Paste,
  icon: 'clipboardLine'
}), _dec28 = command({
  description: _ref7 => {
    var t = _ref7.t;
    return t(CoreMessages.CUT_DESCRIPTION);
  },
  label: _ref8 => {
    var t = _ref8.t;
    return t(CoreMessages.CUT_LABEL);
  },
  shortcut: NamedShortcut.Cut,
  icon: 'scissorsFill'
}), _dec29 = command(), _dec30 = helper(), _dec31 = helper(), _dec32 = helper(), _dec$a(_class$a = (_class2$4 = class CommandsExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "decorated", new Map());

    _defineProperty(this, "forceUpdateTransaction", function (tr) {
      var _this$getCommandMeta = _this.getCommandMeta(tr),
          forcedUpdates = _this$getCommandMeta.forcedUpdates;

      for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
      }

      _this.setCommandMeta(tr, {
        forcedUpdates: uniqueArray([...forcedUpdates, ...keys])
      });

      return tr;
    });
  }

  get name() {
    return 'commands';
  }
  /**
   * The current transaction which allows for making commands chainable.
   *
   * It is shared by all the commands helpers and can even be used in the
   * [[`KeymapExtension`]].
   *
   * @internal
   */


  get transaction() {
    // Make sure we have the most up to date state.
    var state = this.store.getState();

    if (!this._transaction) {
      // Since there is currently no transaction set, make sure to create a new
      // one. Behind the scenes `state.tr` creates a new transaction for us to
      // use.
      this._transaction = state.tr;
    } // Check that the current transaction is valid.


    var isValid = this._transaction.before.eq(state.doc); // Check whether the current transaction has any already applied to it.


    var hasSteps = !isEmptyArray(this._transaction.steps);

    if (!isValid) {
      // Since the transaction is not valid we create a new one to prevent any
      // `mismatched` transaction errors.
      var _tr = state.tr; // Now checking if any steps had been added to the previous transaction
      // and adding them to the newly created transaction.

      if (hasSteps) {
        var _iterator = _createForOfIteratorHelper(this._transaction.steps),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var step = _step.value;

            _tr.step(step);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } // Make sure to store the transaction value to the instance of this
      // extension.


      this._transaction = _tr;
    }

    return this._transaction;
  }
  /**
   * This is the holder for the shared transaction which is shared by commands
   * in order to support chaining.
   *
   * @internal
   */


  onCreate() {
    this.store.setStoreKey('getForcedUpdates', this.getForcedUpdates.bind(this));
  }
  /**
   * Attach commands once the view is attached.
   */


  onView(view) {
    var _this2 = this;

    var _this$store = this.store,
        extensions = _this$store.extensions,
        helpers = _this$store.helpers;
    var commands = object();
    var names = new Set();
    var allDecoratedCommands = object();

    var chain = tr => {
      // This function allows for custom chaining.
      var customChain = object();

      var getTr = () => tr !== null && tr !== void 0 ? tr : this.transaction;

      var commandChain = [];

      var getChain = () => commandChain;

      for (var _i = 0, _Object$entries = Object.entries(commands); _i < _Object$entries.length; _i++) {
        var _allDecoratedCommands;

        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            name = _Object$entries$_i[0],
            _command = _Object$entries$_i[1];

        if ((_allDecoratedCommands = allDecoratedCommands[name]) !== null && _allDecoratedCommands !== void 0 && _allDecoratedCommands.disableChaining) {
          continue;
        }

        customChain[name] = this.chainedFactory({
          chain: customChain,
          command: _command.original,
          getTr,
          getChain
        });
      }
      /**
       * This function is used in place of the `view.dispatch` method which is
       * passed through to all commands.
       *
       * It is responsible for checking that the transaction which was
       * dispatched is the same as the shared transaction which makes chainable
       * commands possible.
       */


      var dispatch = transaction => {
        // Throw an error if the transaction being dispatched is not the same as
        // the currently stored transaction.
        !(transaction === getTr()) ? process.env.NODE_ENV !== "production" ? invariant(false, {
          message: 'Chaining currently only supports `CommandFunction` methods which do not use the `state.tr` property. Instead you should use the provided `tr` property.'
        }) : invariant(false) : void 0;
      };

      customChain.run = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var commands = commandChain;
        commandChain = [];

        var _iterator2 = _createForOfIteratorHelper(commands),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var cmd = _step2.value;

            // Exit early when the command returns false and the option is
            // provided.
            if (!cmd(dispatch) && options.exitEarly) {
              return;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        view.dispatch(getTr());
      };

      customChain.tr = () => {
        var commands = commandChain;
        commandChain = [];

        var _iterator3 = _createForOfIteratorHelper(commands),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var cmd = _step3.value;
            cmd(dispatch);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return getTr();
      };

      customChain.enabled = () => {
        var _iterator4 = _createForOfIteratorHelper(commandChain),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var cmd = _step4.value;

            if (!cmd()) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return true;
      };

      return customChain;
    };

    var _iterator5 = _createForOfIteratorHelper(extensions),
        _step5;

    try {
      var _loop = function _loop() {
        var _extension$createComm, _extension$createComm2, _extension$decoratedC;

        var extension = _step5.value;
        var extensionCommands = (_extension$createComm = (_extension$createComm2 = extension.createCommands) === null || _extension$createComm2 === void 0 ? void 0 : _extension$createComm2.call(extension)) !== null && _extension$createComm !== void 0 ? _extension$createComm : {};
        var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
        var active = {}; // Augment the decorated commands.

        allDecoratedCommands = _objectSpread(_objectSpread({}, allDecoratedCommands), {}, {
          decoratedCommands
        });

        var _loop2 = function _loop2() {
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
              commandName = _Object$entries3$_i[0],
              options = _Object$entries3$_i[1];

          var shortcut = isString(options.shortcut) && options.shortcut.startsWith('_|') ? {
            shortcut: helpers.getNamedShortcut(options.shortcut, extension.options)
          } : undefined;

          _this2.updateDecorated(commandName, _objectSpread(_objectSpread({}, options), {}, {
            name: extension.name
          }, shortcut));

          extensionCommands[commandName] = extension[commandName].bind(extension);

          if (options.active) {
            active[commandName] = () => {
              var _options$active, _options$active2;

              return (_options$active = (_options$active2 = options.active) === null || _options$active2 === void 0 ? void 0 : _options$active2.call(options, extension.options, _this2.store)) !== null && _options$active !== void 0 ? _options$active : false;
            };
          }
        };

        for (var _i3 = 0, _Object$entries3 = Object.entries(decoratedCommands); _i3 < _Object$entries3.length; _i3++) {
          _loop2();
        }

        if (isEmptyObject(extensionCommands)) {
          return "continue";
        } // Gather the returned commands object from the extension.


        _this2.addCommands({
          active,
          names,
          commands,
          extensionCommands
        });
      };

      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    var chainProperty = chain();

    for (var _i2 = 0, _Object$entries2 = Object.entries(chainProperty); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          key = _Object$entries2$_i[0],
          _command2 = _Object$entries2$_i[1];

      chain[key] = _command2;
    }

    this.store.setStoreKey('commands', commands);
    this.store.setStoreKey('chain', chain);
    this.store.setExtensionStore('commands', commands);
    this.store.setExtensionStore('chain', chain);
  }
  /**
   * Update the cached transaction whenever the state is updated.
   */


  onStateUpdate(_ref9) {
    var state = _ref9.state;
    this._transaction = state.tr;
  }
  /**
   * Create a plugin that solely exists to track forced updates via the
   * generated plugin key.
   */


  createPlugin() {
    return {};
  }
  /**
   * Enable custom commands to be used within the editor by users.
   *
   * This is preferred to the initial idea of setting commands on the
   * manager or even as a prop. The problem is that there's no typechecking
   * and it should be just fine to add your custom commands here to see the
   * dispatched immediately.
   *
   * To use it, firstly define the command.
   *
   * ```ts
   * import { CommandFunction } from 'remirror';
   *
   * const myCustomCommand: CommandFunction = ({ tr, dispatch }) => {
   *   dispatch?.(tr.insertText('My Custom Command'));
   *
   *   return true;
   * }
   * ```
   *
   * And then use it within the component.
   *
   * ```ts
   * import React, { useCallback } from 'react';
   * import { useRemirror } from '@remirror/react';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(myCustomCommand);
   *   }, [commands])
   *
   *   return <button onClick={onClick}>Custom Command</button>
   * }
   * ```
   *
   * An alternative is to use a custom command directly from a
   * `prosemirror-*` library. This can be accomplished in the following way.
   *
   *
   * ```ts
   * import { joinDown } from 'prosemirror-commands';
   * import { convertCommand } from 'remirror';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(convertCommand(joinDown));
   *   }, [commands]);
   *
   *   return <button onClick={onClick}>Custom Command</button>;
   * };
   * ```
   */


  customDispatch(command) {
    return command;
  }
  /**
   * Insert text into the dom at the current location by default. If a
   * promise is provided instead of text the resolved value will be inserted
   * at the tracked position.
   */


  insertText(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (isString(text)) {
      return insertText(text, options);
    }

    return this.store.createPlaceholderCommand({
      promise: text,
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, range, props) => {
        return this.insertText(value, _objectSpread(_objectSpread({}, options), range))(props);
      }
    }).generateCommand();
  }
  /**
   * Select the text within the provided range.
   *
   * Here are some ways it can be used.
   *
   * ```ts
   * // Set to the end of the document.
   * commands.selectText('end');
   *
   * // Set the selection to the start of the document.
   * commands.selectText('start');
   *
   * // Select all the text in the document.
   * commands.selectText('all')
   *
   * // Select a range of text. It's up to you to make sure the selected
   * // range is valid.
   * commands.selectText({ from: 10, to: 15 });
   *
   * // Specify the anchor and range in the selection.
   * commands.selectText({ anchor: 10, head: 15 });
   *
   * // Set to a specific position.
   * commands.selectText(10);
   *
   * // Use a ProseMirror selection
   * commands.selectText(new TextSelection(state.doc.resolve(10)))
   * ```
   *
   * Although this is called `selectText` you can provide your own selection
   * option which can be any type of selection.
   */


  selectText(selection) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref10 => {
      var tr = _ref10.tr,
          dispatch = _ref10.dispatch;
      var textSelection = getTextSelection(selection, tr.doc); // Check if the selection is unchanged (for example when refocusing on the
      // editor) and if it is, then the text doesn't need to be reselected.

      var selectionUnchanged = tr.selection.anchor === textSelection.anchor && tr.selection.head === textSelection.head;

      if (selectionUnchanged && !options.forceUpdate) {
        // Do nothing if the selection is unchanged.
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(textSelection));
      return true;
    };
  }
  /**
   * Select the link at the current location.
   */


  selectMark(type) {
    return props => {
      var tr = props.tr;
      var range = getMarkRange(tr.selection.$from, type);

      if (!range) {
        return false;
      }

      return this.store.commands.selectText.original({
        from: range.from,
        to: range.to
      })(props);
    };
  }
  /**
   * Delete the provided range or current selection.
   */


  delete(range) {
    return _ref11 => {
      var tr = _ref11.tr,
          dispatch = _ref11.dispatch;

      var _ref12 = range !== null && range !== void 0 ? range : tr.selection,
          from = _ref12.from,
          to = _ref12.to;

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(from, to));
      return true;
    };
  }
  /**
   * Fire an empty update to trigger an update to all decorations, and state
   * that may not yet have run.
   *
   * This can be used in extensions to trigger updates when certain options that
   * affect the editor state have changed.
   *
   * @param action - provide an action which is called just before the empty
   * update is dispatched (only when dispatch is available). This can be used in
   * chainable editor scenarios when you want to lazily invoke an action at the
   * point the update is about to be applied.
   */


  emptyUpdate(action) {
    return _ref13 => {
      var tr = _ref13.tr,
          dispatch = _ref13.dispatch;

      if (dispatch) {
        action === null || action === void 0 ? void 0 : action();
        dispatch(tr);
      }

      return true;
    };
  }
  /**
   * Force an update of the specific updatable ProseMirror props.
   *
   * This command is always available as a builtin command.
   *
   * @category Builtin Command
   */


  forceUpdate() {
    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    return _ref14 => {
      var tr = _ref14.tr,
          dispatch = _ref14.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(this.forceUpdateTransaction(tr, ...keys));
      return true;
    };
  }
  /**
   * Update the attributes for the node at the specified `pos` in the
   * editor.
   *
   * @category Builtin Command
   */


  updateNodeAttributes(pos, attrs) {
    return _ref15 => {
      var tr = _ref15.tr,
          dispatch = _ref15.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setNodeMarkup(pos, undefined, attrs));
      return true;
    };
  }
  /**
   * Set the content of the editor while preserving history.
   *
   * Under the hood this is replacing the content in the document with the new
   * state.doc of the provided content.
   *
   * If the content is a string you will need to ensure you have the proper
   * string handler set up in the editor.
   */


  setContent(content, selection) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var state = this.store.manager.createState({
        content,
        selection
      });

      if (!state) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.replaceRangeWith(0, tr.doc.nodeSize - 2, state.doc));
      return true;
    };
  }
  /**
   * Reset the content of the editor while preserving the history.
   *
   * This means that undo and redo will still be active since the doc is replaced with a new doc.
   */


  resetContent() {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var doc = this.store.manager.createEmptyDoc();

      if (doc) {
        return this.setContent(doc)(props);
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(0, tr.doc.nodeSize));
      return true;
    };
  }
  /**
   * Fire an update to remove the current range selection. The cursor will
   * be placed at the anchor of the current range selection.
   *
   * A range selection is a non-empty text selection.
   *
   * @category Builtin Command
   */


  emptySelection() {
    return _ref16 => {
      var tr = _ref16.tr,
          dispatch = _ref16.dispatch;

      if (tr.selection.empty) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(TextSelection.create(tr.doc, tr.selection.anchor)));
      return true;
    };
  }
  /**
   * Insert a new line into the editor.
   *
   * Depending on editor setup and where the cursor is placed this may have
   * differing impacts.
   *
   * @category Builtin Command
   */


  insertNewLine() {
    return _ref17 => {
      var dispatch = _ref17.dispatch,
          tr = _ref17.tr;

      if (!isTextSelection(tr.selection)) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.insertText('\n'));
      return true;
    };
  }
  /**
   * Insert a node into the editor with the provided content.
   *
   * @category Builtin Command
   */


  insertNode(node) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref18 => {
      var _ref19, _options$marks;

      var dispatch = _ref18.dispatch,
          tr = _ref18.tr,
          state = _ref18.state;
      var attrs = options.attrs,
          range = options.range,
          selection = options.selection,
          _options$replaceEmpty = options.replaceEmptyParentBlock,
          replaceEmptyParentBlock = _options$replaceEmpty === void 0 ? false : _options$replaceEmpty;

      var _getTextSelection = getTextSelection((_ref19 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref19 !== void 0 ? _ref19 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to,
          $from = _getTextSelection.$from;

      if (isProsemirrorNode(node) || isProsemirrorFragment(node)) {
        var pos = $from.before($from.depth);
        dispatch === null || dispatch === void 0 ? void 0 : dispatch(replaceEmptyParentBlock && from === to && isEmptyBlockNode($from.parent) ? tr.replaceWith(pos, pos + $from.parent.nodeSize, node) : tr.replaceWith(from, to, node));
        return true;
      }

      var nodeType = isString(node) ? state.schema.nodes[node] : node;
      !nodeType ? process.env.NODE_ENV !== "production" ? invariant(false, {
        code: ErrorConstant.SCHEMA,
        message: "The requested node type ".concat(node, " does not exist in the schema.")
      }) : invariant(false) : void 0;
      var marks = (_options$marks = options.marks) === null || _options$marks === void 0 ? void 0 : _options$marks.map(mark => {
        if (mark instanceof Mark) {
          return mark;
        }

        var markType = isString(mark) ? state.schema.marks[mark] : mark;
        !markType ? process.env.NODE_ENV !== "production" ? invariant(false, {
          code: ErrorConstant.SCHEMA,
          message: "The requested mark type ".concat(mark, " does not exist in the schema.")
        }) : invariant(false) : void 0;
        return markType.create();
      });
      var content = nodeType.createAndFill(attrs, isString(options.content) ? state.schema.text(options.content) : options.content, marks);

      if (!content) {
        return false;
      } // This should not be treated as a replacement.


      var isReplacement = from !== to;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(isReplacement ? tr.replaceRangeWith(from, to, content) : tr.insert(from, content));
      return true;
    };
  }
  /**
   * Set the focus for the editor.
   *
   * If using this with chaining this should only be placed at the end of
   * the chain. It can cause hard to debug issues when used in the middle of
   * a chain.
   *
   * ```tsx
   * import { useCallback } from 'react';
   * import { useRemirrorContext } from '@remirror/react';
   *
   * const MenuButton = () => {
   *   const { chain } = useRemirrorContext();
   *   const onClick = useCallback(() => {
   *     chain
   *       .toggleBold()
   *       .focus('end')
   *       .run();
   *   }, [chain])
   *
   *   return <button onClick={onClick}>Bold</button>
   * }
   * ```
   */


  focus(position) {
    return props => {
      var dispatch = props.dispatch,
          tr = props.tr;
      var view = this.store.view;

      if (position === false) {
        return false;
      }

      if (view.hasFocus() && (position === undefined || position === true)) {
        return false;
      } // Keep the current selection when position is `true` or `undefined`.


      if (position === undefined || position === true) {
        var _tr$selection = tr.selection,
            _tr$selection$from = _tr$selection.from,
            from = _tr$selection$from === void 0 ? 0 : _tr$selection$from,
            _tr$selection$to = _tr$selection.to,
            to = _tr$selection$to === void 0 ? from : _tr$selection$to;
        position = {
          from,
          to
        };
      }

      if (dispatch) {
        // Focus only when dispatch is provided.
        this.delayedFocus();
      }

      return this.selectText(position)(props);
    };
  }
  /**
   * Blur focus from the editor and also update the selection at the same
   * time.
   */


  blur(position) {
    return props => {
      var view = this.store.view;

      if (!view.hasFocus()) {
        return false;
      }

      requestAnimationFrame(() => {
        view.dom.blur();
      });
      return position ? this.selectText(position)(props) : true;
    };
  }
  /**
   * Set the block type of the current selection or the provided range.
   *
   * @param nodeType - the node type to create
   * @param attrs - the attributes to add to the node type
   * @param selection - the position in the document to set the block node
   * @param preserveAttrs - when true preserve the attributes at the provided selection
   */


  setBlockNodeType(nodeType, attrs, selection) {
    var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    return setBlockType(nodeType, attrs, selection, preserveAttrs);
  }
  /**
   * Toggle between wrapping an inactive node with the provided node type, and
   * lifting it up into it's parent.
   *
   * @param nodeType - the node type to toggle
   * @param attrs - the attrs to use for the node
   * @param selection - the selection point in the editor to perform the action
   */


  toggleWrappingNode(nodeType, attrs, selection) {
    return toggleWrap(nodeType, attrs, selection);
  }
  /**
   * Toggle a block between the provided type and toggleType.
   */


  toggleBlockNodeItem(toggleProps) {
    return toggleBlockItem(toggleProps);
  }
  /**
   * Wrap the selection or the provided text in a node of the given type with the
   * given attributes.
   */


  wrapInNode(nodeType, attrs, range) {
    return wrapIn(nodeType, attrs, range);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  applyMark(markType, attrs, selection) {
    return applyMark(markType, attrs, selection);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  toggleMark(props) {
    return toggleMark(props);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  removeMark(props) {
    return removeMark(props);
  }
  /**
   * Set the meta data to attach to the editor on the next update.
   */


  setMeta(name, value) {
    return _ref20 => {
      var tr = _ref20.tr;
      tr.setMeta(name, value);
      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  selectAll() {
    return this.selectText('all');
  }
  /**
   * Copy the selected content for non empty selections.
   */


  copy() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('copy');
      }

      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  paste() {
    // Todo check if the permissions are supported first.
    // navigator.permissions.query({name: 'clipboard'})
    return this.store.createPlaceholderCommand({
      // TODO https://caniuse.com/?search=clipboard.read - once browser support is sufficient.
      promise: () => navigator.clipboard.readText(),
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, selection, props) => {
        return this.insertNode(htmlToProsemirrorNode({
          content: value,
          schema: props.state.schema
        }), {
          selection
        })(props);
      }
    }).generateCommand();
  }
  /**
   * Cut the selected content.
   */


  cut() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('cut');
      }

      return true;
    };
  }
  /**
   * Replaces text with an optional appended string at the end. The replacement
   * can be text, or a custom node.
   *
   * @param props - see [[`ReplaceTextProps`]]
   */


  replaceText(props) {
    return replaceText(props);
  }
  /**
   * Get the all the decorated commands available on the editor instance.
   */


  getAllCommandOptions() {
    var uiCommands = {};

    var _iterator6 = _createForOfIteratorHelper(this.decorated),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            name = _step6$value[0],
            options = _step6$value[1];

        if (isEmptyObject(options)) {
          continue;
        }

        uiCommands[name] = options;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return uiCommands;
  }
  /**
   * Get the options that were passed into the provided command.
   */


  getCommandOptions(name) {
    return this.decorated.get(name);
  }
  /**
   * A short hand way of getting the `view`, `state`, `tr` and `dispatch`
   * methods.
   */


  getCommandProp() {
    return {
      tr: this.transaction,
      dispatch: this.store.view.dispatch,
      state: this.store.view.state,
      view: this.store.view
    };
  }
  /**
   * Update the command options via a shallow merge of the provided options. If
   * no options are provided the entry is deleted.
   *
   * @internal
   */


  updateDecorated(name, options) {
    var _this$decorated$get;

    if (!options) {
      this.decorated.delete(name);
      return;
    }

    var decoratorOptions = (_this$decorated$get = this.decorated.get(name)) !== null && _this$decorated$get !== void 0 ? _this$decorated$get : {
      name: ''
    };
    this.decorated.set(name, _objectSpread(_objectSpread({}, decoratorOptions), options));
  }
  /**
   * Needed on iOS since `requestAnimationFrame` doesn't breaks the focus
   * implementation.
   */


  handleIosFocus() {
    if (!environment.isIos) {
      return;
    }

    this.store.view.dom.focus();
  }
  /**
   * Focus the editor after a slight delay.
   */


  delayedFocus() {
    // Manage focus on iOS.
    this.handleIosFocus();
    requestAnimationFrame(() => {
      // Use the built in focus method to refocus the editor.
      this.store.view.focus(); // This has to be called again in order for Safari to scroll into view
      // after the focus. Perhaps there's a better way though or maybe place
      // behind a flag.

      this.store.view.dispatch(this.transaction.scrollIntoView());
    });
  }
  /**
   * A helper for forcing through updates in the view layer. The view layer can
   * check for the meta data of the transaction with
   * `manager.store.getForcedUpdate(tr)`. If that has a value then it should use
   * the unique symbol to update the key.
   */


  /**
   * Check for a forced update in the transaction. This pulls the meta data
   * from the transaction and if it is true then it was a forced update.
   *
   * ```ts
   * import { CommandsExtension } from 'remirror/extensions';
   *
   * const commandsExtension = manager.getExtension(CommandsExtension);
   * log(commandsExtension.getForcedUpdates(tr))
   * ```
   *
   * This can be used for updating:
   *
   * - `nodeViews`
   * - `editable` status of the editor
   * - `attributes` - for the top level node
   *
   * @internal
   */
  getForcedUpdates(tr) {
    return this.getCommandMeta(tr).forcedUpdates;
  }
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_COMMAND_META), meta);
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add the commands from the provided `commands` property to the `chained`,
   * `original` and `unchained` objects.
   */


  addCommands(props) {
    var extensionCommands = props.extensionCommands,
        commands = props.commands,
        names = props.names,
        active = props.active;

    var _iterator7 = _createForOfIteratorHelper(entries(extensionCommands)),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _step7$value = _slicedToArray(_step7.value, 2),
            name = _step7$value[0],
            _command3 = _step7$value[1];

        // Command names must be unique.
        throwIfNameNotUnique({
          name,
          set: names,
          code: ErrorConstant.DUPLICATE_COMMAND_NAMES
        }); // Make sure the command name is not forbidden.

        !!forbiddenNames.has(name) ? process.env.NODE_ENV !== "production" ? invariant(false, {
          code: ErrorConstant.DUPLICATE_COMMAND_NAMES,
          message: 'The command name you chose is forbidden.'
        }) : invariant(false) : void 0; // Create the unchained command.

        commands[name] = this.createUnchainedCommand(_command3, active[name]);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  /**
   * Create an unchained command method.
   */


  unchainedFactory(props) {
    var _this3 = this;

    return function () {
      var _props$shouldDispatch = props.shouldDispatch,
          shouldDispatch = _props$shouldDispatch === void 0 ? true : _props$shouldDispatch,
          command = props.command;
      var view = _this3.store.view;
      var state = view.state;
      var dispatch;

      if (shouldDispatch) {
        dispatch = view.dispatch;
      }

      return command(...arguments)({
        state,
        dispatch,
        view,
        tr: state.tr
      });
    };
  }
  /**
   * Create the unchained command.
   */


  createUnchainedCommand(command, active) {
    var unchainedCommand = this.unchainedFactory({
      command
    });
    unchainedCommand.enabled = this.unchainedFactory({
      command,
      shouldDispatch: false
    });
    unchainedCommand.isEnabled = unchainedCommand.enabled;
    unchainedCommand.original = command;
    unchainedCommand.active = active;
    return unchainedCommand;
  }
  /**
   * Create a chained command method.
   */


  chainedFactory(props) {
    var _this4 = this;

    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var chained = props.chain,
          command = props.command,
          getTr = props.getTr,
          getChain = props.getChain;
      var lazyChain = getChain();
      var view = _this4.store.view;
      var state = view.state;
      lazyChain.push(dispatch => {
        return command(...args)({
          state,
          dispatch,
          view,
          tr: getTr()
        });
      });
      return chained;
    };
  }

}, (_applyDecoratedDescriptor(_class2$4.prototype, "customDispatch", [_dec2$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "customDispatch"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertText", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectText", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectMark", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "delete", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "delete"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptyUpdate", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptyUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "forceUpdate", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "forceUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "updateNodeAttributes", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "updateNodeAttributes"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setContent", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "resetContent", [_dec11], Object.getOwnPropertyDescriptor(_class2$4.prototype, "resetContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptySelection", [_dec12], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptySelection"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNewLine", [_dec13], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNewLine"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNode", [_dec14], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "focus", [_dec15], Object.getOwnPropertyDescriptor(_class2$4.prototype, "focus"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "blur", [_dec16], Object.getOwnPropertyDescriptor(_class2$4.prototype, "blur"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setBlockNodeType", [_dec17], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setBlockNodeType"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleWrappingNode", [_dec18], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleWrappingNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleBlockNodeItem", [_dec19], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleBlockNodeItem"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "wrapInNode", [_dec20], Object.getOwnPropertyDescriptor(_class2$4.prototype, "wrapInNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "applyMark", [_dec21], Object.getOwnPropertyDescriptor(_class2$4.prototype, "applyMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleMark", [_dec22], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "removeMark", [_dec23], Object.getOwnPropertyDescriptor(_class2$4.prototype, "removeMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setMeta", [_dec24], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setMeta"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectAll", [_dec25], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectAll"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "copy", [_dec26], Object.getOwnPropertyDescriptor(_class2$4.prototype, "copy"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "paste", [_dec27], Object.getOwnPropertyDescriptor(_class2$4.prototype, "paste"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "cut", [_dec28], Object.getOwnPropertyDescriptor(_class2$4.prototype, "cut"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "replaceText", [_dec29], Object.getOwnPropertyDescriptor(_class2$4.prototype, "replaceText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getAllCommandOptions", [_dec30], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getAllCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandOptions", [_dec31], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandProp", [_dec32], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandProp"), _class2$4.prototype)), _class2$4)) || _class$a);
var DEFAULT_COMMAND_META = {
  forcedUpdates: []
};
/**
 * Provides the list of Prosemirror EditorView props that should be updated/
 */

/**
 * The names that are forbidden from being used as a command name.
 */
var forbiddenNames = new Set(['run', 'chain', 'original', 'raw', 'enabled', 'tr']);

var _excluded$1 = ["nodeName", "className"];

var _dec$9, _dec2$3, _dec3$3, _dec4$3, _dec5$2, _dec6$1, _dec7$1, _dec8$1, _class$9, _class2$3;
var DecorationsExtension = (_dec$9 = extension({
  defaultOptions: {
    persistentSelectionClass: undefined,
    placeholderClassName: 'placeholder',
    placeholderNodeName: 'span'
  },
  staticKeys: ['placeholderClassName', 'placeholderNodeName'],
  handlerKeys: ['decorations'],
  handlerKeyOptions: {
    decorations: {
      reducer: {
        accumulator: (accumulated, latestValue, state) => {
          return accumulated.add(state.doc, latestValue.find());
        },
        getDefault: () => DecorationSet.empty
      }
    }
  },
  defaultPriority: ExtensionPriority.Low
}), _dec2$3 = command(), _dec3$3 = command(), _dec4$3 = command(), _dec5$2 = command(), _dec6$1 = command(), _dec7$1 = helper(), _dec8$1 = helper(), _dec$9(_class$9 = (_class2$3 = class DecorationsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "placeholders", DecorationSet.empty);

    _defineProperty(this, "placeholderWidgets", new Map());

    _defineProperty(this, "createPlaceholderCommand", props => {
      var id = uniqueId();
      var promise = props.promise,
          placeholder = props.placeholder,
          onFailure = props.onFailure,
          onSuccess = props.onSuccess;
      return new DelayedCommand(promise).validate(props => {
        return this.addPlaceholder(id, placeholder)(props);
      }).success(props => {
        var state = props.state,
            tr = props.tr,
            dispatch = props.dispatch,
            view = props.view,
            value = props.value;
        var range = this.store.helpers.findPlaceholder(id);

        if (!range) {
          var _onFailure;

          var error = new Error('The placeholder has been removed');
          return (_onFailure = onFailure === null || onFailure === void 0 ? void 0 : onFailure({
            error,
            state,
            tr,
            dispatch,
            view
          })) !== null && _onFailure !== void 0 ? _onFailure : false;
        }

        this.removePlaceholder(id)({
          state,
          tr,
          view,
          dispatch: () => {}
        });
        return onSuccess(value, range, {
          state,
          tr,
          dispatch,
          view
        });
      }).failure(props => {
        var _onFailure2;

        this.removePlaceholder(id)(_objectSpread(_objectSpread({}, props), {}, {
          dispatch: () => {}
        }));
        return (_onFailure2 = onFailure === null || onFailure === void 0 ? void 0 : onFailure(props)) !== null && _onFailure2 !== void 0 ? _onFailure2 : false;
      });
    });
  }

  get name() {
    return 'decorations';
  }
  /**
   * The placeholder decorations.
   */


  onCreate() {
    this.store.setExtensionStore('createPlaceholderCommand', this.createPlaceholderCommand);
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createPlugin() {
    var _this = this;

    return {
      state: {
        init: () => {},
        apply: tr => {
          // Get tracker updates from the meta data
          var _this$getMeta = this.getMeta(tr),
              added = _this$getMeta.added,
              clearTrackers = _this$getMeta.clearTrackers,
              removed = _this$getMeta.removed,
              updated = _this$getMeta.updated;

          if (clearTrackers) {
            this.placeholders = DecorationSet.empty;

            var _iterator = _createForOfIteratorHelper(this.placeholderWidgets),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _widget$spec$onDestro, _widget$spec;

                var _step$value = _slicedToArray(_step.value, 2),
                    widget = _step$value[1];

                (_widget$spec$onDestro = (_widget$spec = widget.spec).onDestroy) === null || _widget$spec$onDestro === void 0 ? void 0 : _widget$spec$onDestro.call(_widget$spec, this.store.view, widget.spec.element);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            this.placeholderWidgets.clear();
            return;
          }

          this.placeholders = this.placeholders.map(tr.mapping, tr.doc, {
            onRemove: spec => {
              // Remove any removed widgets.
              var widget = this.placeholderWidgets.get(spec.id);

              if (widget) {
                var _widget$spec$onDestro2, _widget$spec2;

                (_widget$spec$onDestro2 = (_widget$spec2 = widget.spec).onDestroy) === null || _widget$spec$onDestro2 === void 0 ? void 0 : _widget$spec$onDestro2.call(_widget$spec2, this.store.view, widget.spec.element);
              }
            }
          });

          var _iterator2 = _createForOfIteratorHelper(this.placeholderWidgets),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _widget$spec$onUpdate, _widget$spec3;

              var _step2$value = _slicedToArray(_step2.value, 2),
                  _widget = _step2$value[1];

              (_widget$spec$onUpdate = (_widget$spec3 = _widget.spec).onUpdate) === null || _widget$spec$onUpdate === void 0 ? void 0 : _widget$spec$onUpdate.call(_widget$spec3, this.store.view, _widget.from, _widget.spec.element, _widget.spec.data);
            } // Update the decorations with any added position trackers.

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _iterator3 = _createForOfIteratorHelper(added),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var placeholder = _step3.value;

              if (placeholder.type === 'inline') {
                this.addInlinePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'node') {
                this.addNodePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'widget') {
                this.addWidgetPlaceholder(placeholder, tr);
                continue;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var _iterator4 = _createForOfIteratorHelper(updated),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _step4.value,
                  id = _step4$value.id,
                  _data = _step4$value.data;

              var _widget2 = this.placeholderWidgets.get(id); // Only support updating widget decorations.


              if (!_widget2) {
                continue;
              }

              var updatedWidget = Decoration.widget(_widget2.from, _widget2.spec.element, _objectSpread(_objectSpread({}, _widget2.spec), {}, {
                data: _data
              }));
              this.placeholders = this.placeholders.remove([_widget2]).add(tr.doc, [updatedWidget]);
              this.placeholderWidgets.set(id, updatedWidget);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var _iterator5 = _createForOfIteratorHelper(removed),
              _step5;

          try {
            var _loop = function _loop() {
              var id = _step5.value;

              var found = _this.placeholders.find(undefined, undefined, spec => spec.id === id && spec.__type === __type);

              var widget = _this.placeholderWidgets.get(id);

              if (widget) {
                var _widget$spec$onDestro3, _widget$spec4;

                (_widget$spec$onDestro3 = (_widget$spec4 = widget.spec).onDestroy) === null || _widget$spec$onDestro3 === void 0 ? void 0 : _widget$spec$onDestro3.call(_widget$spec4, _this.store.view, widget.spec.element);
              }

              _this.placeholders = _this.placeholders.remove(found);

              _this.placeholderWidgets.delete(id);
            };

            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      },
      props: {
        decorations: state => {
          var decorationSet = this.options.decorations(state);
          decorationSet = decorationSet.add(state.doc, this.placeholders.find());

          var _iterator6 = _createForOfIteratorHelper(this.store.extensions),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _extension = _step6.value;

              // Skip this extension when the method doesn't exist.
              if (!_extension.createDecorations) {
                continue;
              }

              var decorations = _extension.createDecorations(state).find();

              decorationSet = decorationSet.add(state.doc, decorations);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return decorationSet;
        },
        handleDOMEvents: {
          // Dispatch a transaction for focus/blur events so that the editor state
          // can be refreshed.
          //
          // https://discuss.prosemirror.net/t/handling-focus-in-plugins/1981/2
          blur: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, false));
            }

            return false;
          },
          focus: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, true));
            }

            return false;
          }
        }
      }
    };
  }

  updateDecorations() {
    return _ref => {
      var tr = _ref.tr,
          dispatch = _ref.dispatch;
      return dispatch !== null && dispatch !== void 0 && dispatch(tr), true;
    };
  }
  /**
   * Command to dispatch a transaction adding the placeholder decoration to
   * be tracked.
   *
   * @param id - the value that is used to identify this tracker. This can
   * be any value. A promise, a function call, a string.
   * @param options - the options to call the tracked position with. You can
   * specify the range `{ from: number; to: number }` as well as the class
   * name.
   */


  addPlaceholder(id, placeholder, deleteSelection) {
    return _ref2 => {
      var dispatch = _ref2.dispatch,
          tr = _ref2.tr;
      return this.addPlaceholderTransaction(id, placeholder, tr, !dispatch) ? (dispatch !== null && dispatch !== void 0 && dispatch(deleteSelection ? tr.deleteSelection() : tr), true) : false;
    };
  }
  /**
   * A command to updated the placeholder decoration.
   *
   * To update multiple placeholders you can use chained commands.
   *
   * ```ts
   * let idsWithData: Array<{id: unknown, data: number}>;
   *
   * for (const { id, data } of idsWithData) {
   *   chain.updatePlaceholder(id, data);
   * }
   *
   * chain.run();
   * ```
   */


  updatePlaceholder(id, data) {
    return _ref3 => {
      var dispatch = _ref3.dispatch,
          tr = _ref3.tr;
      return this.updatePlaceholderTransaction({
        id,
        data,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove the specified placeholder decoration.
   */


  removePlaceholder(id) {
    return _ref4 => {
      var dispatch = _ref4.dispatch,
          tr = _ref4.tr;
      return this.removePlaceholderTransaction({
        id,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove all active placeholder decorations.
   */


  clearPlaceholders() {
    return _ref5 => {
      var tr = _ref5.tr,
          dispatch = _ref5.dispatch;
      return this.clearPlaceholdersTransaction({
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * Find the position for the tracker with the ID specified.
   *
   * @param id - the unique position id which can be any type
   */


  findPlaceholder(id) {
    return this.findAllPlaceholders().get(id);
  }
  /**
   * Find the positions of all the trackers in document.
   */


  findAllPlaceholders() {
    var trackers = new Map();
    var found = this.placeholders.find(undefined, undefined, spec => spec.__type === __type);

    var _iterator7 = _createForOfIteratorHelper(found),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var decoration = _step7.value;
        trackers.set(decoration.spec.id, {
          from: decoration.from,
          to: decoration.to
        });
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return trackers;
  }
  /**
   * Add some decorations based on the provided settings.
   */


  createDecorations(state) {
    var _this$store$view, _this$store$helpers$i, _this$store$helpers;

    var persistentSelectionClass = this.options.persistentSelectionClass; // Only show the selection decoration when the view doesn't have focus.
    // Notice that we need to listen to the focus/blur DOM events to make
    // it work since the focus state is not stored in `EditorState`.

    if (!persistentSelectionClass || (_this$store$view = this.store.view) !== null && _this$store$view !== void 0 && _this$store$view.hasFocus() || (_this$store$helpers$i = (_this$store$helpers = this.store.helpers).isInteracting) !== null && _this$store$helpers$i !== void 0 && _this$store$helpers$i.call(_this$store$helpers)) {
      return DecorationSet.empty;
    } // Add the selection decoration to the decorations array.


    return generatePersistentSelectionDecorations(state, DecorationSet.empty, {
      class: isString(persistentSelectionClass) ? persistentSelectionClass : 'selection'
    });
  }
  /**
   * This stores all tracked positions in the editor and maps them via the
   * transaction updates.
   */


  onApplyState() {}
  /**
   * Add a widget placeholder and track it as a widget placeholder.
   */


  addWidgetPlaceholder(placeholder, tr) {
    var _createElement;

    var pos = placeholder.pos,
        createElement = placeholder.createElement,
        onDestroy = placeholder.onDestroy,
        onUpdate = placeholder.onUpdate,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var element = (_createElement = createElement === null || createElement === void 0 ? void 0 : createElement(this.store.view, pos)) !== null && _createElement !== void 0 ? _createElement : document.createElement(nodeName);
    element.classList.add(className);
    var decoration = Decoration.widget(pos, element, {
      id,
      __type,
      type,
      element,
      onDestroy,
      onUpdate
    });
    this.placeholderWidgets.set(id, decoration);
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add an inline placeholder.
   */


  addInlinePlaceholder(placeholder, tr) {
    var _placeholder$from = placeholder.from,
        from = _placeholder$from === void 0 ? tr.selection.from : _placeholder$from,
        _placeholder$to = placeholder.to,
        to = _placeholder$to === void 0 ? tr.selection.to : _placeholder$to,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var decoration;

    if (from === to) {
      // Add this as a widget if the range is empty.
      var _element = document.createElement(nodeName);

      _element.classList.add(className);

      decoration = Decoration.widget(from, _element, {
        id,
        type,
        __type,
        widget: _element
      });
    } else {
      // Make this span across nodes if the range is not empty.
      decoration = Decoration.inline(from, to, {
        nodeName,
        class: className
      }, {
        id,
        __type
      });
    }

    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add a placeholder for nodes.
   */


  addNodePlaceholder(placeholder, tr) {
    var pos = placeholder.pos,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id;
    var $pos = isNumber(pos) ? tr.doc.resolve(pos) : tr.selection.$from;
    var found = isNumber(pos) ? $pos.nodeAfter ? {
      pos,
      end: $pos.nodeAfter.nodeSize
    } : undefined : findNodeAtPosition($pos);

    if (!found) {
      return;
    }

    var decoration = Decoration.node(found.pos, found.end, {
      nodeName,
      class: className
    }, {
      id,
      __type
    });
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add the node and class name to the placeholder object.
   */


  withRequiredBase(id, placeholder) {
    var _this$options = this.options,
        placeholderNodeName = _this$options.placeholderNodeName,
        placeholderClassName = _this$options.placeholderClassName;

    var _placeholder$nodeName = placeholder.nodeName,
        nodeName = _placeholder$nodeName === void 0 ? placeholderNodeName : _placeholder$nodeName,
        className = placeholder.className,
        rest = _objectWithoutProperties(placeholder, _excluded$1);

    var classes = (className ? [placeholderClassName, className] : [placeholderClassName]).join(' ');
    return _objectSpread(_objectSpread({
      nodeName,
      className: classes
    }, rest), {}, {
      id
    });
  }
  /**
   * Get the command metadata.
   */


  getMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_PLACEHOLDER_META), meta);
  }
  /**
   * Set the metadata for the command.
   */


  setMeta(tr, update) {
    var meta = this.getMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add a placeholder decoration with the specified params to the transaction
   * and return the transaction.
   *
   * It is up to you to dispatch the transaction or you can just use the
   * commands.
   */


  addPlaceholderTransaction(id, placeholder, tr) {
    var checkOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var existingPosition = this.findPlaceholder(id);

    if (existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta2 = this.getMeta(tr),
        added = _this$getMeta2.added;

    this.setMeta(tr, {
      added: [...added, this.withRequiredBase(id, placeholder)]
    });
    return true;
  }
  /**
   * Update the data stored by a placeholder.
   *
   * This replaces the whole data value.
   */


  updatePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly = props.checkOnly,
        checkOnly = _props$checkOnly === void 0 ? false : _props$checkOnly,
        data = props.data;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta3 = this.getMeta(tr),
        updated = _this$getMeta3.updated;

    this.setMeta(tr, {
      updated: uniqueArray([...updated, {
        id,
        data
      }])
    });
    return true;
  }
  /**
   * Discards a previously defined tracker once not needed.
   *
   * This should be used to cleanup once the position is no longer needed.
   */


  removePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly2 = props.checkOnly,
        checkOnly = _props$checkOnly2 === void 0 ? false : _props$checkOnly2;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta4 = this.getMeta(tr),
        removed = _this$getMeta4.removed;

    this.setMeta(tr, {
      removed: uniqueArray([...removed, id])
    });
    return true;
  }
  /**
   * This helper returns a transaction that clears all position trackers when
   * any exist.
   *
   * Otherwise it returns undefined.
   */


  clearPlaceholdersTransaction(props) {
    var tr = props.tr,
        _props$checkOnly3 = props.checkOnly,
        checkOnly = _props$checkOnly3 === void 0 ? false : _props$checkOnly3;
    var positionTrackerState = this.getPluginState();

    if (positionTrackerState === DecorationSet.empty) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    this.setMeta(tr, {
      clearTrackers: true
    });
    return true;
  }
  /**
   * Handles delayed commands which rely on the
   */


}, (_applyDecoratedDescriptor(_class2$3.prototype, "updateDecorations", [_dec2$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updateDecorations"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "addPlaceholder", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "addPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "updatePlaceholder", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updatePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "removePlaceholder", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "removePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "clearPlaceholders", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "clearPlaceholders"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findPlaceholder", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findAllPlaceholders", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findAllPlaceholders"), _class2$3.prototype)), _class2$3)) || _class$9);
var DEFAULT_PLACEHOLDER_META = {
  added: [],
  updated: [],
  clearTrackers: false,
  removed: []
};
var __type = 'placeholderDecoration';
var persistentSelectionFocusKey = 'persistentSelectionFocus';

/**
 * Generate the persistent selection decoration for when the editor loses focus.
 */
function generatePersistentSelectionDecorations(state, decorationSet, attrs) {
  var selection = state.selection,
      doc = state.doc;

  if (selection.empty) {
    return decorationSet;
  }

  var from = selection.from,
      to = selection.to;
  var decoration = isNodeSelection(selection) ? Decoration.node(from, to, attrs) : Decoration.inline(from, to, attrs);
  return decorationSet.add(doc, [decoration]);
}

var _dec$8, _class$8;
var DocChangedExtension = (_dec$8 = extension({
  handlerKeys: ['docChanged'],
  handlerKeyOptions: {
    docChanged: {
      earlyReturnValue: false
    } // Execute all handlers, even if one returns false

  },
  defaultPriority: ExtensionPriority.Lowest
}), _dec$8(_class$8 = class DocChangedExtension extends PlainExtension {
  get name() {
    return 'docChanged';
  }

  onStateUpdate(props) {
    var firstUpdate = props.firstUpdate,
        transactions = props.transactions,
        tr = props.tr;

    if (firstUpdate) {
      return;
    }

    if ((transactions !== null && transactions !== void 0 ? transactions : [tr]).some(tr => tr === null || tr === void 0 ? void 0 : tr.docChanged)) {
      this.options.docChanged(props);
    }
  }

}) || _class$8);

var _dec$7, _dec2$2, _dec3$2, _dec4$2, _dec5$1, _dec6, _dec7, _dec8, _dec9, _dec10, _class$7, _class2$2;
var HelpersExtension = (_dec$7 = extension({}), _dec2$2 = helper(), _dec3$2 = helper(), _dec4$2 = helper(), _dec5$1 = helper(), _dec6 = helper(), _dec7 = command(), _dec8 = helper(), _dec9 = helper(), _dec10 = helper(), _dec$7(_class$7 = (_class2$2 = class HelpersExtension extends PlainExtension {
  get name() {
    return 'helpers';
  }
  /**
   * Add the `html` and `text` string handlers to the editor.
   */


  onCreate() {
    var _this = this;

    this.store.setStringHandler('text', this.textToProsemirrorNode.bind(this));
    this.store.setStringHandler('html', htmlToProsemirrorNode);
    var helpers = object();
    var active = object();
    var attrs = object();
    var names = new Set();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      var _loop = function _loop() {
        var _extension$createHelp, _extension$createHelp2;

        var extension = _step.value;

        if (isNodeExtension(extension)) {
          active[extension.name] = attrs => {
            return isNodeActive({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var _getActiveNode;

            return (_getActiveNode = getActiveNode({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            })) === null || _getActiveNode === void 0 ? void 0 : _getActiveNode.node.attrs;
          };
        }

        if (isMarkExtension(extension)) {
          active[extension.name] = attrs => {
            return isMarkActive({
              trState: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var markRange = getMarkRange(_this.store.getState().selection.$from, extension.type);

            if (!markRange || !attrs) {
              return markRange === null || markRange === void 0 ? void 0 : markRange.mark.attrs;
            }

            if (containsAttributes(markRange.mark, attrs)) {
              return markRange.mark.attrs;
            }

            return;
          };
        }

        var extensionHelpers = (_extension$createHelp = (_extension$createHelp2 = extension.createHelpers) === null || _extension$createHelp2 === void 0 ? void 0 : _extension$createHelp2.call(extension)) !== null && _extension$createHelp !== void 0 ? _extension$createHelp : {};

        for (var _i = 0, _Object$keys = Object.keys((_extension$decoratedH = extension.decoratedHelpers) !== null && _extension$decoratedH !== void 0 ? _extension$decoratedH : {}); _i < _Object$keys.length; _i++) {
          var _extension$decoratedH;

          var helperName = _Object$keys[_i];
          extensionHelpers[helperName] = extension[helperName].bind(extension);
        }

        if (isEmptyObject(extensionHelpers)) {
          return "continue";
        }

        var _iterator2 = _createForOfIteratorHelper(entries(extensionHelpers)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                _helper = _step2$value[1];

            throwIfNameNotUnique({
              name,
              set: names,
              code: ErrorConstant.DUPLICATE_HELPER_NAMES
            });
            helpers[name] = _helper;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('attrs', attrs);
    this.store.setStoreKey('active', active);
    this.store.setStoreKey('helpers', helpers);
    this.store.setExtensionStore('attrs', attrs);
    this.store.setExtensionStore('active', active);
    this.store.setExtensionStore('helpers', helpers);
  }
  /**
   * Check whether the selection is empty.
   */


  isSelectionEmpty() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return isSelectionEmpty(state);
  }
  /*
   * Check if the document view is currently editable.
   */


  isViewEditable() {
    var _this$store$view$prop, _this$store$view$prop2, _this$store$view$prop3;

    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return (_this$store$view$prop = (_this$store$view$prop2 = (_this$store$view$prop3 = this.store.view.props).editable) === null || _this$store$view$prop2 === void 0 ? void 0 : _this$store$view$prop2.call(_this$store$view$prop3, state)) !== null && _this$store$view$prop !== void 0 ? _this$store$view$prop : false;
  }
  /**
   * Get the full JSON output for the ProseMirror editor state object.
   */


  getStateJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.toJSON();
  }
  /**
   * Get the JSON output for the main ProseMirror `doc` node.
   *
   * This can be used to persist data between sessions and can be passed as
   * content to the `initialContent` prop.
   */


  getJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.doc.toJSON();
  }
  /**
   * @deprecated use `getJSON` instead.
   */


  getRemirrorJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return this.getJSON(state);
  }
  /**
   * Insert a html string as a ProseMirror Node.
   *
   * @category Builtin Command
   */


  insertHtml(html, options) {
    return props => {
      var state = props.state;
      var fragment = htmlToProsemirrorNode({
        content: html,
        schema: state.schema,
        fragment: true
      });
      return this.store.commands.insertNode.original(fragment, options)(props);
    };
  }
  /**
   * A method to get all the content in the editor as text. Depending on the
   * content in your editor, it is not guaranteed to preserve it 100%, so it's
   * best to test that it meets your needs before consuming.
   */


  getText() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$lineBreakDivider = _ref.lineBreakDivider,
        lineBreakDivider = _ref$lineBreakDivider === void 0 ? '\n\n' : _ref$lineBreakDivider,
        _ref$state = _ref.state,
        state = _ref$state === void 0 ? this.store.getState() : _ref$state;

    return state.doc.textBetween(0, state.doc.content.size, lineBreakDivider, NULL_CHARACTER);
  }

  getTextBetween(from, to) {
    var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store.getState().doc;
    return doc.textBetween(from, to, '\n\n', NULL_CHARACTER);
  }
  /**
   * Get the html from the current state, or provide a custom state.
   */


  getHTML() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return prosemirrorNodeToHtml(state.doc, this.store.document);
  }
  /**
   * Wrap the content in a pre tag to preserve whitespace and see what the
   * editor does with it.
   */


  textToProsemirrorNode(options) {
    var content = "<pre>".concat(options.content, "</pre>");
    return this.store.stringHandlers.html(_objectSpread(_objectSpread({}, options), {}, {
      content
    }));
  }

}, (_applyDecoratedDescriptor(_class2$2.prototype, "isSelectionEmpty", [_dec2$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isSelectionEmpty"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "isViewEditable", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isViewEditable"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getStateJSON", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getStateJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getJSON", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getRemirrorJSON", [_dec6], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getRemirrorJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "insertHtml", [_dec7], Object.getOwnPropertyDescriptor(_class2$2.prototype, "insertHtml"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getText", [_dec8], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getText"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getTextBetween", [_dec9], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getTextBetween"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getHTML", [_dec10], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getHTML"), _class2$2.prototype)), _class2$2)) || _class$7);

var _dec$6, _class$6;
var InputRulesExtension = (_dec$6 = extension({
  defaultPriority: ExtensionPriority.Default,
  handlerKeys: ['shouldSkipInputRule'],
  // Return when the value `true` is encountered.
  handlerKeyOptions: {
    shouldSkipInputRule: {
      earlyReturnValue: true
    }
  }
}), _dec$6(_class$6 = class InputRulesExtension extends PlainExtension {
  get name() {
    return 'inputRules';
  }
  /**
   * Add the extension store method for rebuilding all input rules.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildInputRules', this.rebuildInputRules.bind(this));
  }
  /**
   * Add the `inputRules` plugin to the editor.
   */


  createExternalPlugins() {
    return [this.generateInputRulesPlugin()];
  }

  generateInputRulesPlugin() {
    var rules = [];
    var invalidMarks = this.store.markTags[ExtensionTag.ExcludeInputRules];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var _extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.inputRules || // Method doesn't exist
        !_extension.createInputRules || // Extension settings exclude it
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.inputRules) {
          continue;
        } // For each input rule returned by the extension, add a `shouldSkip`
        // property.


        var _iterator2 = _createForOfIteratorHelper(_extension.createInputRules()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var rule = _step2.value;
            rule.shouldSkip = this.options.shouldSkipInputRule;
            rule.invalidMarks = invalidMarks;
            rules.push(rule);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return inputRules({
      rules
    });
  }
  /**
   * The method for rebuilding all the input rules.
   *
   * 1. Rebuild inputRules.
   * 2. Replace the old input rules plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  rebuildInputRules() {
    this.store.updateExtensionPlugins(this);
  }

}) || _class$6);

var _dec$5, _dec2$1, _dec3$1, _dec4$1, _dec5, _class$5, _class2$1;
var KeymapExtension = (_dec$5 = extension({
  defaultPriority: ExtensionPriority.Low,
  defaultOptions: {
    shortcuts: 'default',
    undoInputRuleOnBackspace: true,
    selectParentNodeOnEscape: false,
    excludeBaseKeymap: false,
    exitMarksOnArrowPress: true
  },
  customHandlerKeys: ['keymap']
}), _dec2$1 = keyBinding({
  shortcut: 'ArrowRight',
  isActive: options => options.exitMarksOnArrowPress
}), _dec3$1 = keyBinding({
  shortcut: 'ArrowLeft',
  isActive: options => options.exitMarksOnArrowPress
}), _dec4$1 = keyBinding({
  shortcut: 'Backspace',
  isActive: options => options.exitMarksOnArrowPress
}), _dec5 = helper(), _dec$5(_class$5 = (_class2$1 = class KeymapExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "extraKeyBindings", []);

    _defineProperty(this, "backwardMarkExitTracker", new Map());

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$rebuildKe, _this$store;

      var keymap = _ref.keymap;

      if (!keymap) {
        return;
      }

      this.extraKeyBindings = [...this.extraKeyBindings, keymap];
      (_this$store$rebuildKe = (_this$store = this.store).rebuildKeymap) === null || _this$store$rebuildKe === void 0 ? void 0 : _this$store$rebuildKe.call(_this$store);
      return () => {
        var _this$store$rebuildKe2, _this$store2;

        this.extraKeyBindings = this.extraKeyBindings.filter(binding => binding !== keymap);
        (_this$store$rebuildKe2 = (_this$store2 = this.store).rebuildKeymap) === null || _this$store$rebuildKe2 === void 0 ? void 0 : _this$store$rebuildKe2.call(_this$store2);
      };
    });

    _defineProperty(this, "rebuildKeymap", () => {
      this.store.updateExtensionPlugins(this);
    });
  }

  get name() {
    return 'keymap';
  }
  /**
   * The custom keybindings added by the handlers. In react these can be added
   * via `hooks`.
   */


  /**
   * Get the shortcut map.
   */
  get shortcutMap() {
    var shortcuts = this.options.shortcuts;
    return isString(shortcuts) ? keyboardShortcuts[shortcuts] : shortcuts;
  }
  /**
   * This adds the `createKeymap` method functionality to all extensions.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildKeymap', this.rebuildKeymap);
  }
  /** Add the created keymap to the available plugins. */


  createExternalPlugins() {
    var _this$store$managerSe;

    if ( // The user doesn't want any keymaps in the editor so don't add the keymap
    // handler.
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.keymap) {
      return [];
    }

    return [this.generateKeymap()];
  }
  /**
   * Updates the stored keymap plugin on this extension.
   */


  generateKeymap() {
    var extensionKeymaps = [];
    var shortcutMap = this.shortcutMap;
    var commandsExtension = this.store.getExtension(CommandsExtension);

    var extractNamesFactory = extension => shortcut => extractShortcutNames({
      shortcut,
      map: shortcutMap,
      store: this.store,
      options: extension.options
    });

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$decoratedK, _extension$options$ex;

        var _extension = _step.value;
        var decoratedKeybindings = (_extension$decoratedK = _extension.decoratedKeybindings) !== null && _extension$decoratedK !== void 0 ? _extension$decoratedK : {};

        if ( // The extension was configured to ignore the keymap.
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.keymap) {
          continue;
        }

        if ( // The extension doesn't have the `createKeymap` method.
        _extension.createKeymap) {
          extensionKeymaps.push(updateNamedKeys(_extension.createKeymap(extractNamesFactory(_extension)), shortcutMap));
        }

        var _iterator2 = _createForOfIteratorHelper(entries(decoratedKeybindings)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _options$priority;

            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                options = _step2$value[1];

            if (options.isActive && !options.isActive(_extension.options, this.store)) {
              continue;
            } // Bind the keybinding function to the extension.


            var _keyBinding = _extension[name].bind(_extension); // Extract the keypress pattern.


            var shortcutNames = extractShortcutNames({
              shortcut: options.shortcut,
              map: shortcutMap,
              options: _extension.options,
              store: this.store
            }); // Decide the priority to assign to the keymap.

            var _priority = isFunction(options.priority) ? options.priority(_extension.options, this.store) : (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : ExtensionPriority.Low;

            var bindingObject = object();

            var _iterator3 = _createForOfIteratorHelper(shortcutNames),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _shortcut = _step3.value;
                bindingObject[_shortcut] = _keyBinding;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            extensionKeymaps.push([_priority, bindingObject]); // Attach the normalized shortcut to the decorated command so that is
            // can be referenced in the UI.

            if (options.command) {
              commandsExtension.updateDecorated(options.command, {
                shortcut: shortcutNames
              });
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } // Sort the keymaps with a priority given to keymaps added via
      // `extension.addHandler` (e.g. in hooks).

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var sortedKeymaps = this.sortKeymaps([...this.extraKeyBindings, ...extensionKeymaps]);
    var mappedCommands = mergeProsemirrorKeyBindings(sortedKeymaps);
    return keymap(mappedCommands);
  }
  /**
   * Handle exiting the mark forwards.
   */


  arrowRightShortcut(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return this.exitMarkForwards(excludedMarks, excludedNodes)(props);
  }
  /**
   * Handle the arrow left key to exit the mark.
   */


  arrowLeftShortcut(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes), this.exitMarkBackwards(excludedMarks, excludedNodes))(props);
  }
  /**
   * Handle exiting the mark forwards.
   */


  backspace(props) {
    var excludedMarks = this.store.markTags[ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[ExtensionTag.PreventExits];
    return chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes, true), this.exitMarkBackwards(excludedMarks, excludedNodes, true))(props);
  }
  /**
   * Create the base keymap and give it a low priority so that all other keymaps
   * override it.
   */


  createKeymap() {
    var _this$options = this.options,
        selectParentNodeOnEscape = _this$options.selectParentNodeOnEscape,
        undoInputRuleOnBackspace = _this$options.undoInputRuleOnBackspace,
        excludeBaseKeymap = _this$options.excludeBaseKeymap;
    var baseKeyBindings = object(); // Only add the base keymap if it is **NOT** excluded.

    if (!excludeBaseKeymap) {
      var _iterator4 = _createForOfIteratorHelper(entries(baseKeymap)),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _slicedToArray(_step4.value, 2),
              key = _step4$value[0],
              value = _step4$value[1];

          baseKeyBindings[key] = convertCommand(value);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    } // Automatically remove the input rule when the option is set to true.


    if (undoInputRuleOnBackspace && baseKeymap.Backspace) {
      baseKeyBindings.Backspace = convertCommand(chainCommands(undoInputRule, baseKeymap.Backspace));
    } // Allow escape to select the parent node when set to true.


    if (selectParentNodeOnEscape) {
      baseKeyBindings.Escape = convertCommand(selectParentNode);
    }

    return [ExtensionPriority.Low, baseKeyBindings];
  }
  /**
   * Get the real shortcut name from the named shortcut.
   */


  getNamedShortcut(shortcut) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!shortcut.startsWith('_|')) {
      return [shortcut];
    }

    return extractShortcutNames({
      shortcut,
      map: this.shortcutMap,
      store: this.store,
      options: options
    });
  }
  /**
   * @internalremarks
   *
   * Think about the case where bindings are disposed of and then added in a
   * different position in the `extraKeyBindings` array. This is especially
   * pertinent when using hooks.
   */


  /**
   * Handle changes in the dynamic properties.
   */
  onSetOptions(props) {
    var changes = props.changes;

    if (changes.excludeBaseKeymap.changed || changes.selectParentNodeOnEscape.changed || changes.undoInputRuleOnBackspace.changed) {
      var _this$store$rebuildKe3, _this$store3;

      (_this$store$rebuildKe3 = (_this$store3 = this.store).rebuildKeymap) === null || _this$store$rebuildKe3 === void 0 ? void 0 : _this$store$rebuildKe3.call(_this$store3);
    }
  }

  sortKeymaps(bindings) {
    // Sort the bindings.
    return sort(bindings.map(binding => // Make all bindings prioritized a default priority of
    // `ExtensionPriority.Default`
    isArray(binding) ? binding : [ExtensionPriority.Default, binding]), // Sort from highest binding to the lowest.
    (a, z) => z[0] - a[0] // Extract the bindings from the prioritized tuple.
    ).map(binding => binding[1]);
  }
  /**
   * The method for rebuilding all the extension keymaps.
   *
   * 1. Rebuild keymaps.
   * 2. Replace the old keymap plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  /**
   * Exits the mark forwards when at the end of a block node.
   */
  exitMarkForwards(excludedMarks, excludedNodes) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;

      if (!isEndOfTextBlock(tr.selection)) {
        return false;
      }

      var isInsideExcludedNode = findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      }

      var $pos = tr.selection.$from;
      var marksToRemove = $pos.marks().filter(mark => !excludedMarks.includes(mark.type.name));

      if (isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      }

      var _iterator5 = _createForOfIteratorHelper(marksToRemove),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var mark = _step5.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      dispatch(tr.insertText(' ', tr.selection.from));
      return true;
    };
  }

  exitNodeBackwards(excludedNodes) {
    var startOfDoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return props => {
      var tr = props.tr;
      var checker = startOfDoc ? isStartOfDoc : isStartOfTextBlock;

      if (!checker(tr.selection)) {
        return false;
      }

      var node = tr.selection.$anchor.node();

      if (!isEmptyBlockNode(node) || isDefaultBlockNode(node) || excludedNodes.includes(node.type.name)) {
        return false;
      }

      return this.store.commands.toggleBlockNodeItem.original({
        type: node.type
      })(props);
    };
  }
  /**
   * Exit a mark when at the beginning of a block node.
   */


  exitMarkBackwards(excludedMarks, excludedNodes) {
    var startOfDoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return props => {
      var _tr$storedMarks;

      var tr = props.tr,
          dispatch = props.dispatch;
      var checker = startOfDoc ? isStartOfDoc : isStartOfTextBlock;

      if (!checker(tr.selection) || this.backwardMarkExitTracker.has(tr.selection.anchor)) {
        // Clear the map to prevent it storing stale data.
        this.backwardMarkExitTracker.clear();
        return false;
      }

      var isInsideExcludedNode = findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      } // Find all the marks to remove


      var marksToRemove = [...((_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : []), ...tr.selection.$from.marks()].filter(mark => !excludedMarks.includes(mark.type.name));

      if (isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      } // Remove all the active marks at the current cursor.


      var _iterator6 = _createForOfIteratorHelper(marksToRemove),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var mark = _step6.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      this.backwardMarkExitTracker.set(tr.selection.anchor, true);
      dispatch(tr);
      return true;
    };
  }

}, (_applyDecoratedDescriptor(_class2$1.prototype, "arrowRightShortcut", [_dec2$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowRightShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "arrowLeftShortcut", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowLeftShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "backspace", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "backspace"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "getNamedShortcut", [_dec5], Object.getOwnPropertyDescriptor(_class2$1.prototype, "getNamedShortcut"), _class2$1.prototype)), _class2$1)) || _class$5);

function isNamedShortcut(value) {
  return includes(values(NamedShortcut), value);
}

function extractShortcutNames(_ref2) {
  var shortcut = _ref2.shortcut,
      map = _ref2.map,
      options = _ref2.options,
      store = _ref2.store;

  if (isString(shortcut)) {
    return [normalizeShortcutName(shortcut, map)];
  }

  if (isArray(shortcut)) {
    return shortcut.map(value => normalizeShortcutName(value, map));
  }

  shortcut = shortcut(options, store);
  return extractShortcutNames({
    shortcut,
    map,
    options,
    store
  });
}

function normalizeShortcutName(value, shortcutMap) {
  return isNamedShortcut(value) ? shortcutMap[value] : value;
}

function updateNamedKeys(prioritizedBindings, shortcutMap) {
  var updatedBindings = {};
  var previousBindings;
  var priority;

  if (isArray(prioritizedBindings)) {
    var _prioritizedBindings = _slicedToArray(prioritizedBindings, 2);

    priority = _prioritizedBindings[0];
    previousBindings = _prioritizedBindings[1];
  } else {
    previousBindings = prioritizedBindings;
  }

  var _iterator7 = _createForOfIteratorHelper(entries(previousBindings)),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _slicedToArray(_step7.value, 2),
          shortcutName = _step7$value[0],
          commandFunction = _step7$value[1];

      updatedBindings[normalizeShortcutName(shortcutName, shortcutMap)] = commandFunction;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return isUndefined(priority) ? updatedBindings : [priority, updatedBindings];
}
/**
 * A shortcut map which is used by the `KeymapExtension`.
 */


/**
 * The default named shortcuts used within `remirror`.
 */
var DEFAULT_SHORTCUTS = {
  [NamedShortcut.Copy]: 'Mod-c',
  [NamedShortcut.Cut]: 'Mod-x',
  [NamedShortcut.Paste]: 'Mod-p',
  [NamedShortcut.PastePlain]: 'Mod-Shift-p',
  [NamedShortcut.SelectAll]: 'Mod-a',
  [NamedShortcut.Undo]: 'Mod-z',
  [NamedShortcut.Redo]: environment.isMac ? 'Shift-Mod-z' : 'Mod-y',
  [NamedShortcut.Bold]: 'Mod-b',
  [NamedShortcut.Italic]: 'Mod-i',
  [NamedShortcut.Underline]: 'Mod-u',
  [NamedShortcut.Strike]: 'Mod-d',
  [NamedShortcut.Code]: 'Mod-`',
  [NamedShortcut.Paragraph]: 'Mod-Shift-0',
  [NamedShortcut.H1]: 'Mod-Shift-1',
  [NamedShortcut.H2]: 'Mod-Shift-2',
  [NamedShortcut.H3]: 'Mod-Shift-3',
  [NamedShortcut.H4]: 'Mod-Shift-4',
  [NamedShortcut.H5]: 'Mod-Shift-5',
  [NamedShortcut.H6]: 'Mod-Shift-6',
  [NamedShortcut.TaskList]: 'Mod-Shift-7',
  [NamedShortcut.BulletList]: 'Mod-Shift-8',
  [NamedShortcut.OrderedList]: 'Mod-Shift-9',
  [NamedShortcut.Quote]: 'Mod->',
  [NamedShortcut.Divider]: 'Mod-Shift-|',
  [NamedShortcut.Codeblock]: 'Mod-Shift-~',
  [NamedShortcut.ClearFormatting]: 'Mod-Shift-C',
  [NamedShortcut.Superscript]: 'Mod-.',
  [NamedShortcut.Subscript]: 'Mod-,',
  [NamedShortcut.LeftAlignment]: 'Mod-Shift-L',
  [NamedShortcut.CenterAlignment]: 'Mod-Shift-E',
  [NamedShortcut.RightAlignment]: 'Mod-Shift-R',
  [NamedShortcut.JustifyAlignment]: 'Mod-Shift-J',
  [NamedShortcut.InsertLink]: 'Mod-k',
  [NamedShortcut.Find]: 'Mod-f',
  [NamedShortcut.FindBackwards]: 'Mod-Shift-f',
  [NamedShortcut.FindReplace]: 'Mod-Shift-H',
  [NamedShortcut.AddFootnote]: 'Mod-Alt-f',
  [NamedShortcut.AddComment]: 'Mod-Alt-m',
  [NamedShortcut.ContextMenu]: 'Mod-Shift-\\',
  [NamedShortcut.IncreaseFontSize]: 'Mod-Shift-.',
  [NamedShortcut.DecreaseFontSize]: 'Mod-Shift-,',
  [NamedShortcut.IncreaseIndent]: 'Tab',
  [NamedShortcut.DecreaseIndent]: 'Shift-Tab',
  [NamedShortcut.Shortcuts]: 'Mod-/',
  [NamedShortcut.Format]: environment.isMac ? 'Alt-Shift-f' : 'Shift-Ctrl-f'
};
/**
 * Shortcuts used within google docs.
 */

var GOOGLE_DOC_SHORTCUTS = _objectSpread(_objectSpread({}, DEFAULT_SHORTCUTS), {}, {
  [NamedShortcut.Strike]: 'Mod-Shift-S',
  [NamedShortcut.Code]: 'Mod-Shift-M',
  [NamedShortcut.Paragraph]: 'Mod-Alt-0',
  [NamedShortcut.H1]: 'Mod-Alt-1',
  [NamedShortcut.H2]: 'Mod-Alt-2',
  [NamedShortcut.H3]: 'Mod-Alt-3',
  [NamedShortcut.H4]: 'Mod-Alt-4',
  [NamedShortcut.H5]: 'Mod-Alt-5',
  [NamedShortcut.H6]: 'Mod-Alt-6',
  [NamedShortcut.OrderedList]: 'Mod-Alt-7',
  [NamedShortcut.BulletList]: 'Mod-Alt-8',
  [NamedShortcut.Quote]: 'Mod-Alt-9',
  [NamedShortcut.ClearFormatting]: 'Mod-\\',
  [NamedShortcut.IncreaseIndent]: 'Mod-[',
  [NamedShortcut.DecreaseIndent]: 'Mod-]'
});
var keyboardShortcuts = {
  default: DEFAULT_SHORTCUTS,
  googleDoc: GOOGLE_DOC_SHORTCUTS
};

/**
 * This extension allows others extension to add the `createNodeView` method
 * for creating nodeViews which alter how the dom is rendered for the node.
 *
 * @remarks
 *
 * This is an example of adding custom functionality to an extension via the
 * `ExtensionParameterMethods`.
 *
 * @category Builtin Extension
 */
class NodeViewsExtension extends PlainExtension {
  get name() {
    return 'nodeViews';
  }

  createPlugin() {
    var _this$store$managerSe;

    var nodeViewList = [];
    var nodeViews = object();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;

        if (!extension.createNodeViews) {
          // Method doesn't exist
          continue;
        }

        var _nodeView = extension.createNodeViews(); // `.unshift` ensures higher priority extensions can overwrite the lower
        // priority nodeViews.


        nodeViewList.unshift(isFunction(_nodeView) ? {
          [extension.name]: _nodeView
        } : _nodeView);
      } // Insert the `nodeViews` provided via the manager.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    nodeViewList.unshift((_this$store$managerSe = this.store.managerSettings.nodeViews) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : {});

    for (var _i = 0, _nodeViewList = nodeViewList; _i < _nodeViewList.length; _i++) {
      var nodeView = _nodeViewList[_i];
      Object.assign(nodeViews, nodeView);
    }

    return {
      props: {
        nodeViews
      }
    };
  }

}

/**
 * This extension allows others extension to add the `createPasteRules` method
 * for automatically transforming pasted text which matches a certain regex
 * pattern in the dom.
 *
 * @category Builtin Extension
 */
class PasteRulesExtension extends PlainExtension {
  get name() {
    return 'pasteRules';
  }

  createExternalPlugins() {
    return [this.generatePasteRulesPlugin()];
  }

  generatePasteRulesPlugin() {
    var extensionPasteRules = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.pasteRules || // Method doesn't exist
        !extension.createPasteRules || // Extension settings exclude it
        (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.pasteRules) {
          continue;
        }

        var value = extension.createPasteRules();
        var rules = isArray(value) ? value : [value];
        extensionPasteRules.push(...rules);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return pasteRules(extensionPasteRules);
  }

}

var _dec$4, _class$4;
var PluginsExtension = (_dec$4 = extension({
  defaultPriority: ExtensionPriority.Highest,
  handlerKeys: ['applyState', 'appendTransaction']
}), _dec$4(_class$4 = class PluginsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "plugins", []);

    _defineProperty(this, "managerPlugins", []);

    _defineProperty(this, "applyStateHandlers", []);

    _defineProperty(this, "initStateHandlers", []);

    _defineProperty(this, "appendTransactionHandlers", []);

    _defineProperty(this, "pluginKeys", object());

    _defineProperty(this, "stateGetters", new Map());

    _defineProperty(this, "getPluginStateCreator", key => state => {
      return key.getState(state !== null && state !== void 0 ? state : this.store.getState());
    });

    _defineProperty(this, "getStateByName", identifier => {
      var stateGetter = this.stateGetters.get(identifier);
      !stateGetter ? process.env.NODE_ENV !== "production" ? invariant(false, {
        message: 'No plugin exists for the requested extension name.'
      }) : invariant(false) : void 0;
      return stateGetter();
    });
  }

  get name() {
    return 'plugins';
  }
  /**
   * All plugins created by other extension as well.
   */


  /**
   * This extension is responsible for adding state to the editor.
   */
  onCreate() {
    var _this$store = this.store,
        setStoreKey = _this$store.setStoreKey,
        setExtensionStore = _this$store.setExtensionStore,
        managerSettings = _this$store.managerSettings,
        extensions = _this$store.extensions;
    this.updateExtensionStore(); // Retrieve the plugins passed in when creating the manager.

    var _managerSettings$plug = managerSettings.plugins,
        plugins = _managerSettings$plug === void 0 ? [] : _managerSettings$plug; // Add the plugins which were added directly to the manager.

    this.updatePlugins(plugins, this.managerPlugins);

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;

        if (_extension.onApplyState) {
          this.applyStateHandlers.push(_extension.onApplyState.bind(_extension));
        }

        if (_extension.onInitState) {
          this.initStateHandlers.push(_extension.onInitState.bind(_extension));
        }

        if (_extension.onAppendTransaction) {
          this.appendTransactionHandlers.push(_extension.onAppendTransaction.bind(_extension));
        }

        this.extractExtensionPlugins(_extension);
      } // Store the added plugins for future usage.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.managerPlugins = plugins; // Add all the extracted plugins to the manager store. From the manager
    // store they are automatically added to the state for use in the editor.

    this.store.setStoreKey('plugins', this.plugins); // Here set the plugins keys and state getters for retrieving plugin state.
    // These methods are later used.

    setStoreKey('pluginKeys', this.pluginKeys);
    setStoreKey('getPluginState', this.getStateByName);
    setExtensionStore('getPluginState', this.getStateByName);
  }
  /**
   * Create a plugin which adds the [[`onInitState`]] and [[`onApplyState`]]
   * lifecycle methods.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, previousState, state) => {
        var tr = state.tr;
        var props = {
          previousState,
          tr,
          transactions,
          state
        };

        var _iterator2 = _createForOfIteratorHelper(this.appendTransactionHandlers),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var handler = _step2.value;
            handler(props);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.options.appendTransaction(props); // Return the transaction if it has been amended in any way.

        return tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet ? tr : undefined;
      },
      state: {
        init: (_, state) => {
          var _iterator3 = _createForOfIteratorHelper(this.initStateHandlers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var handler = _step3.value;
              handler(state);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        apply: (tr, _, previousState, state) => {
          var props = {
            previousState,
            state,
            tr
          };

          var _iterator4 = _createForOfIteratorHelper(this.applyStateHandlers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var handler = _step4.value;
              handler(props);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          this.options.applyState(props);
        }
      }
    };
  }
  /**
   * Get all the plugins from the extension.
   */


  extractExtensionPlugins(extension) {
    var _this$store$managerSe, _extension$options$ex;

    var isNotPluginCreator = !extension.createPlugin && !extension.createExternalPlugins;

    if (isNotPluginCreator || // the manager settings don't exclude plugins
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.plugins || // The extension settings don't exclude plugins
    (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.plugins) {
      return;
    } // Create the custom plugin if it exists.


    if (extension.createPlugin) {
      var key = new PluginKey(extension.name); // Assign the plugin key to the extension name.

      this.pluginKeys[extension.name] = key;
      var getter = this.getPluginStateCreator(key);
      extension.pluginKey = key;
      extension.getPluginState = getter;
      this.stateGetters.set(extension.name, getter);
      this.stateGetters.set(extension.constructor, getter);

      var pluginSpec = _objectSpread(_objectSpread({}, extension.createPlugin()), {}, {
        key
      });

      var plugin = new Plugin(pluginSpec);
      this.updatePlugins([plugin], extension.plugin ? [extension.plugin] : undefined);
      extension.plugin = plugin;
    }

    if (extension.createExternalPlugins) {
      var externalPlugins = extension.createExternalPlugins();
      this.updatePlugins(externalPlugins, extension.externalPlugins);
      extension.externalPlugins = externalPlugins;
    }
  }

  /**
   * Add or replace a plugin.
   */
  updatePlugins(plugins, previous) {
    // This is the first time plugins are being added.
    if (!previous || isEmptyArray(previous)) {
      this.plugins = [...this.plugins, ...plugins];
      return;
    } // The number of plugins and previous plugins is different.


    if (plugins.length !== previous.length) {
      // Remove previous plugins and add the new plugins to the end.
      this.plugins = [...this.plugins.filter(plugin => !previous.includes(plugin)), ...plugins];
      return;
    } // The length of plugins is identical, therefore a replacement is possible.


    var pluginMap = new Map();

    var _iterator5 = _createForOfIteratorHelper(plugins.entries()),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _slicedToArray(_step5.value, 2),
            index = _step5$value[0],
            plugin = _step5$value[1];

        pluginMap.set(assertGet(previous, index), plugin);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    this.plugins = this.plugins.map(plugin => {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return previous.includes(plugin) ? pluginMap.get(plugin) : plugin;
    });
  } // Method for retrieving the plugin state by the extension name.


  /**
   * Add the plugin specific properties and methods to the manager and extension
   * store.
   */
  updateExtensionStore() {
    var setExtensionStore = this.store.setExtensionStore; // Allow adding, replacing and removing plugins by other extensions.

    setExtensionStore('updatePlugins', this.updatePlugins.bind(this));
    setExtensionStore('dispatchPluginUpdate', this.dispatchPluginUpdate.bind(this));
    setExtensionStore('updateExtensionPlugins', this.updateExtensionPlugins.bind(this));
  }
  /**
   * Reruns the `createPlugin` and `createExternalPlugins` methods of the
   * provided extension.
   *
   * ```ts
   * // From within an extension
   * this.store.updateExtensionPlugins(this);
   * ```
   */


  updateExtensionPlugins(value) {
    var extension = isExtension(value) ? value : isExtensionConstructor(value) ? this.store.manager.getExtension(value) : this.store.extensions.find(extension => extension.name === value);
    !extension ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "The extension ".concat(value, " does not exist within the editor.")
    }) : invariant(false) : void 0;
    this.extractExtensionPlugins(extension);
    this.store.setStoreKey('plugins', this.plugins); // Dispatch the plugin updates to the editor.

    this.dispatchPluginUpdate();
  }
  /**
   * Applies the store plugins to the state. If any have changed then it will be
   * updated.
   */


  dispatchPluginUpdate() {
    !(this.store.phase >= ManagerPhase.EditorView) ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`dispatchPluginUpdate` should only be called after the view has been added to the manager.'
    }) : invariant(false) : void 0;
    var _this$store2 = this.store,
        view = _this$store2.view,
        updateState = _this$store2.updateState;
    var newState = view.state.reconfigure({
      plugins: this.plugins
    });
    updateState(newState);
  }

}) || _class$4);

var _excluded = ["parseDOM"];

var _dec$3, _class$3;
var SchemaExtension = (_dec$3 = extension({
  defaultPriority: ExtensionPriority.Highest
}), _dec$3(_class$3 = class SchemaExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "dynamicAttributes", {
      marks: object(),
      nodes: object()
    });
  }

  get name() {
    return 'schema';
  }
  /**
   * The dynamic attributes for each node and mark extension.
   *
   * The structure will look like the following.
   *
   * ```ts
   * {
   *   paragraph: { id: () => uid(), hash: (node) => hash(node) },
   *   bold: { random: () => Math.random(), created: () => Date.now() },
   * };
   * ```
   *
   * This object is used by the created plugin to listen for changes to the doc,
   * and check for new nodes and marks which haven't yet applied the dynamic
   * attribute and add the attribute.
   */


  /**
   * This method is responsible for creating, configuring and adding the
   * `schema` to the editor. `Schema` is a special type in ProseMirror editors
   * and with `remirror` it's all just handled for you.
   */
  onCreate() {
    var _this = this;

    var _this$store = this.store,
        managerSettings = _this$store.managerSettings,
        tags = _this$store.tags,
        markNames = _this$store.markNames,
        nodeNames = _this$store.nodeNames,
        extensions = _this$store.extensions;
    var defaultBlockNode = managerSettings.defaultBlockNode,
        disableExtraAttributes = managerSettings.disableExtraAttributes,
        nodeOverride = managerSettings.nodeOverride,
        markOverride = managerSettings.markOverride; // True when the `defaultBlockNode` exists for this editor.

    var isValidDefaultBlockNode = name => !!(name && tags[ExtensionTag.Block].includes(name)); // The user can override the whole schema creation process by providing
    // their own version. In that case we can exit early.


    if (managerSettings.schema) {
      var _getSpecFromSchema = getSpecFromSchema(managerSettings.schema),
          _nodes = _getSpecFromSchema.nodes,
          _marks = _getSpecFromSchema.marks;

      this.addSchema(managerSettings.schema, _nodes, _marks); // Exit early! 🙌

      return;
    } // This nodes object is built up for each extension and then at the end it
    // will be passed to the `Schema` constructor to create a new `schema`.


    var nodes = isValidDefaultBlockNode(defaultBlockNode) ? {
      doc: object(),
      // Ensure that this is the highest positioned block node by adding it
      // to the object early. Later on it will be overwritten but maintain
      // it's position.
      [defaultBlockNode]: object()
    } : object(); // Similar to the `nodes` object above this is passed to the `Schema`.

    var marks = object(); // Get the named extra attributes from the manager. This allows each extra
    // attribute group added to the manager to be applied to the individual
    // extensions which specified.

    var namedExtraAttributes = getNamedSchemaAttributes({
      settings: managerSettings,
      gatheredSchemaAttributes: this.gatherExtraAttributes(extensions),
      nodeNames: nodeNames,
      markNames: markNames,
      tags: tags
    });

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      var _loop = function _loop() {
        var extension = _step.value;
        // Pick the current attributes from the named attributes and merge them
        // with the extra attributes which were added to the extension. Extra
        // attributes added to the extension are prioritized.
        namedExtraAttributes[extension.name] = _objectSpread(_objectSpread({}, namedExtraAttributes[extension.name]), extension.options.extraAttributes); // There are several places that extra attributes can be ignored. This
        // checks them all.

        var ignoreExtraAttributes = disableExtraAttributes === true || extension.options.disableExtraAttributes === true || extension.constructor.disableExtraAttributes === true;

        if (isNodeExtension(extension)) {
          // Create the spec and gather dynamic attributes for this node
          // extension.
          var _createSpec = createSpec({
            createExtensionSpec: (extra, override) => extension.createNodeSpec(extra, override),
            extraAttributes: assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, nodeOverride), extension.options.nodeOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: extension.tags
          }),
              spec = _createSpec.spec,
              dynamic = _createSpec.dynamic; // Store the node spec on the extension for future reference.


          extension.spec = spec; // Add the spec to the `nodes` object which is used to create the schema
          // with the same name as the extension name.

          nodes[extension.name] = spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `NodeType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct nodes.

          if (Object.keys(dynamic).length > 0) {
            _this.dynamicAttributes.nodes[extension.name] = dynamic;
          }
        } // Very similar to the previous conditional block except for marks rather
        // than nodes.


        if (isMarkExtension(extension)) {
          var _extension$tags;

          // Create the spec and gather dynamic attributes for this mark
          // extension.
          var _createSpec2 = createSpec({
            createExtensionSpec: (extra, override) => extension.createMarkSpec(extra, override),
            extraAttributes: assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, markOverride), extension.options.markOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: (_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []
          }),
              _spec = _createSpec2.spec,
              _dynamic = _createSpec2.dynamic; // Store the mark spec on the extension for future reference.


          extension.spec = _spec; // Add the spec to the `marks` object which is used to create the schema
          // with the same name as the extension name.

          marks[extension.name] = _spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `MarkType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct marks.

          if (Object.keys(_dynamic).length > 0) {
            _this.dynamicAttributes.marks[extension.name] = _dynamic;
          }
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      } // Create the schema from the gathered nodes and marks.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var schema = new Schema({
      nodes,
      marks,
      topNode: 'doc'
    }); // Add the schema and nodes marks to the store.

    this.addSchema(schema, nodes, marks);
  }
  /**
   * This creates the plugin that is used to automatically create the dynamic
   * attributes defined in the extra attributes object.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, _, nextState) => {
        // This creates a new transaction which will be used to update the
        // attributes of any node and marks which
        var tr = nextState.tr; // The dynamic attribute updates only need to be run if the document has
        // been modified in a transaction.

        var documentHasChanged = transactions.some(tr => tr.docChanged);

        if (!documentHasChanged) {
          // The document has not been changed therefore no updates are
          // required.
          return null;
        } // The find children method could potentially be quite expensive. Before
        // committing to that level of work let's check that there user has
        // actually defined some dynamic attributes.


        if (Object.keys(this.dynamicAttributes.nodes).length === 0 && Object.keys(this.dynamicAttributes.marks).length === 0) {
          return null;
        } // This function loops through every node in the document and add the
        // dynamic attributes when any relevant nodes have been added.


        tr.doc.descendants((child, pos) => {
          this.checkAndUpdateDynamicNodes(child, pos, tr);
          this.checkAndUpdateDynamicMarks(child, pos, tr); // This means that all nodes will be checked.

          return true;
        }); // If the transaction has any `steps` then it has been modified and
        // should be returned i.e. appended to the additional transactions.
        // However, if there are no steps then ignore and return `null`.

        return tr.steps.length > 0 ? tr : null;
      }
    };
  }
  /**
   * Add the schema and nodes to the manager and extension store.
   */


  addSchema(schema, nodes, marks) {
    // Store the `nodes`, `marks` and `schema` on the manager store. For example
    // the `schema` can be accessed via `manager.store.schema`.
    this.store.setStoreKey('nodes', nodes);
    this.store.setStoreKey('marks', marks);
    this.store.setStoreKey('schema', schema); // Add the schema to the extension store, so that all extension from this
    // point have access to the schema via `this.store.schema`.

    this.store.setExtensionStore('schema', schema);
    this.store.setStoreKey('defaultBlockNode', getDefaultBlockNode(schema).name); // Set the default block node from the schema.

    for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
      var type = _Object$values[_i];

      if (type.name === 'doc') {
        continue;
      } // Break as soon as the first non 'doc' block node is encountered.


      if (type.isBlock || type.isTextblock) {
        break;
      }
    }
  }
  /**
   * Check the dynamic nodes to see if the provided node:
   *
   * - a) is dynamic and therefore can be updated.
   * - b) has just been created and does not yet have a value for the dynamic
   *   node.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state
   */


  checkAndUpdateDynamicNodes(node, pos, tr) {
    // Check for matching nodes.
    var _iterator2 = _createForOfIteratorHelper(entries(this.dynamicAttributes.nodes)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            _name = _step2$value[0],
            dynamic = _step2$value[1];

        if (node.type.name !== _name) {
          continue;
        }

        var _iterator3 = _createForOfIteratorHelper(entries(dynamic)),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
                attributeName = _step3$value[0],
                attributeCreator = _step3$value[1];

            if (!isNullOrUndefined(node.attrs[attributeName])) {
              continue;
            } // The new attributes which will be added to the node.


            var attrs = _objectSpread(_objectSpread({}, node.attrs), {}, {
              [attributeName]: attributeCreator(node)
            }); // Apply the new dynamic attribute to the node via the transaction.


            tr.setNodeMarkup(pos, undefined, attrs); // Ignore this update in the `prosemirror-suggest` plugin

            ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Loop through the dynamic marks to see if the provided node:
   *
   * - a) is wrapped by a matching mark.
   * - b) has just been added and doesn't yet have the dynamic attribute
   *   applied.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state.
   */


  checkAndUpdateDynamicMarks(node, pos, tr) {
    var _this2 = this;

    // Check for matching marks.
    var _iterator4 = _createForOfIteratorHelper(entries(this.dynamicAttributes.marks)),
        _step4;

    try {
      var _loop2 = function _loop2() {
        var _step4$value = _slicedToArray(_step4.value, 2),
            name = _step4$value[0],
            dynamic = _step4$value[1];

        // This is needed to create the new mark. Even though a mark may already
        // exist ProseMirror requires that a new one is created and added in
        // order. More details available
        // [here](https://discuss.prosemirror.net/t/updating-mark-attributes/776/2?u=ifi).
        var type = assertGet(_this2.store.schema.marks, name); // Get the attrs from the mark.

        var mark = node.marks.find(mark => mark.type.name === name); // If the mark doesn't exist within the set then move to the next
        // dynamically updated mark.

        if (!mark) {
          return "continue";
        } // Loop through to find if any of the required matches are missing from
        // the dynamic attribute;


        var _iterator5 = _createForOfIteratorHelper(entries(dynamic)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                attributeName = _step5$value[0],
                attributeCreator = _step5$value[1];

            // When the attributes for this dynamic attributeName are already
            // defined we should move onto the next item;
            if (!isNullOrUndefined(mark.attrs[attributeName])) {
              continue;
            } // Use the starting position of the node to calculate the range range of
            // the current mark.


            var range = getMarkRange(tr.doc.resolve(pos), type);

            if (!range) {
              continue;
            } // The { from, to } range which will be used to update the mark id
            // attribute.


            var from = range.from,
                to = range.to; // Create the new mark with all the existing dynamic attributes applied.

            var newMark = type.create(_objectSpread(_objectSpread({}, mark.attrs), {}, {
              [attributeName]: attributeCreator(mark)
            })); // Update the value of the mark. The only way to do this right now is to
            // remove and then add it back again.

            tr.removeMark(from, to, type).addMark(from, to, newMark); // Ignore this update in the `prosemirror-suggest` plugin

            ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _ret = _loop2();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  /**
   * Gather all the extra attributes that have been added by extensions.
   */


  gatherExtraAttributes(extensions) {
    var extraSchemaAttributes = [];

    var _iterator6 = _createForOfIteratorHelper(extensions),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _extension = _step6.value;

        if (!_extension.createSchemaAttributes) {
          continue;
        }

        extraSchemaAttributes.push(..._extension.createSchemaAttributes());
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return extraSchemaAttributes;
  }

}) || _class$3);
/**
 * With tags, you can select a specific sub selection of marks and nodes. This
 * will be the basis for adding advanced formatting to remirror.
 *
 * ```ts
 * import { ExtensionTag } from 'remirror';
 * import { createCoreManager, CorePreset } from 'remirror/extensions';
 * import { WysiwygPreset } from 'remirror/extensions';
 *
 * const manager = createCoreManager(() => [new WysiwygPreset(), new CorePreset()], {
 *   extraAttributes: [
 *     {
 *       identifiers: {
 *         tags: [ExtensionTag.NodeBlock],
 *         type: 'node',
 *       },
 *       attributes: { role: 'presentation' },
 *     },
 *   ],
 * });
 * ```
 *
 * Each item in the tags array should be read as an `OR` so the following would
 * match `Tag1` OR `Tag2` OR `Tag3`.
 *
 * ```json
 * { tags: ["Tag1", "Tag2", "Tag3"] }
 * ```
 *
 * The `type` property (`mark | node`) is exclusive and limits the type of
 * extension names that will be matched. When `mark` is set it only matches with
 * marks.
 */

/**
 * Get the extension extra attributes created via the manager and convert into a
 * named object which can be added to each node and mark spec.
 */
function getNamedSchemaAttributes(props) {
  var _settings$extraAttrib;

  var settings = props.settings,
      gatheredSchemaAttributes = props.gatheredSchemaAttributes,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;
  var extraAttributes = object();

  if (settings.disableExtraAttributes) {
    return extraAttributes;
  }

  var extraSchemaAttributes = [...gatheredSchemaAttributes, ...((_settings$extraAttrib = settings.extraAttributes) !== null && _settings$extraAttrib !== void 0 ? _settings$extraAttrib : [])];

  for (var _i2 = 0, _arr = extraSchemaAttributes !== null && extraSchemaAttributes !== void 0 ? extraSchemaAttributes : []; _i2 < _arr.length; _i2++) {
    var attributeGroup = _arr[_i2];
    var identifiers = getIdentifiers({
      identifiers: attributeGroup.identifiers,
      nodeNames,
      markNames,
      tags
    });

    var _iterator7 = _createForOfIteratorHelper(identifiers),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _extraAttributes$iden;

        var identifier = _step7.value;
        var currentValue = (_extraAttributes$iden = extraAttributes[identifier]) !== null && _extraAttributes$iden !== void 0 ? _extraAttributes$iden : {};
        extraAttributes[identifier] = _objectSpread(_objectSpread({}, currentValue), attributeGroup.attributes);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }

  return extraAttributes;
}

/**
 * A predicate for checking if the passed in value is an `IdentifiersObject`.
 */
function isIdentifiersObject(value) {
  return isPlainObject(value) && isArray(value.tags);
}
/**
 * Get the array of names from the identifier that the extra attributes should
 * be applied to.
 */


function getIdentifiers(props) {
  var identifiers = props.identifiers,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;

  if (identifiers === 'nodes') {
    return nodeNames;
  }

  if (identifiers === 'marks') {
    return markNames;
  }

  if (identifiers === 'all') {
    return [...nodeNames, ...markNames];
  } // This is already an array of names to apply the attributes to.


  if (isArray(identifiers)) {
    return identifiers;
  } // Make sure the object provides is valid.


  !isIdentifiersObject(identifiers) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    code: ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES,
    message: "Invalid value passed as an identifier when creating `extraAttributes`."
  }) : invariant(false) : void 0; // Provide type aliases for easier readability.

  var _identifiers$tags = identifiers.tags,
      extensionTags = _identifiers$tags === void 0 ? [] : _identifiers$tags,
      _identifiers$names = identifiers.names,
      extensionNames = _identifiers$names === void 0 ? [] : _identifiers$names,
      _identifiers$behavior = identifiers.behavior,
      behavior = _identifiers$behavior === void 0 ? 'any' : _identifiers$behavior,
      excludeNames = identifiers.excludeNames,
      excludeTags = identifiers.excludeTags,
      type = identifiers.type; // Keep track of the set of stored names.

  var names = new Set(); // Collect the array of names that are supported.

  var acceptableNames = type === 'mark' ? markNames : type === 'node' ? nodeNames : [...markNames, ...nodeNames]; // Check if the name is valid

  var isNameValid = name => acceptableNames.includes(name) && !(excludeNames !== null && excludeNames !== void 0 && excludeNames.includes(name));

  var _iterator8 = _createForOfIteratorHelper(extensionNames),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _name2 = _step8.value;

      if (isNameValid(_name2)) {
        names.add(_name2);
      }
    } // Create a map of extension names to their set of included tags. Then check
    // that the length of the `TagSet` for each extension name is equal to the
    // provided extension tags in this identifier.

  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var taggedNamesMap = new Map(); // Loop through every extension

  var _iterator9 = _createForOfIteratorHelper(extensionTags),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var tag = _step9.value;

      if (excludeTags !== null && excludeTags !== void 0 && excludeTags.includes(tag)) {
        continue;
      }

      var _iterator11 = _createForOfIteratorHelper(tags[tag]),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _taggedNamesMap$get;

          var _name3 = _step11.value;

          if (!isNameValid(_name3)) {
            continue;
          } // When any tag can be an identifier simply add the name to names.


          if (behavior === 'any') {
            names.add(_name3);
            continue;
          }

          var tagSet = (_taggedNamesMap$get = taggedNamesMap.get(_name3)) !== null && _taggedNamesMap$get !== void 0 ? _taggedNamesMap$get : new Set();
          tagSet.add(tag);
          taggedNamesMap.set(_name3, tagSet);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    } // Only add the names that have a `TagSet` where `size` is equal to the number
    // of `extensionTags`

  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  var _iterator10 = _createForOfIteratorHelper(taggedNamesMap),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _step10$value = _slicedToArray(_step10.value, 2),
          _name4 = _step10$value[0],
          _tagSet = _step10$value[1];

      if (_tagSet.size === extensionTags.length) {
        names.add(_name4);
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return [...names];
}

/**
 * Create the scheme spec for a node or mark extension.
 *
 * @template Type - either a [[Mark]] or a [[ProsemirrorNode]]
 * @param props - the options object [[CreateSpecProps]]
 */
function createSpec(props) {
  var _spec$group$split, _spec$group;

  var createExtensionSpec = props.createExtensionSpec,
      extraAttributes = props.extraAttributes,
      ignoreExtraAttributes = props.ignoreExtraAttributes,
      name = props.name,
      tags = props.tags,
      override = props.override; // Keep track of the dynamic attributes which are a part of this spec.

  var dynamic = object();
  /** Called for every dynamic creator to track the dynamic attributes */

  function addDynamic(attributeName, creator) {
    dynamic[attributeName] = creator;
  } // Used to track whether the method has been called. If not called when the
  // extension spec is being set up then an error is thrown.


  var defaultsCalled = false;
  /** Called by createDefaults to track when the `defaults` has been called. */

  function onDefaultsCalled() {
    defaultsCalled = true;
  }

  var defaults = createDefaults(extraAttributes, ignoreExtraAttributes, onDefaultsCalled, addDynamic);
  var parse = createParseDOM(extraAttributes, ignoreExtraAttributes);
  var dom = createToDOM(extraAttributes, ignoreExtraAttributes);
  var spec = createExtensionSpec({
    defaults,
    parse,
    dom
  }, override);
  !(ignoreExtraAttributes || defaultsCalled) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    code: ErrorConstant.EXTENSION_SPEC,
    message: "When creating a node specification you must call the 'defaults', and parse, and 'dom' methods. To avoid this error you can set the static property 'disableExtraAttributes' of '".concat(name, "' to 'true'.")
  }) : invariant(false) : void 0; // Add the tags to the group of the created spec.

  spec.group = [...((_spec$group$split = (_spec$group = spec.group) === null || _spec$group === void 0 ? void 0 : _spec$group.split(' ')) !== null && _spec$group$split !== void 0 ? _spec$group$split : []), ...tags].join(' ') || undefined;
  return {
    spec,
    dynamic
  };
}
/**
 * Get the value of the extra attribute as an object.
 *
 * This is needed because the SchemaAttributes object can be configured as a
 * string or as an object.
 */


function getExtraAttributesObject(value) {
  if (isString(value) || isFunction(value)) {
    return {
      default: value
    };
  }

  !value ? process.env.NODE_ENV !== "production" ? invariant(false, {
    message: "".concat(toString(value), " is not supported"),
    code: ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES
  }) : invariant(false) : void 0;
  return value;
}
/**
 * Create the `defaults()` method which is used for setting the property.
 *
 * @param extraAttributes - the extra attributes for this particular node
 * @param shouldIgnore - whether this attribute should be ignored
 * @param onCalled - the function which is called when this is run, to check
 * that it has been added to the attrs
 * @param addDynamic - A function called to add the dynamic creator and name to
 * the store
 */


function createDefaults(extraAttributes, shouldIgnore, onCalled, addDynamicCreator) {
  return () => {
    onCalled();
    var attributes = object(); // Extra attributes can be ignored by the extension, check if that's the
    // case here.

    if (shouldIgnore) {
      return attributes;
    } // Loop through the extra attributes and attach to the attributes object.


    var _iterator12 = _createForOfIteratorHelper(entries(extraAttributes)),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _step12$value = _slicedToArray(_step12.value, 2),
            _name5 = _step12$value[0],
            config = _step12$value[1];

        // Make sure this is an object and not a string.
        var attributesObject = getExtraAttributesObject(config);
        var defaultValue = attributesObject.default; // When true this is a dynamic attribute creator.

        if (isFunction(defaultValue)) {
          // Store the name and method of the dynamic creator.
          addDynamicCreator(_name5, defaultValue); // Set the attributes for this dynamic creator to be null by default.

          defaultValue = null;
        } // When the `defaultValue` is set to `undefined`, it is set as an empty
        // object in order for ProseMirror to set it as a required attribute.


        attributes[_name5] = defaultValue === undefined ? {} : {
          default: defaultValue
        };
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return attributes;
  };
}
/**
 * Create the parseDOM method to be applied to the extension `createNodeSpec`.
 */


function createParseDOM(extraAttributes, shouldIgnore) {
  return domNode => {
    var attributes = object();

    if (shouldIgnore) {
      return attributes;
    }

    var _iterator13 = _createForOfIteratorHelper(entries(extraAttributes)),
        _step13;

    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var _domNode$getAttribute2;

        var _step13$value = _slicedToArray(_step13.value, 2),
            _name6 = _step13$value[0],
            config = _step13$value[1];

        var _getExtraAttributesOb = getExtraAttributesObject(config),
            parseDOM = _getExtraAttributesOb.parseDOM,
            other = _objectWithoutProperties(_getExtraAttributesOb, _excluded);

        if (!isElementDomNode(domNode)) {
          continue;
        }

        if (isNullOrUndefined(parseDOM)) {
          var _domNode$getAttribute;

          attributes[_name6] = (_domNode$getAttribute = domNode.getAttribute(_name6)) !== null && _domNode$getAttribute !== void 0 ? _domNode$getAttribute : other.default;
          continue;
        }

        if (isFunction(parseDOM)) {
          var _parseDOM;

          attributes[_name6] = (_parseDOM = parseDOM(domNode)) !== null && _parseDOM !== void 0 ? _parseDOM : other.default;
          continue;
        }

        attributes[_name6] = (_domNode$getAttribute2 = domNode.getAttribute(parseDOM)) !== null && _domNode$getAttribute2 !== void 0 ? _domNode$getAttribute2 : other.default;
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }

    return attributes;
  };
}
/**
 * Create the `toDOM` method to be applied to the extension `createNodeSpec`.
 */


function createToDOM(extraAttributes, shouldIgnore) {
  return item => {
    var domAttributes = object();

    if (shouldIgnore) {
      return domAttributes;
    }

    function updateDomAttributes(value, name) {
      if (!value) {
        return;
      }

      if (isString(value)) {
        domAttributes[name] = value;
        return;
      }

      if (isArray(value)) {
        var _value = _slicedToArray(value, 2),
            attr = _value[0],
            val = _value[1];

        domAttributes[attr] = val !== null && val !== void 0 ? val : item.attrs[name];
        return;
      }

      var _iterator14 = _createForOfIteratorHelper(entries(value)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var _step14$value = _slicedToArray(_step14.value, 2),
              _attr = _step14$value[0],
              _val = _step14$value[1];

          domAttributes[_attr] = _val;
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }

    var _iterator15 = _createForOfIteratorHelper(entries(extraAttributes)),
        _step15;

    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _step15$value = _slicedToArray(_step15.value, 2),
            _name7 = _step15$value[0],
            config = _step15$value[1];

        var _getExtraAttributesOb2 = getExtraAttributesObject(config),
            toDOM = _getExtraAttributesOb2.toDOM,
            parseDOM = _getExtraAttributesOb2.parseDOM;

        if (isNullOrUndefined(toDOM)) {
          var key = isString(parseDOM) ? parseDOM : _name7;
          domAttributes[key] = item.attrs[_name7];
          continue;
        }

        if (isFunction(toDOM)) {
          updateDomAttributes(toDOM(item.attrs, getNodeMarkOptions(item)), _name7);
          continue;
        }

        updateDomAttributes(toDOM, _name7);
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }

    return domAttributes;
  };
}
/**
 * Get the options object which applies should be used to obtain the node or
 * mark type.
 */


function getNodeMarkOptions(item) {
  if (isProsemirrorNode(item)) {
    return {
      node: item
    };
  }

  if (isProsemirrorMark(item)) {
    return {
      mark: item
    };
  }

  return {};
}
/**
 * Get the mark and node specs from provided schema.
 *
 * This is used when the user provides their own custom schema.
 */


function getSpecFromSchema(schema) {
  var nodes = object();
  var marks = object();

  for (var _i3 = 0, _Object$entries = Object.entries(schema.nodes); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        _name8 = _Object$entries$_i[0],
        type = _Object$entries$_i[1];

    nodes[_name8] = type.spec;
  }

  for (var _i4 = 0, _Object$entries2 = Object.entries(schema.marks); _i4 < _Object$entries2.length; _i4++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
        _name9 = _Object$entries2$_i[0],
        _type = _Object$entries2$_i[1];

    marks[_name9] = _type.spec;
  }

  return {
    nodes,
    marks
  };
}

var _dec$2, _dec2, _dec3, _dec4, _class$2, _class2;
var SuggestExtension = (_dec$2 = extension({
  customHandlerKeys: ['suggester']
}), _dec2 = helper(), _dec3 = helper(), _dec4 = helper(), _dec$2(_class$2 = (_class2 = class SuggestExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$managerSe;

      var suggester = _ref.suggester;

      if (!suggester || (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.suggesters) {
        return;
      } // Update the suggesters with the provided suggester. Returns the cleanup
      // method.


      return addSuggester(this.store.getState(), suggester);
    });
  }

  get name() {
    return 'suggest';
  }
  /**
   * Create the `addSuggester` method and `removeSuggester` methods to the
   * extension store.
   *
   * This can be used by extensions to conditionally add suggestion support.
   */


  onCreate() {
    this.store.setExtensionStore('addSuggester', suggester => addSuggester(this.store.getState(), suggester));
    this.store.setExtensionStore('removeSuggester', suggester => removeSuggester(this.store.getState(), suggester));
  }
  /**
   * Add the `prosemirror-suggest` plugin to the editor.
   */


  createExternalPlugins() {
    var suggesters = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe2, _extension$options$ex;

        var _extension = _step.value;

        if ((_this$store$managerSe2 = this.store.managerSettings.exclude) !== null && _this$store$managerSe2 !== void 0 && _this$store$managerSe2.suggesters) {
          // Exit the loop early when the manager is set to ignore suggesters.
          break;
        }

        if ( // Method doesn't exist
        !_extension.createSuggesters || // Extension settings exclude it from running
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.suggesters) {
          continue;
        }

        var _suggester = _extension.createSuggesters();

        var suggesterList = isArray(_suggester) ? _suggester : [_suggester];
        suggesters.push(...suggesterList);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return [suggest(...suggesters)];
  }
  /**
   * Allow additional `Suggesters` to be added to the editor. This can be used
   * by `React` to create hooks.
   */


  /**
   * Get the suggest plugin state.
   *
   * This may be removed at a later time.
   *
   * @experimental
   */
  getSuggestState(state) {
    return getSuggestPluginState(state !== null && state !== void 0 ? state : this.store.getState());
  }
  /**
   * Get some helpful methods from the SuggestPluginState.
   */


  getSuggestMethods() {
    var _this$getSuggestState = this.getSuggestState(),
        addIgnored = _this$getSuggestState.addIgnored,
        clearIgnored = _this$getSuggestState.clearIgnored,
        removeIgnored = _this$getSuggestState.removeIgnored,
        ignoreNextExit = _this$getSuggestState.ignoreNextExit,
        setMarkRemoved = _this$getSuggestState.setMarkRemoved,
        findMatchAtPosition = _this$getSuggestState.findMatchAtPosition,
        findNextTextSelection = _this$getSuggestState.findNextTextSelection,
        setLastChangeFromAppend = _this$getSuggestState.setLastChangeFromAppend;

    return {
      addIgnored,
      clearIgnored,
      removeIgnored,
      ignoreNextExit,
      setMarkRemoved,
      findMatchAtPosition,
      findNextTextSelection,
      setLastChangeFromAppend
    };
  }
  /**
   * Check to see whether the provided name is the currently active
   * suggester.
   *
   * @param name - the name of the suggester to include
   */


  isSuggesterActive(name) {
    var _this$getSuggestState2;

    return includes(isArray(name) ? name : [name], (_this$getSuggestState2 = this.getSuggestState().match) === null || _this$getSuggestState2 === void 0 ? void 0 : _this$getSuggestState2.suggester.name);
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "getSuggestState", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestState"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "getSuggestMethods", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestMethods"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "isSuggesterActive", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "isSuggesterActive"), _class2.prototype)), _class2)) || _class$2);

var _dec$1, _class$1;
/**
 * Create the extension tags which are passed into each extensions method to
 * enable dynamically generated rules and commands.
 *
 * Tags on nodes and marks are automatically added to the schema as groups.
 *
 * @category Builtin Extension
 */

var TagsExtension = (_dec$1 = extension({
  defaultPriority: ExtensionPriority.Highest
}), _dec$1(_class$1 = class TagsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "allTags", object());

    _defineProperty(this, "plainTags", object());

    _defineProperty(this, "markTags", object());

    _defineProperty(this, "nodeTags", object());
  }

  get name() {
    return 'tags';
  }
  /**
   * Track the tags which have been applied to the extensions in this editor.
   */


  /**
   * Create the tags which are used to identify extension with particular
   * behavioral traits.
   */
  onCreate() {
    this.resetTags();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.updateTagForExtension(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('tags', this.allTags);
    this.store.setExtensionStore('tags', this.allTags);
    this.store.setStoreKey('plainTags', this.plainTags);
    this.store.setExtensionStore('plainTags', this.plainTags);
    this.store.setStoreKey('markTags', this.markTags);
    this.store.setExtensionStore('markTags', this.markTags);
    this.store.setStoreKey('nodeTags', this.nodeTags);
    this.store.setExtensionStore('nodeTags', this.nodeTags);
  }
  /**
   * Reset the tags to the empty object with empty arrays.
   */


  resetTags() {
    var allTags = object();
    var plainTags = object();
    var markTags = object();
    var nodeTags = object();

    var _iterator2 = _createForOfIteratorHelper(values(ExtensionTag)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var tagName = _step2.value;
        allTags[tagName] = [];
        plainTags[tagName] = [];
        markTags[tagName] = [];
        nodeTags[tagName] = [];
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.allTags = allTags;
    this.plainTags = plainTags;
    this.markTags = markTags;
    this.nodeTags = nodeTags;
  }
  /**
   * Update the tags object for each extension.
   */


  updateTagForExtension(extension) {
    var _extension$tags, _extension$createTags, _extension$createTags2, _extension$options$ex, _this$store$managerSe, _this$store$managerSe2;

    var allTags = new Set([// TODO remove `extension.tags` once all tags have been moved over to `createTags`
    ...((_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []), ...((_extension$createTags = (_extension$createTags2 = extension.createTags) === null || _extension$createTags2 === void 0 ? void 0 : _extension$createTags2.call(extension)) !== null && _extension$createTags !== void 0 ? _extension$createTags : []), ...((_extension$options$ex = extension.options.extraTags) !== null && _extension$options$ex !== void 0 ? _extension$options$ex : []), ...((_this$store$managerSe = (_this$store$managerSe2 = this.store.managerSettings.extraTags) === null || _this$store$managerSe2 === void 0 ? void 0 : _this$store$managerSe2[extension.name]) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : [])]);

    var _iterator3 = _createForOfIteratorHelper(allTags),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var tag = _step3.value;
        !isExtensionTag(tag) ? process.env.NODE_ENV !== "production" ? invariant(false, {
          code: ErrorConstant.EXTENSION,
          message: "The tag provided by the extension: ".concat(extension.constructorName, " is not supported by the editor. To add custom tags you can use the 'mutateTag' method.")
        }) : invariant(false) : void 0; // Add tags to the combined tags stored here.

        this.allTags[tag].push(extension.name);

        if (isPlainExtension(extension)) {
          this.plainTags[tag].push(extension.name);
        }

        if (isMarkExtension(extension)) {
          this.markTags[tag].push(extension.name);
        }

        if (isNodeExtension(extension)) {
          this.nodeTags[tag].push(extension.name);
        }
      } // All tags available.

    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    extension.tags = [...allTags];
  }

}) || _class$1);
/**
 * Check if the provided string is an extension tag.
 */

function isExtensionTag(value) {
  return includes(values(ExtensionTag), value);
}
/**
 * The shape of the tag data stored by the extension manager.
 *
 * This data can be used by other extensions to dynamically determine which
 * nodes should affected by commands / plugins / keys etc...
 */

var ActionType;

(function (ActionType) {
  ActionType[ActionType["ADD_PLACEHOLDER"] = 0] = "ADD_PLACEHOLDER";
  ActionType[ActionType["REMOVE_PLACEHOLDER"] = 1] = "REMOVE_PLACEHOLDER";
})(ActionType || (ActionType = {}));

var key = new PluginKey('remirroFilePlaceholderPlugin');
function createUploadPlaceholderPlugin() {
  return new Plugin({
    key: key,
    state: {
      init() {
        return {
          set: DecorationSet.empty,
          payloads: new Map()
        };
      },

      apply(tr, _ref) {
        var set = _ref.set,
            payloads = _ref.payloads;
        // Adjust decoration positions to changes made by the transaction
        set = set.map(tr.mapping, tr.doc); // See if the transaction adds or removes any placeholders

        var action = tr.getMeta(this);

        if (action) {
          if (action.type === ActionType.ADD_PLACEHOLDER) {
            var widget = document.createElement('placeholder');
            var deco = Decoration.widget(action.pos, widget, {
              id: action.id
            });
            set = set.add(tr.doc, [deco]);
            payloads.set(action.id, action.payload);
          } else if (action.type === ActionType.REMOVE_PLACEHOLDER) {
            set = set.remove(set.find(undefined, undefined, spec => spec.id === action.id));
            payloads.delete(action.id);
          }
        }

        return {
          set,
          payloads
        };
      }

    },
    props: {
      decorations(state) {
        return this.getState(state).set;
      }

    }
  });
}
/**
 * Try to find the positon of the placeholder in the document based on the
 * upload placeholder id
 *
 * @remark
 *
 * This function will first try to find the position based on the decoration set.
 * However, in some cases (e.g. `ReplaceStep`) the decoration will not be
 * available. In that case, it will then try to find every node in the document
 * recursively, which is much slower than the decoration set way in a large
 * document.
 */

function findUploadPlaceholderPos(state, id) {
  var _key$getState;

  var set = (_key$getState = key.getState(state)) === null || _key$getState === void 0 ? void 0 : _key$getState.set;

  if (set) {
    var _decos$;

    var decos = set.find(undefined, undefined, spec => spec.id === id);
    var pos = decos === null || decos === void 0 ? void 0 : (_decos$ = decos[0]) === null || _decos$ === void 0 ? void 0 : _decos$.from;

    if (pos !== undefined) {
      return pos;
    }
  }

  var foundPos;
  state.doc.descendants((node, pos) => {
    if (node.attrs.id === id) {
      foundPos = pos;
    }

    return foundPos === undefined; // return false to stop the descent
  });
  return foundPos;
}
function findUploadPlaceholderPayload(state, id) {
  var _key$getState2;

  var payloads = (_key$getState2 = key.getState(state)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.payloads;

  if (!payloads) {
    return undefined;
  }

  return payloads.get(id);
}
/**
 * Determine if there are active file uploads in the given state
 *
 * @remarks
 * This utility is useful to warn users there are still active uploads before
 * exiting or saving a document.
 *
 * @see https://remirror.vercel.app/?path=/story/extensions-file--with-upload-incomplete-warning
 *
 * @param state - the editor state
 */

function hasUploadingFile(state) {
  var _key$getState$payload, _key$getState3, _key$getState3$payloa;

  var placeholderCount = (_key$getState$payload = (_key$getState3 = key.getState(state)) === null || _key$getState3 === void 0 ? void 0 : (_key$getState3$payloa = _key$getState3.payloads) === null || _key$getState3$payloa === void 0 ? void 0 : _key$getState3$payloa.size) !== null && _key$getState$payload !== void 0 ? _key$getState$payload : 0;
  return placeholderCount > 0;
}
function setUploadPlaceholderAction(tr, action) {
  return tr.setMeta(key, action);
}

function createUploadContext() {
  var values = {};
  var emitter = createNanoEvents();

  var get = key => {
    return values[key];
  };

  var set = (key, value) => {
    values[key] = value;
    emitter.emit('set', values);
  };

  var addListener = listener => {
    return emitter.on('set', listener);
  };

  return {
    set,
    get,
    addListener
  };
}

/**
 * Any `ProsemirrorNode` can use the `uploadFile` function in this file as long
 * as its attributes implement this interface.
 */

/**
 * Insert a file into the editor and upload it.
 */
function uploadFile(_ref) {
  var file = _ref.file,
      pos = _ref.pos,
      view = _ref.view,
      fileType = _ref.fileType,
      uploadHandler = _ref.uploadHandler;
  var id = uniqueId('file-placeholder-');
  var context = createUploadContext();
  var fileUploader = createFilePlaceholder({
    id,
    context,
    file,
    pos,
    view,
    fileType,
    uploadHandler
  });
  fileUploader === null || fileUploader === void 0 ? void 0 : fileUploader.upload(context).then(attrs => onFileLoaded({
    id,
    fileType,
    view,
    attrs
  })).catch(error => onFileLoaded({
    id,
    fileType,
    view,
    attrs: {
      error: error.message
    }
  }));
}
/**
 * Try to find a point where a node of the given type can be inserted
 * near `pos`, by searching up the node hierarchy when `pos` itself
 * isn't a valid place. Return null if no position was found.
 *
 * This function is similar to `insertPoint` from `prosemirror-transform`,
 * but it will also search for a valid position even if the `pos` is in the
 * middle of a node.
 */

function insertFilePoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);

  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {
    return pos;
  }

  if ($pos.parentOffset === 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);

      if ($pos.node(d).canReplaceWith(index, index, nodeType)) {
        return $pos.before(d + 1);
      }

      if (index > 0) {
        return null;
      }
    }
  }

  for (var _d = $pos.depth - 1; _d >= 0; _d--) {
    var _index = $pos.indexAfter(_d);

    if ($pos.node(_d).canReplaceWith(_index, _index, nodeType)) {
      return $pos.after(_d + 1);
    }

    if (_index < $pos.node(_d).childCount) {
      return null;
    }
  }

  return null;
}

function createFilePlaceholder(_ref2) {
  var id = _ref2.id,
      context = _ref2.context,
      file = _ref2.file,
      pos = _ref2.pos,
      view = _ref2.view,
      fileType = _ref2.fileType,
      uploadHandler = _ref2.uploadHandler;
  var tr = view.state.tr;
  var insertPos = insertFilePoint(tr.doc, isNumber(pos) ? pos : tr.selection.from, fileType);

  if (!isNumber(insertPos)) {
    // failed to find a postition to insert the file node
    return;
  } // create a fileUploader, which will read and/or upload the file later


  var fileUploader = uploadHandler(); // insert the file node

  var attrs = _objectSpread(_objectSpread({}, fileUploader.insert(file)), {}, {
    id
  });

  tr.insert(insertPos, fileType.createChecked(attrs)); // insert the placeholder decoration

  var payload = {
    context,
    fileUploader
  };
  setUploadPlaceholderAction(tr, {
    type: ActionType.ADD_PLACEHOLDER,
    id,
    pos: insertPos,
    payload
  });
  view.dispatch(tr);
  return fileUploader;
}

function onFileLoaded(_ref3) {
  var id = _ref3.id,
      attrs = _ref3.attrs,
      fileType = _ref3.fileType,
      view = _ref3.view;
  var placeholderPos = findUploadPlaceholderPos(view.state, id); // unexpected

  if (placeholderPos == null) {
    return;
  }

  var $pos = view.state.doc.resolve(placeholderPos);
  var fileNode = $pos.nodeAfter; // if the file node around the placeholder has been deleted, then delete
  // the placeholder and drop the uploaded file.

  if (!fileNode || fileNode.type !== fileType || fileNode.attrs.id !== id) {
    var _tr = view.state.tr;
    setUploadPlaceholderAction(_tr, {
      type: ActionType.REMOVE_PLACEHOLDER,
      id
    });
    view.dispatch(_tr);
    return;
  } // Update the file node at the placeholder's position, and remove
  // the placeholder.


  var tr = view.state.tr;
  setUploadPlaceholderAction(tr, {
    type: ActionType.REMOVE_PLACEHOLDER,
    id
  });

  var fileAttrs = _objectSpread(_objectSpread(_objectSpread({}, fileNode.attrs), attrs), {}, {
    id: null
  }); // We need to update the node to trigger the render function, which will accept
  // differnt properties during and after the upload progress.


  tr.setNodeMarkup(placeholderPos, undefined, fileAttrs);
  view.dispatch(tr);
}

/**
 * `UploadExtension` handle the file upload process.
 */
class UploadExtension extends PlainExtension {
  get name() {
    return 'upload';
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createExternalPlugins() {
    return [createUploadPlaceholderPlugin()];
  }

}

/**
 * Provides all the builtin extensions to the editor.
 *
 * @remarks
 *
 * This is used automatically and (at the time of writing) can't be removed from
 * the editor. If you feel that there's a compelling reason to override these
 * extensions feel free to create a [discussion
 * here](https://github.com/remirror/remirror/discussions/category_choices) and
 * it can be addressed.
 *
 * @category Builtin Extension
 *
 * The order of these extension are important.
 *
 * - [[`TagsExtension`]] is places first because it provides tagging which is
 *   used by the schema extension.
 * - [[`SchemeExtension`]] goes next because it's super important to the editor
 *   functionality and needs to run before everything else which might depend
 *   on it.
 */
function builtinPreset() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultOptions = {
    exitMarksOnArrowPress: KeymapExtension.defaultOptions.exitMarksOnArrowPress,
    excludeBaseKeymap: KeymapExtension.defaultOptions.excludeBaseKeymap,
    selectParentNodeOnEscape: KeymapExtension.defaultOptions.selectParentNodeOnEscape,
    undoInputRuleOnBackspace: KeymapExtension.defaultOptions.undoInputRuleOnBackspace,
    persistentSelectionClass: DecorationsExtension.defaultOptions.persistentSelectionClass
  };
  options = _objectSpread(_objectSpread({}, defaultOptions), options);
  var keymapOptions = pick(options, ['excludeBaseKeymap', 'selectParentNodeOnEscape', 'undoInputRuleOnBackspace']);
  var decorationsOptions = pick(options, ['persistentSelectionClass']);
  return [// The order of these extension is important. First come first served.
  new TagsExtension(), new SchemaExtension(), new AttributesExtension(), new PluginsExtension(), new InputRulesExtension(), new PasteRulesExtension(), new NodeViewsExtension(), new SuggestExtension(), new CommandsExtension(), new HelpersExtension(), new KeymapExtension(keymapOptions), new DocChangedExtension(), new UploadExtension(), new DecorationsExtension(decorationsOptions)];
}

var _dec, _class;
var MetaExtension = (_dec = extension({
  defaultOptions: {
    capture: process.env.NODE_ENV === 'development'
  },
  staticKeys: ['capture'],
  defaultPriority: ExtensionPriority.Highest
}), _dec(_class = class MetaExtension extends PlainExtension {
  get name() {
    return 'meta';
  }

  onCreate() {
    this.store.setStoreKey('getCommandMeta', this.getCommandMeta.bind(this));

    if (!this.options.capture) {
      return;
    }

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.captureCommands(_extension);
        this.captureKeybindings(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * This is here to provide a
   */


  createPlugin() {
    return {};
  }
  /**
   * Intercept command names and attributes.
   */


  captureCommands(extension) {
    var _extension$decoratedC,
        _this = this;

    var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
    var createCommands = extension.createCommands;

    var _loop = function _loop() {
      var name = _Object$keys[_i];
      var command = extension[name];

      extension[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return props => {
          var value = command(...args)(props);

          if (props.dispatch && value) {
            var _props$view;

            _this.setCommandMeta(props.tr, {
              type: 'command',
              chain: props.dispatch !== ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch),
              name: name,
              extension: extension.name,
              decorated: true
            });
          }

          return value;
        };
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(decoratedCommands); _i < _Object$keys.length; _i++) {
      _loop();
    }

    if (createCommands) {
      extension.createCommands = () => {
        var commandsObject = createCommands();

        var _loop2 = function _loop2() {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              name = _Object$entries$_i[0],
              command = _Object$entries$_i[1];

          commandsObject[name] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            return props => {
              var value = command(...args)(props);

              if (props.dispatch && value) {
                var _props$view2;

                _this.setCommandMeta(props.tr, {
                  type: 'command',
                  chain: props.dispatch !== ((_props$view2 = props.view) === null || _props$view2 === void 0 ? void 0 : _props$view2.dispatch),
                  name: name,
                  extension: extension.name,
                  decorated: false
                });
              }

              return value;
            };
          };
        };

        for (var _i2 = 0, _Object$entries = Object.entries(commandsObject); _i2 < _Object$entries.length; _i2++) {
          _loop2();
        }

        return commandsObject;
      };
    }
  }
  /**
   * Intercept command name and attributes.
   */


  captureKeybindings(_) {}
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    return (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : [];
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, [...meta, update]);
  }

}) || _class);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

var _uid = /*#__PURE__*/new WeakMap();

var _getProps = /*#__PURE__*/new WeakMap();

var _previousState = /*#__PURE__*/new WeakMap();

var _firstRender = /*#__PURE__*/new WeakMap();

var _events$1 = /*#__PURE__*/new WeakMap();

var _addHandler = /*#__PURE__*/new WeakMap();

var _initialEditorState = /*#__PURE__*/new WeakMap();

/**
 * This is the `Framework` class which is used to create an abstract class for
 * implementing `Remirror` into the framework of your choice.
 *
 * The best way to learn how to use it is to take a look at the [[`DomFramework`]]
 * and [[`ReactFramework`]] implementations.
 *
 * @remarks
 *
 * There are two methods and one getter property which must be implemented for this
 */
class Framework {
  /**
   * The schema available via the provided extensions.
   *
   * @internal
   */

  /**
   * A unique ID for the editor which can also be used as a key in frameworks
   * that need it.
   */

  /**
   * A method which enables retrieving the props from the editor.
   */

  /**
   * The private reference to the previous state.
   */

  /**
   * True when this is the first render.
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */
  get addHandler() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _addHandler)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _addHandler, _classPrivateFieldGet(this, _events$1).on.bind(_classPrivateFieldGet(this, _events$1)));
  }
  /**
   * The handler which is bound to the events listener object.
   */


  /**
   * The updatable view props.
   */
  get updatableViewProps() {
    return {
      attributes: () => this.getAttributes(),
      editable: () => {
        var _this$props$editable;

        return (_this$props$editable = this.props.editable) !== null && _this$props$editable !== void 0 ? _this$props$editable : true;
      }
    };
  }
  /**
   * True when this is the first render of the editor.
   */


  get firstRender() {
    return _classPrivateFieldGet(this, _firstRender);
  }
  /**
   * Store the name of the framework.
   */


  /**
   * The props passed in when creating or updating the `Framework` instance.
   */
  get props() {
    return _classPrivateFieldGet(this, _getProps).call(this);
  }
  /**
   * Returns the previous editor state. On the first render it defaults to
   * returning the current state. For the first render the previous state and
   * current state will always be equal.
   */


  get previousState() {
    var _ref, _this$previousStateOv;

    return (_ref = (_this$previousStateOv = this.previousStateOverride) !== null && _this$previousStateOv !== void 0 ? _this$previousStateOv : _classPrivateFieldGet(this, _previousState)) !== null && _ref !== void 0 ? _ref : this.initialEditorState;
  }
  /**
   * The instance of the [[`RemirrorManager`]].
   */


  get manager() {
    return this.props.manager;
  }
  /**
   * The ProseMirror [[`EditorView`]].
   */


  get view() {
    return this.manager.view;
  }
  /**
   * A unique id for the editor. Can be used to differentiate between editors.
   *
   * Please note that this ID is only locally unique, it should not be used as a
   * database key.
   */


  get uid() {
    return _classPrivateFieldGet(this, _uid);
  }

  /**
   * The initial editor state from when the editor was first created.
   */
  get initialEditorState() {
    return _classPrivateFieldGet(this, _initialEditorState);
  }

  constructor(options) {
    var _this = this;

    _classPrivateFieldInitSpec(this, _uid, {
      writable: true,
      value: uniqueId()
    });

    _classPrivateFieldInitSpec(this, _getProps, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _previousState, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstRender, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _events$1, {
      writable: true,
      value: createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _addHandler, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _initialEditorState, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _this$view$state;

      return (_this$view$state = this.view.state) !== null && _this$view$state !== void 0 ? _this$view$state : this.initialEditorState;
    });

    _defineProperty(this, "getPreviousState", () => this.previousState);

    _defineProperty(this, "dispatchTransaction", tr => {
      var _this$props$onDispatc, _this$props$onDispatc2, _this$props;

      // This should never happen, but it may have slipped through in the certain places.
      !!this.manager.destroyed ? process.env.NODE_ENV !== "production" ? invariant(false, {
        code: ErrorConstant.MANAGER_PHASE_ERROR,
        message: 'A transaction was dispatched to a manager that has already been destroyed. Please check your set up, or open an issue.'
      }) : invariant(false) : void 0;
      tr = (_this$props$onDispatc = (_this$props$onDispatc2 = (_this$props = this.props).onDispatchTransaction) === null || _this$props$onDispatc2 === void 0 ? void 0 : _this$props$onDispatc2.call(_this$props, tr, this.getState())) !== null && _this$props$onDispatc !== void 0 ? _this$props$onDispatc : tr;
      var previousState = this.getState();

      var _previousState$applyT = previousState.applyTransaction(tr),
          state = _previousState$applyT.state,
          transactions = _previousState$applyT.transactions;

      _classPrivateFieldSet(this, _previousState, previousState); // Use the abstract method to update the state.


      this.updateState({
        state,
        tr,
        transactions
      }); // Update the view props when an update is requested

      var forcedUpdates = this.manager.store.getForcedUpdates(tr);

      if (!isEmptyArray(forcedUpdates)) {
        this.updateViewProps(...forcedUpdates);
      }
    });

    _defineProperty(this, "onChange", function () {
      var _this$props$onChange, _this$props2;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : object();

      var onChangeProps = _this.eventListenerProps(props);

      if (_classPrivateFieldGet(_this, _firstRender)) {
        _classPrivateFieldSet(_this, _firstRender, false);
      }

      (_this$props$onChange = (_this$props2 = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props2, onChangeProps);
    });

    _defineProperty(this, "onBlur", event => {
      var _this$props$onBlur, _this$props3;

      var props = this.eventListenerProps();
      (_this$props$onBlur = (_this$props3 = this.props).onBlur) === null || _this$props$onBlur === void 0 ? void 0 : _this$props$onBlur.call(_this$props3, props, event);

      _classPrivateFieldGet(this, _events$1).emit('blur', props, event);
    });

    _defineProperty(this, "onFocus", event => {
      var _this$props$onFocus, _this$props4;

      var props = this.eventListenerProps();
      (_this$props$onFocus = (_this$props4 = this.props).onFocus) === null || _this$props$onFocus === void 0 ? void 0 : _this$props$onFocus.call(_this$props4, props, event);

      _classPrivateFieldGet(this, _events$1).emit('focus', props, event);
    });

    _defineProperty(this, "setContent", function (content) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$triggerChange = _ref2.triggerChange,
          triggerChange = _ref2$triggerChange === void 0 ? false : _ref2$triggerChange;

      var _this$manager$createS = _this.manager.createState({
        content
      }),
          doc = _this$manager$createS.doc;

      var previousState = _this.getState();

      var _this$getState$applyT = _this.getState().applyTransaction(previousState.tr.replaceRangeWith(0, previousState.doc.nodeSize - 2, doc)),
          state = _this$getState$applyT.state;

      if (triggerChange) {
        return _this.updateState({
          state,
          triggerChange
        });
      }

      _this.view.updateState(state);
    });

    _defineProperty(this, "clearContent", function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$triggerChange = _ref3.triggerChange,
          triggerChange = _ref3$triggerChange === void 0 ? false : _ref3$triggerChange;

      _this.setContent(_this.manager.createEmptyDoc(), {
        triggerChange
      });
    });

    _defineProperty(this, "createStateFromContent", (content, selection) => {
      return this.manager.createState({
        content,
        selection
      });
    });

    _defineProperty(this, "focus", position => {
      this.manager.store.commands.focus(position);
    });

    _defineProperty(this, "blur", position => {
      this.manager.store.commands.blur(position);
    });

    var getProps = options.getProps,
        initialEditorState = options.initialEditorState,
        element = options.element;

    _classPrivateFieldSet(this, _getProps, getProps);

    _classPrivateFieldSet(this, _initialEditorState, initialEditorState); // Attach the framework instance to the manager. The manager will set up the
    // update listener and manage updates to the instance of the framework
    // automatically.


    this.manager.attachFramework(this, this.updateListener.bind(this));

    if (this.manager.view) {
      return;
    } // Create the ProsemirrorView and initialize our editor manager with it.


    var view = this.createView(initialEditorState, element);
    this.manager.addView(view);
  }
  /**
   * Setup the manager event listeners which are disposed of when the manager is
   * destroyed.
   */


  updateListener(props) {
    var state = props.state,
        tr = props.tr;
    return _classPrivateFieldGet(this, _events$1).emit('updated', this.eventListenerProps({
      state,
      tr
    }));
  }
  /**
   * Update the constructor props passed in. Useful for frameworks like react
   * where props are constantly changing and when using hooks function closures
   * can become stale.
   *
   * You can call the update method with the new `props` to update the internal
   * state of this instance.
   */


  update(options) {
    var getProps = options.getProps;

    _classPrivateFieldSet(this, _getProps, getProps);

    return this;
  }
  /**
   * Retrieve the editor state.
   */


  /**
   * Update the view props.
   */
  updateViewProps() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    var props = pick(this.updatableViewProps, keys);
    this.view.setProps(_objectSpread(_objectSpread({}, this.view.props), props));
  }
  /**
   * This sets the attributes for the ProseMirror Dom node.
   */


  getAttributes(ssr) {
    var _this$manager$store;

    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        autoFocus = _this$props5.autoFocus,
        _this$props5$classNam = _this$props5.classNames,
        classNames = _this$props5$classNam === void 0 ? [] : _this$props5$classNam,
        label = _this$props5.label,
        editable = _this$props5.editable;
    var managerAttributes = (_this$manager$store = this.manager.store) === null || _this$manager$store === void 0 ? void 0 : _this$manager$store.attributes; // The attributes which were passed in as props.

    var propAttributes = isFunction(attributes) ? attributes(this.eventListenerProps()) : attributes; // Whether or not the editor is focused.

    var focus = {}; // In Chrome 84 when autofocus is set to any value including `"false"` it
    // will actually trigger the autofocus. This check makes sure there is no
    // `autofocus` attribute attached unless `autoFocus` is expressly a truthy
    // value.

    if (autoFocus || isNumber(autoFocus)) {
      focus = ssr ? {
        autoFocus: true
      } : {
        autofocus: 'true'
      };
    }

    var uniqueClasses = uniqueArray(cx(ssr && 'Prosemirror', 'remirror-editor', managerAttributes === null || managerAttributes === void 0 ? void 0 : managerAttributes.class, ...classNames).split(' ')).join(' ');

    var defaultAttributes = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
      role: 'textbox'
    }, focus), {}, {
      'aria-multiline': 'true'
    }, !(editable !== null && editable !== void 0 ? editable : true) ? {
      'aria-readonly': 'true'
    } : {}), {}, {
      'aria-label': label !== null && label !== void 0 ? label : ''
    }, managerAttributes), {}, {
      class: uniqueClasses
    });

    return omitUndefined(_objectSpread(_objectSpread({}, defaultAttributes), propAttributes));
  }
  /**
   * Part of the Prosemirror API and is called whenever there is state change in
   * the editor.
   *
   * @internalremarks
   * How does it work when transactions are dispatched one after the other.
   */


  /**
   * Adds `onBlur` and `onFocus` listeners.
   *
   * When extending this class make sure to call this method once
   * `ProsemirrorView` has been added to the dom.
   */
  addFocusListeners() {
    this.view.dom.addEventListener('blur', this.onBlur);
    this.view.dom.addEventListener('focus', this.onFocus);
  }
  /**
   * Remove `onBlur` and `onFocus` listeners.
   *
   * When extending this class in your framework, make sure to call this just
   * before the view is destroyed.
   */


  removeFocusListeners() {
    this.view.dom.removeEventListener('blur', this.onBlur);
    this.view.dom.removeEventListener('focus', this.onFocus);
  }
  /**
   * Called when the component unmounts and is responsible for cleanup.
   *
   * @remarks
   *
   * - Removes listeners for the editor `blur` and `focus` events
   */


  destroy() {
    // Let it clear that this instance has been destroyed.
    _classPrivateFieldGet(this, _events$1).emit('destroy');

    if (this.view) {
      // Remove the focus and blur listeners.
      this.removeFocusListeners();
    }
  }
  /**
   * Use this method in the `onUpdate` event to run all change handlers.
   */


  /**
   * Creates the props passed into all event listener handlers. e.g.
   * `onChange`
   */
  eventListenerProps() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : object();
    var state = props.state,
        tr = props.tr,
        transactions = props.transactions;
    return {
      tr,
      transactions,
      internalUpdate: !tr,
      view: this.view,
      firstRender: _classPrivateFieldGet(this, _firstRender),
      state: state !== null && state !== void 0 ? state : this.getState(),
      createStateFromContent: this.createStateFromContent,
      previousState: this.previousState,
      helpers: this.manager.store.helpers
    };
  }

  /**
   * Methods and properties which are made available to all consumers of the
   * `Framework` class.
   */
  get baseOutput() {
    return _objectSpread(_objectSpread({
      manager: this.manager
    }, this.manager.store), {}, {
      addHandler: this.addHandler,
      // Commands
      focus: this.focus,
      blur: this.blur,
      // Properties
      uid: _classPrivateFieldGet(this, _uid),
      view: this.view,
      // Getter Methods
      getState: this.getState,
      getPreviousState: this.getPreviousState,
      getExtension: this.manager.getExtension.bind(this.manager),
      // Setter Methods
      clearContent: this.clearContent,
      setContent: this.setContent
    });
  }
  /**
   * Every framework implementation must provide it's own custom output.
   */


}

/**
 * Transforms the unsorted array of presets and extension into presets and
 * sorted extensions. Handles uniqueness of extensions and automatically throws
 * an error when required extensions are missing.
 *
 * @internalremarks Currently matching by constructor - what if different
 * versions exist in the same app
 *
 * @param initialExtensions - the extensions to be transformed. This includes
 * the extension that are parents to other extensions.
 *
 * @returns the list of extension instances sorted by priority
 */
function transformExtensions(initialExtensions, settings) {
  // This is the holder for the sorted and cleaned extensions returned by this
  // function.
  var extensions = [];
  var extensionMap = new WeakMap(); // All the extensions which provide child extensions.

  var parentExtensions = []; // Used to track duplicates and the extension holders they were added by.

  var duplicateMap = new WeakMap(); // The unsorted, de-duped, unrefined extensions.

  var gatheredExtensions = []; // The mutable objects and the manager settings which are used to gather all
  // the deeply nested extensions.

  var gatherRawExtensionConfig = {
    duplicateMap,
    parentExtensions,
    gatheredExtensions,
    settings
  };

  var _iterator = _createForOfIteratorHelper(initialExtensions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _extension = _step.value;
      gatherRawExtensions(gatherRawExtensionConfig, {
        extension: _extension
      });
    } // Sort the extensions.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  gatheredExtensions = sort(gatheredExtensions, (a, z) => z.priority - a.priority); // Keep track of added constructors for uniqueness.

  var found = new WeakSet();
  var names = new Set(); // Remove extension duplicates and update the parent extension with the
  // highest priority identical extension.

  var _iterator2 = _createForOfIteratorHelper(gatheredExtensions),
      _step2;

  try {
    var _loop = function _loop() {
      var extension = _step2.value;
      var key = extension.constructor;
      var name = extension.name;
      var duplicates = duplicateMap.get(key);
      !duplicates ? process.env.NODE_ENV !== "production" ? invariant(false, {
        message: "No entries were found for the ExtensionConstructor ".concat(extension.name),
        code: ErrorConstant.INTERNAL
      }) : invariant(false) : void 0;

      if (found.has(key) || names.has(name)) {
        return "continue";
      }

      found.add(key);
      names.add(name);
      extensions.push(extension);
      extensionMap.set(key, extension); // Replace the extensions for all presets that referenced this constructor.

      duplicates.forEach(parent => parent === null || parent === void 0 ? void 0 : parent.replaceChildExtension(key, extension));
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var missing = []; // Throw if any required extensions are missing.

  for (var _i = 0, _extensions = extensions; _i < _extensions.length; _i++) {
    var extension = _extensions[_i];
    findMissingExtensions({
      extension,
      found,
      missing
    });
  }

  !isEmptyArray(missing) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    code: ErrorConstant.MISSING_REQUIRED_EXTENSION,
    message: missing.map(_ref => {
      var Constructor = _ref.Constructor,
          extension = _ref.extension;
      return "The extension '".concat(extension.name, "' requires '").concat(Constructor.name, " in order to run correctly.");
    }).join('\n')
  }) : invariant(false) : void 0;
  return {
    extensions,
    extensionMap
  };
}

/**
 * Dive into the current extension and gather all child extensions including
 * those which are deeply nested.
 *
 * It also automatically handles circular dependencies. And logs a warning when
 * one is encountered.
 *
 * @param config - the configuration and mutable objects which are updated by
 * this function.
 * @param props - the extension, gathered names and parent extension.
 */
function gatherRawExtensions(config, props) {
  var _settings$priority;

  var gatheredExtensions = config.gatheredExtensions,
      duplicateMap = config.duplicateMap,
      parentExtensions = config.parentExtensions,
      settings = config.settings;
  var extension = props.extension,
      parentExtension = props.parentExtension; // Get the list of parent names of the current extension. This is used to
  // track circular dependencies.

  var _props$names = props.names,
      names = _props$names === void 0 ? [] : _props$names;
  !isExtension(extension) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    code: ErrorConstant.INVALID_MANAGER_EXTENSION,
    message: "An invalid extension: ".concat(extension, " was provided to the [[`RemirrorManager`]].")
  }) : invariant(false) : void 0; // The children provided by this extension.

  var childExtensions = extension.extensions; // Override the priority if the user has done so in the settings passed to the
  // [[`RemirrorManager`]].

  extension.setPriority((_settings$priority = settings.priority) === null || _settings$priority === void 0 ? void 0 : _settings$priority[extension.name]); // Update the gathered extension list in this block

  gatheredExtensions.push(extension); // Keep track of the extensions which have been added multiple times by
  // separate extension parents. Later on, the highest priority extension will
  // be added to each parent instead of the one that they may have been
  // configured with.

  updateExtensionDuplicates({
    duplicateMap,
    extension,
    parentExtension
  }); // Check if there are any children extensions to be added an if not move onto
  // the next provided extension.

  if (childExtensions.length === 0) {
    return;
  }

  if (names.includes(extension.name)) {
    process.env.NODE_ENV !== "production" ? warning(false, "Circular dependency encountered when loading extensions: ".concat(names.join(' > '), " > ").concat(extension.name)) : void 0;
    return;
  }

  names = [...names, extension.name];
  parentExtensions.push(extension);

  var _iterator3 = _createForOfIteratorHelper(childExtensions),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var child = _step3.value;
      // Recursively gather all the children extension from the current extension
      // level.
      gatherRawExtensions(config, {
        names,
        extension: child,
        parentExtension: extension
      });
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

/**
 * Populate missing Constructors.
 *
 * If any missing extensions are identified then it is the responsibility of the
 * calling method to deal with the error. Currently the action is to `throw` an
 * error.
 */
function findMissingExtensions(props) {
  var _extension$requiredEx;

  var extension = props.extension,
      found = props.found,
      missing = props.missing;

  if (!extension.requiredExtensions) {
    return;
  }

  var _iterator4 = _createForOfIteratorHelper((_extension$requiredEx = extension.requiredExtensions) !== null && _extension$requiredEx !== void 0 ? _extension$requiredEx : []),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var Constructor = _step4.value;

      if (found.has(Constructor)) {
        continue;
      }

      missing.push({
        Constructor: Constructor,
        extension
      });
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}

/**
 * Adds the values to the duplicate map which identifies each unique extension
 * in the manager and tracks the presets responsible for adding them. This is
 * used to make sure that only one instance of each extension is shared amongst
 * the presets which require it.
 *
 * At the moment, the highest priority extension is the one that is to all
 * presets which require it. This is done by checking the `duplicateMap` for
 * each extension, and replacing the instance of the required extension within
 * the preset with the highest priority instance.
 */
function updateExtensionDuplicates(props) {
  var duplicateMap = props.duplicateMap,
      extension = props.extension,
      parentExtension = props.parentExtension; // The extension constructor is used as the identifier for lookups.

  var key = extension.constructor;
  var duplicate = duplicateMap.get(key);
  var parentToAdd = parentExtension ? [parentExtension] : [];
  duplicateMap.set(key, duplicate ? [...duplicate, ...parentToAdd] : parentToAdd);
}
/**
 * This is the object shape that is returned from the combined transformation.
 */


/**
 * This helper function extracts all the lifecycle methods from the provided
 * extension and adds them to the provided `handler` container.
 */
function extractLifecycleMethods(props) {
  var _extension$onCreate, _extension$onView, _extension$onStateUpd, _extension$onDestroy;

  var extension = props.extension,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      plainNames = props.plainNames,
      store = props.store,
      handlers = props.handlers; // Add the store to the extension. The store is used by extensions to access
  // all the data included in `Remirror.ExtensionStore`. I decided on this
  // pattern because passing around parameters into each call method was
  // tedious. Why not just access `this.store` within your extension to get
  // whatever you need? Also using the store allows developers to extend the
  // behaviour of their editor by adding different behaviour to the global
  // namespace [[`Remirror.ExtensionStore`]].

  extension.setStore(store); // Gather all the handlers and add them where they exist.

  var createHandler = (_extension$onCreate = extension.onCreate) === null || _extension$onCreate === void 0 ? void 0 : _extension$onCreate.bind(extension);
  var viewHandler = (_extension$onView = extension.onView) === null || _extension$onView === void 0 ? void 0 : _extension$onView.bind(extension);
  var stateUpdateHandler = (_extension$onStateUpd = extension.onStateUpdate) === null || _extension$onStateUpd === void 0 ? void 0 : _extension$onStateUpd.bind(extension);
  var destroyHandler = (_extension$onDestroy = extension.onDestroy) === null || _extension$onDestroy === void 0 ? void 0 : _extension$onDestroy.bind(extension);

  if (createHandler) {
    handlers.create.push(createHandler);
  }

  if (viewHandler) {
    handlers.view.push(viewHandler);
  }

  if (stateUpdateHandler) {
    handlers.update.push(stateUpdateHandler);
  }

  if (destroyHandler) {
    handlers.destroy.push(destroyHandler);
  } // Keep track of the names of the different types of extension held by this
  // manager. This is already in use by the [[`TagsExtension`]].


  if (isMarkExtension(extension)) {
    markNames.push(extension.name);
  } // Don't include the `doc` as a node since it is a requirement for all editors
  // and doesn't behave in the same way as other nodes.


  if (isNodeExtension(extension) && extension.name !== 'doc') {
    nodeNames.push(extension.name);
  }

  if (isPlainExtension(extension)) {
    plainNames.push(extension.name);
  }
}

/**
 * The `Manager` has multiple hook phases which are able to hook into the
 * extension manager flow and add new functionality to the editor.
 *
 * The `ExtensionEventMethod`s
 *
 * - onCreate - when the extension manager is created and after the schema is
 *   made available.
 * - onView - when the view has been received from the dom ref.
 */

/**
 * A class to manage the extensions and prosemirror interactions within the
 * editor.
 *
 * @remarks
 *
 * The RemirrorManager enables the lifecycle methods of the extensions by
 * calling each method in the distinct phases of the lifecycle.
 *
 * - `onCreate` - This happens when the manager is constructed. It calls on the
 *   extension which have an `onCreate` method and allows them to do their work.
 *
 * For the built in methods, this is when the `SchemaExtension` creates the
 * Schema and when the `TagsExtension` combines the tags for the editor
 * instance.
 *
 * ```ts
 * const manager = Manager.create(() => [
 *   new DocExtension(),
 *   new TextExtension(),
 *   new ParagraphExtension(),
 * ])
 * ```
 *
 * At this point all the `onCreate` methods have been called. Including the
 * `onCreate` for the `Schema`.
 *
 * - `onView` - This is called the framework instance connects the
 *   `RemirrorManager` to the ProseMirror EditorView.
 *
 * ```ts
 * manager.addView(new EditorView(...))
 * manager.store.commands.insertText('Hello world');.
 * ```
 *
 * - [[`onStateUpdate`]] - This is the method called every time the ProseMirror
 *   state changes. Both the extensions and the `Framework` listen to this event
 *   and can provide updates in response.
 */

var _extensionStore = /*#__PURE__*/new WeakMap();

var _stringHandlers = /*#__PURE__*/new WeakMap();

var _store = /*#__PURE__*/new WeakMap();

var _extensions = /*#__PURE__*/new WeakMap();

var _extensionMap = /*#__PURE__*/new WeakMap();

var _phase = /*#__PURE__*/new WeakMap();

var _settings = /*#__PURE__*/new WeakMap();

var _firstStateUpdate = /*#__PURE__*/new WeakMap();

var _handlers = /*#__PURE__*/new WeakMap();

var _disposers = /*#__PURE__*/new WeakMap();

var _events = /*#__PURE__*/new WeakMap();

var _framework = /*#__PURE__*/new WeakMap();

var _disposeFramework = /*#__PURE__*/new WeakMap();

class RemirrorManager {
  /**
   * Create the manager for your `Remirror` editor.
   */
  static create(extensions) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new RemirrorManager([...getLazyArray(extensions), ...builtinPreset(settings.builtin)], settings);
  }
  /**
   * Utility getter for storing the base method props which is available to
   * all extensions.
   */


  /**
   * Identifies this as a `Manager`.
   *
   * @internal
   */
  get [__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return RemirrorIdentifier.Manager;
  }
  /**
   * Returns `true` if the manager has been destroyed.
   */


  get destroyed() {
    return _classPrivateFieldGet(this, _phase) === ManagerPhase.Destroy;
  }
  /**
   * `true` when the view has been added to the UI layer and the editor is
   * running.
   */


  get mounted() {
    return _classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView && _classPrivateFieldGet(this, _phase) < ManagerPhase.Destroy;
  }
  /**
   * Retrieve the framework output.
   *
   * This be undefined if the manager hasn't been provided to a framework yet
   * the manager.
   *
   * With synchronous frameworks this means that it should only be accessed
   * after the manager has been applied to the editor creation function.
   *
   * For frameworks like React it is only available when the manager is provided
   * to the `Remirror` component and after the very first render. This means it
   * is available within the `onRef` callback.
   *
   * ```tsx
   * import React, { useEffect } from 'react';
   * import { useRemirror, Remirror } from '@remirror/react';
   *
   * const Editor = () => {
   *   const { manager } = useRemirror();
   *
   *   const callback = () => {
   *     return manager.output; // ✅ This is fine.
   *   }
   *
   *   useEffect(() => {
   *     log(manager.output); // ✅  This is also fine.
   *   }, []);
   *
   *   log(manager.output); // ❌ This will be undefined on the first render.
   *
   *   return <Remirror manager={manager} />
   * }
   * ```
   */


  get output() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.frameworkOutput;
  }
  /**
   * Returns true when a framework is attached to the manager.
   *
   * This can be used to check if it is safe to call `manager.output`.
   */


  get frameworkAttached() {
    return !!_classPrivateFieldGet(this, _framework);
  }
  /**
   * The extensions stored by this manager
   */


  get extensions() {
    return _classPrivateFieldGet(this, _extensions);
  }
  /**
   * The registered string handlers provided by the extensions.
   *
   * By default this includes `html` and `plainText`
   */


  get stringHandlers() {
    return _classPrivateFieldGet(this, _stringHandlers);
  }
  /**
   * Get the extension manager store which is accessible at initialization.
   */


  get store() {
    return freeze(_classPrivateFieldGet(this, _store));
  }
  /**
   * Provides access to the extension store.
   */


  get extensionStore() {
    return freeze(_classPrivateFieldGet(this, _extensionStore));
  }
  /**
   * Shorthand access to the active transaction from the manager. This is the
   * shared transaction available to all commands and should be used when you
   * need to make your commands chainable.
   *
   * If working with react and setting up your editor as a controlled component
   * then this is the preferred way to run custom commands, otherwise your
   * commands will end up being non-chainable and be overwritten by anything
   * that comes after.
   */


  get tr() {
    return this.getExtension(CommandsExtension).transaction;
  }
  /**
   * Returns the stored nodes
   */


  get nodes() {
    return _classPrivateFieldGet(this, _store).nodes;
  }
  /**
   * Returns the store marks.
   */


  get marks() {
    return _classPrivateFieldGet(this, _store).marks;
  }
  /**
   * A shorthand method for retrieving the schema for this extension manager
   * from the data.
   */


  get schema() {
    return _classPrivateFieldGet(this, _store).schema;
  }
  /**
   * A shorthand getter for retrieving the tags from the extension manager.
   */


  get extensionTags() {
    return _classPrivateFieldGet(this, _store).tags;
  }
  /**
   * A shorthand way of retrieving the editor view.
   */


  get view() {
    return _classPrivateFieldGet(this, _store).view;
  }
  /**
   * Retrieve the settings used when creating the manager.
   */


  get settings() {
    return _classPrivateFieldGet(this, _settings);
  }
  /**
   * The document to use for rendering and outputting HTML.
   */


  get document() {
    var _classPrivateFieldGet3;

    return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _settings).document) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : getDocument(_classPrivateFieldGet(this, _settings).forceEnvironment);
  }
  /**
   * Creates the extension manager which is used to simplify the management of
   * the prosemirror editor.
   *
   * This is set to private to encourage using `RemirrorManager.create`
   * instead of the `new` keyword.
   */


  constructor(initialExtension) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classPrivateFieldInitSpec(this, _extensionStore, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _stringHandlers, {
      writable: true,
      value: object()
    });

    _classPrivateFieldInitSpec(this, _store, {
      writable: true,
      value: object()
    });

    _classPrivateFieldInitSpec(this, _extensions, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _extensionMap, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _phase, {
      writable: true,
      value: ManagerPhase.None
    });

    _classPrivateFieldInitSpec(this, _settings, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstStateUpdate, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _handlers, {
      writable: true,
      value: {
        create: [],
        view: [],
        update: [],
        destroy: []
      }
    });

    _classPrivateFieldInitSpec(this, _disposers, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _events, {
      writable: true,
      value: createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _framework, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _disposeFramework, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _classPrivateFieldGet4;

      if (_classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView) {
        return this.view.state;
      }

      !_classPrivateFieldGet(this, _framework) ? process.env.NODE_ENV !== "production" ? invariant(false, {
        code: ErrorConstant.MANAGER_PHASE_ERROR,
        message: '`getState` can only be called after the `Framework` or the `EditorView` has been added to the manager`. Check your plugins to make sure that the decorations callback uses the state argument.'
      }) : invariant(false) : void 0;
      return (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.initialEditorState;
    });

    _defineProperty(this, "updateState", state => {
      var previousState = this.getState();
      this.view.updateState(state);
      this.onStateUpdate({
        previousState,
        state
      });
    });

    var _transformExtensions = transformExtensions(initialExtension, settings),
        extensions = _transformExtensions.extensions,
        extensionMap = _transformExtensions.extensionMap;

    _classPrivateFieldSet(this, _settings, settings);

    _classPrivateFieldSet(this, _extensions, freeze(extensions));

    _classPrivateFieldSet(this, _extensionMap, extensionMap);

    _classPrivateFieldSet(this, _extensionStore, this.createExtensionStore());

    _classPrivateFieldSet(this, _phase, ManagerPhase.Create);

    this.setupLifecycleHandlers();

    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).create),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _handler = _step.value;

        var disposer = _handler();

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Loops through all extensions to set up the lifecycle handlers.
   */


  setupLifecycleHandlers() {
    var store = _classPrivateFieldGet(this, _extensionStore);

    var handlers = _classPrivateFieldGet(this, _handlers);

    var nodeNames = [];
    var markNames = [];
    var plainNames = []; // The names are stored as readonly arrays - which is the reason for not
    // just saying `store.nodeNames = []`.

    store.nodeNames = nodeNames;
    store.markNames = markNames;
    store.plainNames = plainNames;

    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _extension = _step2.value;
        extractLifecycleMethods({
          extension: _extension,
          nodeNames,
          markNames,
          plainNames,
          handlers,
          store
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Set the string handler to use for a given name.
   *
   * This allows users to set the string handler
   */


  setStringHandler(name, handler) {
    _classPrivateFieldGet(this, _stringHandlers)[name] = handler;
  }
  /**
   * Set the manager value for the provided key. This is used by extensions to
   * add data to the manager.
   */


  setStoreKey(key, value) {
    _classPrivateFieldGet(this, _store)[key] = value;
  }
  /**
   * Get the manager value for the provided key. This is used by extensions to
   * get data from the manager.
   */


  getStoreKey(key) {
    var value = _classPrivateFieldGet(this, _store)[key];

    !!isNullOrUndefined(value) ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`getStoreKey` should not be called before the values are available.'
    }) : invariant(false) : void 0;
    return value;
  }
  /**
   * A method to set values in the extension store which is made available to
   * extension.
   *
   * **NOTE** This method should only be used in the `onCreate` extension method
   * or it will throw an error.
   */


  setExtensionStore(key, value) {
    !(_classPrivateFieldGet(this, _phase) <= ManagerPhase.EditorView) ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`setExtensionStore` should only be called during the `onCreate` lifecycle hook. Make sure to only call it within the returned methods.'
    }) : invariant(false) : void 0;
    _classPrivateFieldGet(this, _extensionStore)[key] = value;
  }
  /**
   * Create the initial store.
   */


  createExtensionStore() {
    var store = object();
    var enumerable = true; // Allow current state to default to `getState` for first access.
    // This fixed an issue with #814

    var currentState;
    var previousState;
    Object.defineProperties(store, {
      extensions: {
        get: () => _classPrivateFieldGet(this, _extensions),
        enumerable
      },
      phase: {
        get: () => _classPrivateFieldGet(this, _phase),
        enumerable
      },
      view: {
        get: () => this.view,
        enumerable
      },
      managerSettings: {
        get: () => freeze(_classPrivateFieldGet(this, _settings)),
        enumerable
      },
      getState: {
        value: this.getState,
        enumerable
      },
      updateState: {
        value: this.updateState,
        enumerable
      },
      isMounted: {
        value: () => this.mounted,
        enumerable
      },
      getExtension: {
        value: this.getExtension.bind(this),
        enumerable
      },
      manager: {
        get: () => this,
        enumerable
      },
      document: {
        get: () => this.document,
        enumerable
      },
      stringHandlers: {
        get: () => _classPrivateFieldGet(this, _stringHandlers),
        enumerable
      },
      currentState: {
        get: () => {
          var _currentState;

          return (_currentState = currentState) !== null && _currentState !== void 0 ? _currentState : currentState = this.getState();
        },
        set: state => {
          currentState = state;
        },
        enumerable
      },
      previousState: {
        get: () => previousState,
        set: state => {
          previousState = state;
        },
        enumerable
      }
    });
    store.getStoreKey = this.getStoreKey.bind(this);
    store.setStoreKey = this.setStoreKey.bind(this);
    store.setExtensionStore = this.setExtensionStore.bind(this);
    store.setStringHandler = this.setStringHandler.bind(this);
    return store;
  }
  /**
   * A state getter method which is passed into the params.
   */


  /**
   * Stores the editor view on the manager
   *
   * @param view - the editor view
   */
  addView(view) {
    if (_classPrivateFieldGet(this, _phase) >= ManagerPhase.EditorView) {
      // Do nothing since a view has already been added.
      return this;
    }

    _classPrivateFieldSet(this, _firstStateUpdate, true); // Update the lifecycle phase.


    _classPrivateFieldSet(this, _phase, ManagerPhase.EditorView); // Store the view.


    _classPrivateFieldGet(this, _store).view = view;

    var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).view),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _handler2 = _step3.value;

        var disposer = _handler2(view);

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return this;
  }
  /**
   * Attach a framework to the manager.
   */


  attachFramework(framework, updateHandler) {
    if (_classPrivateFieldGet(this, _framework) === framework) {
      // Do nothing if the instances are identical.
      return;
    }

    if (_classPrivateFieldGet(this, _framework)) {
      var _classPrivateFieldGet5;

      // Destroy the old instance.
      _classPrivateFieldGet(this, _framework).destroy(); // Remove the event listener. This should exist.


      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.call(this);
    } // Replace with the new instance.


    _classPrivateFieldSet(this, _framework, framework);

    _classPrivateFieldSet(this, _disposeFramework, this.addHandler('stateUpdate', updateHandler));
  }
  /* Public Methods */

  /**
   * Create an empty document for the editor based on the current schema.
   *
   * This automatically looks at the supported content for the doc and the
   * available nodes which fulfil that content in order to create a document
   * with only the minimal required content.
   *
   * This can be used in conjunction with the create state to reset the current
   * value of the editor.
   */


  createEmptyDoc() {
    var _this$schema$nodes$do;

    var doc = (_this$schema$nodes$do = this.schema.nodes.doc) === null || _this$schema$nodes$do === void 0 ? void 0 : _this$schema$nodes$do.createAndFill(); // Make sure the `doc` was created.

    !doc ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.INVALID_CONTENT,
      message: "An empty node could not be created due to an invalid schema."
    }) : invariant(false) : void 0;
    return doc;
  }
  /**
   * Create the editor state from content passed to this extension manager.
   */


  createState() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _this$settings = this.settings,
        onError = _this$settings.onError,
        _this$settings$defaul = _this$settings.defaultSelection,
        defaultSelection = _this$settings$defaul === void 0 ? 'end' : _this$settings$defaul;
    var _props$content = props.content,
        content = _props$content === void 0 ? this.createEmptyDoc() : _props$content,
        _props$selection = props.selection,
        selection = _props$selection === void 0 ? defaultSelection : _props$selection,
        _props$stringHandler = props.stringHandler,
        stringHandler = _props$stringHandler === void 0 ? this.settings.stringHandler : _props$stringHandler;
    var _this$store = this.store,
        schema = _this$store.schema,
        plugins = _this$store.plugins;
    var doc = createDocumentNode({
      stringHandler: isString(stringHandler) ? this.stringHandlers[stringHandler] : stringHandler,
      document: this.document,
      content,
      onError,
      schema,
      selection
    });
    return EditorState.create({
      schema,
      doc,
      plugins,
      selection: getTextSelection(selection, doc)
    });
  }
  /**
   * Add a handler to the manager.
   *
   * Currently the only event that can be listened to is the `destroy` event.
   */


  addHandler(event, cb) {
    return _classPrivateFieldGet(this, _events).on(event, cb);
  }
  /**
   * Update the state of the view and trigger the `onStateUpdate` lifecycle
   * method as well.
   */


  /**
   * This method should be called by the view layer every time the state is
   * updated.
   *
   * An example usage of this is within the collaboration extension.
   */
  onStateUpdate(props) {
    var firstUpdate = _classPrivateFieldGet(this, _firstStateUpdate);

    _classPrivateFieldGet(this, _extensionStore).currentState = props.state;
    _classPrivateFieldGet(this, _extensionStore).previousState = props.previousState;

    if (firstUpdate) {
      _classPrivateFieldSet(this, _phase, ManagerPhase.Runtime);

      _classPrivateFieldSet(this, _firstStateUpdate, false);
    }

    var propsWithUpdate = _objectSpread(_objectSpread({}, props), {}, {
      firstUpdate
    });

    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).update),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _handler3 = _step4.value;

        _handler3(propsWithUpdate);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    _classPrivateFieldGet(this, _events).emit('stateUpdate', propsWithUpdate);
  }
  /**
   * Get the extension instance matching the provided constructor from the
   * manager.
   *
   * This will throw an error if non existent.
   */


  getExtension(Constructor) {
    var extension = _classPrivateFieldGet(this, _extensionMap).get(Constructor); // Throws an error if attempting to get an extension which is not present in
    // the manager.


    !extension ? process.env.NODE_ENV !== "production" ? invariant(false, {
      code: ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "'".concat(Constructor.name, "' doesn't exist within this manager. Make sure it is properly added before attempting to use it.")
    }) : invariant(false) : void 0;
    return extension;
  }
  /**
   * Make a clone of the manager.
   *
   * @internalremarks What about the state stored in the extensions and presets,
   * does this need to be recreated as well?
   */


  clone() {
    var extensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.options));

    var manager = RemirrorManager.create(() => extensions, _classPrivateFieldGet(this, _settings));

    _classPrivateFieldGet(this, _events).emit('clone', manager);

    return manager;
  }
  /**
   * Recreate the manager with new settings and extensions
   */


  recreate() {
    var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var currentExtensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.initialOptions));

    var manager = RemirrorManager.create(() => [...currentExtensions, ...extensions], settings);

    _classPrivateFieldGet(this, _events).emit('recreate', manager);

    return manager;
  }
  /**
   * This method should be called to destroy the manager and remove the view.
   */


  destroy() {
    var _classPrivateFieldGet6, _classPrivateFieldGet7, _this$view, _this$view$state$plug, _this$view2;

    _classPrivateFieldSet(this, _phase, ManagerPhase.Destroy);

    var _iterator5 = _createForOfIteratorHelper((_this$view$state$plug = (_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.state.plugins) !== null && _this$view$state$plug !== void 0 ? _this$view$state$plug : []),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _plugin$getState, _plugin$getState$dest;

        var plugin = _step5.value;
        (_plugin$getState = plugin.getState(this.view.state)) === null || _plugin$getState === void 0 ? void 0 : (_plugin$getState$dest = _plugin$getState.destroy) === null || _plugin$getState$dest === void 0 ? void 0 : _plugin$getState$dest.call(_plugin$getState);
      } // Make sure to destroy the framework and it's state update listener if it
      // exists.

    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.destroy();
    (_classPrivateFieldGet7 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.call(this); // Run all cleanup methods returned by the `onView` and `onCreate` methods.

    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _disposers)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var dispose = _step6.value;
        dispose();
      } // TODO: prevent `dispatchTransaction` from being called again

    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).destroy),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var onDestroy = _step7.value;
        onDestroy();
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.destroy();

    _classPrivateFieldGet(this, _events).emit('destroy');
  }
  /**
   * Check whether the manager includes the names or constructors provided for
   * the preset and extensions.
   *
   * Returns true if all are included, returns false otherwise.
   */


  includes(mustIncludeList) {
    // Searches can be made by either the name of the extension / preset or the
    // names of the constructor. We gather the values to check in separate
    // arrays
    var names = [];
    var extensionsAndPresets = [];

    var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var item = _step8.value;
        names.push(item.name, item.constructorName);
        extensionsAndPresets.push(item.constructor);
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    return mustIncludeList.every(item => isString(item) ? includes(names, item) : includes(extensionsAndPresets, item));
  }

}
/**
 * A function that returns the extension to be used in the RemirrorManager. This
 * is similar to a preset function except that it takes no arguments.
 *
 * ```ts
 * import { RemirrorManager } from 'remirror';
 * import { BoldExtension, ItalicExtension } from 'remirror/extensions';
 *
 * const template = () => [new BoldExtension(), new ItalicExtension()]
 * const manager = RemirrorManager.create(template);
 * ```
 *
 * If the template is mixed in with other manager creators it will add the
 * relevant extension provided.
 */

/**
 * Checks to see whether the provided value is a `RemirrorManager` instance.
 *
 * An optional parameter `mustIncludeList` is available if you want to check
 * that the manager includes all the listed extensions.
 *
 * @param value - the value to check
 * @param mustIncludeList - an array of presets and extension the manager must
 * include to pass the test. The identifier can either be the Extension / Preset
 * name e.g. `bold`, or the Extension / Preset constructor `BoldExtension`
 */
function isRemirrorManager(value, mustIncludeList) {
  if (!isRemirrorType(value) || !isIdentifierOfType(value, RemirrorIdentifier.Manager)) {
    return false;
  } // We can return true since there are no other checks to make.


  if (!mustIncludeList) {
    return true;
  }

  return value.includes(mustIncludeList);
}

export { AttributesExtension, CommandsExtension, DEFAULT_SHORTCUTS, DecorationsExtension, DelayedCommand, DocChangedExtension, Framework, GOOGLE_DOC_SHORTCUTS, HelpersExtension, InputRulesExtension, KeymapExtension, MarkExtension, MetaExtension, NodeExtension, NodeViewsExtension, PasteRulesExtension, PlainExtension, PluginsExtension, RemirrorManager, SchemaExtension, SuggestExtension, TagsExtension, UploadExtension, builtinPreset, command, delayedCommand, extension, extensionDecorator, findUploadPlaceholderPayload, findUploadPlaceholderPos, hasUploadingFile, helper, insertText, isDelayedValue, isExtension, isExtensionConstructor, isExtensionTag, isMarkExtension, isNodeExtension, isPlainExtension, isRemirrorManager, keyBinding, keyboardShortcuts, mutateDefaultExtensionOptions, setUploadPlaceholderAction, toggleMark, uploadFile };
