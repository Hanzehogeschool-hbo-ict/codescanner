'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var prosemirrorModel = require('prosemirror-model');
var prosemirrorState = require('prosemirror-state');
var coreConstants = require('@remirror/core-constants');
var coreHelpers = require('@remirror/core-helpers');

/**
 * Create the paste plugin handler.
 */

function pasteRules(pasteRules) {
  var sortedPasteRules = coreHelpers.sort(pasteRules, (a, z) => {
    var _z$priority, _a$priority;

    return ((_z$priority = z.priority) !== null && _z$priority !== void 0 ? _z$priority : coreConstants.ExtensionPriority.Low) - ((_a$priority = a.priority) !== null && _a$priority !== void 0 ? _a$priority : coreConstants.ExtensionPriority.Low);
  }); // Container for the regex based paste rules.

  var regexPasteRules = []; // Container for the file based paste rules.

  var filePasteRules = [];

  var _iterator = _createForOfIteratorHelper(sortedPasteRules),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var rule = _step.value;

      if (isRegexPastRule(rule)) {
        regexPasteRules.push(rule);
      } else {
        filePasteRules.push(rule);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _view;

  return new prosemirrorState.Plugin({
    key: pastePluginKey,
    view: editorView => {
      _view = editorView;
      return {};
    },
    props: {
      // The regex based paste rules are passed into this function to take care of.
      transformPasted: slice => {
        var $pos = _view.state.selection.$from;
        var nodeName = $pos.node().type.name;
        var markNames = new Set($pos.marks().map(mark => mark.type.name)); // Iterate over each rule by order of priority and update the slice each time.

        var _iterator2 = _createForOfIteratorHelper(regexPasteRules),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _rule$ignoredNodes, _rule$ignoredMarks, _slice$content$firstC, _slice$content$firstC2;

            var rule = _step2.value;

            if ( // The parent node is ignored.
            (_rule$ignoredNodes = rule.ignoredNodes) !== null && _rule$ignoredNodes !== void 0 && _rule$ignoredNodes.includes(nodeName) || // The current position contains ignored marks.
            (_rule$ignoredMarks = rule.ignoredMarks) !== null && _rule$ignoredMarks !== void 0 && _rule$ignoredMarks.some(ignored => markNames.has(ignored))) {
              continue;
            }

            var textContent = (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
            var canBeReplaced = !_view.state.selection.empty && slice.content.childCount === 1 && textContent;
            var _match = coreHelpers.findMatches(textContent, rule.regexp)[0];

            if (canBeReplaced && _match && rule.type === 'mark' && rule.replaceSelection) {
              var _view$state$selection = _view.state.selection,
                  from = _view$state$selection.from,
                  to = _view$state$selection.to;

              var textSlice = _view.state.doc.slice(from, to);

              var _textContent = textSlice.content.textBetween(0, textSlice.content.size);

              if (typeof rule.replaceSelection !== 'boolean' ? rule.replaceSelection(_textContent) : rule.replaceSelection) {
                var _ret = function () {
                  var newTextNodes = [];
                  var getAttributes = rule.getAttributes,
                      markType = rule.markType;
                  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(_match, true) : getAttributes;
                  var mark = markType.create(attributes);
                  textSlice.content.forEach(textNode => {
                    if (textNode.isText) {
                      var marks = mark.addToSet(textNode.marks);
                      newTextNodes.push(textNode.mark(marks));
                    }
                  });
                  return {
                    v: prosemirrorModel.Slice.maxOpen(prosemirrorModel.Fragment.fromArray(newTextNodes))
                  };
                }();

                if (typeof _ret === "object") return _ret.v;
              }
            }

            var _regexPasteRuleHandle = regexPasteRuleHandler(slice.content, rule, _view.state.schema),
                transformedNodes = _regexPasteRuleHandle.nodes,
                transformed = _regexPasteRuleHandle.transformed;

            if (transformed) {
              // If we have created a block node, we don't want to keep the slice's open depth for both side.
              slice = rule.type === 'node' && rule.nodeType.isBlock ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), 0, 0) : new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), slice.openStart, slice.openEnd);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return slice;
      },
      handleDOMEvents: {
        // Handle paste for pasting content.
        paste: (view, event) => {
          var _view$props$editable, _view$props;

          if (!((_view$props$editable = (_view$props = view.props).editable) !== null && _view$props$editable !== void 0 && _view$props$editable.call(_view$props, view.state))) {
            return false;
          }

          var clipboardData = event.clipboardData;

          if (!clipboardData) {
            return false;
          }

          var allFiles = [...clipboardData.items].map(data => data.getAsFile()).filter(file => !!file);

          if (allFiles.length === 0) {
            return false;
          }

          var selection = view.state.selection;

          var _iterator3 = _createForOfIteratorHelper(filePasteRules),
              _step3;

          try {
            var _loop = function _loop() {
              var _step3$value = _step3.value,
                  fileHandler = _step3$value.fileHandler,
                  regexp = _step3$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                selection,
                view,
                type: 'paste'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _ret2 = _loop();

              if (_ret2 === "continue") continue;
              if (typeof _ret2 === "object") return _ret2.v;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return false;
        },
        // Handle drop for pasting content.
        drop: (view, event) => {
          var _view$props$editable2, _view$props2, _view$posAtCoords$pos, _view$posAtCoords;

          if (!((_view$props$editable2 = (_view$props2 = view.props).editable) !== null && _view$props$editable2 !== void 0 && _view$props$editable2.call(_view$props2, view.state))) {
            return false;
          }

          var dataTransfer = event.dataTransfer,
              clientX = event.clientX,
              clientY = event.clientY;

          if (!dataTransfer) {
            return false;
          }

          var allFiles = getDataTransferFiles(event);

          if (allFiles.length === 0) {
            return false;
          }

          var pos = (_view$posAtCoords$pos = (_view$posAtCoords = view.posAtCoords({
            left: clientX,
            top: clientY
          })) === null || _view$posAtCoords === void 0 ? void 0 : _view$posAtCoords.pos) !== null && _view$posAtCoords$pos !== void 0 ? _view$posAtCoords$pos : view.state.selection.anchor;

          var _iterator4 = _createForOfIteratorHelper(filePasteRules),
              _step4;

          try {
            var _loop2 = function _loop2() {
              var _step4$value = _step4.value,
                  fileHandler = _step4$value.fileHandler,
                  regexp = _step4$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                pos,
                view,
                type: 'drop'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _ret3 = _loop2();

              if (_ret3 === "continue") continue;
              if (typeof _ret3 === "object") return _ret3.v;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return false;
        }
      }
    }
  });
}
var pastePluginKey = new prosemirrorState.PluginKey('pasteRule');
/**
 * @template RegexPasteRule
 */

/**
 * Factory for creating paste rules.
 */
function createPasteRuleHandler(transformer, schema) {
  return function handler(props) {
    var fragment = props.fragment,
        rule = props.rule,
        nodes = props.nodes;
    var regexp = rule.regexp,
        ignoreWhitespace = rule.ignoreWhitespace,
        ignoredMarks = rule.ignoredMarks,
        ignoredNodes = rule.ignoredNodes;
    var transformed = false;
    fragment.forEach(child => {
      var _child$text;

      // Check if this node should be ignored.
      if (ignoredNodes !== null && ignoredNodes !== void 0 && ignoredNodes.includes(child.type.name) || isCodeNode(child)) {
        nodes.push(child);
        return;
      } // When the current node is not a text node, recursively dive into it's child nodes.


      if (!child.isText) {
        var childResult = handler({
          fragment: child.content,
          rule,
          nodes: []
        });
        transformed || (transformed = childResult.transformed);
        var content = prosemirrorModel.Fragment.fromArray(childResult.nodes);

        if (child.type.validContent(content)) {
          nodes.push(child.copy(content));
        } else {
          nodes.push(...childResult.nodes);
        }

        return;
      } // When this is a text node ignore this child if it is wrapped by an ignored
      // mark or a code mark.


      if (child.marks.some(mark => isCodeMark(mark) || (ignoredMarks === null || ignoredMarks === void 0 ? void 0 : ignoredMarks.includes(mark.type.name)))) {
        nodes.push(child);
        return;
      }

      var text = (_child$text = child.text) !== null && _child$text !== void 0 ? _child$text : '';
      var pos = 0; // Find all matches and add the defined mark.

      var _iterator5 = _createForOfIteratorHelper(coreHelpers.findMatches(text, regexp)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _match2 = _step5.value;
          // The captured value from the regex.
          var capturedValue = _match2[1];
          var fullValue = _match2[0];

          if ( // This helps prevent matches which are only whitespace from triggering
          // an update.
          ignoreWhitespace && (capturedValue === null || capturedValue === void 0 ? void 0 : capturedValue.trim()) === '' || !fullValue) {
            return;
          }

          var start = _match2.index;
          var end = start + fullValue.length;

          if (start > 0) {
            nodes.push(child.cut(pos, start));
          }

          var textNode = child.cut(start, end); // When a capture value is provided use it.

          if (fullValue && capturedValue) {
            var startSpaces = fullValue.search(/\S/);
            var textStart = start + fullValue.indexOf(capturedValue);
            var textEnd = textStart + capturedValue.length;

            if (startSpaces) {
              nodes.push(child.cut(start, start + startSpaces));
            }

            textNode = child.cut(textStart, textEnd);
          } // A transformer to push the required nodes.


          transformer({
            nodes,
            rule,
            textNode,
            match: _match2,
            schema
          });
          transformed = true;
          pos = end;
        } // Add the rest of the node to the gathered nodes if any characters are
        // remaining.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      if (text && pos < text.length) {
        nodes.push(child.cut(pos));
      }
    });
    return {
      nodes,
      transformed
    };
  };
}
/**
 * Mark rule transformer which pushes the transformed mark into the provided
 * nodes.
 */


function markRuleTransformer(props) {
  var _textNode$text;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch,
      getAttributes = rule.getAttributes,
      markType = rule.markType;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var text = (_textNode$text = textNode.text) !== null && _textNode$text !== void 0 ? _textNode$text : '';
  var mark = markType.create(attributes);
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty text

  if (transformedCapturedValue === '') {
    return;
  } // remove the mark if transformMatch returns false


  if (transformedCapturedValue === false) {
    nodes.push(schema.text(text, textNode.marks));
    return;
  }

  var marks = mark.addToSet(textNode.marks);
  nodes.push(schema.text(transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : text, marks));
}
/**
 * Support for pasting and transforming text content into the editor.
 */


function textRuleTransformer(props) {
  var _ref;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch;
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty string or false

  if (transformedCapturedValue === '' || transformedCapturedValue === false) {
    return;
  }

  var text = (_ref = transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : textNode.text) !== null && _ref !== void 0 ? _ref : '';
  nodes.push(schema.text(text, textNode.marks));
}
/**
 * Support for pasting node content into the editor.
 */


function nodeRuleTransformer(props) {
  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match;
  var getAttributes = rule.getAttributes,
      nodeType = rule.nodeType,
      getContent = rule.getContent;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var content = (getContent ? getContent(match) : textNode) || undefined;
  nodes.push(nodeType.createChecked(attributes, content));
}
/**
 * The run the handlers for the regex paste rules on the content which has been transformed by prosemirror.
 */


function regexPasteRuleHandler(fragment, rule, schema) {
  var nodes = [];

  switch (rule.type) {
    case 'mark':
      return createPasteRuleHandler(markRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    case 'node':
      return createPasteRuleHandler(nodeRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    default:
      return createPasteRuleHandler(textRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
  }
}

var regexPasteRules = ['mark', 'node', 'text'];

/**
 * Check if the paste rule is regex based.
 */
function isRegexPastRule(rule) {
  return coreHelpers.includes(regexPasteRules, rule.type);
}

/**
 * Check whether the current selection is completely contained within a code block or mark.
 */
function isInCode(selection) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$contained = _ref2.contained,
      contained = _ref2$contained === void 0 ? true : _ref2$contained;

  if (selection.empty) {
    return resolvedPosInCode(selection.$head);
  }

  if (contained) {
    return resolvedPosInCode(selection.$head) && resolvedPosInCode(selection.$anchor);
  }

  return resolvedPosInCode(selection.$head) || resolvedPosInCode(selection.$anchor);
}
/**
 * Check if the provided position is within a code mark or node.
 */

function resolvedPosInCode($pos) {
  // Start at the current depth and work down until a depth of 1.
  var _iterator6 = _createForOfIteratorHelper(coreHelpers.range($pos.depth, 1)),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var depth = _step6.value;

      if (isCodeNode($pos.node(depth))) {
        return true;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var _iterator7 = _createForOfIteratorHelper($pos.marks()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var mark = _step7.value;

      if (isCodeMark(mark)) {
        return true;
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return false;
}
/**
 * Check if the current node is a code node.
 */


function isCodeNode(node) {
  var _node$type$spec$group;

  return node.type.spec.code || ((_node$type$spec$group = node.type.spec.group) === null || _node$type$spec$group === void 0 ? void 0 : _node$type$spec$group.split(' ').includes('code'));
}
/**
 * Check if the current mark is a code mark.
 */


function isCodeMark(mark) {
  var _mark$type$spec$group;

  return mark.type.name === 'code' || ((_mark$type$spec$group = mark.type.spec.group) === null || _mark$type$spec$group === void 0 ? void 0 : _mark$type$spec$group.split(' ').includes('code'));
}

function getDataTransferFiles(event) {
  var _dataTransfer$files, _dataTransfer$items;

  var dataTransfer = event.dataTransfer;

  if (!dataTransfer) {
    return [];
  }

  if (((_dataTransfer$files = dataTransfer.files) === null || _dataTransfer$files === void 0 ? void 0 : _dataTransfer$files.length) > 0) {
    return [...dataTransfer.files];
  }

  if ((_dataTransfer$items = dataTransfer.items) !== null && _dataTransfer$items !== void 0 && _dataTransfer$items.length) {
    // During the drag even the dataTransfer.files is null
    // but Chrome implements some drag store, which is accesible via dataTransfer.items
    return [...dataTransfer.items].map(item => item.getAsFile()).filter(item => !!item);
  }

  return [];
}

exports.isInCode = isInCode;
exports.pasteRules = pasteRules;
