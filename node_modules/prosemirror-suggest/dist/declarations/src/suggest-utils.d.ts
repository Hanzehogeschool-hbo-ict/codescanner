import { PickPartial } from '@remirror/types';
import type { CompareMatchProps, DocChangedProps, EditorSchema, EditorStateProps, ResolvedPos, ResolvedPosProps, ResolvedRangeWithCursor, Suggester, SuggestMatch, SuggestReasonMap } from './suggest-types';
interface FindFromSuggestersProps<Schema extends EditorSchema = EditorSchema> extends ResolvedPosProps<Schema>, DocChangedProps {
    /**
     * The matchers to search through.
     */
    suggesters: Array<Required<Suggester<Schema>>>;
    /**
     * When `true` the selection is empty.
     */
    selectionEmpty: boolean;
}
declare type FindReasonProps<Schema extends EditorSchema = EditorSchema> = EditorStateProps<Schema> & ResolvedPosProps<Schema> & Partial<CompareMatchProps<Schema>> & object;
/**
 * Creates an array of the actions taken based on the current prev and next
 * state field
 */
export declare function findReason<Schema extends EditorSchema = EditorSchema>(props: FindReasonProps<Schema>): SuggestReasonMap<Schema>;
/**
 * Check whether the mark is active anywhere between `$from` and `$end`.
 *
 * Currently this is not doing exactly what it should. I've decided to be lazy
 * and only check the following.
 *
 * - Do any of the requested marks span the entire range using `rangeHasMarks`?
 * - Does the starting position have a mark?
 * - Does the cursor have a mark?
 * - Does the end position have a mark?
 *
 * In reality I should also check for each position within the range to see if a
 * target mark is active but I won't for now.
 */
export declare function markActiveInRange<Schema extends EditorSchema = EditorSchema>(resolvedRange: Omit<ResolvedRangeWithCursor<Schema>, '$cursor'>, marks: string[]): boolean;
/**
 * Check if the entire matching range `from` the start point all the way through
 * `to` the end point, has any of the provided marks that span it.
 */
export declare function rangeHasMarks<Schema extends EditorSchema = EditorSchema>(resolvedRange: Omit<ResolvedRangeWithCursor<Schema>, '$cursor'>, marks: string[]): boolean;
/**
 * Check if the provided position has the given marks.
 */
export declare function positionHasMarks<Schema extends EditorSchema = EditorSchema>($pos: ResolvedPos<Schema>, marks: string[]): boolean;
/**
 * Find a match for the provided matchers.
 */
export declare function findFromSuggesters<Schema extends EditorSchema = EditorSchema>(props: FindFromSuggestersProps<Schema>): SuggestMatch<Schema> | undefined;
/**
 * Get the `char` from the `suggester` as regex.
 */
export declare function getCharAsRegex(char: RegExp | string): RegExp;
interface CreateRegExpFromSuggesterProps extends Pick<Required<Suggester>, 'startOfLine' | 'char' | 'supportedCharacters' | 'matchOffset'>, Pick<Suggester, 'multiline' | 'caseInsensitive' | 'captureChar' | 'unicode'> {
}
/**
 * Create a regex expression which evaluate matches directly from the suggester
 * properties.
 */
export declare function createRegexFromSuggester(props: CreateRegExpFromSuggesterProps): RegExp;
/**
 * The default value for the suggester.
 */
export declare const DEFAULT_SUGGESTER: PickPartial<Suggester<any>>;
/**
 * This can be added to the meta data of an update to let the suggestion plugin
 * know that it should ignore the update.
 */
export declare const IGNORE_SUGGEST_META_KEY = "__ignore_prosemirror_suggest_update__";
/**
 * Takes the passed through `suggester` and adds all the missing default values.
 */
export declare function getSuggesterWithDefaults<Schema extends EditorSchema = EditorSchema>(suggester: Suggester<Schema>): Required<Suggester<Schema>>;
export {};
