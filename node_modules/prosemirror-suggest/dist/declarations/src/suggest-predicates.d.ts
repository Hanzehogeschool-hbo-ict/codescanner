import { TextSelection } from 'prosemirror-state';
import type { CompareMatchProps, EditorSchema, SelectionProps, SuggestMatch, SuggestReasonMap, SuggestStateMatchProps } from './suggest-types';
import { ChangeReason, ExitReason } from './suggest-types';
/**
 * Is this a change in the current suggestion (added or deleted characters)?
 */
export declare function isChange<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>): compare is CompareMatchProps<Schema>;
/**
 * Is this is a repetition of the same check?
 */
export declare function isIdentical<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>, match: SuggestReasonMap<Schema>): compare is CompareMatchProps<Schema>;
/**
 * Has the cursor moved within the current suggestion (added or deleted
 * characters)?
 */
export declare function isMove<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>): compare is CompareMatchProps<Schema>;
/**
 * Are we entering a new suggestion?
 */
export declare function isEntry<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>): compare is Pick<CompareMatchProps<Schema>, 'next'>;
/**
 * Are we exiting a suggestion?
 */
export declare function isExit<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>): compare is Pick<CompareMatchProps<Schema>, 'prev'>;
/**
 * Is this a jump from one suggestion to another?
 */
export declare function isJump<Schema extends EditorSchema = EditorSchema>(compare: Partial<CompareMatchProps<Schema>>): compare is CompareMatchProps<Schema>;
/**
 * Check that the passed in value is an [[`ExitReason`]].
 */
export declare function isExitReason(value: unknown): value is ExitReason;
/**
 * Check that that the passed in value is a [[`ChangeReason`]].
 */
export declare function isChangeReason(value: unknown): value is ChangeReason;
declare const selectionExitReasons: readonly [ExitReason.MoveEnd, ExitReason.MoveStart, ExitReason.SelectionOutside, ExitReason.JumpForward, ExitReason.JumpBackward];
/**
 * An exit which is caused by a change in the selection and no other change in
 * the document.
 */
export declare function isSelectionExitReason(value: unknown): value is typeof selectionExitReasons[number];
declare const selectionChangeReasons: readonly [ChangeReason.JumpBackward, ChangeReason.JumpForward, ChangeReason.Move, ChangeReason.SelectionInside];
export declare function isSelectionChangeReason(value: unknown): value is typeof selectionChangeReasons[number];
/**
 * Checks that the reason passed is a split reason. This typically means that we
 * should default to a partial update / creation of the mention.
 */
export declare function isSplitReason(value?: unknown): value is ExitReason.Split;
/**
 * Checks that the reason was caused by a split at a point where there is no
 * query.
 */
export declare function isInvalidSplitReason(value?: unknown): value is ExitReason.InvalidSplit;
/**
 * Checks that the reason was caused by a deletion.
 */
export declare function isRemovedReason(value?: unknown): value is ExitReason.Removed;
/**
 * Checks to see if this is a jump reason.
 */
export declare function isJumpReason<Schema extends EditorSchema = EditorSchema>(map: SuggestReasonMap<Schema>): map is Required<SuggestReasonMap<Schema>>;
/**
 * True when the match is currently active (i.e. it's query has a value)
 */
export declare function isValidMatch<Schema extends EditorSchema = EditorSchema>(match: SuggestMatch<Schema> | undefined): match is SuggestMatch<Schema>;
/**
 * True when the current selection is outside the match.
 */
export declare function selectionOutsideMatch<Schema extends EditorSchema = EditorSchema>(props: Partial<SuggestStateMatchProps<Schema>> & SelectionProps<Schema>): boolean;
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */
export declare function isTextSelection<Schema extends EditorSchema = EditorSchema>(value: unknown): value is TextSelection<Schema>;
export {};
