'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var prosemirrorState = require('prosemirror-state');
var _createForOfIteratorHelper = require('@babel/runtime/helpers/createForOfIteratorHelper');
var _objectSpread = require('@babel/runtime/helpers/objectSpread2');
var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _classPrivateFieldSet = require('@babel/runtime/helpers/classPrivateFieldSet');
var _classPrivateFieldGet = require('@babel/runtime/helpers/classPrivateFieldGet');
var prosemirrorView = require('prosemirror-view');
var coreHelpers = require('@remirror/core-helpers');
var escapeStringRegex = require('escape-string-regexp');
var coreConstants = require('@remirror/core-constants');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var escapeStringRegex__default = /*#__PURE__*/_interopDefault(escapeStringRegex);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

/**
 * This [[`Suggester`]] interface defines all the options required to create a
 * suggestion within your editor.
 *
 * @remarks
 *
 * The options are passed to the [[`suggest`]] method which uses them.
 */

/**
 * A function for checking whether the next selection is valid.
 *
 * It is called for all registered suggesters before any of the onChange
 * handlers are fired.
 *
 * @param $pos - the next valid position that supports text selections.
 * @param tr - the transaction that can be mutated when `appendTransaction` is
 * set to true.
 * @param matches - the possibly undefined exit and change matcher names. These
 * can be used to check if the name matches the current suggester.
 */

/**
 * A function that can be used to determine whether the decoration should be set
 * or not.
 *
 * @param match - the current active match
 * @param resolvedRange - the range of the match with each position resolved.
 */

/**
 * The potential reasons for an exit of a mention.
 */
exports.ExitReason = void 0;
/**
 * The potential reason for changes
 */

(function (ExitReason) {
  ExitReason["End"] = "exit-end";
  ExitReason["Removed"] = "delete";
  ExitReason["Split"] = "exit-split";
  ExitReason["InvalidSplit"] = "invalid-exit-split";
  ExitReason["MoveEnd"] = "move-end";
  ExitReason["MoveStart"] = "move-start";
  ExitReason["JumpForward"] = "jump-forward-exit";
  ExitReason["JumpBackward"] = "jump-backward-exit";
  ExitReason["SelectionOutside"] = "selection-outside";
})(exports.ExitReason || (exports.ExitReason = {}));

exports.ChangeReason = void 0;
/**
 * The parameters needed for the [[`SuggestIgnoreProps.addIgnored`]] action
 * method available to the suggest plugin handlers.
 *
 * @remarks
 *
 * See:
 * - [[`RemoveIgnoredProps`]]
 */

(function (ChangeReason) {
  ChangeReason["Start"] = "start";
  ChangeReason["Text"] = "change-character";
  ChangeReason["SelectionInside"] = "selection-inside";
  ChangeReason["Move"] = "move";
  ChangeReason["JumpBackward"] = "jump-backward-change";
  ChangeReason["JumpForward"] = "jump-forward-change";
})(exports.ChangeReason || (exports.ChangeReason = {}));

/**
 * Is this a change in the current suggestion (added or deleted characters)?
 */

function isChange(compare) {
  return !!(compare.prev && compare.next && compare.prev.text.full !== compare.next.text.full);
}
/**
 * Has the cursor moved within the current suggestion (added or deleted
 * characters)?
 */

function isMove(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.cursor !== compare.next.range.cursor);
}
/**
 * Are we entering a new suggestion?
 */

function isEntry(compare) {
  return !!(!compare.prev && compare.next);
}
/**
 * Are we exiting a suggestion?
 */

function isExit(compare) {
  return !!(compare.prev && !compare.next);
}
/**
 * Is this a jump from one suggestion to another?
 */

function isJump(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.from !== compare.next.range.from);
}
/**
 * Check that the passed in value is an [[`ExitReason`]].
 */

function isExitReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ExitReason).includes(value);
}
/**
 * Check that that the passed in value is a [[`ChangeReason`]].
 */

function isChangeReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ChangeReason).includes(value);
}
var selectionExitReasons = [exports.ExitReason.MoveEnd, exports.ExitReason.MoveStart, exports.ExitReason.SelectionOutside, exports.ExitReason.JumpForward, exports.ExitReason.JumpBackward];
/**
 * An exit which is caused by a change in the selection and no other change in
 * the document.
 */

function isSelectionExitReason(value) {
  return coreHelpers.includes(selectionExitReasons, value);
}
var selectionChangeReasons = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward, exports.ChangeReason.Move, exports.ChangeReason.SelectionInside];
function isSelectionChangeReason(value) {
  return coreHelpers.includes(selectionChangeReasons, value);
}
/**
 * Checks that the reason passed is a split reason. This typically means that we
 * should default to a partial update / creation of the mention.
 */

function isSplitReason(value) {
  return value === exports.ExitReason.Split;
}
/**
 * Checks that the reason was caused by a split at a point where there is no
 * query.
 */

function isInvalidSplitReason(value) {
  return value === exports.ExitReason.InvalidSplit;
}
/**
 * Checks that the reason was caused by a deletion.
 */

function isRemovedReason(value) {
  return value === exports.ExitReason.Removed;
} // Constants for the jump reasons

var exitJump = [exports.ExitReason.JumpBackward, exports.ExitReason.JumpForward];
var changeJump = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward];
/**
 * Checks to see if this is a jump reason.
 */

function isJumpReason(map) {
  var _map$exit, _map$change;

  return coreHelpers.includes(exitJump, (_map$exit = map.exit) === null || _map$exit === void 0 ? void 0 : _map$exit.exitReason) || coreHelpers.includes(changeJump, (_map$change = map.change) === null || _map$change === void 0 ? void 0 : _map$change.changeReason);
}
/**
 * True when the match is currently active (i.e. it's query has a value)
 */

function isValidMatch(match) {
  return !!(match && match.query.full.length >= match.suggester.matchOffset);
}
/**
 * True when the current selection is outside the match.
 */

function selectionOutsideMatch(props) {
  var match = props.match,
      selection = props.selection;
  return !!match && (selection.from < match.range.from || selection.from > match.range.to);
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof prosemirrorState.TextSelection;
}

/**
 * Small utility method for creating a match with the reason property available.
 */
function createMatchWithReason(props) {
  var match = props.match,
      changeReason = props.changeReason,
      exitReason = props.exitReason;
  return _objectSpread(_objectSpread({}, match), {}, {
    changeReason,
    exitReason
  });
}

/**
 * Checks to see if the text before the matching character is a valid prefix.
 *
 * @param prefix - the prefix to test
 * @param options - see [[`IsPrefixValidOptions`]]
 */
function isPrefixValid(prefix, options) {
  var invalidPrefixCharacters = options.invalidPrefixCharacters,
      validPrefixCharacters = options.validPrefixCharacters; // Will ignore the empty string intentionally.

  if (invalidPrefixCharacters) {
    var regex = new RegExp(regexToString(invalidPrefixCharacters));
    return !regex.test(prefix);
  }

  {
    var _regex = new RegExp(regexToString(validPrefixCharacters));

    return _regex.test(prefix);
  }
}
/**
 * Find the position of a mention for a given selection and character
 *
 * @param props - see [[`FindPositionProps`]]
 */


function findPosition(props) {
  var text = props.text,
      regexp = props.regexp,
      $pos = props.$pos,
      suggester = props.suggester; // The starting position for matches

  var start = $pos.start();
  var position;
  coreHelpers.findMatches(text, regexp).forEach(match => {
    // Check the character before the current match to ensure it is not one of
    // the supported characters
    var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);

    if (isPrefixValid(matchPrefix, suggester)) {
      // The absolute position of the matching parent node
      var from = match.index + start; // The full match of the created regex.

      var fullMatch = match[0]; // The matching text for the `char` regex or string is always captured as
      // the first matching group.

      var charMatch = match[1];

      if (!coreHelpers.isString(fullMatch) || !coreHelpers.isString(charMatch)) {
        return;
      } // The position where the match ends


      var to = from + fullMatch.length; // The cursor position (or end position whichever is greater)

      var cursor = Math.min(to, $pos.pos); // The length of the current match

      var matchLength = cursor - from; // If the $position is located within the matched substring, return that
      // range.

      if (from < $pos.pos && to >= $pos.pos) {
        position = {
          range: {
            from,
            to,
            cursor
          },
          match,
          query: {
            partial: fullMatch.slice(charMatch.length, matchLength),
            full: fullMatch.slice(charMatch.length)
          },
          text: {
            partial: fullMatch.slice(0, matchLength),
            full: fullMatch
          },
          textAfter: $pos.doc.textBetween(to, $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          textBefore: $pos.doc.textBetween(start, from, coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          suggester
        };
      }
    }
  });
  return position;
}

/**
 * Checks if any matches exist at the current selection so that the suggesters
 * can be activated or deactivated.
 */
function findMatch(props) {
  var $pos = props.$pos,
      suggester = props.suggester;
  var char = suggester.char,
      name = suggester.name,
      startOfLine = suggester.startOfLine,
      supportedCharacters = suggester.supportedCharacters,
      matchOffset = suggester.matchOffset,
      multiline = suggester.multiline,
      caseInsensitive = suggester.caseInsensitive,
      unicode = suggester.unicode; // Create the regular expression to match the text against

  var regexp = createRegexFromSuggester({
    char,
    matchOffset,
    startOfLine,
    supportedCharacters,
    multiline,
    caseInsensitive,
    unicode
  }); // All the text in the current node

  var text = $pos.doc.textBetween($pos.before(), $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER); // Find the position and return it

  return findPosition({
    suggester,
    text,
    regexp,
    $pos,
    char,
    name
  });
}

/**
 * Checks the provided match and generates a new match. This is useful for
 * determining the kind of change that has happened.
 *
 * If the match still exists and it is different then it's likely a split has
 * occurred.
 */
function recheckMatch(props) {
  var state = props.state,
      match = props.match;

  try {
    // Wrapped in try/catch because it's possible for everything to be deleted
    // and the doc.resolve will fail.
    return findMatch({
      $pos: state.doc.resolve(match.range.cursor),
      suggester: match.suggester
    });
  } catch (_unused) {
    return;
  }
}

/**
 * Check whether the insert action occurred at the end, in the middle or caused
 * the suggestion to be invalid.
 *
 * Prev refers to the original previous and next refers to the updated version
 * after the split
 */
function createInsertReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state; // Has the text been removed? TODO how to tests for deletions mid document?

  if (!next && prev.range.from >= state.doc.nodeSize) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.Removed
      })
    };
  } // Are we within an invalid split?


  if (!next || !prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.InvalidSplit
      })
    };
  } // Are we at the end position?


  if (prev.range.to === next.range.cursor) {
    // It seems that this never gets called. Revisit the logic and check whether
    // it's even necessary.
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.End
      })
    };
  } // Are we in the middle of the mention


  if (prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.Split
      })
    };
  }

  return {};
}

/**
 * Find the reason for the Jump between two suggesters.
 */
function findJumpReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state;
  var value = coreHelpers.object();
  var updatedPrevious = recheckMatch({
    state,
    match: prev
  });

  var _ref = updatedPrevious && updatedPrevious.query.full !== prev.query.full // has query changed
  ? createInsertReason({
    prev,
    next: updatedPrevious,
    state
  }) : value,
      exit = _ref.exit;

  var isJumpForward = prev.range.from < next.range.from;

  if (isJumpForward) {
    return {
      exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.JumpForward
      }),
      change: createMatchWithReason({
        match: next,
        changeReason: exports.ChangeReason.JumpForward
      })
    };
  }

  return {
    exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
      match: prev,
      exitReason: exports.ExitReason.JumpBackward
    }),
    change: createMatchWithReason({
      match: next,
      changeReason: exports.ChangeReason.JumpBackward
    })
  };
}

/**
 * Find the reason for the exit.
 *
 * This provides some context and helps sets up a helper command with sane
 * defaults.
 */
function findExitReason(props) {
  var match = props.match,
      state = props.state,
      $pos = props.$pos;
  var selection = state.selection;
  var updatedPrevious = recheckMatch({
    match,
    state
  }); // Exit created a split

  if (!updatedPrevious || updatedPrevious.text.full !== match.text.full) {
    return createInsertReason({
      prev: match,
      next: updatedPrevious,
      state
    });
  } // Exit caused by a selection


  if (!selection.empty && (selection.from <= match.range.from || selection.to >= match.range.to)) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.SelectionOutside
      })
    };
  } // Exit happened at the end of previous suggestion


  if ($pos.pos > match.range.to) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveEnd
      })
    };
  } // Exit happened at the start of previous suggestion


  if ($pos.pos <= match.range.from) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveStart
      })
    };
  }

  return {};
}

/**
 * Creates an array of the actions taken based on the current prev and next
 * state field
 */
function findReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state,
      $pos = props.$pos;
  var value = coreHelpers.object();

  if (!prev && !next) {
    return value;
  }

  var compare = {
    prev,
    next
  }; // Check for a Jump

  if (isJump(compare)) {
    return findJumpReason({
      prev: compare.prev,
      next: compare.next,
      state
    });
  } // Entered into a new suggestion


  if (isEntry(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Start
      })
    };
  } // Exited a suggestion


  if (isExit(compare)) {
    return findExitReason({
      $pos,
      match: compare.prev,
      state
    });
  }

  if (isChange(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Text
      })
    };
  }

  if (isMove(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: state.selection.empty ? exports.ChangeReason.Move : exports.ChangeReason.SelectionInside
      })
    };
  }

  return value;
}
/**
 * Check to see if the current $pos has a parent node matching the type.
 */

function hasParentNode($pos, types) {
  for (var depth = $pos.depth; depth > 0; depth--) {
    var node = $pos.node(depth);

    if (types.includes(node.type.name)) {
      return true;
    }
  }

  return false;
}
/**
 * Check whether the mark is active anywhere between `$from` and `$end`.
 *
 * Currently this is not doing exactly what it should. I've decided to be lazy
 * and only check the following.
 *
 * - Do any of the requested marks span the entire range using `rangeHasMarks`?
 * - Does the starting position have a mark?
 * - Does the cursor have a mark?
 * - Does the end position have a mark?
 *
 * In reality I should also check for each position within the range to see if a
 * target mark is active but I won't for now.
 */


function markActiveInRange(resolvedRange, marks) {
  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Check if there is a mark spanning the range of marks.

  if (rangeHasMarks(resolvedRange, marks)) {
    return true;
  } // Check if any of the positions in the available range have the active mark
  // associated with


  return coreHelpers.range($from.pos, $to.pos).some(value => positionHasMarks($from.doc.resolve(value), marks));
}
/**
 * Check if the entire matching range `from` the start point all the way through
 * `to` the end point, has any of the provided marks that span it.
 */

function rangeHasMarks(resolvedRange, marks) {
  var _$from$marksAcross;

  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Get the set of marks which span across the whole range.

  var setOfMarks = new Set(((_$from$marksAcross = $from.marksAcross($to)) !== null && _$from$marksAcross !== void 0 ? _$from$marksAcross : []).map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Check if the provided position has the given marks.
 */

function positionHasMarks($pos, marks) {
  // Get the set of marks for the current `$pos` which is used to check firstly
  // whether the set of marks is valid, and secondly whether the set of marks
  // includes any invalid marks.
  var setOfMarks = new Set($pos.marks().map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Checks if the suggester is in an invalid position.
 */

function isPositionValidForSuggester(suggester, resolvedRange) {
  var $cursor = resolvedRange.$cursor;
  var validMarks = suggester.validMarks,
      validNodes = suggester.validNodes,
      invalidMarks = suggester.invalidMarks,
      invalidNodes = suggester.invalidNodes; // Break early in the default case.

  if (!validMarks && !validNodes && coreHelpers.isEmptyArray(invalidMarks) && coreHelpers.isEmptyArray(invalidNodes)) {
    return true;
  }

  if (validMarks && !rangeHasMarks(resolvedRange, validMarks)) {
    return false;
  }

  if (validNodes && !hasParentNode($cursor, validNodes)) {
    return false;
  }

  if (!validMarks && markActiveInRange(resolvedRange, invalidMarks)) {
    return false;
  }

  if (!validNodes && hasParentNode($cursor, invalidNodes)) {
    return false;
  }

  return true;
}
/**
 * Find a match for the provided matchers.
 */


function findFromSuggesters(props) {
  var suggesters = props.suggesters,
      $pos = props.$pos,
      selectionEmpty = props.selectionEmpty; // Find the first match and break when done

  var _iterator = _createForOfIteratorHelper(suggesters),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var suggester = _step.value;

      // Make sure the selection is valid for this `suggester`.
      if (suggester.emptySelectionsOnly && !selectionEmpty) {
        continue;
      }

      try {
        var match = findMatch({
          suggester,
          $pos
        });

        if (!match) {
          continue;
        } // The resolved positions where `to` represents the cursor position.


        var resolvedRange = {
          $from: $pos.doc.resolve(match.range.from),
          $to: $pos.doc.resolve(match.range.to),
          $cursor: $pos
        };

        if (isPositionValidForSuggester(suggester, resolvedRange) && suggester.isValidPosition(resolvedRange, match)) {
          return match;
        } // Break early and return the match which was found.

      } catch (_unused2) {// Captures any errors which can pop up when all the content in the editor
        // is deleted or an invalid position was provided.
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return;
}
/**
 * Convert a RegExp into a string
 *
 * @param regexOrString
 */

function regexToString(regexOrString) {
  return coreHelpers.isRegExp(regexOrString) ? regexOrString.source : regexOrString;
}
/**
 * Find regex prefix when depending on whether the mention only supports the
 * start of a line or not
 *
 * @param onlyStartOfLine
 */


function getRegexPrefix(onlyStartOfLine) {
  return onlyStartOfLine ? '^' : '';
}
/**
 * Get the supported characters regex string.
 */


function getRegexSupportedCharacters(supportedCharacters, matchOffset) {
  return "(?:".concat(regexToString(supportedCharacters), "){").concat(matchOffset, ",}");
}
/**
 * Get the `char` from the `suggester` as regex.
 */


function getCharAsRegex(char) {
  return coreHelpers.isString(char) ? new RegExp(escapeStringRegex__default["default"](char)) : char;
}

/**
 * Create a regex expression which evaluate matches directly from the suggester
 * properties.
 */
function createRegexFromSuggester(props) {
  var char = props.char,
      matchOffset = props.matchOffset,
      startOfLine = props.startOfLine,
      supportedCharacters = props.supportedCharacters,
      _props$captureChar = props.captureChar,
      captureChar = _props$captureChar === void 0 ? true : _props$captureChar,
      _props$caseInsensitiv = props.caseInsensitive,
      caseInsensitive = _props$caseInsensitiv === void 0 ? false : _props$caseInsensitiv,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$unicode = props.unicode,
      unicode = _props$unicode === void 0 ? false : _props$unicode;
  var flags = "g".concat(multiline ? 'm' : '').concat(caseInsensitive ? 'i' : '').concat(unicode ? 'u' : '');
  var charRegex = getCharAsRegex(char).source;

  if (captureChar) {
    charRegex = "(".concat(charRegex, ")");
  }

  return new RegExp("".concat(getRegexPrefix(startOfLine)).concat(charRegex).concat(getRegexSupportedCharacters(supportedCharacters, matchOffset)), flags);
}
/**
 * The default value for the suggester.
 */

var DEFAULT_SUGGESTER = {
  appendTransaction: false,
  priority: 50,
  ignoredTag: 'span',
  matchOffset: 0,
  disableDecorations: false,
  startOfLine: false,
  suggestClassName: 'suggest',
  suggestTag: 'span',
  supportedCharacters: /\w+/,
  validPrefixCharacters: /^[\s\0]?$/,
  invalidPrefixCharacters: null,
  ignoredClassName: null,
  invalidMarks: [],
  invalidNodes: [],
  validMarks: null,
  validNodes: null,
  isValidPosition: () => true,
  checkNextValidSelection: null,
  emptySelectionsOnly: false,
  caseInsensitive: false,
  multiline: false,
  unicode: false,
  captureChar: true
};
/**
 * This can be added to the meta data of an update to let the suggestion plugin
 * know that it should ignore the update.
 */

var IGNORE_SUGGEST_META_KEY = '__ignore_prosemirror_suggest_update__';
/**
 * Takes the passed through `suggester` and adds all the missing default values.
 */

function getSuggesterWithDefaults(suggester) {
  return _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);
}

/**
 * The `prosemirror-suggest` state which manages the list of suggesters.
 */

var _docChanged = /*#__PURE__*/new WeakMap();

var _ignoreNextExit = /*#__PURE__*/new WeakMap();

var _suggesters = /*#__PURE__*/new WeakMap();

var _next = /*#__PURE__*/new WeakMap();

var _prev = /*#__PURE__*/new WeakMap();

var _handlerMatches = /*#__PURE__*/new WeakMap();

var _ignored = /*#__PURE__*/new WeakMap();

var _removed = /*#__PURE__*/new WeakMap();

var _lastChangeFromAppend = /*#__PURE__*/new WeakMap();

class SuggestState {
  /**
   * Create an instance of the SuggestState class.
   */
  static create(suggesters) {
    return new SuggestState(suggesters);
  }
  /**
   * True when the doc changed in the most recently applied transaction.
   */


  /**
   * The set of all decorations.
   */
  get decorationSet() {
    return _classPrivateFieldGet(this, _ignored);
  }
  /**
   * True when the most recent change was to remove a mention.
   *
   * @remarks
   *
   * This is needed because sometimes removing a prosemirror `Mark` has no
   * effect. Hence we need to keep track of whether it's removed and then later
   * in the apply step check that a removal has happened and reset the
   * `handlerMatches` to prevent an infinite loop.
   */


  get removed() {
    return _classPrivateFieldGet(this, _removed);
  }
  /**
   * Returns the current active suggester state field if one exists
   */


  get match() {
    return _classPrivateFieldGet(this, _next) ? _classPrivateFieldGet(this, _next) : _classPrivateFieldGet(this, _prev) && _classPrivateFieldGet(this, _handlerMatches).exit ? _classPrivateFieldGet(this, _prev) : undefined;
  }
  /**
   * Create the state for the `prosemirror-suggest` plugin.
   *
   * @remarks
   *
   * Each suggester must provide a name value which is globally unique since it
   * acts as the identifier.
   *
   * It is possible to register multiple suggesters with identical `char`
   * properties. The matched suggester is based on the specificity of the
   * `regex` and the order in which they are passed in. Earlier suggesters are
   * prioritized.
   */


  constructor(_suggesters2) {
    _classPrivateFieldInitSpec(this, _docChanged, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _ignoreNextExit, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _suggesters, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _next, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _prev, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _handlerMatches, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _ignored, {
      writable: true,
      value: prosemirrorView.DecorationSet.empty
    });

    _classPrivateFieldInitSpec(this, _removed, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _lastChangeFromAppend, {
      writable: true,
      value: false
    });

    _defineProperty(this, "setMarkRemoved", () => {
      _classPrivateFieldSet(this, _removed, true);
    });

    _defineProperty(this, "findNextTextSelection", selection => {
      var doc = selection.$from.doc; // Make sure the position doesn't exceed the bounds of the document.

      var pos = Math.min(doc.nodeSize - 2, selection.to + 1);
      var $pos = doc.resolve(pos); // Get the position furthest along in the editor to pass back to suggesters
      // which have the handler.

      var nextSelection = prosemirrorState.Selection.findFrom($pos, 1, true); // Ignore non-text selections and null / undefined values. This is needed
      // for TS mainly, since the `true` in the `Selection.findFrom` method means
      // only `TextSelection` instances will be returned.

      if (!isTextSelection(nextSelection)) {
        return;
      }

      return nextSelection;
    });

    _defineProperty(this, "ignoreNextExit", () => {
      _classPrivateFieldSet(this, _ignoreNextExit, true);
    });

    _defineProperty(this, "addIgnored", _ref => {
      var from = _ref.from,
          name = _ref.name,
          _ref$specific = _ref.specific,
          specific = _ref$specific === void 0 ? false : _ref$specific;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;
      var to = from + offset;
      var attributes = suggester.ignoredClassName ? {
        class: suggester.ignoredClassName
      } : {};
      var decoration = prosemirrorView.Decoration.inline(from, to, _objectSpread({
        nodeName: suggester.ignoredTag
      }, attributes), {
        name,
        specific,
        char: suggester.char
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).add(this.view.state.doc, [decoration]));
    });

    _defineProperty(this, "removeIgnored", _ref2 => {
      var from = _ref2.from,
          name = _ref2.name;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;

      var decoration = _classPrivateFieldGet(this, _ignored).find(from, from + offset)[0];

      if (!decoration || decoration.spec.name !== name) {
        return;
      }

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove([decoration]));
    });

    _defineProperty(this, "clearIgnored", name => {
      if (!name) {
        _classPrivateFieldSet(this, _ignored, prosemirrorView.DecorationSet.empty);

        return;
      }

      var decorations = _classPrivateFieldGet(this, _ignored).find();

      var decorationsToClear = decorations.filter(_ref3 => {
        var spec = _ref3.spec;
        return spec.name === name;
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove(decorationsToClear));
    });

    _defineProperty(this, "findMatchAtPosition", ($pos, name) => {
      var suggesters = name ? _classPrivateFieldGet(this, _suggesters).filter(suggester => suggester.name === name) : _classPrivateFieldGet(this, _suggesters);
      return findFromSuggesters({
        suggesters,
        $pos,
        docChanged: false,
        selectionEmpty: true
      });
    });

    _defineProperty(this, "setLastChangeFromAppend", () => {
      _classPrivateFieldSet(this, _lastChangeFromAppend, true);
    });

    var mapper = createSuggesterMapper();

    _classPrivateFieldSet(this, _suggesters, _suggesters2.map(mapper));

    _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(_classPrivateFieldGet(this, _suggesters), (a, b) => b.priority - a.priority));
  }
  /**
   * Initialize the SuggestState with a view which is stored for use later.
   */


  init(view) {
    this.view = view;
    return this;
  }
  /**
   * Sets the removed property to be true.
   *
   * This is useful when working with marks.
   */


  /**
   * Create the props which should be passed into each action handler
   */
  createProps(match) {
    var _match$suggester = match.suggester,
        name = _match$suggester.name,
        char = _match$suggester.char;
    return _objectSpread({
      view: this.view,
      addIgnored: this.addIgnored,
      clearIgnored: this.clearIgnored,
      ignoreNextExit: this.ignoreNextExit,
      setMarkRemoved: this.setMarkRemoved,
      name,
      char
    }, match);
  }
  /**
   * Check whether the exit callback is valid at this time.
   */


  shouldRunExit() {
    if (_classPrivateFieldGet(this, _ignoreNextExit)) {
      _classPrivateFieldSet(this, _ignoreNextExit, false);

      return false;
    }

    return true;
  }
  /**
   * Find the next text selection from the current selection.
   */


  /**
   * Update all the suggesters with the next valid selection. This is called
   * within the `appendTransaction` ProseMirror method before any of the change
   * handlers are called.
   *
   * @internal
   */
  updateWithNextSelection(tr) {
    // Get the position furthest along in the editor to pass back to suggesters
    // which have the handler.
    var nextSelection = this.findNextTextSelection(tr.selection);

    if (!nextSelection) {
      return;
    } // Update every suggester with a method attached.


    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _suggesters)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _classPrivateFieldGet2, _classPrivateFieldGet3, _suggester$checkNextV;

        var suggester = _step.value;
        var change = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _handlerMatches).change) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.suggester.name;
        var exit = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _handlerMatches).exit) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.suggester.name;
        (_suggester$checkNextV = suggester.checkNextValidSelection) === null || _suggester$checkNextV === void 0 ? void 0 : _suggester$checkNextV.call(suggester, nextSelection.$from, tr, {
          change,
          exit
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Call the `onChange` handlers.
   *
   * @internal
   */


  changeHandler(tr, appendTransaction) {
    var _classPrivateFieldGet4 = _classPrivateFieldGet(this, _handlerMatches),
        change = _classPrivateFieldGet4.change,
        exit = _classPrivateFieldGet4.exit;

    var match = this.match; // Cancel update when a suggester isn't active

    if (!change && !exit || !isValidMatch(match)) {
      return;
    }

    var shouldRunExit = appendTransaction === (exit === null || exit === void 0 ? void 0 : exit.suggester.appendTransaction) && this.shouldRunExit();
    var shouldRunChange = appendTransaction === (change === null || change === void 0 ? void 0 : change.suggester.appendTransaction);

    if (!shouldRunExit && !shouldRunChange) {
      return;
    } // When a jump happens run the action that involves the position that occurs
    // later in the document. This is so that changes don't affect previous
    // positions.


    if (change && exit && isJumpReason({
      change,
      exit
    })) {
      var exitDetails = this.createProps(exit);
      var changeDetails = this.createProps(change); // Whether the jump was forwards or backwards. A forwards jump means that
      // the user was within a suggester nearer the beginning of the document,
      // before jumping forward to a point later on in the document.

      var movedForwards = exit.range.from < change.range.from;

      if (movedForwards) {
        // Subtle change to call exit first. Conceptually it happens before the
        // change so call the handler before the change handler.
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      } else {
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      }

      if (shouldRunExit) {
        _classPrivateFieldSet(this, _removed, false);
      }

      return;
    }

    if (change && shouldRunChange) {
      change.suggester.onChange(this.createProps(change), tr);
    }

    if (exit && shouldRunExit) {
      exit.suggester.onChange(this.createProps(exit), tr);

      _classPrivateFieldSet(this, _removed, false);

      if (isInvalidSplitReason(exit.exitReason)) {
        // When the split has made the match invalid, remove the matches before
        // the next input.
        _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());
      }
    }

    return;
  }
  /**
   * Update the current ignored decorations based on the latest changes to the
   * prosemirror document.
   */


  mapIgnoredDecorations(tr) {
    // Map over and update the ignored decorations.
    var ignored = _classPrivateFieldGet(this, _ignored).map(tr.mapping, tr.doc);

    var decorations = ignored.find(); // For suggesters with multiple characters it is possible for a `paste` or
    // any edit action within the decoration to expand the ignored section. We
    // check for that here and if the section size has changed it should be
    // marked as invalid and removed from the ignored `DecorationSet`.

    var invalid = decorations.filter(_ref4 => {
      var from = _ref4.from,
          to = _ref4.to,
          spec = _ref4.spec;
      var charLength = coreHelpers.isString(spec.char) ? spec.char.length : 1;

      if (to - from !== charLength) {
        return true;
      }

      return false;
    });

    _classPrivateFieldSet(this, _ignored, ignored.remove(invalid));
  }
  /**
   * This sets the next exit to not trigger the exit reason inside the
   * `onChange` callback.
   *
   * This can be useful when you trigger a command, that exists the suggestion
   * match and want to prevent further onChanges from occurring for the
   * currently active suggester.
   */


  /**
   * Checks whether a match should be ignored.
   *
   * TODO add logic here to decide whether to ignore a match based on the active
   * node, or mark.
   */
  shouldIgnoreMatch(_ref5) {
    var range = _ref5.range,
        name = _ref5.suggester.name;

    var decorations = _classPrivateFieldGet(this, _ignored).find();

    var shouldIgnore = decorations.some(_ref6 => {
      var spec = _ref6.spec,
          from = _ref6.from;

      if (from !== range.from) {
        return false;
      }

      return spec.specific ? spec.name === name : true;
    });
    return shouldIgnore;
  }
  /**
   * Reset the state.
   */


  resetState() {
    _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());

    _classPrivateFieldSet(this, _next, undefined);

    _classPrivateFieldSet(this, _removed, false);

    _classPrivateFieldSet(this, _lastChangeFromAppend, false);
  }
  /**
   * Update the next state value.
   */


  updateReasons(props) {
    var $pos = props.$pos,
        state = props.state;

    var docChanged = _classPrivateFieldGet(this, _docChanged);

    var suggesters = _classPrivateFieldGet(this, _suggesters);

    var selectionEmpty = state.selection.empty;
    var match = isTextSelection(state.selection) ? findFromSuggesters({
      suggesters,
      $pos,
      docChanged,
      selectionEmpty
    }) : undefined; // Track the next match if not being ignored.

    _classPrivateFieldSet(this, _next, match && this.shouldIgnoreMatch(match) ? undefined : match); // Store the matches with reasons


    _classPrivateFieldSet(this, _handlerMatches, findReason({
      next: _classPrivateFieldGet(this, _next),
      prev: _classPrivateFieldGet(this, _prev),
      state,
      $pos
    }));
  }
  /**
   * A helper method to check is a match exists for the provided suggester name
   * at the provided position.
   */


  /**
   * Add a new suggest or replace it if it already exists.
   */
  addSuggester(suggester) {
    var previous = _classPrivateFieldGet(this, _suggesters).find(item => item.name === suggester.name);

    var mapper = createSuggesterMapper();

    if (previous) {
      _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).map(item => item === previous ? mapper(suggester) : item));
    } else {
      var suggesters = [..._classPrivateFieldGet(this, _suggesters), mapper(suggester)];

      _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(suggesters, (a, b) => b.priority - a.priority));
    }

    return () => this.removeSuggester(suggester.name);
  }
  /**
   * Remove a suggester if it exists.
   */


  removeSuggester(suggester) {
    var name = coreHelpers.isString(suggester) ? suggester : suggester.name;

    _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).filter(item => item.name !== name)); // When removing a suggester make sure to clear the ignored sections.


    this.clearIgnored(name);
  }

  toJSON() {
    return this.match;
  }
  /**
   * Applies updates to the state to be used within the plugins apply method.
   *
   * @param - params
   */


  apply(props) {
    var _classPrivateFieldGet5 = _classPrivateFieldGet(this, _handlerMatches),
        exit = _classPrivateFieldGet5.exit,
        change = _classPrivateFieldGet5.change;

    if (_classPrivateFieldGet(this, _lastChangeFromAppend)) {
      _classPrivateFieldSet(this, _lastChangeFromAppend, false);

      if (!(exit !== null && exit !== void 0 && exit.suggester.appendTransaction) && !(change !== null && change !== void 0 && change.suggester.appendTransaction)) {
        return this;
      }
    }

    var tr = props.tr,
        state = props.state;
    var transactionHasChanged = tr.docChanged || tr.selectionSet;
    var shouldIgnoreUpdate = tr.getMeta(IGNORE_SUGGEST_META_KEY);

    if (shouldIgnoreUpdate || !transactionHasChanged && !_classPrivateFieldGet(this, _removed)) {
      return this;
    }

    _classPrivateFieldSet(this, _docChanged, tr.docChanged);

    this.mapIgnoredDecorations(tr); // If the previous run was an exit, reset the suggester matches.

    if (exit) {
      this.resetState();
    } // Track the previous match.


    _classPrivateFieldSet(this, _prev, _classPrivateFieldGet(this, _next)); // Match against the current selection position


    this.updateReasons({
      $pos: tr.selection.$from,
      state
    });
    return this;
  }
  /**
   * Handle the decorations which wrap the mention while it is active and not
   * yet complete.
   */


  createDecorations(state) {
    var match = this.match;

    if (!isValidMatch(match)) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var disableDecorations = match.suggester.disableDecorations;
    var shouldSkip = coreHelpers.isFunction(disableDecorations) ? disableDecorations(state, match) : disableDecorations;

    if (shouldSkip) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var range = match.range,
        suggester = match.suggester;
    var name = suggester.name,
        suggestTag = suggester.suggestTag,
        suggestClassName = suggester.suggestClassName;
    var from = range.from,
        to = range.to;
    return this.shouldIgnoreMatch(match) ? _classPrivateFieldGet(this, _ignored) : _classPrivateFieldGet(this, _ignored).add(state.doc, [prosemirrorView.Decoration.inline(from, to, {
      nodeName: suggestTag,
      class: name ? "".concat(suggestClassName, " suggest-").concat(name) : suggestClassName
    }, {
      name
    })]);
  }
  /**
   * Set that the last change was caused by an appended transaction.
   *
   * @internal
   */


}

/**
 * Map over the suggesters provided and make sure they have all the required
 * properties.
 */
function createSuggesterMapper() {
  var names = new Set();
  return suggester => {
    if (names.has(suggester.name)) {
      throw new Error("A suggester already exists with the name '".concat(suggester.name, "'. The name provided must be unique."));
    } // Attach the defaults to the passed in suggester.


    var suggesterWithDefaults = _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);

    names.add(suggester.name);
    return suggesterWithDefaults;
  };
}
/**
 * This key is stored to provide access to the plugin state.
 */


var suggestPluginKey = new prosemirrorState.PluginKey('suggest');

/**
 * Get the state of the suggest plugin.
 *
 * @param state - the editor state.
 */

function getSuggestPluginState(state) {
  return suggestPluginKey.getState(state);
}
/**
 * Add a new suggester or replace it if the name already exists in the existing
 * configuration.
 *
 * Will return a function for disposing of the added suggester.
 */

function addSuggester(state, suggester) {
  return getSuggestPluginState(state).addSuggester(suggester);
}
/**
 * Call this method with a transaction to skip the suggest plugin checks for the
 * next update.
 *
 * This can be used for updates that don't need to trigger a recheck of the
 * suggest state.
 */

function ignoreUpdateForSuggest(tr) {
  tr.setMeta(IGNORE_SUGGEST_META_KEY, true);
}
/**
 * Remove a suggester if it exists. Pass in the name or the full suggester
 * object.
 */

function removeSuggester(state, suggester) {
  return getSuggestPluginState(state).removeSuggester(suggester);
}
/**
 * This creates a suggest plugin with all the suggesters that you provide.
 *
 * The priority of the suggesters is the order in which they are passed into
 * this function.
 *
 * - `const plugin = suggest(two, one, three)` - Here `two` will be checked
 *   first, then `one` and then `three`.
 *
 * Only one suggester can match at any given time. The order and specificity of
 * the regex parameters help determines which suggester will be active.
 *
 * @param suggesters - a list of suggesters in the order they should be
 * evaluated.
 */

function suggest() {
  for (var _len = arguments.length, suggesters = new Array(_len), _key = 0; _key < _len; _key++) {
    suggesters[_key] = arguments[_key];
  }

  // Create the initial plugin state for the suggesters.
  var pluginState = SuggestState.create(suggesters);
  return new prosemirrorState.Plugin({
    key: suggestPluginKey,
    // Handle the plugin view
    view: _view => {
      // Initialize the state with the required view before it is used.
      pluginState.init(_view);
      return {
        update: view => {
          return pluginState.changeHandler(view.state.tr, false);
        }
      };
    },
    state: {
      // Initialize the state
      init: () => {
        return pluginState;
      },
      // Apply changes to the state
      apply: (tr, _pluginState, _oldState, state) => {
        return pluginState.apply({
          tr,
          state
        });
      }
    },

    /** Append a transaction via the onChange handlers */
    appendTransaction: (_, __, state) => {
      var tr = state.tr; // Run the transaction updater for the next selection.

      pluginState.updateWithNextSelection(tr); // Run the change handler.

      pluginState.changeHandler(tr, true); // Check if the transaction has been amended in any way.

      if (tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet) {
        pluginState.setLastChangeFromAppend();
        return tr;
      }

      return null;
    },
    props: {
      // Sets up a decoration (styling options) on the currently active
      // decoration
      decorations: state => {
        return pluginState.createDecorations(state);
      }
    }
  });
}

exports.DEFAULT_SUGGESTER = DEFAULT_SUGGESTER;
exports.IGNORE_SUGGEST_META_KEY = IGNORE_SUGGEST_META_KEY;
exports.addSuggester = addSuggester;
exports.createRegexFromSuggester = createRegexFromSuggester;
exports.findFromSuggesters = findFromSuggesters;
exports.getSuggestPluginState = getSuggestPluginState;
exports.getSuggesterWithDefaults = getSuggesterWithDefaults;
exports.ignoreUpdateForSuggest = ignoreUpdateForSuggest;
exports.isChangeReason = isChangeReason;
exports.isExitReason = isExitReason;
exports.isInvalidSplitReason = isInvalidSplitReason;
exports.isJumpReason = isJumpReason;
exports.isRemovedReason = isRemovedReason;
exports.isSelectionChangeReason = isSelectionChangeReason;
exports.isSelectionExitReason = isSelectionExitReason;
exports.isSplitReason = isSplitReason;
exports.isValidMatch = isValidMatch;
exports.markActiveInRange = markActiveInRange;
exports.positionHasMarks = positionHasMarks;
exports.rangeHasMarks = rangeHasMarks;
exports.removeSuggester = removeSuggester;
exports.selectionOutsideMatch = selectionOutsideMatch;
exports.suggest = suggest;
