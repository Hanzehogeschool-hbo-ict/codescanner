/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseJson = exports.runScan = void 0;
const vscode = __webpack_require__(1);
const fs = __webpack_require__(3);
const functions_1 = __webpack_require__(4);
const functions_2 = __webpack_require__(4);
const md_to_html_1 = __webpack_require__(5);
const os_1 = __webpack_require__(144);
var pluginPath = `${os_1.homedir}` + "/.vscode/extensions/mk2000.code-project-scanner-1.0.0/";
async function startOwasp() {
    // get work folder location
    var wf = undefined;
    if (vscode.workspace.workspaceFolders !== undefined) {
        wf = (vscode.workspace.workspaceFolders[0].uri.path).substring(1); // substring removes first "/" of the wf path           
    }
    else {
        let message = "Working folder not found, open a folder an try again";
        vscode.window.showErrorMessage(message);
    }
    // start terminal with owasp dependency-check
    let terminal = vscode.window.createTerminal({
        name: "Code Project Scanner: Dependency-Check",
        //cwd: pluginPath,
        hideFromUser: false,
        shellPath: pluginPath + "dependency-check/bin/dependency-check.bat",
        shellArgs: `-s ${wf} -f JSON -o scanresults`,
    });
    terminal.show();
}
async function runScan() {
    startOwasp();
}
exports.runScan = runScan;
function parseJson() {
    let wf = (0, functions_1.workspaceFolder)();
    var output = "No results were found. Make sure to run the scan first.";
    var name, workspace, reportDate, dependencies, table, criticalCount, highCount, mediumCount, lowCount, noneCount, vulnerableCount, notVulnerableCount, dependenciesCount, vulnerablePercentage;
    name = workspace = reportDate = dependencies = "No result";
    table = "";
    vulnerableCount = notVulnerableCount = dependenciesCount = vulnerablePercentage = criticalCount = highCount = mediumCount = lowCount = 0;
    try {
        const resultFile = fs.readFileSync(`${wf}` + "/scanresults/dependency-check-report.json", 'utf-8'); //fs.readFileSync(pluginPath + "dependency-check/scanresults/dependency-check-report.json", 'utf-8');
        const data = JSON.parse(resultFile);
        // projectinfo
        name = vscode.workspace.name;
        workspace = (0, functions_1.workspaceFolder)();
        reportDate = new Date(data.projectInfo.reportDate).toLocaleString("nl-NL");
        // dependencies
        let dependenciesJson = data.dependencies;
        const dependenciesString = JSON.stringify(dependenciesJson);
        dependencies = JSON.parse(dependenciesString);
        // Initialise vulnerability properties
        var severity = "Unknown";
        var description = "There are no description available for this vulnerability.";
        var packageId = "Unknown";
        var packageUrl = "Unknown";
        // Initialise cvss properties
        var accessVector = "Unknown";
        var accessComplexity = "Unknown";
        var confidentialImpact = "Unknown";
        var integrityImpact = "Unknown";
        var availabilityImpact = "Unknown";
        var accessVectorDesc = "Unknown";
        var accessComplexityDesc = "Unknown";
        var confidentialImpactDesc = "Unknown";
        var integrityImpactDesc = "Unknown";
        var availabilityImpactDesc = "Unknown";
        // initialise project risk variables
        var projectRisk;
        var totRiskScore = new Array();
        var totRiskScoreSum = 0;
        var projectRiskConfHigh;
        var projectRiskConfLow;
        var totRiskScoreConfHigh = new Array();
        var totRiskScoreConfLow = new Array();
        var totRiskScoreSumConfHigh = 0;
        var totRiskScoreSumConfLow = 0;
        var projectRiskIntegHigh;
        var projectRiskIntegLow;
        var totRiskScoreIntegHigh = new Array();
        var totRiskScoreIntegLow = new Array();
        var totRiskScoreSumIntegHigh = 0;
        var totRiskScoreSumIntegLow = 0;
        var projectRiskAvailHigh;
        var projectRiskAvailLow;
        var totRiskScoreAvailHigh = new Array();
        var totRiskScoreAvailLow = new Array();
        var totRiskScoreSumAvailHigh = 0;
        var totRiskScoreSumAvailLow = 0;
        // Initialise maps
        const severityMap = new Map();
        severityMap.set("Low", 0);
        severityMap.set("Medium", 1);
        severityMap.set("High", 2);
        severityMap.set("Critical", 3);
        var highestSeverity = "Unknown";
        const cvssv2Map = new Map();
        cvssv2Map.set("N", 0);
        cvssv2Map.set("L", 1);
        cvssv2Map.set("H", 2);
        // Loop through found dependencies
        for (var index in dependencies) {
            let fileName = dependencies[index].fileName;
            let filePath = dependencies[index].filePath;
            let virtual = dependencies[index].isVirtual;
            let isVulnerable = true;
            if (virtual === false) {
                isVulnerable = false;
            }
            table += "<tr>";
            table += "<td>" + fileName + "</td>";
            if (isVulnerable === true) {
                vulnerableCount += 1;
                try {
                    description = dependencies[index].vulnerabilities[0].description;
                    packageId = dependencies[index].packages[0].id;
                    packageUrl = dependencies[index].packages[0].url;
                }
                catch {
                }
                var descriptionArr = new Array();
                var values = new Array();
                var scores = new Array();
                var cweArr = new Array();
                var referenceNames = new Array();
                try {
                    var confImpact;
                    var integImpact;
                    var availImpact;
                    var impactScore;
                    var accessVectorScore;
                    var accessComplexityScore;
                    var exploitScore;
                    var baseScore;
                    var adjustedImpact;
                    var adjustedBaseScoreLow;
                    var adjustedBaseScoreHigh;
                    var riskScore;
                    let i = 0;
                    while (dependencies[index].vulnerabilities[i]) {
                        let description = dependencies[index].vulnerabilities[i].description;
                        descriptionArr.push(description);
                        severity = dependencies[index].vulnerabilities[i].severity;
                        severity = severity.charAt(0).toUpperCase() + severity.slice(1).toLowerCase(); // capitalize first letter, rest is lowercase
                        for (let [key, value] of severityMap) {
                            if (key === severity) {
                                values.push(value);
                            }
                        }
                        let cvssv2 = dependencies[index].vulnerabilities[i].cvssv2;
                        // get CVSS properties  
                        if (cvssv2 !== undefined) {
                            let score = cvssv2.score;
                            let accessVectorCVSS = cvssv2.accessVector;
                            let accessComplexityCVSS = cvssv2.accessComplexity;
                            let confidentialImpactCVSS = cvssv2.confidentialImpact;
                            let integrityImpactCVSS = cvssv2.integrityImpact;
                            let availabilityImpactCVSS = cvssv2.availabilityImpact;
                            if (accessVectorCVSS === "L") {
                                accessVectorScore = 0.395;
                                accessVector = "Local";
                            }
                            else if (accessVectorCVSS === "A") {
                                accessVectorScore = 0.646;
                                accessVector = "Adjecent Network";
                            }
                            else if (accessVectorCVSS === "N") {
                                accessVectorScore = 1;
                                accessVector = "Network";
                            }
                            if (accessComplexityCVSS === "H") {
                                accessComplexityScore = 0.35;
                                accessComplexity = "High";
                            }
                            else if (accessComplexityCVSS === "M") {
                                accessComplexityScore = 0.61;
                                accessComplexity = "Medium";
                            }
                            else if (accessComplexityCVSS === "L") {
                                accessComplexityScore = 0.71;
                                accessComplexity = "Low";
                            }
                            if (confidentialImpactCVSS === "N") {
                                confImpact = 0;
                                confidentialImpact = "None";
                            }
                            else if (confidentialImpactCVSS === "L") {
                                confImpact = 0.275;
                                confidentialImpact = "Partial";
                            }
                            else if (confidentialImpactCVSS === "H") {
                                confImpact = 0.66;
                                confidentialImpact = "Complete";
                            }
                            if (integrityImpactCVSS === "N") {
                                integImpact = 0;
                                integrityImpact = "None";
                            }
                            else if (integrityImpactCVSS === "L") {
                                integImpact = 0.275;
                                integrityImpact = "Partial";
                            }
                            else if (integrityImpactCVSS === "H") {
                                integImpact = 0.66;
                                integrityImpact = "Complete";
                            }
                            if (availabilityImpactCVSS === "N") {
                                availImpact = 0;
                                availabilityImpact = "None";
                            }
                            else if (availabilityImpactCVSS === "L") {
                                availImpact = 0.275;
                                availabilityImpact = "Partial";
                            }
                            else if (availabilityImpactCVSS === "H") {
                                availImpact = 0.66;
                                availabilityImpact = "Complete";
                            }
                            scores.push(score);
                        }
                        let cwes = dependencies[index].vulnerabilities[i].cwes;
                        if (cwes.length !== 0) {
                            for (let cwe of cwes) {
                                cweArr.push(cwe);
                            }
                        }
                        let referenceSource = dependencies[index].vulnerabilities[i].references[0].source;
                        let referenceName = dependencies[index].vulnerabilities[i].references[0].name;
                        let referenceUrl = dependencies[index].vulnerabilities[i].references[0].url;
                        if (referenceName.includes("\n- ")) {
                            for (let item of referenceName.split("\n- ")) {
                                referenceNames.push(item.replace("- ", "")); // remove first "- "
                            }
                        }
                        else {
                            referenceNames.push(referenceName);
                        }
                        i++;
                    }
                }
                catch {
                    descriptionArr.push(description);
                }
                if (accessVectorScore !== undefined && accessComplexityScore !== undefined) {
                    exploitScore = 20 * accessVectorScore * accessComplexityScore * 0.704;
                }
                else {
                    exploitScore = "Unknown";
                }
                let adjustedConfImpactHigh;
                let adjustedConfImpactLow;
                let adjustedIntegImpactHigh;
                let adjustedIntegImpactLow;
                let adjustedAvailImpactHigh;
                let adjustedAvailImpactLow;
                let adjustedBaseScoreConfHigh;
                let adjustedBaseScoreConfLow;
                let adjustedBaseScoreIntegHigh;
                let adjustedBaseScoreIntegLow;
                let adjustedBaseScoreAvailHigh;
                let adjustedBaseScoreAvailLow;
                if (confImpact !== undefined && integImpact !== undefined && availImpact !== undefined) {
                    impactScore = 10.41 * (1 - (1 - confImpact) * (1 - integImpact) * (1 - availImpact));
                    adjustedConfImpactHigh = Math.min(10, 10.41 * (1 - (1 - confImpact * 1.51) * (1 - integImpact * 1) * (1 - availImpact * 1)));
                    adjustedConfImpactLow = Math.min(10, 10.41 * (1 - (1 - confImpact * 0.5) * (1 - integImpact * 1) * (1 - availImpact * 1)));
                    adjustedIntegImpactHigh = Math.min(10, 10.41 * (1 - (1 - confImpact * 1) * (1 - integImpact * 1.51) * (1 - availImpact * 1)));
                    adjustedIntegImpactLow = Math.min(10, 10.41 * (1 - (1 - confImpact * 1) * (1 - integImpact * 0.5) * (1 - availImpact * 1)));
                    adjustedAvailImpactHigh = Math.min(10, 10.41 * (1 - (1 - confImpact * 1) * (1 - integImpact * 1) * (1 - availImpact * 1.51)));
                    adjustedAvailImpactLow = Math.min(10, 10.41 * (1 - (1 - confImpact * 1) * (1 - integImpact * 1) * (1 - availImpact * 0.5)));
                }
                else {
                    impactScore = adjustedImpact = "Unknown";
                }
                if (typeof impactScore === "number" && typeof exploitScore === "number") {
                    if (impactScore === 0) {
                        baseScore = (((0.6 * impactScore) + (0.4 * exploitScore) - 1.5) * 0);
                    }
                    else {
                        baseScore = (((0.6 * impactScore) + (0.4 * exploitScore) - 1.5) * 1.176);
                        if (adjustedConfImpactHigh !== undefined && adjustedConfImpactLow !== undefined && adjustedIntegImpactHigh !== undefined && adjustedIntegImpactLow !== undefined && adjustedAvailImpactHigh !== undefined && adjustedAvailImpactLow !== undefined) {
                            adjustedBaseScoreConfHigh = (0, functions_2.round)((((0.6 * adjustedConfImpactHigh) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                            adjustedBaseScoreConfLow = (0, functions_2.round)((((0.6 * adjustedConfImpactLow) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                            adjustedBaseScoreIntegHigh = (0, functions_2.round)((((0.6 * adjustedIntegImpactHigh) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                            adjustedBaseScoreIntegLow = (0, functions_2.round)((((0.6 * adjustedIntegImpactLow) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                            adjustedBaseScoreAvailHigh = (0, functions_2.round)((((0.6 * adjustedAvailImpactHigh) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                            adjustedBaseScoreAvailLow = (0, functions_2.round)((((0.6 * adjustedAvailImpactLow) + (0.4 * exploitScore) - 1.5) * 1.176), 1);
                        }
                    }
                }
                else {
                    baseScore = "Unknown";
                }
                let descSet = new Set(descriptionArr);
                descriptionArr = Array.from(descSet.values());
                // get key based on value
                for (let [key, value] of cvssv2Map.entries()) {
                    if (key === "N") {
                        key = "None";
                    }
                    else if (key === "L") {
                        key = "Low";
                    }
                    else if (key === "M") {
                        key = "Medium";
                    }
                    else if (key === "H") {
                        key = "High";
                    }
                    else {
                        key = "Unknown";
                    }
                    if (accessVector === "Local") {
                        accessVectorDesc = "a vulnerability exploitable with only local access requires the attacker to have either physical access to the vulnerable system or a local (shell) account. Examples of locally exploitable vulnerabilities are peripheral attacks such as Firewire/USB DMA attacks, and local privilege escalations (e.g., sudo).";
                    }
                    else if (accessVector === "Adjecent Network") {
                        accessVectorDesc = "a vulnerability exploitable with adjacent network access requires the attacker to have access to either the broadcast or collision domain of the vulnerable software.  Examples of local networks include local IP subnet, Bluetooth, IEEE 802.11, and local Ethernet segment.";
                    }
                    else if (accessVector === "Network") {
                        accessVectorDesc = "a vulnerability exploitable with network access means the vulnerable software is bound to the network stack and the attacker does not require local network access or local access. Such a vulnerability is often termed 'remotely exploitable'. An example of a network attack is an RPC buffer overflow.";
                    }
                    else {
                        accessVectorDesc = "DESCRIPTION COULD NOT BE FOUND, PLEASE BE CAUTIOUS!";
                    }
                    if (accessComplexityDesc) {
                        if (accessComplexity === "Low") {
                            accessComplexityDesc = "specialized access conditions do not exist. Examples are: ";
                            accessComplexityDesc += "<ul>";
                            accessComplexityDesc += "<li>The affected product requires access to a wide range of systems and users, possibly anonymous and untrusted.</li>";
                            accessComplexityDesc += "<li>The affected configuration is default or commonly used in practice.</li>";
                            accessComplexityDesc += "<li>The attack can be performed manually and requires little skill or additional information gathering.</li>";
                            accessComplexityDesc += "</ul>";
                        }
                        else if (accessComplexity === "Medium") {
                            accessComplexityDesc = "The access conditions are somewhat specialized. Examples are: ";
                            accessComplexityDesc += "<ul>";
                            accessComplexityDesc += "<li>The attacking party is limited to a group of systems or users at some level of authorization, possibly untrusted.</li>";
                            accessComplexityDesc += "<li>Some information must be gathered before a successful attack can be launched.</li>";
                            accessComplexityDesc += "<li>The affected configuration is non-default.</li>";
                            accessComplexityDesc += "<li>The attack requires a small amount of social engineering that might occasionally fool cautious users (e.g., phishing attacks that modify a web browsers status bar to show a false link.</li>";
                            accessComplexityDesc += "</ul>";
                        }
                        else if (accessComplexity === "High") {
                            accessComplexityDesc = "specialized access conditions exist. Examples are: ";
                            accessComplexityDesc += "<ul>";
                            accessComplexityDesc += "<li>The attacking part must already have elevated privileges or spoof additional systems in addition to the attacking system.</li>";
                            accessComplexityDesc += "<li>The attack depends on social engineering methods that would be easily detected by knowledgeable people. For example, the victim must perform several suspicious or atypical actions.</li>";
                            accessComplexityDesc += "<li>The vulnerable configuration is seen very rarely in practice.</li>";
                            accessComplexityDesc += "<li>If a race condition exists, the window is very narrow.</li>";
                            accessComplexityDesc += "</ul>";
                        }
                        else {
                            accessComplexityDesc = "DESCRIPTION COULD NOT BE FOUND, PLEASE BE CAUTIOUS!";
                        }
                    }
                    if (confidentialImpact === "None") {
                        confidentialImpactDesc = "there is no impact to the condifentiality of the system";
                    }
                    else if (confidentialImpact === "Partial") {
                        confidentialImpactDesc = "there is considerable informational disclosure. Access to some system files is possible, but the attacker does not have control over what is obtained, or the scope of the loss is constrained. An example is a vulnerability that divulges only certain tables in a database.";
                    }
                    else if (confidentialImpact === "Complete") {
                        confidentialImpactDesc = "there is total information disclosure, resulting in all system files being revealed. The attacker is able to read all of the system's data (memory, files, etc.)";
                    }
                    else {
                        confidentialImpactDesc = "DESCRIPTION COULD NOT BE FOUND, PLEASE BE CAUTIOUS!";
                    }
                    if (integrityImpact === "None") {
                        integrityImpactDesc = "there is no impact to the integrity of the system";
                    }
                    else if (integrityImpact === "Partial") {
                        integrityImpactDesc = "modification of some system files or information is possible, but the attacker does not have control over what can be modified, or the scope of what the attacker can affect is limited. For example, system or application files may be overwritten or modified, but either the attacker has no control over which files are affected or the attacker can modify files within only a limited context or scope.";
                    }
                    else if (integrityImpact === "Complete") {
                        integrityImpactDesc = "there is a total compromise of system integrity. There is a complete loss of system protection, resulting in the entire system being compromised. The attacker is able to modify any files on the target system.";
                    }
                    else {
                        integrityImpactDesc = "DESCRIPTION COULD NOT BE FOUND, PLEASE BE CAUTIOUS!";
                    }
                    if (availabilityImpact === "None") {
                        availabilityImpactDesc = "there is no impact to the availability of the system";
                    }
                    else if (availabilityImpact === "Partial") {
                        availabilityImpactDesc = "there is reduced performance or interruptions in resource availability. An example is a network-based flood attack that permits a limited number of successful connections to an Internet service.";
                    }
                    else if (availabilityImpact === "Complete") {
                        availabilityImpactDesc = "there is a total shutdown of the affected resource. The attacker can render the resource completely unavailable.";
                    }
                    else {
                        availabilityImpactDesc = "DESCRIPTION COULD NOT BE FOUND, PLEASE BE CAUTIOUS!";
                    }
                }
                let cweSet = new Set(cweArr);
                cweArr = Array.from(cweSet.values());
                if (cweArr.length === 0) {
                    cweArr.push("Unknown");
                }
                values.sort(); // sort to get highest value as last value
                let highestSeverityVal = values[values.length - 1]; // get last/highest value
                let lowestSeverityval = values[0];
                // get key based on value
                for (let [key, value] of severityMap.entries()) {
                    if (value === highestSeverityVal) {
                        highestSeverity = key;
                    }
                }
                if (typeof baseScore === "number") {
                    totRiskScore.push(baseScore);
                    totRiskScoreSum += baseScore;
                }
                if (typeof adjustedBaseScoreConfHigh === "number") {
                    totRiskScoreConfHigh.push(adjustedBaseScoreConfHigh);
                    totRiskScoreSumConfHigh += adjustedBaseScoreConfHigh;
                }
                if (typeof adjustedBaseScoreConfLow === "number") {
                    totRiskScoreConfLow.push(adjustedBaseScoreConfLow);
                    totRiskScoreSumConfLow += adjustedBaseScoreConfLow;
                }
                if (typeof adjustedBaseScoreIntegHigh === "number") {
                    totRiskScoreIntegHigh.push(adjustedBaseScoreIntegHigh);
                    totRiskScoreSumIntegHigh += adjustedBaseScoreIntegHigh;
                }
                if (typeof adjustedBaseScoreIntegLow === "number") {
                    totRiskScoreIntegLow.push(adjustedBaseScoreIntegLow);
                    totRiskScoreSumIntegLow += adjustedBaseScoreIntegLow;
                }
                if (typeof adjustedBaseScoreAvailHigh === "number") {
                    totRiskScoreAvailHigh.push(adjustedBaseScoreAvailHigh);
                    totRiskScoreSumAvailHigh += adjustedBaseScoreAvailHigh;
                }
                if (typeof adjustedBaseScoreAvailLow === "number") {
                    totRiskScoreAvailLow.push(adjustedBaseScoreAvailLow);
                    totRiskScoreSumAvailLow += adjustedBaseScoreAvailLow;
                }
                let highestScore = Math.max.apply(Math, scores);
                let lowestScore = Math.min.apply(Math, scores);
                // let avgScore: any = parseFloat((scoresSum / scores.length).toFixed(1))+"/10";
                if (scores.length === 0) {
                    highestScore = "Unknown";
                    lowestScore = "Unknown";
                }
                riskScore = baseScore;
                if (baseScore === "Unknown") {
                    riskScore = highestScore;
                }
                riskScore = (0, functions_2.round)(riskScore, 1);
                if (riskScore > 0 && riskScore < 4) {
                    severity = "Low";
                }
                else if (riskScore >= 4 && riskScore < 7) {
                    severity = "Medium";
                }
                else if (riskScore >= 7 && riskScore < 9) {
                    severity = "High";
                }
                else if (riskScore >= 9) {
                    severity = "Critical";
                }
                else {
                    severity = "Unknown";
                }
                // create modal per vulnerable dependency
                let modalId = "modal" + vulnerableCount;
                table += "<div id='" + modalId + "' class='modal'><div class='modal-content'>";
                table += "<span onclick='document.getElementById(`" + modalId + "`).style.display=`none`'class='close'>&times;</span>";
                table += "<h1><b>" + fileName + "</b></h1>";
                table += "<p><b>Location: </b>" + filePath + "</p><br>";
                table += "<h2><b>Vulnerability Info</b></h2>";
                table += "<p><i>This section indicates the overall risk of using the specific dependency.</i></p>";
                if (typeof impactScore === "number") {
                    table += "<p><b>Impact score: </b>" + (0, functions_2.round)(impactScore, 1) + "</p>";
                    table += "<p><i>The higher the impact score, the greater the negative influence when a successful attack is performed </i></p>";
                }
                else {
                    table += "<p><b>Impact score: </b>" + impactScore + "</p>";
                }
                if (typeof exploitScore === "number") {
                    table += "<p><b>Exploit score: </b>" + (0, functions_2.round)(exploitScore, 1) + "</p>";
                    table += "<p><i>The higher the exploit score, the easier an attack could be successfully executed.</i></p>";
                }
                else {
                    table += "<p><b>Exploit score: </b>" + exploitScore + "</p>";
                }
                table += "<p><b>Risk score: </b>" + riskScore + "</p>";
                table += "<p><b>Risk: </b>" + severity + "</p>";
                table += "<p><i>The higher the risk, the more it is recommended to solve the vulnerability that has been found. The higher the risk, the sooner the risk should be addressed to prevent the execution of a successfull attack.</i></p>";
                table += "<br>";
                table += "<h3><b>Access Vector</b></h3>";
                table += "<p><i>This metric indicates via what way an attacker can intrude in a system to be able to perform an attack.</i></p>";
                table += "<p><u>Value: </u>" + accessVector + "</p>";
                table += "<p><i>The greater the distance at which a successful attack is possible between the attacker and the target , the greater the risk. Example: Local access is closer to the target, so the risk is less than when the access vector is network, which is further from the target. </i></p>";
                table += "<p><u>Explanation: </u> The access vector is " + accessVector + ", this means that " + accessVectorDesc + "</p><br>";
                table += "<h3><b>Access Complexity</b></h3>";
                table += "<p><i>This metric indicates the complexity of an attack to be successful.</i></p>";
                table += "<p><u>Value: </u>" + accessComplexity + "</p>";
                table += "<p><i>The lower the complexity, the easier an attack could be successfully executed</i></p>";
                table += "<p><u>Explanation: </u> The access complexity is rated as " + accessComplexity + ", this means that " + accessComplexityDesc + "</p><br>";
                table += "<h3><b>Confidential Impact</b></h3>";
                table += "<p><i>This metric indicates the impact on the confidentiality when an attack is successfully executed.</i></p>";
                table += "<p><u>Value: </u>" + confidentialImpact + "</p>";
                table += "<p><i>The higher the impact, the greater the negative influence when a successful attack is performed</i></p>";
                table += "<p><u>Explanation: </u> The confidential impact is rated as " + confidentialImpact + ", this means that " + confidentialImpactDesc + "</p><br>";
                table += "<p><u>Risk score without priorities: </u>" + riskScore + "</p>";
                table += "<p><u>Risk score priority to confidentiality: </u>" + adjustedBaseScoreConfHigh + "</p>";
                table += "<p><u>Risk score unimportance to confidentiality: </u>" + adjustedBaseScoreConfLow + "</p><br>";
                table += "<h3><b>Integrity Impact</b></h3>";
                table += "<p><i>This metric indicates the impact on the integrity when an attack is successfully executed.</i></p>";
                table += "<p><u>Value: </u>" + integrityImpact + "</p>";
                table += "<p><i>The higher the impact, the greater the negative influence when a successful attack is performed</i></p>";
                table += "<p><u>Explanation: </u> The integrity impact is rated as " + integrityImpact + ", this means that " + integrityImpactDesc + "</p><br>";
                table += "<p><u>Risk score without priorities: </u>" + riskScore + "</p>";
                table += "<p><u>Risk score priority to integrity: </u>" + adjustedBaseScoreIntegHigh + "</p>";
                table += "<p><u>Risk score unimportance to integrity: </u>" + adjustedBaseScoreIntegLow + "</p><br>";
                table += "<h3><b>Availability Impact</b></h3>";
                table += "<p><i>This metric indicates the impact on the availability when an attack is successfully executed.</i></p>";
                table += "<p><u>Value: </u>" + availabilityImpact + "</p>";
                table += "<p><i>The higher the impact, the greater the negative influence when a successful attack is performed</i></p><br>";
                table += "<p><u>Explanation: </u> The availability impact is rated as " + availabilityImpact + ", this means that " + availabilityImpactDesc + "</p>";
                table += "<p><u>Risk score without priorities: </u>" + riskScore + "</p>";
                table += "<p><u>Risk score priority to availability: </u>" + adjustedBaseScoreAvailHigh + "</p>";
                table += "<p><u>Risk score unimportance to availability: </u>" + adjustedBaseScoreAvailLow + "</p><br>";
                table += "<h2><b>Descriptions</b></h2>";
                table += "<p><i>This section shows all descriptions about the vulnerability that have been found.</i></p>";
                for (let i = 0; i < descriptionArr.length; i++) {
                    let desc = descriptionArr[i];
                    let sum = i + 1;
                    table += "<p><b>Description " + sum + ": </b></p>";
                    try {
                        table += (0, md_to_html_1.markdownToHtml)(desc);
                    }
                    catch {
                        table += desc;
                    }
                }
                table += "<br>";
                table += "<br>";
                table += "<h2><b>Weaknesses (CWES)</b></h2>";
                table += "<p><i>This section shows CWE-entries. Clicking on a CWE shows the weakness that has been found, including examples to help understand the problem.</i></p>";
                table += "<ul>";
                for (let item of cweArr) {
                    if (item !== "Unknown") {
                        let cweNum = item.replace("CWE-", "");
                        let url = "https://cwe.mitre.org/data/definitions/" + cweNum + ".html";
                        table += "<li><a href='" + url + "'>" + item + "</a></li>";
                    }
                    else {
                        table += "<li>" + item + "</li>";
                    }
                }
                table += "</ul>";
                table += "<br>";
                table += "<h2><b>References</b></h2>";
                table += "<p><i>This section shows the references of the found vulnerability. These references contain comprehensive information about the vulnerability, sometimes including a solution or patch.</i></p>";
                table += "<ul>";
                for (let item of referenceNames) {
                    table += "<li><a href='" + item + "'>" + item + "</a></li>";
                }
                table += "</ul>";
                table += "<br>";
                table += "<h2><b>Package Info</b></h2>";
                table += "<p><b>Package : </b>" + packageId + "</p>";
                table += "<p><b>Package info: </b><a href=" + packageUrl + ">Learn More</a> (opens in browser)</p><br>";
                table += "</div></div>";
                table += "<td><b>" + "Yes" + "</b></td>";
                if (severity === "Critical") {
                    criticalCount += 1;
                    table += "<td style='background-color: firebrick'><span style='color: white'><b>" + severity.toUpperCase() + "</b></span></td>";
                }
                else if (severity === "High") {
                    highCount += 1;
                    table += "<td style='background-color: red'><span style='color: white'>" + severity + "</span></td>";
                }
                else if (severity === "Medium") {
                    mediumCount += 1;
                    table += "<td style='background-color: orange'><span style='color: white'>" + severity + "</span></td>";
                }
                else if (severity === "Low") {
                    lowCount += 1;
                    table += "<td style='background-color: yellow'><span style='color: black'>" + severity + "</span></td>";
                }
                else if (severity) {
                    table += "<td>" + severity + "</td>";
                }
                else {
                    table += "<td>Unknown</td>";
                }
                table += "<td>" + riskScore + "/10</td>"; // comment
                table += "<td><button onclick='document.getElementById(`" + modalId + "`).style.display=`block`'>Show Details</button></td>";
                table += "</tr>";
            }
            else {
                table += "<td>" + "No" + "</td>";
                table += "<td style='background-color: chartreuse'><span style='color: white'>None</span></td>";
                table += "<td>" + "None" + "</td>";
                table += "</tr>";
                notVulnerableCount += 1;
            }
        }
        dependenciesCount = vulnerableCount + notVulnerableCount;
        vulnerablePercentage = ((vulnerableCount / dependenciesCount) * 100).toPrecision(3);
        output = "";
        projectRisk = (totRiskScoreSum / totRiskScore.length) * (vulnerableCount / dependenciesCount);
        if (projectRisk > 0 && projectRisk < 4) {
            projectRisk = projectRisk.toFixed(1) + "- Low";
        }
        else if (projectRisk >= 4 && projectRisk < 7) {
            projectRisk = projectRisk.toFixed(1) + "- Medium";
        }
        else if (projectRisk >= 7 && projectRisk < 9) {
            projectRisk = projectRisk.toFixed(1) + "- High";
        }
        else if (projectRisk >= 9) {
            projectRisk = projectRisk.toFixed(1) + "- Critical";
        }
        else if (projectRisk === 0) {
            projectRisk = projectRisk.toFixed(1) + "- None";
        }
        else {
            projectRisk = "Unknown";
        }
        projectRiskConfHigh = (totRiskScoreSumConfHigh / totRiskScoreConfHigh.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskConfHigh > 0 && projectRiskConfHigh < 4) {
            projectRiskConfHigh = projectRiskConfHigh.toFixed(1) + "- Low";
        }
        else if (projectRiskConfHigh >= 4 && projectRiskConfHigh < 7) {
            projectRiskConfHigh = projectRiskConfHigh.toFixed(1) + "- Medium";
        }
        else if (projectRiskConfHigh >= 7 && projectRiskConfHigh < 9) {
            projectRiskConfHigh = projectRiskConfHigh.toFixed(1) + "- High";
        }
        else if (projectRiskConfHigh >= 9) {
            projectRiskConfHigh = projectRiskConfHigh.toFixed(1) + "- Critical";
        }
        else if (projectRiskConfHigh === 0) {
            projectRiskConfHigh = projectRiskConfHigh.toFixed(1) + "- None";
        }
        else {
            projectRiskConfHigh = "Unknown";
        }
        projectRiskConfLow = (totRiskScoreSumConfLow / totRiskScoreConfLow.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskConfLow > 0 && projectRiskConfLow < 4) {
            projectRiskConfLow = projectRiskConfLow.toFixed(1) + "- Low";
        }
        else if (projectRiskConfLow >= 4 && projectRiskConfLow < 7) {
            projectRiskConfLow = projectRiskConfLow.toFixed(1) + "- Medium";
        }
        else if (projectRiskConfLow >= 7 && projectRiskConfLow < 9) {
            projectRiskConfLow = projectRiskConfLow.toFixed(1) + "- High";
        }
        else if (projectRiskConfLow >= 9) {
            projectRiskConfLow = projectRiskConfLow.toFixed(1) + "- Critical";
        }
        else if (projectRiskConfLow === 0) {
            projectRiskConfLow = projectRiskConfLow.toFixed(1) + "- None";
        }
        else {
            projectRiskConfLow = "Unknown";
        }
        projectRiskIntegHigh = (totRiskScoreSumIntegHigh / totRiskScoreIntegHigh.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskIntegHigh > 0 && projectRiskIntegHigh < 4) {
            projectRiskIntegHigh = projectRiskIntegHigh.toFixed(1) + "- Low";
        }
        else if (projectRiskIntegHigh >= 4 && projectRiskIntegHigh < 7) {
            projectRiskIntegHigh = projectRiskIntegHigh.toFixed(1) + "- Medium";
        }
        else if (projectRiskIntegHigh >= 7 && projectRiskIntegHigh < 9) {
            projectRiskIntegHigh = projectRiskIntegHigh.toFixed(1) + "- High";
        }
        else if (projectRiskIntegHigh >= 9) {
            projectRiskIntegHigh = projectRiskIntegHigh.toFixed(1) + "- Critical";
        }
        else if (projectRiskIntegHigh === 0) {
            projectRiskIntegHigh = projectRiskIntegHigh.toFixed(1) + "- None";
        }
        else {
            projectRiskIntegHigh = "Unknown";
        }
        projectRiskIntegLow = (totRiskScoreSumIntegLow / totRiskScoreIntegLow.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskIntegLow > 0 && projectRiskIntegLow < 4) {
            projectRiskIntegLow = projectRiskIntegLow.toFixed(1) + "- Low";
        }
        else if (projectRiskIntegLow >= 4 && projectRiskIntegLow < 7) {
            projectRiskIntegLow = projectRiskIntegLow.toFixed(1) + "- Medium";
        }
        else if (projectRiskIntegLow >= 7 && projectRiskIntegLow < 9) {
            projectRiskIntegLow = projectRiskIntegLow.toFixed(1) + "- High";
        }
        else if (projectRiskIntegLow >= 9) {
            projectRiskIntegLow = projectRiskIntegLow.toFixed(1) + "- Critical";
        }
        else if (projectRiskIntegLow === 0) {
            projectRiskIntegLow = projectRiskIntegLow.toFixed(1) + "- None";
        }
        else {
            projectRiskIntegLow = "Unknown";
        }
        projectRiskAvailHigh = (totRiskScoreSumAvailHigh / totRiskScoreAvailHigh.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskAvailHigh > 0 && projectRiskAvailHigh < 4) {
            projectRiskAvailHigh = projectRiskAvailHigh.toFixed(1) + "- Low";
        }
        else if (projectRiskAvailHigh >= 4 && projectRiskAvailHigh < 7) {
            projectRiskAvailHigh = projectRiskAvailHigh.toFixed(1) + "- Medium";
        }
        else if (projectRiskAvailHigh >= 7 && projectRiskAvailHigh < 9) {
            projectRiskAvailHigh = projectRiskAvailHigh.toFixed(1) + "- High";
        }
        else if (projectRiskAvailHigh >= 9) {
            projectRiskAvailHigh = projectRiskAvailHigh.toFixed(1) + "- Critical";
        }
        else if (projectRiskAvailHigh === 0) {
            projectRiskAvailHigh = projectRiskAvailHigh.toFixed(1) + "- None";
        }
        else {
            projectRiskAvailHigh = "Unknown";
        }
        projectRiskAvailLow = (totRiskScoreSumAvailLow / totRiskScoreAvailLow.length) * (vulnerableCount / dependenciesCount);
        if (projectRiskAvailLow > 0 && projectRiskAvailLow < 4) {
            projectRiskAvailLow = projectRiskAvailLow.toFixed(1) + "- Low";
        }
        else if (projectRiskAvailLow >= 4 && projectRiskAvailLow < 7) {
            projectRiskAvailLow = projectRiskAvailLow.toFixed(1) + "- Medium";
        }
        else if (projectRiskAvailLow >= 7 && projectRiskAvailLow < 9) {
            projectRiskAvailLow = projectRiskAvailLow.toFixed(1) + "- High";
        }
        else if (projectRiskAvailLow >= 9) {
            projectRiskAvailLow = projectRiskAvailLow.toFixed(1) + "- Critical";
        }
        else if (projectRiskAvailLow === 0) {
            projectRiskAvailLow = projectRiskAvailLow.toFixed(1) + "- None";
        }
        else {
            projectRiskAvailLow = "Unknown";
        }
        noneCount = (dependenciesCount - vulnerableCount);
    }
    catch {
        let message = "Failed loading results, make sure to run the scan first.";
        vscode.window.showErrorMessage(message);
    }
    return { name, workspace, reportDate, dependencies, table, criticalCount, highCount, mediumCount, lowCount, noneCount, vulnerableCount, notVulnerableCount, dependenciesCount, vulnerablePercentage, projectRisk, projectRiskConfHigh, projectRiskConfLow, projectRiskIntegHigh, projectRiskIntegLow, projectRiskAvailHigh, projectRiskAvailLow, output };
}
exports.parseJson = parseJson;


/***/ }),
/* 3 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.round = exports.workspaceFolder = exports.getNonce = void 0;
const vscode = __webpack_require__(1);
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}
exports.getNonce = getNonce;
function workspaceFolder() {
    var wf = undefined;
    if (vscode.workspace.workspaceFolders !== undefined) {
        wf = (vscode.workspace.workspaceFolders[0].uri.path).substring(1); // substring removes first "/" of the wf path           
    }
    else {
        wf = "None";
    }
    return (wf);
}
exports.workspaceFolder = workspaceFolder;
function round(value, precision) {
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
}
exports.round = round;


/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/**
 * Source: https://gist.github.com/ifiokjr/ef8722805e56086785ae8ab46ca0c261
 *
 * @packageDocumentation
 *
 * Provides the main method used to convert markdown to html.
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.markdownToHtml = void 0;
const core_1 = __webpack_require__(6);
/**
 * Converts the provided markdown to HTML.
 */
function markdownToHtml(markdown) {
    return parse(markdown);
}
exports.markdownToHtml = markdownToHtml;
function parse(text) {
    // clean input
    text = text
        .replace(/[\b\v\f\r]/g, '')
        .replace(/\\./g, (match) => `&#${match.charCodeAt(1)};`);
    let temp = block(text);
    if (temp === text && !temp.match(/^\s*$/i)) {
        temp = inlineBlock(temp)
            // handle paragraphs
            .replace(/((.|\n)+?)(\n\n+|$)/g, (match, text) => tag('p', text));
    }
    return temp.replace(/&#(\d+);/g, (_, code) => String.fromCharCode(Number.parseInt(code, 10)));
}
/**
 * Process the markdown with the rules provided.
 */
function processMarkdown(text, rules, parse) {
    for (const rule of rules) {
        const { regex, replacer } = rule;
        const content = regex.exec(text);
        // No content found for the current rule therefore we can move to the next
        // one.
        if (!content) {
            continue;
        }
        // Keep track of where the original content ended in relation to the text
        // provided.
        const endOfContentIndex = content.index + content[0].length;
        const textBeforeHtmlReplacement = parse(text.slice(0, content.index));
        const textAfterHtmlReplacement = parse(text.slice(endOfContentIndex));
        // The replacement text that has been transformed to HTML.
        let htmlReplacement;
        if ((0, core_1.isString)(replacer)) {
            // String `Replacer`s only support replacing the first digit - like `$1`.
            htmlReplacement = replacer.replace(/\$(\d)/g, (_, firstDigit) => content[firstDigit]);
        }
        else {
            // With function `Replacer`s the whole match and all content is provided
            const [fullMatch, ...rest] = content;
            htmlReplacement = replacer(fullMatch, ...rest);
        }
        return `${textBeforeHtmlReplacement}${htmlReplacement}${textAfterHtmlReplacement}`;
    }
    // No matches found in loop so we can return the text unchanged.
    return text;
}
function inline(text) {
    return processMarkdown(text, [
        // - Bold => `**bold**`
        // - Italic => `*italic*` | `_italic_`
        // - Bold and Italic => `**_mixed_**` TODO this doesn't check for
        //   correctly matching tags.
        {
            regex: /([*_]{1,3})((.|\n)+?)\1/g,
            replacer: (_, tokens, content) => {
                tokens = tokens.length;
                content = inline(content);
                if (tokens > 1) {
                    content = tag('strong', content);
                }
                if (tokens % 2) {
                    content = tag('em', content);
                }
                return content;
            },
        },
        // - Underline => `~underline~`
        // - Strikethrough => `~~strike-through~~`
        // - Delete => `~~~delete~~`
        {
            regex: /(~{1,3})((.|\n)+?)\1/g,
            replacer: (_, tokens, content) => tag(['u', 's', 'del'][tokens.length - 1], inline(content)),
        },
        // - Replace remaining lines with a break tag => `<br />`
        { regex: / {2}\n|\n {2}/g, replacer: '<br />' },
    ], inline);
}
function inlineBlock(text = '', shouldInline = true) {
    // A collection of all the tags created so far.
    const gatheredTags = [];
    function injectInlineBlock(text) {
        return text.replace(/\\(\d+)/g, (match, code) => injectInlineBlock(gatheredTags[Number.parseInt(code, 10) - 1]));
    }
    text = text
        .trim()
        // inline code block
        .replace(/`([^`]*)`/g, (_, text) => `\\${gatheredTags.push(tag('code', encodeHtml(text)))}`)
        // inline media (a / img / iframe)
        .replace(/[!&]?\[([!&]?\[.*?\)|[^\]]*?)]\((.*?)( .*?)?\)|(\w+:\/\/[\w!$'()*+,./-]+)/g, (match, text, href, title, link) => {
        if (link) {
            return shouldInline
                ? `\\${gatheredTags.push(tag('a', link, { href: link }))}`
                : match;
        }
        if (match[0] === '&') {
            text = text.match(/^(.+),(.+),([^ \]]+)( ?.+?)?$/);
            return `\\${gatheredTags.push(tag('iframe', '', {
                width: text[1],
                height: text[2],
                frameborder: text[3],
                class: text[4],
                src: href,
                title,
            }))}`;
        }
        return `\\${gatheredTags.push(match[0] === '!'
            ? tag('img', '', { src: href, alt: text, title })
            : tag('a', inlineBlock(text, false), { href, title }))}`;
    });
    text = injectInlineBlock(shouldInline ? inline(text) : text);
    return text;
}
function block(text) {
    return processMarkdown(text, [
        // comments
        { regex: /<!--((.|\n)*?)-->/g, replacer: '<!--$1-->' },
        // pre format block
        {
            regex: /^("""|```)(.*)\n((.*\n)*?)\1/gm,
            replacer: (_, wrapper, classNames, text) => wrapper === '"""'
                ? tag('div', parse(text), { class: classNames })
                : tag('pre', tag('code', encodeHtml(text), { class: classNames })),
        },
        // blockquotes
        {
            regex: /(^>.*\n?)+/gm,
            replacer: chain('blockquote', /^> ?(.*)$/gm, '$1', inline),
        },
        // tables
        {
            regex: /((^|\n)\|.+)+/g,
            replacer: chain('table', /^.*(\n\|---.*?)?$/gm, (match, subline) => chain('tr', /\|(-?)([^|]+)\1(\|$)?/gm, (match, type, text) => tag(type || subline ? 'th' : 'td', inlineBlock(text)))(match.slice(0, match.length - (subline || '').length))),
        },
        // lists
        { regex: /(?:(^|\n)([+-]|\d+\.) +(.*(\n[\t ]+.*)*))+/g, replacer: list },
        //anchor
        { regex: /#\[([^\]]+?)]/g, replacer: '<a name="$1"></a>' },
        // headlines
        {
            regex: /^(#+) +(.*)$/gm,
            replacer: (_, headerSyntax, headerText) => tag(`h${headerSyntax.length}`, inlineBlock(headerText)),
        },
        // horizontal rule
        { regex: /^(===+|---+)(?=\s*$)/gm, replacer: '<hr>' },
    ], parse);
}
/**
 * Chain string replacement methods and output a function that returns the tag
 * representation of the match.
 */
function chain(tagName, regex, replacer, parser) {
    return (match) => {
        match = match.replace(regex, replacer);
        return tag(tagName, parser ? parser(match) : match);
    };
}
/**
 * Handle lists in markdown.
 */
function list(text) {
    const wrapperTag = text.match(/^[+-]/m) ? 'ul' : 'ol';
    return text
        ? `<${wrapperTag}>${text.replace(/(?:[+-]|\d+\.) +(.*)\n?(([\t ].*\n?)*)/g, (_, listItemText, childList) => `<li>${inlineBlock(`${listItemText}\n${removeIndentation(childList || '').replace(/(?:(^|\n)([+-]|\d+\.) +(.*(\n[\t ]+.*)*))+/g, list)}`)}</li>`)}</${wrapperTag}>`
        : '';
}
/**
 * Encode html tags within the markdown output.
 */
function encodeHtml(text) {
    return text
        ? text.replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
        : '';
}
function removeIndentation(text) {
    return text.replace(new RegExp(`^${(text.match(/^\S?\s+/) || '')[0]}`, 'gm'), '');
}
/**
 * Create a tag with the content provided.
 */
function tag(tag, text, attributes) {
    return `<${tag +
        (attributes
            ? ` ${Object.keys(attributes)
                .map((k) => attributes[k] ? `${k}="${encodeHtml(attributes[k]) || ''}"` : '')
                .join(' ')}`
            : '')}>${text}</${tag}>`;
}


/***/ }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(7);
} else {
  module.exports = __webpack_require__(143);
}


/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _slicedToArray = __webpack_require__(8);
var _objectSpread = __webpack_require__(14);
var _createForOfIteratorHelper = __webpack_require__(16);
var _defineProperty = __webpack_require__(15);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);
var coreUtils = __webpack_require__(36);
var commands = __webpack_require__(116);
var coreTypes = __webpack_require__(120);
var _classPrivateFieldSet = __webpack_require__(91);
var _classPrivateFieldGet = __webpack_require__(94);
var nanoevents = __webpack_require__(126);
var state = __webpack_require__(38);
__webpack_require__(127);
var _applyDecoratedDescriptor = __webpack_require__(128);
var messages = __webpack_require__(68);
var model = __webpack_require__(64);
var _objectWithoutProperties = __webpack_require__(48);
var view = __webpack_require__(129);
var inputrules = __webpack_require__(83);
var keymap = __webpack_require__(132);
var pasteRules = __webpack_require__(137);
var suggest = __webpack_require__(87);

function defaultEquals(valueA, valueB) {
  return valueA === valueB;
}
/**
 * Get the property changes and the next value from an update.
 */


function getChangedOptions(props) {
  var previousOptions = props.previousOptions,
      update = props.update,
      _props$equals = props.equals,
      equals = _props$equals === void 0 ? defaultEquals : _props$equals;
  var next = coreHelpers.freeze(_objectSpread(_objectSpread({}, previousOptions), update));
  var changes = coreHelpers.object();
  var optionKeys = coreHelpers.keys(previousOptions);

  var _iterator = _createForOfIteratorHelper(optionKeys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      var previousValue = previousOptions[key];
      var value = next[key];

      if (equals(previousValue, value)) {
        changes[key] = {
          changed: false
        };
        continue;
      }

      changes[key] = {
        changed: true,
        previousValue,
        value
      };
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var pickChanged = keys => {
    var picked = coreHelpers.object();

    var _iterator2 = _createForOfIteratorHelper(keys),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var key = _step2.value;
        var item = changes[key];

        if (item !== null && item !== void 0 && item.changed) {
          picked[key] = item.value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return picked;
  };

  return {
    changes: coreHelpers.freeze(changes),
    options: next,
    pickChanged
  };
}
({
  [coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES]: 'helper method',
  [coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'command method'
});
/**
 * Checks whether a given string is unique to the set. Add the name if it
 * doesn't already exist, or throw an error when `shouldThrow` is true.
 *
 * @param props - destructured params
 */

function throwIfNameNotUnique(props) {
  var name = props.name,
      set = props.set;
      props.code;
  !!set.has(name) ? coreHelpers.invariant(false) : void 0;
  set.add(name);
}

var IGNORE = '__IGNORE__';
var GENERAL_OPTIONS = '__ALL__';
class BaseClass {
  /**
   * The default options for this extension.
   *
   * TODO see if this can be cast to something other than any and allow
   * composition.
   */

  /**
   * The static keys for this class.
   */

  /**
   * The event handler keys.
   */

  /**
   * Customize the way the handler should behave.
   */

  /**
   * The custom keys.
   */

  /**
   * The unique name of this extension.
   *
   * @remarks
   *
   * Every extension **must** have a name. The name should have a distinct type
   * to allow for better type inference for end users. By convention the name
   * should be `camelCased` and unique within your editor instance.
   *
   * ```ts
   * class SimpleExtension extends Extension {
   *   get name() {
   *     return 'simple' as const;
   *   }
   * }
   * ```
   */

  /**
   * The options for this extension.
   *
   * @remarks
   *
   * Options are composed of Static, Dynamic, Handlers and ObjectHandlers.
   *
   * - `Static` - set at instantiation by the constructor.
   * - `Dynamic` - optionally set at instantiation by the constructor and also
   *   set during the runtime.
   * - `Handlers` - can only be set during the runtime.
   * - `ObjectHandlers` - Can only be set during the runtime of the extension.
   */
  get options() {
    return this._options;
  }
  /**
   * Get the dynamic keys for this extension.
   */


  get dynamicKeys() {
    return this._dynamicKeys;
  }
  /**
   * The options that this instance was created with, merged with all the
   * default options.
   */


  get initialOptions() {
    return this._initialOptions;
  }
  /**
   * The initial options at creation (used to reset).
   */


  constructor(defaultOptions) {
    for (var _len = arguments.length, _ref = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      _ref[_key - 1] = arguments[_key];
    }

    var options = _ref[0];
    this._mappedHandlers = coreHelpers.object();
    this.populateMappedHandlers();
    this._options = this._initialOptions = coreHelpers.deepMerge(defaultOptions, this.constructor.defaultOptions, options !== null && options !== void 0 ? options : coreHelpers.object(), this.createDefaultHandlerOptions());
    this._dynamicKeys = this.getDynamicKeys(); // Triggers the `init` options update for this extension.

    this.init();
  }
  /**
   * This method is called by the extension constructor. It is not strictly a
   * lifecycle method since at this point the manager has not yet been
   * instantiated.
   *
   * @remarks
   *
   * It should be used instead of overriding the constructor which is strongly
   * advised against.
   *
   * There are some limitations when using this method.
   *
   * - Accessing `this.store` will throw an error since the manager hasn't been
   *   created and it hasn't yet been attached to the extensions.
   * - `this.type` in `NodeExtension` and `MarkExtension` will also throw an
   *   error since the schema hasn't been created yet.
   *
   * You should use this to setup any instance properties with the options
   * provided to the extension.
   */


  init() {}
  /**
   * Clone the current instance with the provided options. If nothing is
   * provided it uses the same initial options as the current instance.
   */


  /**
   * Get the dynamic keys for this extension.
   */
  getDynamicKeys() {
    var dynamicKeys = [];
    var _this$constructor = this.constructor,
        customHandlerKeys = _this$constructor.customHandlerKeys,
        handlerKeys = _this$constructor.handlerKeys,
        staticKeys = _this$constructor.staticKeys;

    var _iterator = _createForOfIteratorHelper(coreHelpers.keys(this._options)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key2 = _step.value;

        if (staticKeys.includes(_key2) || handlerKeys.includes(_key2) || customHandlerKeys.includes(_key2)) {
          continue;
        }

        dynamicKeys.push(_key2);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return dynamicKeys;
  }
  /**
   * Throw an error if non dynamic keys are updated.
   */


  ensureAllKeysAreDynamic(update) {
    {
      return;
    }
  }
  /**
   * Update the properties with the provided partial value when changed.
   */


  setOptions(update) {
    var _this$onSetOptions;

    var previousOptions = this.getDynamicOptions();
    this.ensureAllKeysAreDynamic(update);

    var _getChangedOptions = getChangedOptions({
      previousOptions,
      update
    }),
        changes = _getChangedOptions.changes,
        options = _getChangedOptions.options,
        pickChanged = _getChangedOptions.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so the extension can respond to any relevant
    // property updates.

    (_this$onSetOptions = this.onSetOptions) === null || _this$onSetOptions === void 0 ? void 0 : _this$onSetOptions.call(this, {
      reason: 'set',
      changes,
      options,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Reset the extension properties to their default values.
   *
   * @nonVirtual
   */


  resetOptions() {
    var _this$onSetOptions2;

    var previousOptions = this.getDynamicOptions();

    var _getChangedOptions2 = getChangedOptions({
      previousOptions,
      update: this._initialOptions
    }),
        changes = _getChangedOptions2.changes,
        options = _getChangedOptions2.options,
        pickChanged = _getChangedOptions2.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so that child extension properties can also be
    // updated.

    (_this$onSetOptions2 = this.onSetOptions) === null || _this$onSetOptions2 === void 0 ? void 0 : _this$onSetOptions2.call(this, {
      reason: 'reset',
      options,
      changes,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Override this to receive updates whenever the options have been updated on
   * this instance. This method is called after the updates have already been
   * applied to the instance. If you need more control over exactly how the
   * option should be applied you should set the option to be `Custom`.
   *
   * **Please Note**:
   *
   * This must be defined as a instance method and not a property since it is
   * called in the constructor.
   *
   * ```ts
   * class ThisPreset extends Preset {
   *   // GOOD ✅
   *   onSetOptions(props: OnSetOptionsProps<Options>) {}
   *
   *    // BAD ❌
   *   onSetOptions = (props: OnSetOptionsProps<Options>) => {}
   * }
   * ```
   *
   * @abstract
   */


  /**
   * Update the private options.
   */
  getDynamicOptions() {
    return coreHelpers.omit(this._options, [...this.constructor.customHandlerKeys, ...this.constructor.handlerKeys]);
  }
  /**
   * Update the dynamic options.
   */


  updateDynamicOptions(options) {
    this._options = _objectSpread(_objectSpread({}, this._options), options);
  }
  /**
   * Set up the mapped handlers object with default values (an empty array);
   */


  populateMappedHandlers() {
    var _iterator3 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _key4 = _step3.value;
        this._mappedHandlers[_key4] = [];
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  /**
   * This is currently fudged together, I'm not sure it will work.
   */


  createDefaultHandlerOptions() {
    var _this = this;

    var methods = coreHelpers.object();

    var _iterator4 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step4;

    try {
      var _loop = function _loop() {
        var key = _step4.value;

        methods[key] = function () {
          var _handlerKeyOptions$ke;

          var handlerKeyOptions = _this.constructor.handlerKeyOptions;
          var reducer = (_handlerKeyOptions$ke = handlerKeyOptions[key]) === null || _handlerKeyOptions$ke === void 0 ? void 0 : _handlerKeyOptions$ke.reducer;

          for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var returnValue = reducer === null || reducer === void 0 ? void 0 : reducer.getDefault(...args);

          var _iterator5 = _createForOfIteratorHelper(_this._mappedHandlers[key]),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  handler = _step5$value[1];

              var _value = handler(...args);

              returnValue = reducer ? reducer.accumulator(returnValue, _value, ...args) : _value; // Check if the method should cause an early return, based on the
              // return value.

              if (shouldReturnEarly(handlerKeyOptions, returnValue, key)) {
                return returnValue;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          return returnValue;
        };
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    return methods;
  }
  /**
   * Add a handler to the event handlers so that it is called along with all the
   * other handler methods.
   *
   * This is helpful for integrating react hooks which can be used in multiple
   * places. The original problem with fixed properties is that you can only
   * assign to a method once and it overwrites any other methods. This pattern
   * for adding handlers allows for multiple usages of the same handler in the
   * most relevant part of the code.
   *
   * More to come on this pattern.
   *
   * @nonVirtual
   */


  addHandler(key, method) {
    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coreConstants.ExtensionPriority.Default;

    this._mappedHandlers[key].push([priority, method]);

    this.sortHandlers(key); // Return a method for disposing of the handler.

    return () => this._mappedHandlers[key] = this._mappedHandlers[key].filter(_ref2 => {
      var _ref3 = _slicedToArray(_ref2, 2),
          handler = _ref3[1];

      return handler !== method;
    });
  }
  /**
   * Determines if handlers exist for the given key.
   *
   * Checking the existence of a handler property directly gives wrong results.
   * `this.options.onHandlerName` is always truthy because it is a reference to
   * the wrapper function that calls each handler.
   *
   * ```ts
   *
   * // GOOD ✅
   * if (!this.hasHandlers('onHandlerName')) {
   *   return;
   * }
   *
   * // BAD ❌
   * if (!this.options.onHandlerName) {
   *   return;
   * }
   * ```
   *
   * @param key The handler to test
   */


  hasHandlers(key) {
    var _this$_mappedHandlers;

    return ((_this$_mappedHandlers = this._mappedHandlers[key]) !== null && _this$_mappedHandlers !== void 0 ? _this$_mappedHandlers : []).length > 0;
  }

  sortHandlers(key) {
    this._mappedHandlers[key] = coreHelpers.sort(this._mappedHandlers[key], // Sort from highest binding to the lowest.
    (_ref4, _ref5) => {
      var _ref6 = _slicedToArray(_ref4, 1),
          a = _ref6[0];

      var _ref7 = _slicedToArray(_ref5, 1),
          z = _ref7[0];

      return z - a;
    });
  }
  /**
   * A method that can be used to add a custom handler. It is up to the
   * extension creator to manage the handlers and dispose methods.
   */


  addCustomHandler(key, value) {
    var _this$onAddCustomHand, _this$onAddCustomHand2;

    return (_this$onAddCustomHand = (_this$onAddCustomHand2 = this.onAddCustomHandler) === null || _this$onAddCustomHand2 === void 0 ? void 0 : _this$onAddCustomHand2.call(this, {
      [key]: value
    })) !== null && _this$onAddCustomHand !== void 0 ? _this$onAddCustomHand : coreHelpers.noop;
  }
  /**
   * Override this method if you want to set custom handlers on your extension.
   *
   * This must return a dispose function.
   */


}

_defineProperty(BaseClass, "defaultOptions", {});

_defineProperty(BaseClass, "staticKeys", []);

_defineProperty(BaseClass, "handlerKeys", []);

_defineProperty(BaseClass, "handlerKeyOptions", {});

_defineProperty(BaseClass, "customHandlerKeys", []);

/**
 * A function used to determine whether the value provided by the handler
 * warrants an early return.
 */
function shouldReturnEarly(handlerKeyOptions, returnValue, handlerKey) {
  var generalOptions = handlerKeyOptions[GENERAL_OPTIONS];
  var handlerOptions = handlerKeyOptions[handlerKey];

  if (!generalOptions && !handlerOptions) {
    return false;
  } // First check if there are options set for the provided handlerKey


  if (handlerOptions && // Only proceed if the value should not be ignored.
  handlerOptions.earlyReturnValue !== IGNORE && (coreHelpers.isFunction(handlerOptions.earlyReturnValue) ? handlerOptions.earlyReturnValue(returnValue) === true : returnValue === handlerOptions.earlyReturnValue)) {
    return true;
  }

  if (generalOptions && // Only proceed if they are not ignored.
  generalOptions.earlyReturnValue !== IGNORE && ( // Check whether the `earlyReturnValue` is a predicate check.
  coreHelpers.isFunction(generalOptions.earlyReturnValue) ? // If it is a predicate and when called with the current
  // `returnValue` the value is `true` then we should return
  // early.
  generalOptions.earlyReturnValue(returnValue) === true : // Check the actual return value.
  returnValue === generalOptions.earlyReturnValue)) {
    return true;
  }

  return false;
}
/**
 * @internal
 */

/**
 * Auto infers the parameter for the constructor. If there is a required static
 * option then the TypeScript compiler will error if nothing is passed in.
 */

/**
 * Extensions are fundamental to the way that Remirror works by grouping
 * together the functionality and handling the management of similar concerns.
 *
 * @remarks
 *
 *  Extension can adjust editor functionality in any way. Here are some
 *  examples.
 *
 * - How the editor displays certain content, i.e. **bold**, _italic_,
 *   **underline**.
 * - Which commands should be made available e.g. `commands.toggleBold()` to
 *   toggle the weight of the selected text.
 * - Check if a command is currently enabled (i.e a successful dry run) e.g.
 *   `commands.toggleBold.isEnabled()`.
 * - Register Prosemirror `Plugin`s, `keymap`s, `InputRule`s `PasteRule`s,
 *   `Suggestions`, and custom `nodeViews` which affect the behavior of the
 *   editor.
 *
 * There are three types of `Extension`.
 *
 * - `NodeExtension` - For creating Prosemirror nodes in the editor. See
 *   {@link NodeExtension}
 * - `MarkExtension` - For creating Prosemirror marks in the editor. See
 *   {@link MarkExtension}
 * - `PlainExtension` - For behavior which doesn't map to a `ProsemirrorNode` or
 *   `Mark` and as a result doesn't directly affect the Prosemirror `Schema` or
 *   content. See {@link PlainExtension}.
 *
 * This `Extension` is an abstract class that should not be used directly but
 * rather extended to add the intended functionality.
 *
 * ```ts
 * import { PlainExtension, Static } from 'remirror';
 *
 * interface AwesomeExtensionOptions {
 *   isAwesome?: Static<boolean>;
 *   id?: string;
 * }
 *
 * class AwesomeExtension extends PlainExtension<AwesomeExtensionOptions> {
 *   static defaultOptions: DefaultExtensionOptions<AwesomeExtensionOptions> = {
 *     isAwesome: true,
 *     id: '',
 *   }
 *
 *   get name() {
 *     return 'awesome' as const;
 *   }
 * }
 * ```
 */
class Extension extends BaseClass {
  /**
   * The default priority for this family of extensions.
   */

  /**
   * The priority level for this instance of the extension. A higher value
   * corresponds to a higher priority extension
   */
  get priority() {
    var _ref, _this$priorityOverrid;

    return (_ref = (_this$priorityOverrid = this.priorityOverride) !== null && _this$priorityOverrid !== void 0 ? _this$priorityOverrid : this.options.priority) !== null && _ref !== void 0 ? _ref : this.constructor.defaultPriority;
  }
  /**
   * The name that the constructor should have, which doesn't get mangled in
   * production.
   */


  get constructorName() {
    return "".concat(coreHelpers.pascalCase(this.name), "Extension");
  }
  /**
   * The store is a shared object that's internal to each extension. It includes
   * often used items like the `view` and `schema` that are added by the
   * extension manager and also the lifecycle extension methods.
   *
   * **NOTE** - The store is not available until the manager has been created
   * and received the extension. As a result trying to access the store during
   * `init` and `constructor` will result in a runtime error.
   *
   * Some properties of the store are available at different phases. You should
   * check the inline documentation to know when a certain property is useable
   * in your extension.
   */


  get store() {
    !this._store ? coreHelpers.invariant(false) : void 0;
    return coreHelpers.freeze(this._store, {
      requireKeys: true
    });
  }
  /**
   * The list of extensions added to the editor by this `Preset`.
   */


  get extensions() {
    return this._extensions;
  }
  /**
   * Private list of extension stored within this [[`Preset`]].
   */


  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    super(defaultOptions, ...args); // Create the extension list.

    this._extensions = coreHelpers.uniqueBy(this.createExtensions(), // Ensure that all the provided extensions are unique.
    extension => extension.constructor);
    this.extensionMap = new Map(); // Create the extension map for retrieving extensions from the `Preset`

    var _iterator = _createForOfIteratorHelper(this._extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;
        this.extensionMap.set(extension.constructor, extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * When there are duplicate extensions used within the editor the extension
   * manager will call this method and make sure all extension holders are using
   * the same instance of the `ExtensionConstructor`.
   *
   * @internal
   */


  replaceChildExtension(constructor, extension) {
    if (!this.extensionMap.has(constructor)) {
      return;
    }

    this.extensionMap.set(constructor, extension);
    this._extensions = this.extensions.map(currentExtension => extension.constructor === constructor ? extension : currentExtension);
  }
  /**
   * Not for usage. This is purely for types to make it easier to infer
   * available sub extension types.
   *
   * @internal
   */


  /**
   * Create the extensions which will be consumed by the preset. Override this
   * if you would like to make your extension a parent to other (holder)
   * extensions which don't make sense existing outside of the context of this
   * extension.
   *
   * @remarks
   *
   * Since this method is called in the constructor it should always be created
   * as an instance method and not a property. Properties aren't available for
   * the call to the parent class.
   *
   * ```ts
   * class HolderExtension extends PlainExtension {
   *   get name() {
   *     return 'holder'
   *   }
   *
   *   // GOOD ✅
   *   createExtensions() {
   *     return [];
   *   }
   *
   *   // BAD ❌
   *   createExtensions = () => {
   *     return [];
   *   }
   * }
   * ```
   */
  createExtensions() {
    return [];
  }
  /**
   * Get an extension from this holder extension by providing the desired
   * `Constructor`.
   *
   * @param Constructor - the extension constructor to find in the editor.
   *
   * @remarks
   *
   * This method will throw an error if the constructor doesn't exist within the
   * extension created by this extension.
   *
   * It can be used to forward options and attach handlers to the children
   * extensions. It is the spiritual replacement of the `Preset` extension.
   *
   * ```ts
   * import { PlainExtension, OnSetOptionsProps } from 'remirror';
   *
   * interface ParentOptions { weight?: string }
   *
   * class ParentExtension extends PlainExtension<ParentOptions> {
   *   get name() {
   *     return 'parent' as const;
   *   }
   *
   *   createExtensions() {
   *     return [new BoldExtension()]
   *   }
   *
   *   onSetOptions(options: OnSetOptionsProps<ParentOptions>): void {
   *     if (options.changes.weight.changed) {
   *       // Update the value of the provided extension.
   *       this.getExtension(BoldExtension).setOption({ weight: options.changes.weight.value });
   *     }
   *   }
   * }
   * ```
   */


  getExtension(Constructor) {
    var extension = this.extensionMap.get(Constructor); // Throws an error if attempting to get an extension which is not available
    // in this preset.

    !extension ? coreHelpers.invariant(false) : void 0;
    return extension;
  }
  /**
   * Check if the type of this extension's constructor matches the type of the
   * provided constructor.
   */


  isOfType(Constructor) {
    return this.constructor === Constructor;
  }
  /**
   * Pass a reference to the globally shared `ExtensionStore` for this
   * extension.
   *
   * @remarks
   *
   * The extension store allows extensions to access important variables without
   * complicating their creator methods.
   *
   * ```ts
   * import { PlainExtension } from 'remirror';
   *
   * class Awesome extends PlainExtension {
   *   customMethod() {
   *     if (this.store.view.hasFocus()) {
   *       log('dance dance dance');
   *     }
   *   }
   * }
   * ```
   *
   * This should only be called by the `RemirrorManager`.
   *
   * @internal
   * @nonVirtual
   */


  setStore(store) {
    if (this._store) {
      return;
    }

    this._store = store;
  }
  /**
   * Clone an extension.
   */


  clone() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new this.constructor(...args);
  }
  /**
   * Set the priority override for this extension. This is used in the
   * `RemirrorManager` in order to override the priority of an extension.
   *
   * If you set the first parameter to `undefined` it will remove the priority
   * override.
   *
   * @internal
   */


  setPriority(priority) {
    this.priorityOverride = priority;
  }

}
/**
 * Declaration merging since the constructor property can't be defined on the
 * actual class.
 */


_defineProperty(Extension, "defaultPriority", coreConstants.ExtensionPriority.Default);

/**
 * Create a plain extension which doesn't directly map to Prosemirror nodes or
 * marks.
 *
 * Plain extensions are a great way to add custom behavior to your editor.
 */
class PlainExtension extends Extension {
  /** @internal */
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.PlainExtensionConstructor;
  }
  /** @internal */


  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.PlainExtension;
  }

}
/**
 * A mark extension is based on the `Mark` concept from from within prosemirror
 * {@link https://prosemirror.net/docs/guide/#schema.marks}
 *
 * @remarks
 *
 * Marks are used to add extra styling or other information to inline content.
 * Mark types are objects much like node types, used to tag mark objects and
 * provide additional information about them.
 */

class MarkExtension extends Extension {
  /** @internal */
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.MarkExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.MarkExtension;
  }
  /**
   * Provides access to the mark type from the schema.
   *
   * @remarks
   *
   * The type is available as soon as the schema is created by the
   * `SchemaExtension` which has the priority `Highest`. It should be safe to
   * access in any of the lifecycle methods.
   */


  get type() {
    return coreHelpers.assertGet(this.store.schema.marks, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `MarkExtension`.
   *
   * @remarks
   *
   * The main difference between the return value of this method and Prosemirror
   * `MarkSpec` is that that the `toDOM` method doesn't allow dom manipulation.
   * You can only return an array or string.
   *
   * For more advanced requirements, it may be possible to create a `nodeView`
   * to manage the dom interactions.
   */


}

_defineProperty(MarkExtension, "disableExtraAttributes", false);

/**
 * Defines the abstract class for extensions which can place nodes into the
 * prosemirror state.
 *
 * @remarks
 *
 * For more information see {@link https://prosemirror.net/docs/ref/#model.Node}
 */
class NodeExtension extends Extension {
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.NodeExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.NodeExtension;
  }
  /**
   * Provides access to the node type from the schema.
   */


  get type() {
    return coreHelpers.assertGet(this.store.schema.nodes, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `NodeExtension`.
   *
   * @remarks
   *
   * A node schema defines the behavior of the content within the editor. This
   * is very tied to the prosemirror implementation and the best place to learn
   * more about it is in the
   * {@link https://prosemirror.net/docs/guide/#schema docs}.
   *
   * @params hole - a method that is meant to indicate where extra attributes
   * should be placed (if they exist).
   *
   * The `hole` is a function that augments the passed object adding a special
   * `secret` key which is used to insert the extra attributes setter.
   *
   * ```ts
   * import { NodeExtension, SpecHole } from 'remirror';
   *
   * class AwesomeExtension extends NodeExtension {
   *   get name() { return 'awesome' as const'; }
   *
   *   createNodeSpec() {
   *     return {
   *       toDOM: (node) => {
   *         return ['p', hole(), 0]
   *       }
   *     }
   *   }
   * }
   * ```
   *
   * The above example will have the `hole()` method call replaced with the
   * extra attributes.
   */


}

_defineProperty(NodeExtension, "disableExtraAttributes", false);

/**
 * These are the default options merged into every extension. They can be
 * overridden.
 */
var defaultOptions = {
  priority: undefined,
  extraAttributes: {},
  disableExtraAttributes: false,
  exclude: {}
};
/**
 * Mutate the default extension options.
 *
 * @remarks
 *
 * This is a dangerous method since it allows you to mutate the received object.
 * Don't use it unless you absolutely have to.
 *
 * A potential use case is for adding a new default option to all extensions. It
 * shows an example of how to accomplish this in a typesafe way.
 *
 * ```ts
 * import { mutateDefaultExtensionOptions } from 'remirror';
 *
 * mutateDefaultExtensionOptions((settings) => {
 *   // Set the default value of all extensions to have a property `customSetting` with value `false`.
 *   settings.customSetting = false;
 * })
 *
 * declare global {
 *   namespace Remirror {
 *     interface BaseExtensionOptions {
 *       customSetting?: boolean;
 *     }
 *   }
 * }
 *```
 *
 * The mutation must happen before any extension have been instantiated.
 */

function mutateDefaultExtensionOptions(mutatorMethod) {
  mutatorMethod(defaultOptions);
}
/**
 * Determines if the passed value is an extension.
 *
 * @param value - the value to test
 */

function isExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, [coreConstants.RemirrorIdentifier.PlainExtension, coreConstants.RemirrorIdentifier.MarkExtension, coreConstants.RemirrorIdentifier.NodeExtension]);
}
/**
 * Determines if the passed value is an extension constructor.
 *
 * @param value - the value to test
 */

function isExtensionConstructor(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, [coreConstants.RemirrorIdentifier.PlainExtensionConstructor, coreConstants.RemirrorIdentifier.MarkExtensionConstructor, coreConstants.RemirrorIdentifier.NodeExtensionConstructor]);
}
/**
 * Checks whether the provided value is a plain extension.
 *
 * @param value - the extension to check
 */

function isPlainExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.PlainExtension);
}
/**
 * Determines if the passed in extension is a node extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isNodeExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.NodeExtension);
}
/**
 * Determines if the passed in extension is a mark extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isMarkExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.MarkExtension);
}

var _excluded$2 = ["defaultOptions", "customHandlerKeys", "handlerKeys", "staticKeys", "defaultPriority", "handlerKeyOptions"];

/**
 * A decorator for the remirror extension.
 *
 * This adds static properties to the extension constructor.
 */
function extension(options) {
  return ReadonlyConstructor => {
    var _ref, _ref2, _ref3;

    var defaultOptions = options.defaultOptions,
        customHandlerKeys = options.customHandlerKeys,
        handlerKeys = options.handlerKeys,
        staticKeys = options.staticKeys,
        defaultPriority = options.defaultPriority,
        handlerKeyOptions = options.handlerKeyOptions,
        rest = _objectWithoutProperties(options, _excluded$2);

    var Constructor = coreHelpers.Cast(ReadonlyConstructor);

    if (defaultOptions) {
      Constructor.defaultOptions = defaultOptions;
    }

    if (defaultPriority) {
      Constructor.defaultPriority = defaultPriority;
    }

    if (handlerKeyOptions) {
      Constructor.handlerKeyOptions = handlerKeyOptions;
    }

    Constructor.staticKeys = (_ref = staticKeys) !== null && _ref !== void 0 ? _ref : [];
    Constructor.handlerKeys = (_ref2 = handlerKeys) !== null && _ref2 !== void 0 ? _ref2 : [];
    Constructor.customHandlerKeys = (_ref3 = customHandlerKeys) !== null && _ref3 !== void 0 ? _ref3 : [];

    for (var _i = 0, _Object$entries = Object.entries(rest); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (Constructor[key]) {
        continue;
      }

      Constructor[key] = value;
    }

    return coreHelpers.Cast(Constructor);
  };
}
/**
 * @deprecated use `extension` instead.
 */

var extensionDecorator = extension;

/**
 * This extension allows others extension to add the `createAttributes` method
 * for adding attributes to the prosemirror dom element.
 *
 * @remarks
 *
 * Use this to include all the dynamically generated attributes provided by each
 * extension. High priority extensions have preference over the lower priority
 * extensions.
 *
 * @category Builtin Extension
 */

class AttributesExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "attributeList", []);

    _defineProperty(this, "attributeObject", coreHelpers.object());

    _defineProperty(this, "updateAttributes", function () {
      var triggerUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _this.transformAttributes();

      if (triggerUpdate) {
        _this.store.commands.forceUpdate('attributes');
      }
    });
  }

  get name() {
    return 'attributes';
  }

  /**
   * Create the attributes object on initialization.
   *
   * @internal
   */
  onCreate() {
    this.transformAttributes();
    this.store.setExtensionStore('updateAttributes', this.updateAttributes);
  }

  transformAttributes() {
    var _this$store$managerSe;

    this.attributeObject = coreHelpers.object(); // Exit early when the manager excludes these settings.

    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.attributes) {
      this.store.setStoreKey('attributes', this.attributeObject);
      return;
    } // Reset this attributes


    this.attributeList = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$options$ex, _extension$createAttr, _extension$classNames;

        var extension = _step.value;

        if ((_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.attributes) {
          continue;
        }

        var createdAttributes = (_extension$createAttr = extension.createAttributes) === null || _extension$createAttr === void 0 ? void 0 : _extension$createAttr.call(extension);

        var attributes = _objectSpread(_objectSpread({}, createdAttributes), {}, {
          class: coreHelpers.cx(...((_extension$classNames = extension.classNames) !== null && _extension$classNames !== void 0 ? _extension$classNames : []), createdAttributes === null || createdAttributes === void 0 ? void 0 : createdAttributes.class)
        }); // Inserted at the start of the list so that when combining the full
        // attribute object the higher priority extension attributes are
        // preferred to the lower priority since they merge with the object
        // later.


        this.attributeList.unshift(attributes);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(this.attributeList),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _attributes = _step2.value;
        this.attributeObject = _objectSpread(_objectSpread(_objectSpread({}, this.attributeObject), _attributes), {}, {
          class: coreHelpers.cx(this.attributeObject.class, _attributes.class)
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.store.setStoreKey('attributes', this.attributeObject);
  }

}

/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as helpers. This can be used as a replacement for the
 * `createHelpers` method.
 *
 * To allow the TypeScript compiler to automatically infer types, please create
 * your methods with the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { helper, Helper } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @helper()
 *   alwaysTrue(): Helper<boolean> {
 *     return true;
 *   }
 * }
 * ```
 *
 * The above helper can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { helpers } = useRemirrorContext();
 *
 *   return helpers.alwaysTrue() ? <button>My Button</button> : null
 * }
 * ```
 *
 * @category Method Decorator
 */
function helper() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedHelp;

    // Attach the options to the `decoratedCommands` property for this extension.
    ((_target$decoratedHelp = target.decoratedHelpers) !== null && _target$decoratedHelp !== void 0 ? _target$decoratedHelp : target.decoratedHelpers = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as commands. This can be used as a replacement for the
 * `createCommands` method.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createCommands`. Internally the decorators are being used as they are better
 * for documentation purposes.
 *
 * For automated type inference methods that use this decorator must implement
 * the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { command, CommandFunction } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @command() myCommand(text: string): CommandFunction {return ({ tr, dispatch
 *   }) => {dispatch?.(tr.insertText('my command ' + text)); return true;
 *     }
 *   }
 * }
 * ```
 *
 * The above command can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { commands } = useRemirrorContext();
 *
 *   return <button onClick={() => commands.myCommand('hello')}>My Button</button>
 * }
 * ```
 *
 * @category Method Decorator
 */

function command() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedComm;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedComm = target.decoratedCommands) !== null && _target$decoratedComm !== void 0 ? _target$decoratedComm : target.decoratedCommands = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to an extension method to
 * identify as a key binding method. This can be used as a replacement for
 * the `createKeymap` method depending on your preference.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createKeymap`.
 *
 * @category Method Decorator
 */

function keyBinding(options) {
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedKeyb;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedKeyb = target.decoratedKeybindings) !== null && _target$decoratedKeyb !== void 0 ? _target$decoratedKeyb : target.decoratedKeybindings = {})[propertyKey] = options;
  };
}

/**
 * Returns `true` when the provided value is a delayed value.
 */
function isDelayedValue(value) {
  return coreHelpers.isFunction(value) || coreHelpers.isPromise(value);
}
/**
 * Add tentative support for delayed commands in the editor.
 *
 * Delayed commands are commands that run an immediate action, like adding a
 * tracker to a position in the document. Once the promise that is provided is
 * returned the `onDone` parameter is run with the document in the current
 * state. The tracker that was added can now be used to insert content, delete
 * content or replace content.
 *
 * @experimental This is still being worked on and the API is subject to changes
 * in structure going forward.
 *
 * @deprecated use [[`DelayedCommand`]] instead.
 *
 */

function delayedCommand(_ref) {
  var immediate = _ref.immediate,
      promise = _ref.promise,
      onDone = _ref.onDone,
      onFail = _ref.onFail;
  return props => {
    var view = props.view;

    if ((immediate === null || immediate === void 0 ? void 0 : immediate(props)) === false) {
      return false;
    }

    if (!view) {
      return true;
    }

    var deferred = coreHelpers.isFunction(promise) ? promise() : promise;
    deferred.then(value => {
      // Run the command
      onDone({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view,
        value
      });
    }).catch(() => {
      // Run the failure command if it exists.
      onFail === null || onFail === void 0 ? void 0 : onFail({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view
      });
    });
    return true;
  };
}
class DelayedCommand {
  constructor(promiseCreator) {
    _defineProperty(this, "failureHandlers", []);

    _defineProperty(this, "successHandlers", []);

    _defineProperty(this, "validateHandlers", []);

    _defineProperty(this, "generateCommand", () => {
      return props => {
        var isValid = true;
        var view = props.view,
            tr = props.tr,
            dispatch = props.dispatch;

        if (!view) {
          return false;
        }

        var _iterator = _createForOfIteratorHelper(this.validateHandlers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var handler = _step.value;

            if (!handler(_objectSpread(_objectSpread({}, props), {}, {
              dispatch: () => {}
            }))) {
              isValid = false;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (!dispatch || !isValid) {
          return isValid;
        } // Start the promise.


        var deferred = this.promiseCreator(props);
        deferred.then(value => {
          this.runHandlers(this.successHandlers, {
            value,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        }).catch(error => {
          this.runHandlers(this.failureHandlers, {
            error,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        });
        dispatch(tr);
        return true;
      };
    });

    this.promiseCreator = promiseCreator;
  }
  /**
   * The commands that will immediately be run and used to evaluate whether to
   * proceed.
   */


  validate(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.validateHandlers[method](handler);
    return this;
  }
  /**
   * Add a success callback to the handler.
   */


  success(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.successHandlers[method](handler);
    return this;
  }
  /**
   * Add a failure callback to the handler.
   */


  failure(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.failureHandlers[method](handler);
    return this;
  }

  runHandlers(handlers, param) {
    var _param$dispatch;

    var _iterator2 = _createForOfIteratorHelper(handlers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var handler = _step2.value;

        if (!handler(_objectSpread(_objectSpread({}, param), {}, {
          dispatch: () => {}
        }))) {
          break;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    (_param$dispatch = param.dispatch) === null || _param$dispatch === void 0 ? void 0 : _param$dispatch.call(param, param.tr);
  }
  /**
   * Generate the `remirror` command.
   */


}

/**
 * A custom `toggleMark` function that works for the `remirror` codebase.
 *
 * Create a command function that toggles the given mark with the given
 * attributes. Will return `false` when the current selection doesn't support
 * that mark. This will remove the mark if any marks of that type exist in the
 * selection, or add it otherwise. If the selection is empty, this applies to
 * the [stored marks](#state.EditorState.storedMarks) instead of a range of the
 * document.
 *
 * The differences from the `prosemirror-commands` version.
 * - Acts on the transaction rather than the state to allow for commands to be
 *   chained together.
 * - Uses the ONE parameter function signature for compatibility with remirror.
 * - Supports passing a custom range.
 */
function toggleMark(props) {
  var type = props.type,
      attrs = props.attrs,
      range = props.range,
      selection = props.selection;
  return props => {
    var dispatch = props.dispatch,
        tr = props.tr,
        state = props.state;
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;
    !markType ? coreHelpers.invariant(false) : void 0;

    if (range || selection) {
      var _ref2;

      var _getTextSelection = coreUtils.getTextSelection((_ref2 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref2 !== void 0 ? _ref2 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to;

      coreUtils.isMarkActive(_objectSpread({
        trState: tr,
        type
      }, range)) ? dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, to, markType)) : dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, markType.create(attrs)));
      return true;
    }

    return coreUtils.convertCommand(commands.toggleMark(markType, attrs))(props);
  };
}
/**
 * Verifies that the mark type can be applied to the current document.
 */

function markApplies(type, doc, ranges) {
  var _iterator3 = _createForOfIteratorHelper(ranges),
      _step3;

  try {
    var _loop = function _loop() {
      var _step3$value = _step3.value,
          $from = _step3$value.$from,
          $to = _step3$value.$to;
      var markIsAllowed = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
      doc.nodesBetween($from.pos, $to.pos, node => {
        if (markIsAllowed) {
          // This prevents diving deeper into child nodes.
          return false;
        }

        markIsAllowed = node.inlineContent && node.type.allowsMarkType(type);
        return;
      });

      if (markIsAllowed) {
        return {
          v: true
        };
      }
    };

    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ret = _loop();

      if (typeof _ret === "object") return _ret.v;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return false;
}
/**
 * Apply the provided mark type and attributes.
 *
 * @param markType - the mark to apply.
 * @param attrs - the attributes to set on the applied mark.
 * @param selectionPoint - optionally specify where the mark should be applied.
 * Defaults to the current selection.
 */


function applyMark(type, attrs, selectionPoint) {
  return _ref3 => {
    var tr = _ref3.tr,
        dispatch = _ref3.dispatch,
        state = _ref3.state;
    var selection = coreUtils.getTextSelection(selectionPoint !== null && selectionPoint !== void 0 ? selectionPoint : tr.selection, tr.doc);
    var $cursor = coreUtils.getCursor(selection);
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;
    !markType ? coreHelpers.invariant(false) : void 0;

    if (selection.empty && !$cursor || !markApplies(markType, tr.doc, selection.ranges)) {
      return false;
    }

    if (!dispatch) {
      return true;
    }

    if ($cursor) {
      tr.removeStoredMark(markType);

      if (attrs) {
        tr.addStoredMark(markType.create(attrs));
      }

      dispatch(tr);
      return true;
    }

    var containsMark = false;

    var _iterator4 = _createForOfIteratorHelper(selection.ranges),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = _step4.value,
            $from = _step4$value.$from,
            $to = _step4$value.$to;

        if (containsMark) {
          break;
        }

        containsMark = tr.doc.rangeHasMark($from.pos, $to.pos, markType);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var _iterator5 = _createForOfIteratorHelper(selection.ranges),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _step5.value,
            _$from = _step5$value.$from,
            _$to = _step5$value.$to;

        if (containsMark) {
          tr.removeMark(_$from.pos, _$to.pos, markType);
        }

        if (attrs) {
          tr.addMark(_$from.pos, _$to.pos, markType.create(attrs));
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    dispatch(tr);
    return true;
  };
}

/**
 * Insert text into the dom at the current location by default. If a promise is
 * provided then the text will be inserted at the tracked position when the
 * promise is resolved.
 */
function insertText(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _ref4 => {
    var tr = _ref4.tr,
        dispatch = _ref4.dispatch,
        state = _ref4.state;
    var schema = state.schema;
    var selection = tr.selection;
    var _options$from = options.from,
        from = _options$from === void 0 ? selection.from : _options$from,
        _options$to = options.to,
        to = _options$to === void 0 ? from !== null && from !== void 0 ? from : selection.to : _options$to,
        _options$marks = options.marks,
        marks = _options$marks === void 0 ? {} : _options$marks;

    if (!dispatch) {
      return true;
    } // Insert the text


    tr.insertText(text, from, to); // Map the end position after inserting the text to understand what needs to
    // be wrapped with a mark.

    var end = coreHelpers.assertGet(tr.steps, tr.steps.length - 1).getMap().map(to); // Loop through the provided marks to add the mark to the selection. This
    // uses the order of the map you created. If any marks are exclusive, they
    // will override the previous.

    var _iterator6 = _createForOfIteratorHelper(coreHelpers.entries(marks)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            markName = _step6$value[0],
            attributes = _step6$value[1];

        tr.addMark(from, end, coreHelpers.assertGet(schema.marks, markName).create(attributes));
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    dispatch(tr);
    return true;
  };
}

var _dec$a, _dec2$4, _dec3$4, _dec4$4, _dec5$3, _dec6$2, _dec7$2, _dec8$2, _dec9$1, _dec10$1, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$a, _class2$4;
var CommandsExtension = (_dec$a = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest,
  defaultOptions: {
    trackerClassName: 'remirror-tracker-position',
    trackerNodeName: 'span'
  },
  staticKeys: ['trackerClassName', 'trackerNodeName']
}), _dec2$4 = command(), _dec3$4 = command(), _dec4$4 = command(), _dec5$3 = command(), _dec6$2 = command(), _dec7$2 = command(), _dec8$2 = command(), _dec9$1 = command(), _dec10$1 = command(), _dec11 = command(), _dec12 = command(), _dec13 = command(), _dec14 = command(), _dec15 = command(), _dec16 = command(), _dec17 = command(), _dec18 = command(), _dec19 = command(), _dec20 = command(), _dec21 = command(), _dec22 = command(), _dec23 = command(), _dec24 = command(), _dec25 = command({
  description: _ref => {
    var t = _ref.t;
    return t(messages.CoreMessages.SELECT_ALL_DESCRIPTION);
  },
  label: _ref2 => {
    var t = _ref2.t;
    return t(messages.CoreMessages.SELECT_ALL_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.SelectAll
}), _dec26 = command({
  description: _ref3 => {
    var t = _ref3.t;
    return t(messages.CoreMessages.COPY_DESCRIPTION);
  },
  label: _ref4 => {
    var t = _ref4.t;
    return t(messages.CoreMessages.COPY_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Copy,
  icon: 'fileCopyLine'
}), _dec27 = command({
  description: _ref5 => {
    var t = _ref5.t;
    return t(messages.CoreMessages.PASTE_DESCRIPTION);
  },
  label: _ref6 => {
    var t = _ref6.t;
    return t(messages.CoreMessages.PASTE_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Paste,
  icon: 'clipboardLine'
}), _dec28 = command({
  description: _ref7 => {
    var t = _ref7.t;
    return t(messages.CoreMessages.CUT_DESCRIPTION);
  },
  label: _ref8 => {
    var t = _ref8.t;
    return t(messages.CoreMessages.CUT_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Cut,
  icon: 'scissorsFill'
}), _dec29 = command(), _dec30 = helper(), _dec31 = helper(), _dec32 = helper(), _dec$a(_class$a = (_class2$4 = class CommandsExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "decorated", new Map());

    _defineProperty(this, "forceUpdateTransaction", function (tr) {
      var _this$getCommandMeta = _this.getCommandMeta(tr),
          forcedUpdates = _this$getCommandMeta.forcedUpdates;

      for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
      }

      _this.setCommandMeta(tr, {
        forcedUpdates: coreHelpers.uniqueArray([...forcedUpdates, ...keys])
      });

      return tr;
    });
  }

  get name() {
    return 'commands';
  }
  /**
   * The current transaction which allows for making commands chainable.
   *
   * It is shared by all the commands helpers and can even be used in the
   * [[`KeymapExtension`]].
   *
   * @internal
   */


  get transaction() {
    // Make sure we have the most up to date state.
    var state = this.store.getState();

    if (!this._transaction) {
      // Since there is currently no transaction set, make sure to create a new
      // one. Behind the scenes `state.tr` creates a new transaction for us to
      // use.
      this._transaction = state.tr;
    } // Check that the current transaction is valid.


    var isValid = this._transaction.before.eq(state.doc); // Check whether the current transaction has any already applied to it.


    var hasSteps = !coreHelpers.isEmptyArray(this._transaction.steps);

    if (!isValid) {
      // Since the transaction is not valid we create a new one to prevent any
      // `mismatched` transaction errors.
      var _tr = state.tr; // Now checking if any steps had been added to the previous transaction
      // and adding them to the newly created transaction.

      if (hasSteps) {
        var _iterator = _createForOfIteratorHelper(this._transaction.steps),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var step = _step.value;

            _tr.step(step);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } // Make sure to store the transaction value to the instance of this
      // extension.


      this._transaction = _tr;
    }

    return this._transaction;
  }
  /**
   * This is the holder for the shared transaction which is shared by commands
   * in order to support chaining.
   *
   * @internal
   */


  onCreate() {
    this.store.setStoreKey('getForcedUpdates', this.getForcedUpdates.bind(this));
  }
  /**
   * Attach commands once the view is attached.
   */


  onView(view) {
    var _this2 = this;

    var _this$store = this.store,
        extensions = _this$store.extensions,
        helpers = _this$store.helpers;
    var commands = coreHelpers.object();
    var names = new Set();
    var allDecoratedCommands = coreHelpers.object();

    var chain = tr => {
      // This function allows for custom chaining.
      var customChain = coreHelpers.object();

      var getTr = () => tr !== null && tr !== void 0 ? tr : this.transaction;

      var commandChain = [];

      var getChain = () => commandChain;

      for (var _i = 0, _Object$entries = Object.entries(commands); _i < _Object$entries.length; _i++) {
        var _allDecoratedCommands;

        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            name = _Object$entries$_i[0],
            _command = _Object$entries$_i[1];

        if ((_allDecoratedCommands = allDecoratedCommands[name]) !== null && _allDecoratedCommands !== void 0 && _allDecoratedCommands.disableChaining) {
          continue;
        }

        customChain[name] = this.chainedFactory({
          chain: customChain,
          command: _command.original,
          getTr,
          getChain
        });
      }
      /**
       * This function is used in place of the `view.dispatch` method which is
       * passed through to all commands.
       *
       * It is responsible for checking that the transaction which was
       * dispatched is the same as the shared transaction which makes chainable
       * commands possible.
       */


      var dispatch = transaction => {
        // Throw an error if the transaction being dispatched is not the same as
        // the currently stored transaction.
        !(transaction === getTr()) ? coreHelpers.invariant(false) : void 0;
      };

      customChain.run = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var commands = commandChain;
        commandChain = [];

        var _iterator2 = _createForOfIteratorHelper(commands),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var cmd = _step2.value;

            // Exit early when the command returns false and the option is
            // provided.
            if (!cmd(dispatch) && options.exitEarly) {
              return;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        view.dispatch(getTr());
      };

      customChain.tr = () => {
        var commands = commandChain;
        commandChain = [];

        var _iterator3 = _createForOfIteratorHelper(commands),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var cmd = _step3.value;
            cmd(dispatch);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return getTr();
      };

      customChain.enabled = () => {
        var _iterator4 = _createForOfIteratorHelper(commandChain),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var cmd = _step4.value;

            if (!cmd()) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return true;
      };

      return customChain;
    };

    var _iterator5 = _createForOfIteratorHelper(extensions),
        _step5;

    try {
      var _loop = function _loop() {
        var _extension$createComm, _extension$createComm2, _extension$decoratedC;

        var extension = _step5.value;
        var extensionCommands = (_extension$createComm = (_extension$createComm2 = extension.createCommands) === null || _extension$createComm2 === void 0 ? void 0 : _extension$createComm2.call(extension)) !== null && _extension$createComm !== void 0 ? _extension$createComm : {};
        var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
        var active = {}; // Augment the decorated commands.

        allDecoratedCommands = _objectSpread(_objectSpread({}, allDecoratedCommands), {}, {
          decoratedCommands
        });

        var _loop2 = function _loop2() {
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
              commandName = _Object$entries3$_i[0],
              options = _Object$entries3$_i[1];

          var shortcut = coreHelpers.isString(options.shortcut) && options.shortcut.startsWith('_|') ? {
            shortcut: helpers.getNamedShortcut(options.shortcut, extension.options)
          } : undefined;

          _this2.updateDecorated(commandName, _objectSpread(_objectSpread({}, options), {}, {
            name: extension.name
          }, shortcut));

          extensionCommands[commandName] = extension[commandName].bind(extension);

          if (options.active) {
            active[commandName] = () => {
              var _options$active, _options$active2;

              return (_options$active = (_options$active2 = options.active) === null || _options$active2 === void 0 ? void 0 : _options$active2.call(options, extension.options, _this2.store)) !== null && _options$active !== void 0 ? _options$active : false;
            };
          }
        };

        for (var _i3 = 0, _Object$entries3 = Object.entries(decoratedCommands); _i3 < _Object$entries3.length; _i3++) {
          _loop2();
        }

        if (coreHelpers.isEmptyObject(extensionCommands)) {
          return "continue";
        } // Gather the returned commands object from the extension.


        _this2.addCommands({
          active,
          names,
          commands,
          extensionCommands
        });
      };

      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    var chainProperty = chain();

    for (var _i2 = 0, _Object$entries2 = Object.entries(chainProperty); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          key = _Object$entries2$_i[0],
          _command2 = _Object$entries2$_i[1];

      chain[key] = _command2;
    }

    this.store.setStoreKey('commands', commands);
    this.store.setStoreKey('chain', chain);
    this.store.setExtensionStore('commands', commands);
    this.store.setExtensionStore('chain', chain);
  }
  /**
   * Update the cached transaction whenever the state is updated.
   */


  onStateUpdate(_ref9) {
    var state = _ref9.state;
    this._transaction = state.tr;
  }
  /**
   * Create a plugin that solely exists to track forced updates via the
   * generated plugin key.
   */


  createPlugin() {
    return {};
  }
  /**
   * Enable custom commands to be used within the editor by users.
   *
   * This is preferred to the initial idea of setting commands on the
   * manager or even as a prop. The problem is that there's no typechecking
   * and it should be just fine to add your custom commands here to see the
   * dispatched immediately.
   *
   * To use it, firstly define the command.
   *
   * ```ts
   * import { CommandFunction } from 'remirror';
   *
   * const myCustomCommand: CommandFunction = ({ tr, dispatch }) => {
   *   dispatch?.(tr.insertText('My Custom Command'));
   *
   *   return true;
   * }
   * ```
   *
   * And then use it within the component.
   *
   * ```ts
   * import React, { useCallback } from 'react';
   * import { useRemirror } from '@remirror/react';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(myCustomCommand);
   *   }, [commands])
   *
   *   return <button onClick={onClick}>Custom Command</button>
   * }
   * ```
   *
   * An alternative is to use a custom command directly from a
   * `prosemirror-*` library. This can be accomplished in the following way.
   *
   *
   * ```ts
   * import { joinDown } from 'prosemirror-commands';
   * import { convertCommand } from 'remirror';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(convertCommand(joinDown));
   *   }, [commands]);
   *
   *   return <button onClick={onClick}>Custom Command</button>;
   * };
   * ```
   */


  customDispatch(command) {
    return command;
  }
  /**
   * Insert text into the dom at the current location by default. If a
   * promise is provided instead of text the resolved value will be inserted
   * at the tracked position.
   */


  insertText(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (coreHelpers.isString(text)) {
      return insertText(text, options);
    }

    return this.store.createPlaceholderCommand({
      promise: text,
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, range, props) => {
        return this.insertText(value, _objectSpread(_objectSpread({}, options), range))(props);
      }
    }).generateCommand();
  }
  /**
   * Select the text within the provided range.
   *
   * Here are some ways it can be used.
   *
   * ```ts
   * // Set to the end of the document.
   * commands.selectText('end');
   *
   * // Set the selection to the start of the document.
   * commands.selectText('start');
   *
   * // Select all the text in the document.
   * commands.selectText('all')
   *
   * // Select a range of text. It's up to you to make sure the selected
   * // range is valid.
   * commands.selectText({ from: 10, to: 15 });
   *
   * // Specify the anchor and range in the selection.
   * commands.selectText({ anchor: 10, head: 15 });
   *
   * // Set to a specific position.
   * commands.selectText(10);
   *
   * // Use a ProseMirror selection
   * commands.selectText(new TextSelection(state.doc.resolve(10)))
   * ```
   *
   * Although this is called `selectText` you can provide your own selection
   * option which can be any type of selection.
   */


  selectText(selection) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref10 => {
      var tr = _ref10.tr,
          dispatch = _ref10.dispatch;
      var textSelection = coreUtils.getTextSelection(selection, tr.doc); // Check if the selection is unchanged (for example when refocusing on the
      // editor) and if it is, then the text doesn't need to be reselected.

      var selectionUnchanged = tr.selection.anchor === textSelection.anchor && tr.selection.head === textSelection.head;

      if (selectionUnchanged && !options.forceUpdate) {
        // Do nothing if the selection is unchanged.
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(textSelection));
      return true;
    };
  }
  /**
   * Select the link at the current location.
   */


  selectMark(type) {
    return props => {
      var tr = props.tr;
      var range = coreUtils.getMarkRange(tr.selection.$from, type);

      if (!range) {
        return false;
      }

      return this.store.commands.selectText.original({
        from: range.from,
        to: range.to
      })(props);
    };
  }
  /**
   * Delete the provided range or current selection.
   */


  delete(range) {
    return _ref11 => {
      var tr = _ref11.tr,
          dispatch = _ref11.dispatch;

      var _ref12 = range !== null && range !== void 0 ? range : tr.selection,
          from = _ref12.from,
          to = _ref12.to;

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(from, to));
      return true;
    };
  }
  /**
   * Fire an empty update to trigger an update to all decorations, and state
   * that may not yet have run.
   *
   * This can be used in extensions to trigger updates when certain options that
   * affect the editor state have changed.
   *
   * @param action - provide an action which is called just before the empty
   * update is dispatched (only when dispatch is available). This can be used in
   * chainable editor scenarios when you want to lazily invoke an action at the
   * point the update is about to be applied.
   */


  emptyUpdate(action) {
    return _ref13 => {
      var tr = _ref13.tr,
          dispatch = _ref13.dispatch;

      if (dispatch) {
        action === null || action === void 0 ? void 0 : action();
        dispatch(tr);
      }

      return true;
    };
  }
  /**
   * Force an update of the specific updatable ProseMirror props.
   *
   * This command is always available as a builtin command.
   *
   * @category Builtin Command
   */


  forceUpdate() {
    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    return _ref14 => {
      var tr = _ref14.tr,
          dispatch = _ref14.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(this.forceUpdateTransaction(tr, ...keys));
      return true;
    };
  }
  /**
   * Update the attributes for the node at the specified `pos` in the
   * editor.
   *
   * @category Builtin Command
   */


  updateNodeAttributes(pos, attrs) {
    return _ref15 => {
      var tr = _ref15.tr,
          dispatch = _ref15.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setNodeMarkup(pos, undefined, attrs));
      return true;
    };
  }
  /**
   * Set the content of the editor while preserving history.
   *
   * Under the hood this is replacing the content in the document with the new
   * state.doc of the provided content.
   *
   * If the content is a string you will need to ensure you have the proper
   * string handler set up in the editor.
   */


  setContent(content, selection) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var state = this.store.manager.createState({
        content,
        selection
      });

      if (!state) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.replaceRangeWith(0, tr.doc.nodeSize - 2, state.doc));
      return true;
    };
  }
  /**
   * Reset the content of the editor while preserving the history.
   *
   * This means that undo and redo will still be active since the doc is replaced with a new doc.
   */


  resetContent() {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var doc = this.store.manager.createEmptyDoc();

      if (doc) {
        return this.setContent(doc)(props);
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(0, tr.doc.nodeSize));
      return true;
    };
  }
  /**
   * Fire an update to remove the current range selection. The cursor will
   * be placed at the anchor of the current range selection.
   *
   * A range selection is a non-empty text selection.
   *
   * @category Builtin Command
   */


  emptySelection() {
    return _ref16 => {
      var tr = _ref16.tr,
          dispatch = _ref16.dispatch;

      if (tr.selection.empty) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(state.TextSelection.create(tr.doc, tr.selection.anchor)));
      return true;
    };
  }
  /**
   * Insert a new line into the editor.
   *
   * Depending on editor setup and where the cursor is placed this may have
   * differing impacts.
   *
   * @category Builtin Command
   */


  insertNewLine() {
    return _ref17 => {
      var dispatch = _ref17.dispatch,
          tr = _ref17.tr;

      if (!coreUtils.isTextSelection(tr.selection)) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.insertText('\n'));
      return true;
    };
  }
  /**
   * Insert a node into the editor with the provided content.
   *
   * @category Builtin Command
   */


  insertNode(node) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref18 => {
      var _ref19, _options$marks;

      var dispatch = _ref18.dispatch,
          tr = _ref18.tr,
          state = _ref18.state;
      var attrs = options.attrs,
          range = options.range,
          selection = options.selection,
          _options$replaceEmpty = options.replaceEmptyParentBlock,
          replaceEmptyParentBlock = _options$replaceEmpty === void 0 ? false : _options$replaceEmpty;

      var _getTextSelection = coreUtils.getTextSelection((_ref19 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref19 !== void 0 ? _ref19 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to,
          $from = _getTextSelection.$from;

      if (coreUtils.isProsemirrorNode(node) || coreUtils.isProsemirrorFragment(node)) {
        var pos = $from.before($from.depth);
        dispatch === null || dispatch === void 0 ? void 0 : dispatch(replaceEmptyParentBlock && from === to && coreUtils.isEmptyBlockNode($from.parent) ? tr.replaceWith(pos, pos + $from.parent.nodeSize, node) : tr.replaceWith(from, to, node));
        return true;
      }

      var nodeType = coreHelpers.isString(node) ? state.schema.nodes[node] : node;
      !nodeType ? coreHelpers.invariant(false) : void 0;
      var marks = (_options$marks = options.marks) === null || _options$marks === void 0 ? void 0 : _options$marks.map(mark => {
        if (mark instanceof model.Mark) {
          return mark;
        }

        var markType = coreHelpers.isString(mark) ? state.schema.marks[mark] : mark;
        !markType ? coreHelpers.invariant(false) : void 0;
        return markType.create();
      });
      var content = nodeType.createAndFill(attrs, coreHelpers.isString(options.content) ? state.schema.text(options.content) : options.content, marks);

      if (!content) {
        return false;
      } // This should not be treated as a replacement.


      var isReplacement = from !== to;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(isReplacement ? tr.replaceRangeWith(from, to, content) : tr.insert(from, content));
      return true;
    };
  }
  /**
   * Set the focus for the editor.
   *
   * If using this with chaining this should only be placed at the end of
   * the chain. It can cause hard to debug issues when used in the middle of
   * a chain.
   *
   * ```tsx
   * import { useCallback } from 'react';
   * import { useRemirrorContext } from '@remirror/react';
   *
   * const MenuButton = () => {
   *   const { chain } = useRemirrorContext();
   *   const onClick = useCallback(() => {
   *     chain
   *       .toggleBold()
   *       .focus('end')
   *       .run();
   *   }, [chain])
   *
   *   return <button onClick={onClick}>Bold</button>
   * }
   * ```
   */


  focus(position) {
    return props => {
      var dispatch = props.dispatch,
          tr = props.tr;
      var view = this.store.view;

      if (position === false) {
        return false;
      }

      if (view.hasFocus() && (position === undefined || position === true)) {
        return false;
      } // Keep the current selection when position is `true` or `undefined`.


      if (position === undefined || position === true) {
        var _tr$selection = tr.selection,
            _tr$selection$from = _tr$selection.from,
            from = _tr$selection$from === void 0 ? 0 : _tr$selection$from,
            _tr$selection$to = _tr$selection.to,
            to = _tr$selection$to === void 0 ? from : _tr$selection$to;
        position = {
          from,
          to
        };
      }

      if (dispatch) {
        // Focus only when dispatch is provided.
        this.delayedFocus();
      }

      return this.selectText(position)(props);
    };
  }
  /**
   * Blur focus from the editor and also update the selection at the same
   * time.
   */


  blur(position) {
    return props => {
      var view = this.store.view;

      if (!view.hasFocus()) {
        return false;
      }

      requestAnimationFrame(() => {
        view.dom.blur();
      });
      return position ? this.selectText(position)(props) : true;
    };
  }
  /**
   * Set the block type of the current selection or the provided range.
   *
   * @param nodeType - the node type to create
   * @param attrs - the attributes to add to the node type
   * @param selection - the position in the document to set the block node
   * @param preserveAttrs - when true preserve the attributes at the provided selection
   */


  setBlockNodeType(nodeType, attrs, selection) {
    var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    return coreUtils.setBlockType(nodeType, attrs, selection, preserveAttrs);
  }
  /**
   * Toggle between wrapping an inactive node with the provided node type, and
   * lifting it up into it's parent.
   *
   * @param nodeType - the node type to toggle
   * @param attrs - the attrs to use for the node
   * @param selection - the selection point in the editor to perform the action
   */


  toggleWrappingNode(nodeType, attrs, selection) {
    return coreUtils.toggleWrap(nodeType, attrs, selection);
  }
  /**
   * Toggle a block between the provided type and toggleType.
   */


  toggleBlockNodeItem(toggleProps) {
    return coreUtils.toggleBlockItem(toggleProps);
  }
  /**
   * Wrap the selection or the provided text in a node of the given type with the
   * given attributes.
   */


  wrapInNode(nodeType, attrs, range) {
    return coreUtils.wrapIn(nodeType, attrs, range);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  applyMark(markType, attrs, selection) {
    return applyMark(markType, attrs, selection);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  toggleMark(props) {
    return toggleMark(props);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  removeMark(props) {
    return coreUtils.removeMark(props);
  }
  /**
   * Set the meta data to attach to the editor on the next update.
   */


  setMeta(name, value) {
    return _ref20 => {
      var tr = _ref20.tr;
      tr.setMeta(name, value);
      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  selectAll() {
    return this.selectText('all');
  }
  /**
   * Copy the selected content for non empty selections.
   */


  copy() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('copy');
      }

      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  paste() {
    // Todo check if the permissions are supported first.
    // navigator.permissions.query({name: 'clipboard'})
    return this.store.createPlaceholderCommand({
      // TODO https://caniuse.com/?search=clipboard.read - once browser support is sufficient.
      promise: () => navigator.clipboard.readText(),
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, selection, props) => {
        return this.insertNode(coreUtils.htmlToProsemirrorNode({
          content: value,
          schema: props.state.schema
        }), {
          selection
        })(props);
      }
    }).generateCommand();
  }
  /**
   * Cut the selected content.
   */


  cut() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('cut');
      }

      return true;
    };
  }
  /**
   * Replaces text with an optional appended string at the end. The replacement
   * can be text, or a custom node.
   *
   * @param props - see [[`ReplaceTextProps`]]
   */


  replaceText(props) {
    return coreUtils.replaceText(props);
  }
  /**
   * Get the all the decorated commands available on the editor instance.
   */


  getAllCommandOptions() {
    var uiCommands = {};

    var _iterator6 = _createForOfIteratorHelper(this.decorated),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            name = _step6$value[0],
            options = _step6$value[1];

        if (coreHelpers.isEmptyObject(options)) {
          continue;
        }

        uiCommands[name] = options;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return uiCommands;
  }
  /**
   * Get the options that were passed into the provided command.
   */


  getCommandOptions(name) {
    return this.decorated.get(name);
  }
  /**
   * A short hand way of getting the `view`, `state`, `tr` and `dispatch`
   * methods.
   */


  getCommandProp() {
    return {
      tr: this.transaction,
      dispatch: this.store.view.dispatch,
      state: this.store.view.state,
      view: this.store.view
    };
  }
  /**
   * Update the command options via a shallow merge of the provided options. If
   * no options are provided the entry is deleted.
   *
   * @internal
   */


  updateDecorated(name, options) {
    var _this$decorated$get;

    if (!options) {
      this.decorated.delete(name);
      return;
    }

    var decoratorOptions = (_this$decorated$get = this.decorated.get(name)) !== null && _this$decorated$get !== void 0 ? _this$decorated$get : {
      name: ''
    };
    this.decorated.set(name, _objectSpread(_objectSpread({}, decoratorOptions), options));
  }
  /**
   * Needed on iOS since `requestAnimationFrame` doesn't breaks the focus
   * implementation.
   */


  handleIosFocus() {
    if (!coreUtils.environment.isIos) {
      return;
    }

    this.store.view.dom.focus();
  }
  /**
   * Focus the editor after a slight delay.
   */


  delayedFocus() {
    // Manage focus on iOS.
    this.handleIosFocus();
    requestAnimationFrame(() => {
      // Use the built in focus method to refocus the editor.
      this.store.view.focus(); // This has to be called again in order for Safari to scroll into view
      // after the focus. Perhaps there's a better way though or maybe place
      // behind a flag.

      this.store.view.dispatch(this.transaction.scrollIntoView());
    });
  }
  /**
   * A helper for forcing through updates in the view layer. The view layer can
   * check for the meta data of the transaction with
   * `manager.store.getForcedUpdate(tr)`. If that has a value then it should use
   * the unique symbol to update the key.
   */


  /**
   * Check for a forced update in the transaction. This pulls the meta data
   * from the transaction and if it is true then it was a forced update.
   *
   * ```ts
   * import { CommandsExtension } from 'remirror/extensions';
   *
   * const commandsExtension = manager.getExtension(CommandsExtension);
   * log(commandsExtension.getForcedUpdates(tr))
   * ```
   *
   * This can be used for updating:
   *
   * - `nodeViews`
   * - `editable` status of the editor
   * - `attributes` - for the top level node
   *
   * @internal
   */
  getForcedUpdates(tr) {
    return this.getCommandMeta(tr).forcedUpdates;
  }
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_COMMAND_META), meta);
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add the commands from the provided `commands` property to the `chained`,
   * `original` and `unchained` objects.
   */


  addCommands(props) {
    var extensionCommands = props.extensionCommands,
        commands = props.commands,
        names = props.names,
        active = props.active;

    var _iterator7 = _createForOfIteratorHelper(coreHelpers.entries(extensionCommands)),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _step7$value = _slicedToArray(_step7.value, 2),
            name = _step7$value[0],
            _command3 = _step7$value[1];

        // Command names must be unique.
        throwIfNameNotUnique({
          name,
          set: names,
          code: coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES
        }); // Make sure the command name is not forbidden.

        !!forbiddenNames.has(name) ?          false ? 0 : coreHelpers.invariant(false) : void 0; // Create the unchained command.

        commands[name] = this.createUnchainedCommand(_command3, active[name]);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  /**
   * Create an unchained command method.
   */


  unchainedFactory(props) {
    var _this3 = this;

    return function () {
      var _props$shouldDispatch = props.shouldDispatch,
          shouldDispatch = _props$shouldDispatch === void 0 ? true : _props$shouldDispatch,
          command = props.command;
      var view = _this3.store.view;
      var state = view.state;
      var dispatch;

      if (shouldDispatch) {
        dispatch = view.dispatch;
      }

      return command(...arguments)({
        state,
        dispatch,
        view,
        tr: state.tr
      });
    };
  }
  /**
   * Create the unchained command.
   */


  createUnchainedCommand(command, active) {
    var unchainedCommand = this.unchainedFactory({
      command
    });
    unchainedCommand.enabled = this.unchainedFactory({
      command,
      shouldDispatch: false
    });
    unchainedCommand.isEnabled = unchainedCommand.enabled;
    unchainedCommand.original = command;
    unchainedCommand.active = active;
    return unchainedCommand;
  }
  /**
   * Create a chained command method.
   */


  chainedFactory(props) {
    var _this4 = this;

    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var chained = props.chain,
          command = props.command,
          getTr = props.getTr,
          getChain = props.getChain;
      var lazyChain = getChain();
      var view = _this4.store.view;
      var state = view.state;
      lazyChain.push(dispatch => {
        return command(...args)({
          state,
          dispatch,
          view,
          tr: getTr()
        });
      });
      return chained;
    };
  }

}, (_applyDecoratedDescriptor(_class2$4.prototype, "customDispatch", [_dec2$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "customDispatch"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertText", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectText", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectMark", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "delete", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "delete"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptyUpdate", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptyUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "forceUpdate", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "forceUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "updateNodeAttributes", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "updateNodeAttributes"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setContent", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "resetContent", [_dec11], Object.getOwnPropertyDescriptor(_class2$4.prototype, "resetContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptySelection", [_dec12], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptySelection"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNewLine", [_dec13], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNewLine"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNode", [_dec14], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "focus", [_dec15], Object.getOwnPropertyDescriptor(_class2$4.prototype, "focus"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "blur", [_dec16], Object.getOwnPropertyDescriptor(_class2$4.prototype, "blur"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setBlockNodeType", [_dec17], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setBlockNodeType"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleWrappingNode", [_dec18], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleWrappingNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleBlockNodeItem", [_dec19], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleBlockNodeItem"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "wrapInNode", [_dec20], Object.getOwnPropertyDescriptor(_class2$4.prototype, "wrapInNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "applyMark", [_dec21], Object.getOwnPropertyDescriptor(_class2$4.prototype, "applyMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleMark", [_dec22], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "removeMark", [_dec23], Object.getOwnPropertyDescriptor(_class2$4.prototype, "removeMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setMeta", [_dec24], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setMeta"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectAll", [_dec25], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectAll"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "copy", [_dec26], Object.getOwnPropertyDescriptor(_class2$4.prototype, "copy"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "paste", [_dec27], Object.getOwnPropertyDescriptor(_class2$4.prototype, "paste"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "cut", [_dec28], Object.getOwnPropertyDescriptor(_class2$4.prototype, "cut"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "replaceText", [_dec29], Object.getOwnPropertyDescriptor(_class2$4.prototype, "replaceText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getAllCommandOptions", [_dec30], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getAllCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandOptions", [_dec31], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandProp", [_dec32], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandProp"), _class2$4.prototype)), _class2$4)) || _class$a);
var DEFAULT_COMMAND_META = {
  forcedUpdates: []
};
/**
 * Provides the list of Prosemirror EditorView props that should be updated/
 */

/**
 * The names that are forbidden from being used as a command name.
 */
var forbiddenNames = new Set(['run', 'chain', 'original', 'raw', 'enabled', 'tr']);

var _excluded$1 = ["nodeName", "className"];

var _dec$9, _dec2$3, _dec3$3, _dec4$3, _dec5$2, _dec6$1, _dec7$1, _dec8$1, _class$9, _class2$3;
var DecorationsExtension = (_dec$9 = extension({
  defaultOptions: {
    persistentSelectionClass: undefined,
    placeholderClassName: 'placeholder',
    placeholderNodeName: 'span'
  },
  staticKeys: ['placeholderClassName', 'placeholderNodeName'],
  handlerKeys: ['decorations'],
  handlerKeyOptions: {
    decorations: {
      reducer: {
        accumulator: (accumulated, latestValue, state) => {
          return accumulated.add(state.doc, latestValue.find());
        },
        getDefault: () => view.DecorationSet.empty
      }
    }
  },
  defaultPriority: coreConstants.ExtensionPriority.Low
}), _dec2$3 = command(), _dec3$3 = command(), _dec4$3 = command(), _dec5$2 = command(), _dec6$1 = command(), _dec7$1 = helper(), _dec8$1 = helper(), _dec$9(_class$9 = (_class2$3 = class DecorationsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "placeholders", view.DecorationSet.empty);

    _defineProperty(this, "placeholderWidgets", new Map());

    _defineProperty(this, "createPlaceholderCommand", props => {
      var id = coreHelpers.uniqueId();
      var promise = props.promise,
          placeholder = props.placeholder,
          onFailure = props.onFailure,
          onSuccess = props.onSuccess;
      return new DelayedCommand(promise).validate(props => {
        return this.addPlaceholder(id, placeholder)(props);
      }).success(props => {
        var state = props.state,
            tr = props.tr,
            dispatch = props.dispatch,
            view = props.view,
            value = props.value;
        var range = this.store.helpers.findPlaceholder(id);

        if (!range) {
          var _onFailure;

          var error = new Error('The placeholder has been removed');
          return (_onFailure = onFailure === null || onFailure === void 0 ? void 0 : onFailure({
            error,
            state,
            tr,
            dispatch,
            view
          })) !== null && _onFailure !== void 0 ? _onFailure : false;
        }

        this.removePlaceholder(id)({
          state,
          tr,
          view,
          dispatch: () => {}
        });
        return onSuccess(value, range, {
          state,
          tr,
          dispatch,
          view
        });
      }).failure(props => {
        var _onFailure2;

        this.removePlaceholder(id)(_objectSpread(_objectSpread({}, props), {}, {
          dispatch: () => {}
        }));
        return (_onFailure2 = onFailure === null || onFailure === void 0 ? void 0 : onFailure(props)) !== null && _onFailure2 !== void 0 ? _onFailure2 : false;
      });
    });
  }

  get name() {
    return 'decorations';
  }
  /**
   * The placeholder decorations.
   */


  onCreate() {
    this.store.setExtensionStore('createPlaceholderCommand', this.createPlaceholderCommand);
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createPlugin() {
    var _this = this;

    return {
      state: {
        init: () => {},
        apply: tr => {
          // Get tracker updates from the meta data
          var _this$getMeta = this.getMeta(tr),
              added = _this$getMeta.added,
              clearTrackers = _this$getMeta.clearTrackers,
              removed = _this$getMeta.removed,
              updated = _this$getMeta.updated;

          if (clearTrackers) {
            this.placeholders = view.DecorationSet.empty;

            var _iterator = _createForOfIteratorHelper(this.placeholderWidgets),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _widget$spec$onDestro, _widget$spec;

                var _step$value = _slicedToArray(_step.value, 2),
                    widget = _step$value[1];

                (_widget$spec$onDestro = (_widget$spec = widget.spec).onDestroy) === null || _widget$spec$onDestro === void 0 ? void 0 : _widget$spec$onDestro.call(_widget$spec, this.store.view, widget.spec.element);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            this.placeholderWidgets.clear();
            return;
          }

          this.placeholders = this.placeholders.map(tr.mapping, tr.doc, {
            onRemove: spec => {
              // Remove any removed widgets.
              var widget = this.placeholderWidgets.get(spec.id);

              if (widget) {
                var _widget$spec$onDestro2, _widget$spec2;

                (_widget$spec$onDestro2 = (_widget$spec2 = widget.spec).onDestroy) === null || _widget$spec$onDestro2 === void 0 ? void 0 : _widget$spec$onDestro2.call(_widget$spec2, this.store.view, widget.spec.element);
              }
            }
          });

          var _iterator2 = _createForOfIteratorHelper(this.placeholderWidgets),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _widget$spec$onUpdate, _widget$spec3;

              var _step2$value = _slicedToArray(_step2.value, 2),
                  _widget = _step2$value[1];

              (_widget$spec$onUpdate = (_widget$spec3 = _widget.spec).onUpdate) === null || _widget$spec$onUpdate === void 0 ? void 0 : _widget$spec$onUpdate.call(_widget$spec3, this.store.view, _widget.from, _widget.spec.element, _widget.spec.data);
            } // Update the decorations with any added position trackers.

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _iterator3 = _createForOfIteratorHelper(added),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var placeholder = _step3.value;

              if (placeholder.type === 'inline') {
                this.addInlinePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'node') {
                this.addNodePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'widget') {
                this.addWidgetPlaceholder(placeholder, tr);
                continue;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var _iterator4 = _createForOfIteratorHelper(updated),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _step4.value,
                  id = _step4$value.id,
                  _data = _step4$value.data;

              var _widget2 = this.placeholderWidgets.get(id); // Only support updating widget decorations.


              if (!_widget2) {
                continue;
              }

              var updatedWidget = view.Decoration.widget(_widget2.from, _widget2.spec.element, _objectSpread(_objectSpread({}, _widget2.spec), {}, {
                data: _data
              }));
              this.placeholders = this.placeholders.remove([_widget2]).add(tr.doc, [updatedWidget]);
              this.placeholderWidgets.set(id, updatedWidget);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var _iterator5 = _createForOfIteratorHelper(removed),
              _step5;

          try {
            var _loop = function _loop() {
              var id = _step5.value;

              var found = _this.placeholders.find(undefined, undefined, spec => spec.id === id && spec.__type === __type);

              var widget = _this.placeholderWidgets.get(id);

              if (widget) {
                var _widget$spec$onDestro3, _widget$spec4;

                (_widget$spec$onDestro3 = (_widget$spec4 = widget.spec).onDestroy) === null || _widget$spec$onDestro3 === void 0 ? void 0 : _widget$spec$onDestro3.call(_widget$spec4, _this.store.view, widget.spec.element);
              }

              _this.placeholders = _this.placeholders.remove(found);

              _this.placeholderWidgets.delete(id);
            };

            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      },
      props: {
        decorations: state => {
          var decorationSet = this.options.decorations(state);
          decorationSet = decorationSet.add(state.doc, this.placeholders.find());

          var _iterator6 = _createForOfIteratorHelper(this.store.extensions),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _extension = _step6.value;

              // Skip this extension when the method doesn't exist.
              if (!_extension.createDecorations) {
                continue;
              }

              var decorations = _extension.createDecorations(state).find();

              decorationSet = decorationSet.add(state.doc, decorations);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return decorationSet;
        },
        handleDOMEvents: {
          // Dispatch a transaction for focus/blur events so that the editor state
          // can be refreshed.
          //
          // https://discuss.prosemirror.net/t/handling-focus-in-plugins/1981/2
          blur: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, false));
            }

            return false;
          },
          focus: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, true));
            }

            return false;
          }
        }
      }
    };
  }

  updateDecorations() {
    return _ref => {
      var tr = _ref.tr,
          dispatch = _ref.dispatch;
      return dispatch !== null && dispatch !== void 0 && dispatch(tr), true;
    };
  }
  /**
   * Command to dispatch a transaction adding the placeholder decoration to
   * be tracked.
   *
   * @param id - the value that is used to identify this tracker. This can
   * be any value. A promise, a function call, a string.
   * @param options - the options to call the tracked position with. You can
   * specify the range `{ from: number; to: number }` as well as the class
   * name.
   */


  addPlaceholder(id, placeholder, deleteSelection) {
    return _ref2 => {
      var dispatch = _ref2.dispatch,
          tr = _ref2.tr;
      return this.addPlaceholderTransaction(id, placeholder, tr, !dispatch) ? (dispatch !== null && dispatch !== void 0 && dispatch(deleteSelection ? tr.deleteSelection() : tr), true) : false;
    };
  }
  /**
   * A command to updated the placeholder decoration.
   *
   * To update multiple placeholders you can use chained commands.
   *
   * ```ts
   * let idsWithData: Array<{id: unknown, data: number}>;
   *
   * for (const { id, data } of idsWithData) {
   *   chain.updatePlaceholder(id, data);
   * }
   *
   * chain.run();
   * ```
   */


  updatePlaceholder(id, data) {
    return _ref3 => {
      var dispatch = _ref3.dispatch,
          tr = _ref3.tr;
      return this.updatePlaceholderTransaction({
        id,
        data,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove the specified placeholder decoration.
   */


  removePlaceholder(id) {
    return _ref4 => {
      var dispatch = _ref4.dispatch,
          tr = _ref4.tr;
      return this.removePlaceholderTransaction({
        id,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove all active placeholder decorations.
   */


  clearPlaceholders() {
    return _ref5 => {
      var tr = _ref5.tr,
          dispatch = _ref5.dispatch;
      return this.clearPlaceholdersTransaction({
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * Find the position for the tracker with the ID specified.
   *
   * @param id - the unique position id which can be any type
   */


  findPlaceholder(id) {
    return this.findAllPlaceholders().get(id);
  }
  /**
   * Find the positions of all the trackers in document.
   */


  findAllPlaceholders() {
    var trackers = new Map();
    var found = this.placeholders.find(undefined, undefined, spec => spec.__type === __type);

    var _iterator7 = _createForOfIteratorHelper(found),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var decoration = _step7.value;
        trackers.set(decoration.spec.id, {
          from: decoration.from,
          to: decoration.to
        });
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return trackers;
  }
  /**
   * Add some decorations based on the provided settings.
   */


  createDecorations(state) {
    var _this$store$view, _this$store$helpers$i, _this$store$helpers;

    var persistentSelectionClass = this.options.persistentSelectionClass; // Only show the selection decoration when the view doesn't have focus.
    // Notice that we need to listen to the focus/blur DOM events to make
    // it work since the focus state is not stored in `EditorState`.

    if (!persistentSelectionClass || (_this$store$view = this.store.view) !== null && _this$store$view !== void 0 && _this$store$view.hasFocus() || (_this$store$helpers$i = (_this$store$helpers = this.store.helpers).isInteracting) !== null && _this$store$helpers$i !== void 0 && _this$store$helpers$i.call(_this$store$helpers)) {
      return view.DecorationSet.empty;
    } // Add the selection decoration to the decorations array.


    return generatePersistentSelectionDecorations(state, view.DecorationSet.empty, {
      class: coreHelpers.isString(persistentSelectionClass) ? persistentSelectionClass : 'selection'
    });
  }
  /**
   * This stores all tracked positions in the editor and maps them via the
   * transaction updates.
   */


  onApplyState() {}
  /**
   * Add a widget placeholder and track it as a widget placeholder.
   */


  addWidgetPlaceholder(placeholder, tr) {
    var _createElement;

    var pos = placeholder.pos,
        createElement = placeholder.createElement,
        onDestroy = placeholder.onDestroy,
        onUpdate = placeholder.onUpdate,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var element = (_createElement = createElement === null || createElement === void 0 ? void 0 : createElement(this.store.view, pos)) !== null && _createElement !== void 0 ? _createElement : document.createElement(nodeName);
    element.classList.add(className);
    var decoration = view.Decoration.widget(pos, element, {
      id,
      __type,
      type,
      element,
      onDestroy,
      onUpdate
    });
    this.placeholderWidgets.set(id, decoration);
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add an inline placeholder.
   */


  addInlinePlaceholder(placeholder, tr) {
    var _placeholder$from = placeholder.from,
        from = _placeholder$from === void 0 ? tr.selection.from : _placeholder$from,
        _placeholder$to = placeholder.to,
        to = _placeholder$to === void 0 ? tr.selection.to : _placeholder$to,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var decoration;

    if (from === to) {
      // Add this as a widget if the range is empty.
      var _element = document.createElement(nodeName);

      _element.classList.add(className);

      decoration = view.Decoration.widget(from, _element, {
        id,
        type,
        __type,
        widget: _element
      });
    } else {
      // Make this span across nodes if the range is not empty.
      decoration = view.Decoration.inline(from, to, {
        nodeName,
        class: className
      }, {
        id,
        __type
      });
    }

    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add a placeholder for nodes.
   */


  addNodePlaceholder(placeholder, tr) {
    var pos = placeholder.pos,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id;
    var $pos = coreHelpers.isNumber(pos) ? tr.doc.resolve(pos) : tr.selection.$from;
    var found = coreHelpers.isNumber(pos) ? $pos.nodeAfter ? {
      pos,
      end: $pos.nodeAfter.nodeSize
    } : undefined : coreUtils.findNodeAtPosition($pos);

    if (!found) {
      return;
    }

    var decoration = view.Decoration.node(found.pos, found.end, {
      nodeName,
      class: className
    }, {
      id,
      __type
    });
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add the node and class name to the placeholder object.
   */


  withRequiredBase(id, placeholder) {
    var _this$options = this.options,
        placeholderNodeName = _this$options.placeholderNodeName,
        placeholderClassName = _this$options.placeholderClassName;

    var _placeholder$nodeName = placeholder.nodeName,
        nodeName = _placeholder$nodeName === void 0 ? placeholderNodeName : _placeholder$nodeName,
        className = placeholder.className,
        rest = _objectWithoutProperties(placeholder, _excluded$1);

    var classes = (className ? [placeholderClassName, className] : [placeholderClassName]).join(' ');
    return _objectSpread(_objectSpread({
      nodeName,
      className: classes
    }, rest), {}, {
      id
    });
  }
  /**
   * Get the command metadata.
   */


  getMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_PLACEHOLDER_META), meta);
  }
  /**
   * Set the metadata for the command.
   */


  setMeta(tr, update) {
    var meta = this.getMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add a placeholder decoration with the specified params to the transaction
   * and return the transaction.
   *
   * It is up to you to dispatch the transaction or you can just use the
   * commands.
   */


  addPlaceholderTransaction(id, placeholder, tr) {
    var checkOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var existingPosition = this.findPlaceholder(id);

    if (existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta2 = this.getMeta(tr),
        added = _this$getMeta2.added;

    this.setMeta(tr, {
      added: [...added, this.withRequiredBase(id, placeholder)]
    });
    return true;
  }
  /**
   * Update the data stored by a placeholder.
   *
   * This replaces the whole data value.
   */


  updatePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly = props.checkOnly,
        checkOnly = _props$checkOnly === void 0 ? false : _props$checkOnly,
        data = props.data;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta3 = this.getMeta(tr),
        updated = _this$getMeta3.updated;

    this.setMeta(tr, {
      updated: coreHelpers.uniqueArray([...updated, {
        id,
        data
      }])
    });
    return true;
  }
  /**
   * Discards a previously defined tracker once not needed.
   *
   * This should be used to cleanup once the position is no longer needed.
   */


  removePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly2 = props.checkOnly,
        checkOnly = _props$checkOnly2 === void 0 ? false : _props$checkOnly2;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta4 = this.getMeta(tr),
        removed = _this$getMeta4.removed;

    this.setMeta(tr, {
      removed: coreHelpers.uniqueArray([...removed, id])
    });
    return true;
  }
  /**
   * This helper returns a transaction that clears all position trackers when
   * any exist.
   *
   * Otherwise it returns undefined.
   */


  clearPlaceholdersTransaction(props) {
    var tr = props.tr,
        _props$checkOnly3 = props.checkOnly,
        checkOnly = _props$checkOnly3 === void 0 ? false : _props$checkOnly3;
    var positionTrackerState = this.getPluginState();

    if (positionTrackerState === view.DecorationSet.empty) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    this.setMeta(tr, {
      clearTrackers: true
    });
    return true;
  }
  /**
   * Handles delayed commands which rely on the
   */


}, (_applyDecoratedDescriptor(_class2$3.prototype, "updateDecorations", [_dec2$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updateDecorations"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "addPlaceholder", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "addPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "updatePlaceholder", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updatePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "removePlaceholder", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "removePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "clearPlaceholders", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "clearPlaceholders"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findPlaceholder", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findAllPlaceholders", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findAllPlaceholders"), _class2$3.prototype)), _class2$3)) || _class$9);
var DEFAULT_PLACEHOLDER_META = {
  added: [],
  updated: [],
  clearTrackers: false,
  removed: []
};
var __type = 'placeholderDecoration';
var persistentSelectionFocusKey = 'persistentSelectionFocus';

/**
 * Generate the persistent selection decoration for when the editor loses focus.
 */
function generatePersistentSelectionDecorations(state, decorationSet, attrs) {
  var selection = state.selection,
      doc = state.doc;

  if (selection.empty) {
    return decorationSet;
  }

  var from = selection.from,
      to = selection.to;
  var decoration = coreUtils.isNodeSelection(selection) ? view.Decoration.node(from, to, attrs) : view.Decoration.inline(from, to, attrs);
  return decorationSet.add(doc, [decoration]);
}

var _dec$8, _class$8;
var DocChangedExtension = (_dec$8 = extension({
  handlerKeys: ['docChanged'],
  handlerKeyOptions: {
    docChanged: {
      earlyReturnValue: false
    } // Execute all handlers, even if one returns false

  },
  defaultPriority: coreConstants.ExtensionPriority.Lowest
}), _dec$8(_class$8 = class DocChangedExtension extends PlainExtension {
  get name() {
    return 'docChanged';
  }

  onStateUpdate(props) {
    var firstUpdate = props.firstUpdate,
        transactions = props.transactions,
        tr = props.tr;

    if (firstUpdate) {
      return;
    }

    if ((transactions !== null && transactions !== void 0 ? transactions : [tr]).some(tr => tr === null || tr === void 0 ? void 0 : tr.docChanged)) {
      this.options.docChanged(props);
    }
  }

}) || _class$8);

var _dec$7, _dec2$2, _dec3$2, _dec4$2, _dec5$1, _dec6, _dec7, _dec8, _dec9, _dec10, _class$7, _class2$2;
var HelpersExtension = (_dec$7 = extension({}), _dec2$2 = helper(), _dec3$2 = helper(), _dec4$2 = helper(), _dec5$1 = helper(), _dec6 = helper(), _dec7 = command(), _dec8 = helper(), _dec9 = helper(), _dec10 = helper(), _dec$7(_class$7 = (_class2$2 = class HelpersExtension extends PlainExtension {
  get name() {
    return 'helpers';
  }
  /**
   * Add the `html` and `text` string handlers to the editor.
   */


  onCreate() {
    var _this = this;

    this.store.setStringHandler('text', this.textToProsemirrorNode.bind(this));
    this.store.setStringHandler('html', coreUtils.htmlToProsemirrorNode);
    var helpers = coreHelpers.object();
    var active = coreHelpers.object();
    var attrs = coreHelpers.object();
    var names = new Set();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      var _loop = function _loop() {
        var _extension$createHelp, _extension$createHelp2;

        var extension = _step.value;

        if (isNodeExtension(extension)) {
          active[extension.name] = attrs => {
            return coreUtils.isNodeActive({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var _getActiveNode;

            return (_getActiveNode = coreUtils.getActiveNode({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            })) === null || _getActiveNode === void 0 ? void 0 : _getActiveNode.node.attrs;
          };
        }

        if (isMarkExtension(extension)) {
          active[extension.name] = attrs => {
            return coreUtils.isMarkActive({
              trState: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var markRange = coreUtils.getMarkRange(_this.store.getState().selection.$from, extension.type);

            if (!markRange || !attrs) {
              return markRange === null || markRange === void 0 ? void 0 : markRange.mark.attrs;
            }

            if (coreUtils.containsAttributes(markRange.mark, attrs)) {
              return markRange.mark.attrs;
            }

            return;
          };
        }

        var extensionHelpers = (_extension$createHelp = (_extension$createHelp2 = extension.createHelpers) === null || _extension$createHelp2 === void 0 ? void 0 : _extension$createHelp2.call(extension)) !== null && _extension$createHelp !== void 0 ? _extension$createHelp : {};

        for (var _i = 0, _Object$keys = Object.keys((_extension$decoratedH = extension.decoratedHelpers) !== null && _extension$decoratedH !== void 0 ? _extension$decoratedH : {}); _i < _Object$keys.length; _i++) {
          var _extension$decoratedH;

          var helperName = _Object$keys[_i];
          extensionHelpers[helperName] = extension[helperName].bind(extension);
        }

        if (coreHelpers.isEmptyObject(extensionHelpers)) {
          return "continue";
        }

        var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(extensionHelpers)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                _helper = _step2$value[1];

            throwIfNameNotUnique({
              name,
              set: names,
              code: coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES
            });
            helpers[name] = _helper;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('attrs', attrs);
    this.store.setStoreKey('active', active);
    this.store.setStoreKey('helpers', helpers);
    this.store.setExtensionStore('attrs', attrs);
    this.store.setExtensionStore('active', active);
    this.store.setExtensionStore('helpers', helpers);
  }
  /**
   * Check whether the selection is empty.
   */


  isSelectionEmpty() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return coreUtils.isSelectionEmpty(state);
  }
  /*
   * Check if the document view is currently editable.
   */


  isViewEditable() {
    var _this$store$view$prop, _this$store$view$prop2, _this$store$view$prop3;

    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return (_this$store$view$prop = (_this$store$view$prop2 = (_this$store$view$prop3 = this.store.view.props).editable) === null || _this$store$view$prop2 === void 0 ? void 0 : _this$store$view$prop2.call(_this$store$view$prop3, state)) !== null && _this$store$view$prop !== void 0 ? _this$store$view$prop : false;
  }
  /**
   * Get the full JSON output for the ProseMirror editor state object.
   */


  getStateJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.toJSON();
  }
  /**
   * Get the JSON output for the main ProseMirror `doc` node.
   *
   * This can be used to persist data between sessions and can be passed as
   * content to the `initialContent` prop.
   */


  getJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.doc.toJSON();
  }
  /**
   * @deprecated use `getJSON` instead.
   */


  getRemirrorJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return this.getJSON(state);
  }
  /**
   * Insert a html string as a ProseMirror Node.
   *
   * @category Builtin Command
   */


  insertHtml(html, options) {
    return props => {
      var state = props.state;
      var fragment = coreUtils.htmlToProsemirrorNode({
        content: html,
        schema: state.schema,
        fragment: true
      });
      return this.store.commands.insertNode.original(fragment, options)(props);
    };
  }
  /**
   * A method to get all the content in the editor as text. Depending on the
   * content in your editor, it is not guaranteed to preserve it 100%, so it's
   * best to test that it meets your needs before consuming.
   */


  getText() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$lineBreakDivider = _ref.lineBreakDivider,
        lineBreakDivider = _ref$lineBreakDivider === void 0 ? '\n\n' : _ref$lineBreakDivider,
        _ref$state = _ref.state,
        state = _ref$state === void 0 ? this.store.getState() : _ref$state;

    return state.doc.textBetween(0, state.doc.content.size, lineBreakDivider, coreConstants.NULL_CHARACTER);
  }

  getTextBetween(from, to) {
    var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store.getState().doc;
    return doc.textBetween(from, to, '\n\n', coreConstants.NULL_CHARACTER);
  }
  /**
   * Get the html from the current state, or provide a custom state.
   */


  getHTML() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return coreUtils.prosemirrorNodeToHtml(state.doc, this.store.document);
  }
  /**
   * Wrap the content in a pre tag to preserve whitespace and see what the
   * editor does with it.
   */


  textToProsemirrorNode(options) {
    var content = "<pre>".concat(options.content, "</pre>");
    return this.store.stringHandlers.html(_objectSpread(_objectSpread({}, options), {}, {
      content
    }));
  }

}, (_applyDecoratedDescriptor(_class2$2.prototype, "isSelectionEmpty", [_dec2$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isSelectionEmpty"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "isViewEditable", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isViewEditable"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getStateJSON", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getStateJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getJSON", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getRemirrorJSON", [_dec6], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getRemirrorJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "insertHtml", [_dec7], Object.getOwnPropertyDescriptor(_class2$2.prototype, "insertHtml"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getText", [_dec8], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getText"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getTextBetween", [_dec9], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getTextBetween"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getHTML", [_dec10], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getHTML"), _class2$2.prototype)), _class2$2)) || _class$7);

var _dec$6, _class$6;
var InputRulesExtension = (_dec$6 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Default,
  handlerKeys: ['shouldSkipInputRule'],
  // Return when the value `true` is encountered.
  handlerKeyOptions: {
    shouldSkipInputRule: {
      earlyReturnValue: true
    }
  }
}), _dec$6(_class$6 = class InputRulesExtension extends PlainExtension {
  get name() {
    return 'inputRules';
  }
  /**
   * Add the extension store method for rebuilding all input rules.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildInputRules', this.rebuildInputRules.bind(this));
  }
  /**
   * Add the `inputRules` plugin to the editor.
   */


  createExternalPlugins() {
    return [this.generateInputRulesPlugin()];
  }

  generateInputRulesPlugin() {
    var rules = [];
    var invalidMarks = this.store.markTags[coreConstants.ExtensionTag.ExcludeInputRules];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var _extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.inputRules || // Method doesn't exist
        !_extension.createInputRules || // Extension settings exclude it
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.inputRules) {
          continue;
        } // For each input rule returned by the extension, add a `shouldSkip`
        // property.


        var _iterator2 = _createForOfIteratorHelper(_extension.createInputRules()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var rule = _step2.value;
            rule.shouldSkip = this.options.shouldSkipInputRule;
            rule.invalidMarks = invalidMarks;
            rules.push(rule);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return inputrules.inputRules({
      rules
    });
  }
  /**
   * The method for rebuilding all the input rules.
   *
   * 1. Rebuild inputRules.
   * 2. Replace the old input rules plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  rebuildInputRules() {
    this.store.updateExtensionPlugins(this);
  }

}) || _class$6);

var _dec$5, _dec2$1, _dec3$1, _dec4$1, _dec5, _class$5, _class2$1;
var KeymapExtension = (_dec$5 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Low,
  defaultOptions: {
    shortcuts: 'default',
    undoInputRuleOnBackspace: true,
    selectParentNodeOnEscape: false,
    excludeBaseKeymap: false,
    exitMarksOnArrowPress: true
  },
  customHandlerKeys: ['keymap']
}), _dec2$1 = keyBinding({
  shortcut: 'ArrowRight',
  isActive: options => options.exitMarksOnArrowPress
}), _dec3$1 = keyBinding({
  shortcut: 'ArrowLeft',
  isActive: options => options.exitMarksOnArrowPress
}), _dec4$1 = keyBinding({
  shortcut: 'Backspace',
  isActive: options => options.exitMarksOnArrowPress
}), _dec5 = helper(), _dec$5(_class$5 = (_class2$1 = class KeymapExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "extraKeyBindings", []);

    _defineProperty(this, "backwardMarkExitTracker", new Map());

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$rebuildKe, _this$store;

      var keymap = _ref.keymap;

      if (!keymap) {
        return;
      }

      this.extraKeyBindings = [...this.extraKeyBindings, keymap];
      (_this$store$rebuildKe = (_this$store = this.store).rebuildKeymap) === null || _this$store$rebuildKe === void 0 ? void 0 : _this$store$rebuildKe.call(_this$store);
      return () => {
        var _this$store$rebuildKe2, _this$store2;

        this.extraKeyBindings = this.extraKeyBindings.filter(binding => binding !== keymap);
        (_this$store$rebuildKe2 = (_this$store2 = this.store).rebuildKeymap) === null || _this$store$rebuildKe2 === void 0 ? void 0 : _this$store$rebuildKe2.call(_this$store2);
      };
    });

    _defineProperty(this, "rebuildKeymap", () => {
      this.store.updateExtensionPlugins(this);
    });
  }

  get name() {
    return 'keymap';
  }
  /**
   * The custom keybindings added by the handlers. In react these can be added
   * via `hooks`.
   */


  /**
   * Get the shortcut map.
   */
  get shortcutMap() {
    var shortcuts = this.options.shortcuts;
    return coreHelpers.isString(shortcuts) ? keyboardShortcuts[shortcuts] : shortcuts;
  }
  /**
   * This adds the `createKeymap` method functionality to all extensions.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildKeymap', this.rebuildKeymap);
  }
  /** Add the created keymap to the available plugins. */


  createExternalPlugins() {
    var _this$store$managerSe;

    if ( // The user doesn't want any keymaps in the editor so don't add the keymap
    // handler.
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.keymap) {
      return [];
    }

    return [this.generateKeymap()];
  }
  /**
   * Updates the stored keymap plugin on this extension.
   */


  generateKeymap() {
    var extensionKeymaps = [];
    var shortcutMap = this.shortcutMap;
    var commandsExtension = this.store.getExtension(CommandsExtension);

    var extractNamesFactory = extension => shortcut => extractShortcutNames({
      shortcut,
      map: shortcutMap,
      store: this.store,
      options: extension.options
    });

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$decoratedK, _extension$options$ex;

        var _extension = _step.value;
        var decoratedKeybindings = (_extension$decoratedK = _extension.decoratedKeybindings) !== null && _extension$decoratedK !== void 0 ? _extension$decoratedK : {};

        if ( // The extension was configured to ignore the keymap.
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.keymap) {
          continue;
        }

        if ( // The extension doesn't have the `createKeymap` method.
        _extension.createKeymap) {
          extensionKeymaps.push(updateNamedKeys(_extension.createKeymap(extractNamesFactory(_extension)), shortcutMap));
        }

        var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(decoratedKeybindings)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _options$priority;

            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                options = _step2$value[1];

            if (options.isActive && !options.isActive(_extension.options, this.store)) {
              continue;
            } // Bind the keybinding function to the extension.


            var _keyBinding = _extension[name].bind(_extension); // Extract the keypress pattern.


            var shortcutNames = extractShortcutNames({
              shortcut: options.shortcut,
              map: shortcutMap,
              options: _extension.options,
              store: this.store
            }); // Decide the priority to assign to the keymap.

            var _priority = coreHelpers.isFunction(options.priority) ? options.priority(_extension.options, this.store) : (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : coreConstants.ExtensionPriority.Low;

            var bindingObject = coreHelpers.object();

            var _iterator3 = _createForOfIteratorHelper(shortcutNames),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _shortcut = _step3.value;
                bindingObject[_shortcut] = _keyBinding;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            extensionKeymaps.push([_priority, bindingObject]); // Attach the normalized shortcut to the decorated command so that is
            // can be referenced in the UI.

            if (options.command) {
              commandsExtension.updateDecorated(options.command, {
                shortcut: shortcutNames
              });
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } // Sort the keymaps with a priority given to keymaps added via
      // `extension.addHandler` (e.g. in hooks).

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var sortedKeymaps = this.sortKeymaps([...this.extraKeyBindings, ...extensionKeymaps]);
    var mappedCommands = coreUtils.mergeProsemirrorKeyBindings(sortedKeymaps);
    return keymap.keymap(mappedCommands);
  }
  /**
   * Handle exiting the mark forwards.
   */


  arrowRightShortcut(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return this.exitMarkForwards(excludedMarks, excludedNodes)(props);
  }
  /**
   * Handle the arrow left key to exit the mark.
   */


  arrowLeftShortcut(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return coreUtils.chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes), this.exitMarkBackwards(excludedMarks, excludedNodes))(props);
  }
  /**
   * Handle exiting the mark forwards.
   */


  backspace(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return coreUtils.chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes, true), this.exitMarkBackwards(excludedMarks, excludedNodes, true))(props);
  }
  /**
   * Create the base keymap and give it a low priority so that all other keymaps
   * override it.
   */


  createKeymap() {
    var _this$options = this.options,
        selectParentNodeOnEscape = _this$options.selectParentNodeOnEscape,
        undoInputRuleOnBackspace = _this$options.undoInputRuleOnBackspace,
        excludeBaseKeymap = _this$options.excludeBaseKeymap;
    var baseKeyBindings = coreHelpers.object(); // Only add the base keymap if it is **NOT** excluded.

    if (!excludeBaseKeymap) {
      var _iterator4 = _createForOfIteratorHelper(coreHelpers.entries(commands.baseKeymap)),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _slicedToArray(_step4.value, 2),
              key = _step4$value[0],
              value = _step4$value[1];

          baseKeyBindings[key] = coreUtils.convertCommand(value);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    } // Automatically remove the input rule when the option is set to true.


    if (undoInputRuleOnBackspace && commands.baseKeymap.Backspace) {
      baseKeyBindings.Backspace = coreUtils.convertCommand(commands.chainCommands(inputrules.undoInputRule, commands.baseKeymap.Backspace));
    } // Allow escape to select the parent node when set to true.


    if (selectParentNodeOnEscape) {
      baseKeyBindings.Escape = coreUtils.convertCommand(commands.selectParentNode);
    }

    return [coreConstants.ExtensionPriority.Low, baseKeyBindings];
  }
  /**
   * Get the real shortcut name from the named shortcut.
   */


  getNamedShortcut(shortcut) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!shortcut.startsWith('_|')) {
      return [shortcut];
    }

    return extractShortcutNames({
      shortcut,
      map: this.shortcutMap,
      store: this.store,
      options: options
    });
  }
  /**
   * @internalremarks
   *
   * Think about the case where bindings are disposed of and then added in a
   * different position in the `extraKeyBindings` array. This is especially
   * pertinent when using hooks.
   */


  /**
   * Handle changes in the dynamic properties.
   */
  onSetOptions(props) {
    var changes = props.changes;

    if (changes.excludeBaseKeymap.changed || changes.selectParentNodeOnEscape.changed || changes.undoInputRuleOnBackspace.changed) {
      var _this$store$rebuildKe3, _this$store3;

      (_this$store$rebuildKe3 = (_this$store3 = this.store).rebuildKeymap) === null || _this$store$rebuildKe3 === void 0 ? void 0 : _this$store$rebuildKe3.call(_this$store3);
    }
  }

  sortKeymaps(bindings) {
    // Sort the bindings.
    return coreHelpers.sort(bindings.map(binding => // Make all bindings prioritized a default priority of
    // `ExtensionPriority.Default`
    coreHelpers.isArray(binding) ? binding : [coreConstants.ExtensionPriority.Default, binding]), // Sort from highest binding to the lowest.
    (a, z) => z[0] - a[0] // Extract the bindings from the prioritized tuple.
    ).map(binding => binding[1]);
  }
  /**
   * The method for rebuilding all the extension keymaps.
   *
   * 1. Rebuild keymaps.
   * 2. Replace the old keymap plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  /**
   * Exits the mark forwards when at the end of a block node.
   */
  exitMarkForwards(excludedMarks, excludedNodes) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;

      if (!coreUtils.isEndOfTextBlock(tr.selection)) {
        return false;
      }

      var isInsideExcludedNode = coreUtils.findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      }

      var $pos = tr.selection.$from;
      var marksToRemove = $pos.marks().filter(mark => !excludedMarks.includes(mark.type.name));

      if (coreHelpers.isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      }

      var _iterator5 = _createForOfIteratorHelper(marksToRemove),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var mark = _step5.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      dispatch(tr.insertText(' ', tr.selection.from));
      return true;
    };
  }

  exitNodeBackwards(excludedNodes) {
    var startOfDoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return props => {
      var tr = props.tr;
      var checker = startOfDoc ? coreUtils.isStartOfDoc : coreUtils.isStartOfTextBlock;

      if (!checker(tr.selection)) {
        return false;
      }

      var node = tr.selection.$anchor.node();

      if (!coreUtils.isEmptyBlockNode(node) || coreUtils.isDefaultBlockNode(node) || excludedNodes.includes(node.type.name)) {
        return false;
      }

      return this.store.commands.toggleBlockNodeItem.original({
        type: node.type
      })(props);
    };
  }
  /**
   * Exit a mark when at the beginning of a block node.
   */


  exitMarkBackwards(excludedMarks, excludedNodes) {
    var startOfDoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return props => {
      var _tr$storedMarks;

      var tr = props.tr,
          dispatch = props.dispatch;
      var checker = startOfDoc ? coreUtils.isStartOfDoc : coreUtils.isStartOfTextBlock;

      if (!checker(tr.selection) || this.backwardMarkExitTracker.has(tr.selection.anchor)) {
        // Clear the map to prevent it storing stale data.
        this.backwardMarkExitTracker.clear();
        return false;
      }

      var isInsideExcludedNode = coreUtils.findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      } // Find all the marks to remove


      var marksToRemove = [...((_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : []), ...tr.selection.$from.marks()].filter(mark => !excludedMarks.includes(mark.type.name));

      if (coreHelpers.isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      } // Remove all the active marks at the current cursor.


      var _iterator6 = _createForOfIteratorHelper(marksToRemove),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var mark = _step6.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      this.backwardMarkExitTracker.set(tr.selection.anchor, true);
      dispatch(tr);
      return true;
    };
  }

}, (_applyDecoratedDescriptor(_class2$1.prototype, "arrowRightShortcut", [_dec2$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowRightShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "arrowLeftShortcut", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowLeftShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "backspace", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "backspace"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "getNamedShortcut", [_dec5], Object.getOwnPropertyDescriptor(_class2$1.prototype, "getNamedShortcut"), _class2$1.prototype)), _class2$1)) || _class$5);

function isNamedShortcut(value) {
  return coreHelpers.includes(coreHelpers.values(coreConstants.NamedShortcut), value);
}

function extractShortcutNames(_ref2) {
  var shortcut = _ref2.shortcut,
      map = _ref2.map,
      options = _ref2.options,
      store = _ref2.store;

  if (coreHelpers.isString(shortcut)) {
    return [normalizeShortcutName(shortcut, map)];
  }

  if (coreHelpers.isArray(shortcut)) {
    return shortcut.map(value => normalizeShortcutName(value, map));
  }

  shortcut = shortcut(options, store);
  return extractShortcutNames({
    shortcut,
    map,
    options,
    store
  });
}

function normalizeShortcutName(value, shortcutMap) {
  return isNamedShortcut(value) ? shortcutMap[value] : value;
}

function updateNamedKeys(prioritizedBindings, shortcutMap) {
  var updatedBindings = {};
  var previousBindings;
  var priority;

  if (coreHelpers.isArray(prioritizedBindings)) {
    var _prioritizedBindings = _slicedToArray(prioritizedBindings, 2);

    priority = _prioritizedBindings[0];
    previousBindings = _prioritizedBindings[1];
  } else {
    previousBindings = prioritizedBindings;
  }

  var _iterator7 = _createForOfIteratorHelper(coreHelpers.entries(previousBindings)),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _slicedToArray(_step7.value, 2),
          shortcutName = _step7$value[0],
          commandFunction = _step7$value[1];

      updatedBindings[normalizeShortcutName(shortcutName, shortcutMap)] = commandFunction;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return coreHelpers.isUndefined(priority) ? updatedBindings : [priority, updatedBindings];
}
/**
 * A shortcut map which is used by the `KeymapExtension`.
 */


/**
 * The default named shortcuts used within `remirror`.
 */
var DEFAULT_SHORTCUTS = {
  [coreConstants.NamedShortcut.Copy]: 'Mod-c',
  [coreConstants.NamedShortcut.Cut]: 'Mod-x',
  [coreConstants.NamedShortcut.Paste]: 'Mod-p',
  [coreConstants.NamedShortcut.PastePlain]: 'Mod-Shift-p',
  [coreConstants.NamedShortcut.SelectAll]: 'Mod-a',
  [coreConstants.NamedShortcut.Undo]: 'Mod-z',
  [coreConstants.NamedShortcut.Redo]: coreUtils.environment.isMac ? 'Shift-Mod-z' : 'Mod-y',
  [coreConstants.NamedShortcut.Bold]: 'Mod-b',
  [coreConstants.NamedShortcut.Italic]: 'Mod-i',
  [coreConstants.NamedShortcut.Underline]: 'Mod-u',
  [coreConstants.NamedShortcut.Strike]: 'Mod-d',
  [coreConstants.NamedShortcut.Code]: 'Mod-`',
  [coreConstants.NamedShortcut.Paragraph]: 'Mod-Shift-0',
  [coreConstants.NamedShortcut.H1]: 'Mod-Shift-1',
  [coreConstants.NamedShortcut.H2]: 'Mod-Shift-2',
  [coreConstants.NamedShortcut.H3]: 'Mod-Shift-3',
  [coreConstants.NamedShortcut.H4]: 'Mod-Shift-4',
  [coreConstants.NamedShortcut.H5]: 'Mod-Shift-5',
  [coreConstants.NamedShortcut.H6]: 'Mod-Shift-6',
  [coreConstants.NamedShortcut.TaskList]: 'Mod-Shift-7',
  [coreConstants.NamedShortcut.BulletList]: 'Mod-Shift-8',
  [coreConstants.NamedShortcut.OrderedList]: 'Mod-Shift-9',
  [coreConstants.NamedShortcut.Quote]: 'Mod->',
  [coreConstants.NamedShortcut.Divider]: 'Mod-Shift-|',
  [coreConstants.NamedShortcut.Codeblock]: 'Mod-Shift-~',
  [coreConstants.NamedShortcut.ClearFormatting]: 'Mod-Shift-C',
  [coreConstants.NamedShortcut.Superscript]: 'Mod-.',
  [coreConstants.NamedShortcut.Subscript]: 'Mod-,',
  [coreConstants.NamedShortcut.LeftAlignment]: 'Mod-Shift-L',
  [coreConstants.NamedShortcut.CenterAlignment]: 'Mod-Shift-E',
  [coreConstants.NamedShortcut.RightAlignment]: 'Mod-Shift-R',
  [coreConstants.NamedShortcut.JustifyAlignment]: 'Mod-Shift-J',
  [coreConstants.NamedShortcut.InsertLink]: 'Mod-k',
  [coreConstants.NamedShortcut.Find]: 'Mod-f',
  [coreConstants.NamedShortcut.FindBackwards]: 'Mod-Shift-f',
  [coreConstants.NamedShortcut.FindReplace]: 'Mod-Shift-H',
  [coreConstants.NamedShortcut.AddFootnote]: 'Mod-Alt-f',
  [coreConstants.NamedShortcut.AddComment]: 'Mod-Alt-m',
  [coreConstants.NamedShortcut.ContextMenu]: 'Mod-Shift-\\',
  [coreConstants.NamedShortcut.IncreaseFontSize]: 'Mod-Shift-.',
  [coreConstants.NamedShortcut.DecreaseFontSize]: 'Mod-Shift-,',
  [coreConstants.NamedShortcut.IncreaseIndent]: 'Tab',
  [coreConstants.NamedShortcut.DecreaseIndent]: 'Shift-Tab',
  [coreConstants.NamedShortcut.Shortcuts]: 'Mod-/',
  [coreConstants.NamedShortcut.Format]: coreUtils.environment.isMac ? 'Alt-Shift-f' : 'Shift-Ctrl-f'
};
/**
 * Shortcuts used within google docs.
 */

var GOOGLE_DOC_SHORTCUTS = _objectSpread(_objectSpread({}, DEFAULT_SHORTCUTS), {}, {
  [coreConstants.NamedShortcut.Strike]: 'Mod-Shift-S',
  [coreConstants.NamedShortcut.Code]: 'Mod-Shift-M',
  [coreConstants.NamedShortcut.Paragraph]: 'Mod-Alt-0',
  [coreConstants.NamedShortcut.H1]: 'Mod-Alt-1',
  [coreConstants.NamedShortcut.H2]: 'Mod-Alt-2',
  [coreConstants.NamedShortcut.H3]: 'Mod-Alt-3',
  [coreConstants.NamedShortcut.H4]: 'Mod-Alt-4',
  [coreConstants.NamedShortcut.H5]: 'Mod-Alt-5',
  [coreConstants.NamedShortcut.H6]: 'Mod-Alt-6',
  [coreConstants.NamedShortcut.OrderedList]: 'Mod-Alt-7',
  [coreConstants.NamedShortcut.BulletList]: 'Mod-Alt-8',
  [coreConstants.NamedShortcut.Quote]: 'Mod-Alt-9',
  [coreConstants.NamedShortcut.ClearFormatting]: 'Mod-\\',
  [coreConstants.NamedShortcut.IncreaseIndent]: 'Mod-[',
  [coreConstants.NamedShortcut.DecreaseIndent]: 'Mod-]'
});
var keyboardShortcuts = {
  default: DEFAULT_SHORTCUTS,
  googleDoc: GOOGLE_DOC_SHORTCUTS
};

/**
 * This extension allows others extension to add the `createNodeView` method
 * for creating nodeViews which alter how the dom is rendered for the node.
 *
 * @remarks
 *
 * This is an example of adding custom functionality to an extension via the
 * `ExtensionParameterMethods`.
 *
 * @category Builtin Extension
 */
class NodeViewsExtension extends PlainExtension {
  get name() {
    return 'nodeViews';
  }

  createPlugin() {
    var _this$store$managerSe;

    var nodeViewList = [];
    var nodeViews = coreHelpers.object();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;

        if (!extension.createNodeViews) {
          // Method doesn't exist
          continue;
        }

        var _nodeView = extension.createNodeViews(); // `.unshift` ensures higher priority extensions can overwrite the lower
        // priority nodeViews.


        nodeViewList.unshift(coreHelpers.isFunction(_nodeView) ? {
          [extension.name]: _nodeView
        } : _nodeView);
      } // Insert the `nodeViews` provided via the manager.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    nodeViewList.unshift((_this$store$managerSe = this.store.managerSettings.nodeViews) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : {});

    for (var _i = 0, _nodeViewList = nodeViewList; _i < _nodeViewList.length; _i++) {
      var nodeView = _nodeViewList[_i];
      Object.assign(nodeViews, nodeView);
    }

    return {
      props: {
        nodeViews
      }
    };
  }

}

/**
 * This extension allows others extension to add the `createPasteRules` method
 * for automatically transforming pasted text which matches a certain regex
 * pattern in the dom.
 *
 * @category Builtin Extension
 */
class PasteRulesExtension extends PlainExtension {
  get name() {
    return 'pasteRules';
  }

  createExternalPlugins() {
    return [this.generatePasteRulesPlugin()];
  }

  generatePasteRulesPlugin() {
    var extensionPasteRules = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.pasteRules || // Method doesn't exist
        !extension.createPasteRules || // Extension settings exclude it
        (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.pasteRules) {
          continue;
        }

        var value = extension.createPasteRules();
        var rules = coreHelpers.isArray(value) ? value : [value];
        extensionPasteRules.push(...rules);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return pasteRules.pasteRules(extensionPasteRules);
  }

}

var _dec$4, _class$4;
var PluginsExtension = (_dec$4 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest,
  handlerKeys: ['applyState', 'appendTransaction']
}), _dec$4(_class$4 = class PluginsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "plugins", []);

    _defineProperty(this, "managerPlugins", []);

    _defineProperty(this, "applyStateHandlers", []);

    _defineProperty(this, "initStateHandlers", []);

    _defineProperty(this, "appendTransactionHandlers", []);

    _defineProperty(this, "pluginKeys", coreHelpers.object());

    _defineProperty(this, "stateGetters", new Map());

    _defineProperty(this, "getPluginStateCreator", key => state => {
      return key.getState(state !== null && state !== void 0 ? state : this.store.getState());
    });

    _defineProperty(this, "getStateByName", identifier => {
      var stateGetter = this.stateGetters.get(identifier);
      !stateGetter ? coreHelpers.invariant(false) : void 0;
      return stateGetter();
    });
  }

  get name() {
    return 'plugins';
  }
  /**
   * All plugins created by other extension as well.
   */


  /**
   * This extension is responsible for adding state to the editor.
   */
  onCreate() {
    var _this$store = this.store,
        setStoreKey = _this$store.setStoreKey,
        setExtensionStore = _this$store.setExtensionStore,
        managerSettings = _this$store.managerSettings,
        extensions = _this$store.extensions;
    this.updateExtensionStore(); // Retrieve the plugins passed in when creating the manager.

    var _managerSettings$plug = managerSettings.plugins,
        plugins = _managerSettings$plug === void 0 ? [] : _managerSettings$plug; // Add the plugins which were added directly to the manager.

    this.updatePlugins(plugins, this.managerPlugins);

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;

        if (_extension.onApplyState) {
          this.applyStateHandlers.push(_extension.onApplyState.bind(_extension));
        }

        if (_extension.onInitState) {
          this.initStateHandlers.push(_extension.onInitState.bind(_extension));
        }

        if (_extension.onAppendTransaction) {
          this.appendTransactionHandlers.push(_extension.onAppendTransaction.bind(_extension));
        }

        this.extractExtensionPlugins(_extension);
      } // Store the added plugins for future usage.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.managerPlugins = plugins; // Add all the extracted plugins to the manager store. From the manager
    // store they are automatically added to the state for use in the editor.

    this.store.setStoreKey('plugins', this.plugins); // Here set the plugins keys and state getters for retrieving plugin state.
    // These methods are later used.

    setStoreKey('pluginKeys', this.pluginKeys);
    setStoreKey('getPluginState', this.getStateByName);
    setExtensionStore('getPluginState', this.getStateByName);
  }
  /**
   * Create a plugin which adds the [[`onInitState`]] and [[`onApplyState`]]
   * lifecycle methods.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, previousState, state) => {
        var tr = state.tr;
        var props = {
          previousState,
          tr,
          transactions,
          state
        };

        var _iterator2 = _createForOfIteratorHelper(this.appendTransactionHandlers),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var handler = _step2.value;
            handler(props);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.options.appendTransaction(props); // Return the transaction if it has been amended in any way.

        return tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet ? tr : undefined;
      },
      state: {
        init: (_, state) => {
          var _iterator3 = _createForOfIteratorHelper(this.initStateHandlers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var handler = _step3.value;
              handler(state);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        apply: (tr, _, previousState, state) => {
          var props = {
            previousState,
            state,
            tr
          };

          var _iterator4 = _createForOfIteratorHelper(this.applyStateHandlers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var handler = _step4.value;
              handler(props);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          this.options.applyState(props);
        }
      }
    };
  }
  /**
   * Get all the plugins from the extension.
   */


  extractExtensionPlugins(extension) {
    var _this$store$managerSe, _extension$options$ex;

    var isNotPluginCreator = !extension.createPlugin && !extension.createExternalPlugins;

    if (isNotPluginCreator || // the manager settings don't exclude plugins
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.plugins || // The extension settings don't exclude plugins
    (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.plugins) {
      return;
    } // Create the custom plugin if it exists.


    if (extension.createPlugin) {
      var key = new state.PluginKey(extension.name); // Assign the plugin key to the extension name.

      this.pluginKeys[extension.name] = key;
      var getter = this.getPluginStateCreator(key);
      extension.pluginKey = key;
      extension.getPluginState = getter;
      this.stateGetters.set(extension.name, getter);
      this.stateGetters.set(extension.constructor, getter);

      var pluginSpec = _objectSpread(_objectSpread({}, extension.createPlugin()), {}, {
        key
      });

      var plugin = new state.Plugin(pluginSpec);
      this.updatePlugins([plugin], extension.plugin ? [extension.plugin] : undefined);
      extension.plugin = plugin;
    }

    if (extension.createExternalPlugins) {
      var externalPlugins = extension.createExternalPlugins();
      this.updatePlugins(externalPlugins, extension.externalPlugins);
      extension.externalPlugins = externalPlugins;
    }
  }

  /**
   * Add or replace a plugin.
   */
  updatePlugins(plugins, previous) {
    // This is the first time plugins are being added.
    if (!previous || coreHelpers.isEmptyArray(previous)) {
      this.plugins = [...this.plugins, ...plugins];
      return;
    } // The number of plugins and previous plugins is different.


    if (plugins.length !== previous.length) {
      // Remove previous plugins and add the new plugins to the end.
      this.plugins = [...this.plugins.filter(plugin => !previous.includes(plugin)), ...plugins];
      return;
    } // The length of plugins is identical, therefore a replacement is possible.


    var pluginMap = new Map();

    var _iterator5 = _createForOfIteratorHelper(plugins.entries()),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _slicedToArray(_step5.value, 2),
            index = _step5$value[0],
            plugin = _step5$value[1];

        pluginMap.set(coreHelpers.assertGet(previous, index), plugin);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    this.plugins = this.plugins.map(plugin => {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return previous.includes(plugin) ? pluginMap.get(plugin) : plugin;
    });
  } // Method for retrieving the plugin state by the extension name.


  /**
   * Add the plugin specific properties and methods to the manager and extension
   * store.
   */
  updateExtensionStore() {
    var setExtensionStore = this.store.setExtensionStore; // Allow adding, replacing and removing plugins by other extensions.

    setExtensionStore('updatePlugins', this.updatePlugins.bind(this));
    setExtensionStore('dispatchPluginUpdate', this.dispatchPluginUpdate.bind(this));
    setExtensionStore('updateExtensionPlugins', this.updateExtensionPlugins.bind(this));
  }
  /**
   * Reruns the `createPlugin` and `createExternalPlugins` methods of the
   * provided extension.
   *
   * ```ts
   * // From within an extension
   * this.store.updateExtensionPlugins(this);
   * ```
   */


  updateExtensionPlugins(value) {
    var extension = isExtension(value) ? value : isExtensionConstructor(value) ? this.store.manager.getExtension(value) : this.store.extensions.find(extension => extension.name === value);
    !extension ? coreHelpers.invariant(false) : void 0;
    this.extractExtensionPlugins(extension);
    this.store.setStoreKey('plugins', this.plugins); // Dispatch the plugin updates to the editor.

    this.dispatchPluginUpdate();
  }
  /**
   * Applies the store plugins to the state. If any have changed then it will be
   * updated.
   */


  dispatchPluginUpdate() {
    !(this.store.phase >= coreConstants.ManagerPhase.EditorView) ? coreHelpers.invariant(false) : void 0;
    var _this$store2 = this.store,
        view = _this$store2.view,
        updateState = _this$store2.updateState;
    var newState = view.state.reconfigure({
      plugins: this.plugins
    });
    updateState(newState);
  }

}) || _class$4);

var _excluded = ["parseDOM"];

var _dec$3, _class$3;
var SchemaExtension = (_dec$3 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec$3(_class$3 = class SchemaExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "dynamicAttributes", {
      marks: coreHelpers.object(),
      nodes: coreHelpers.object()
    });
  }

  get name() {
    return 'schema';
  }
  /**
   * The dynamic attributes for each node and mark extension.
   *
   * The structure will look like the following.
   *
   * ```ts
   * {
   *   paragraph: { id: () => uid(), hash: (node) => hash(node) },
   *   bold: { random: () => Math.random(), created: () => Date.now() },
   * };
   * ```
   *
   * This object is used by the created plugin to listen for changes to the doc,
   * and check for new nodes and marks which haven't yet applied the dynamic
   * attribute and add the attribute.
   */


  /**
   * This method is responsible for creating, configuring and adding the
   * `schema` to the editor. `Schema` is a special type in ProseMirror editors
   * and with `remirror` it's all just handled for you.
   */
  onCreate() {
    var _this = this;

    var _this$store = this.store,
        managerSettings = _this$store.managerSettings,
        tags = _this$store.tags,
        markNames = _this$store.markNames,
        nodeNames = _this$store.nodeNames,
        extensions = _this$store.extensions;
    var defaultBlockNode = managerSettings.defaultBlockNode,
        disableExtraAttributes = managerSettings.disableExtraAttributes,
        nodeOverride = managerSettings.nodeOverride,
        markOverride = managerSettings.markOverride; // True when the `defaultBlockNode` exists for this editor.

    var isValidDefaultBlockNode = name => !!(name && tags[coreConstants.ExtensionTag.Block].includes(name)); // The user can override the whole schema creation process by providing
    // their own version. In that case we can exit early.


    if (managerSettings.schema) {
      var _getSpecFromSchema = getSpecFromSchema(managerSettings.schema),
          _nodes = _getSpecFromSchema.nodes,
          _marks = _getSpecFromSchema.marks;

      this.addSchema(managerSettings.schema, _nodes, _marks); // Exit early! 🙌

      return;
    } // This nodes object is built up for each extension and then at the end it
    // will be passed to the `Schema` constructor to create a new `schema`.


    var nodes = isValidDefaultBlockNode(defaultBlockNode) ? {
      doc: coreHelpers.object(),
      // Ensure that this is the highest positioned block node by adding it
      // to the object early. Later on it will be overwritten but maintain
      // it's position.
      [defaultBlockNode]: coreHelpers.object()
    } : coreHelpers.object(); // Similar to the `nodes` object above this is passed to the `Schema`.

    var marks = coreHelpers.object(); // Get the named extra attributes from the manager. This allows each extra
    // attribute group added to the manager to be applied to the individual
    // extensions which specified.

    var namedExtraAttributes = getNamedSchemaAttributes({
      settings: managerSettings,
      gatheredSchemaAttributes: this.gatherExtraAttributes(extensions),
      nodeNames: nodeNames,
      markNames: markNames,
      tags: tags
    });

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      var _loop = function _loop() {
        var extension = _step.value;
        // Pick the current attributes from the named attributes and merge them
        // with the extra attributes which were added to the extension. Extra
        // attributes added to the extension are prioritized.
        namedExtraAttributes[extension.name] = _objectSpread(_objectSpread({}, namedExtraAttributes[extension.name]), extension.options.extraAttributes); // There are several places that extra attributes can be ignored. This
        // checks them all.

        var ignoreExtraAttributes = disableExtraAttributes === true || extension.options.disableExtraAttributes === true || extension.constructor.disableExtraAttributes === true;

        if (isNodeExtension(extension)) {
          // Create the spec and gather dynamic attributes for this node
          // extension.
          var _createSpec = createSpec({
            createExtensionSpec: (extra, override) => extension.createNodeSpec(extra, override),
            extraAttributes: coreHelpers.assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, nodeOverride), extension.options.nodeOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: extension.tags
          }),
              spec = _createSpec.spec,
              dynamic = _createSpec.dynamic; // Store the node spec on the extension for future reference.


          extension.spec = spec; // Add the spec to the `nodes` object which is used to create the schema
          // with the same name as the extension name.

          nodes[extension.name] = spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `NodeType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct nodes.

          if (Object.keys(dynamic).length > 0) {
            _this.dynamicAttributes.nodes[extension.name] = dynamic;
          }
        } // Very similar to the previous conditional block except for marks rather
        // than nodes.


        if (isMarkExtension(extension)) {
          var _extension$tags;

          // Create the spec and gather dynamic attributes for this mark
          // extension.
          var _createSpec2 = createSpec({
            createExtensionSpec: (extra, override) => extension.createMarkSpec(extra, override),
            extraAttributes: coreHelpers.assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, markOverride), extension.options.markOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: (_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []
          }),
              _spec = _createSpec2.spec,
              _dynamic = _createSpec2.dynamic; // Store the mark spec on the extension for future reference.


          extension.spec = _spec; // Add the spec to the `marks` object which is used to create the schema
          // with the same name as the extension name.

          marks[extension.name] = _spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `MarkType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct marks.

          if (Object.keys(_dynamic).length > 0) {
            _this.dynamicAttributes.marks[extension.name] = _dynamic;
          }
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      } // Create the schema from the gathered nodes and marks.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var schema = new model.Schema({
      nodes,
      marks,
      topNode: 'doc'
    }); // Add the schema and nodes marks to the store.

    this.addSchema(schema, nodes, marks);
  }
  /**
   * This creates the plugin that is used to automatically create the dynamic
   * attributes defined in the extra attributes object.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, _, nextState) => {
        // This creates a new transaction which will be used to update the
        // attributes of any node and marks which
        var tr = nextState.tr; // The dynamic attribute updates only need to be run if the document has
        // been modified in a transaction.

        var documentHasChanged = transactions.some(tr => tr.docChanged);

        if (!documentHasChanged) {
          // The document has not been changed therefore no updates are
          // required.
          return null;
        } // The find children method could potentially be quite expensive. Before
        // committing to that level of work let's check that there user has
        // actually defined some dynamic attributes.


        if (Object.keys(this.dynamicAttributes.nodes).length === 0 && Object.keys(this.dynamicAttributes.marks).length === 0) {
          return null;
        } // This function loops through every node in the document and add the
        // dynamic attributes when any relevant nodes have been added.


        tr.doc.descendants((child, pos) => {
          this.checkAndUpdateDynamicNodes(child, pos, tr);
          this.checkAndUpdateDynamicMarks(child, pos, tr); // This means that all nodes will be checked.

          return true;
        }); // If the transaction has any `steps` then it has been modified and
        // should be returned i.e. appended to the additional transactions.
        // However, if there are no steps then ignore and return `null`.

        return tr.steps.length > 0 ? tr : null;
      }
    };
  }
  /**
   * Add the schema and nodes to the manager and extension store.
   */


  addSchema(schema, nodes, marks) {
    // Store the `nodes`, `marks` and `schema` on the manager store. For example
    // the `schema` can be accessed via `manager.store.schema`.
    this.store.setStoreKey('nodes', nodes);
    this.store.setStoreKey('marks', marks);
    this.store.setStoreKey('schema', schema); // Add the schema to the extension store, so that all extension from this
    // point have access to the schema via `this.store.schema`.

    this.store.setExtensionStore('schema', schema);
    this.store.setStoreKey('defaultBlockNode', coreUtils.getDefaultBlockNode(schema).name); // Set the default block node from the schema.

    for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
      var type = _Object$values[_i];

      if (type.name === 'doc') {
        continue;
      } // Break as soon as the first non 'doc' block node is encountered.


      if (type.isBlock || type.isTextblock) {
        break;
      }
    }
  }
  /**
   * Check the dynamic nodes to see if the provided node:
   *
   * - a) is dynamic and therefore can be updated.
   * - b) has just been created and does not yet have a value for the dynamic
   *   node.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state
   */


  checkAndUpdateDynamicNodes(node, pos, tr) {
    // Check for matching nodes.
    var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(this.dynamicAttributes.nodes)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            _name = _step2$value[0],
            dynamic = _step2$value[1];

        if (node.type.name !== _name) {
          continue;
        }

        var _iterator3 = _createForOfIteratorHelper(coreHelpers.entries(dynamic)),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
                attributeName = _step3$value[0],
                attributeCreator = _step3$value[1];

            if (!coreHelpers.isNullOrUndefined(node.attrs[attributeName])) {
              continue;
            } // The new attributes which will be added to the node.


            var attrs = _objectSpread(_objectSpread({}, node.attrs), {}, {
              [attributeName]: attributeCreator(node)
            }); // Apply the new dynamic attribute to the node via the transaction.


            tr.setNodeMarkup(pos, undefined, attrs); // Ignore this update in the `prosemirror-suggest` plugin

            suggest.ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Loop through the dynamic marks to see if the provided node:
   *
   * - a) is wrapped by a matching mark.
   * - b) has just been added and doesn't yet have the dynamic attribute
   *   applied.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state.
   */


  checkAndUpdateDynamicMarks(node, pos, tr) {
    var _this2 = this;

    // Check for matching marks.
    var _iterator4 = _createForOfIteratorHelper(coreHelpers.entries(this.dynamicAttributes.marks)),
        _step4;

    try {
      var _loop2 = function _loop2() {
        var _step4$value = _slicedToArray(_step4.value, 2),
            name = _step4$value[0],
            dynamic = _step4$value[1];

        // This is needed to create the new mark. Even though a mark may already
        // exist ProseMirror requires that a new one is created and added in
        // order. More details available
        // [here](https://discuss.prosemirror.net/t/updating-mark-attributes/776/2?u=ifi).
        var type = coreHelpers.assertGet(_this2.store.schema.marks, name); // Get the attrs from the mark.

        var mark = node.marks.find(mark => mark.type.name === name); // If the mark doesn't exist within the set then move to the next
        // dynamically updated mark.

        if (!mark) {
          return "continue";
        } // Loop through to find if any of the required matches are missing from
        // the dynamic attribute;


        var _iterator5 = _createForOfIteratorHelper(coreHelpers.entries(dynamic)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                attributeName = _step5$value[0],
                attributeCreator = _step5$value[1];

            // When the attributes for this dynamic attributeName are already
            // defined we should move onto the next item;
            if (!coreHelpers.isNullOrUndefined(mark.attrs[attributeName])) {
              continue;
            } // Use the starting position of the node to calculate the range range of
            // the current mark.


            var range = coreUtils.getMarkRange(tr.doc.resolve(pos), type);

            if (!range) {
              continue;
            } // The { from, to } range which will be used to update the mark id
            // attribute.


            var from = range.from,
                to = range.to; // Create the new mark with all the existing dynamic attributes applied.

            var newMark = type.create(_objectSpread(_objectSpread({}, mark.attrs), {}, {
              [attributeName]: attributeCreator(mark)
            })); // Update the value of the mark. The only way to do this right now is to
            // remove and then add it back again.

            tr.removeMark(from, to, type).addMark(from, to, newMark); // Ignore this update in the `prosemirror-suggest` plugin

            suggest.ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _ret = _loop2();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  /**
   * Gather all the extra attributes that have been added by extensions.
   */


  gatherExtraAttributes(extensions) {
    var extraSchemaAttributes = [];

    var _iterator6 = _createForOfIteratorHelper(extensions),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _extension = _step6.value;

        if (!_extension.createSchemaAttributes) {
          continue;
        }

        extraSchemaAttributes.push(..._extension.createSchemaAttributes());
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return extraSchemaAttributes;
  }

}) || _class$3);
/**
 * With tags, you can select a specific sub selection of marks and nodes. This
 * will be the basis for adding advanced formatting to remirror.
 *
 * ```ts
 * import { ExtensionTag } from 'remirror';
 * import { createCoreManager, CorePreset } from 'remirror/extensions';
 * import { WysiwygPreset } from 'remirror/extensions';
 *
 * const manager = createCoreManager(() => [new WysiwygPreset(), new CorePreset()], {
 *   extraAttributes: [
 *     {
 *       identifiers: {
 *         tags: [ExtensionTag.NodeBlock],
 *         type: 'node',
 *       },
 *       attributes: { role: 'presentation' },
 *     },
 *   ],
 * });
 * ```
 *
 * Each item in the tags array should be read as an `OR` so the following would
 * match `Tag1` OR `Tag2` OR `Tag3`.
 *
 * ```json
 * { tags: ["Tag1", "Tag2", "Tag3"] }
 * ```
 *
 * The `type` property (`mark | node`) is exclusive and limits the type of
 * extension names that will be matched. When `mark` is set it only matches with
 * marks.
 */

/**
 * Get the extension extra attributes created via the manager and convert into a
 * named object which can be added to each node and mark spec.
 */
function getNamedSchemaAttributes(props) {
  var _settings$extraAttrib;

  var settings = props.settings,
      gatheredSchemaAttributes = props.gatheredSchemaAttributes,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;
  var extraAttributes = coreHelpers.object();

  if (settings.disableExtraAttributes) {
    return extraAttributes;
  }

  var extraSchemaAttributes = [...gatheredSchemaAttributes, ...((_settings$extraAttrib = settings.extraAttributes) !== null && _settings$extraAttrib !== void 0 ? _settings$extraAttrib : [])];

  for (var _i2 = 0, _arr = extraSchemaAttributes !== null && extraSchemaAttributes !== void 0 ? extraSchemaAttributes : []; _i2 < _arr.length; _i2++) {
    var attributeGroup = _arr[_i2];
    var identifiers = getIdentifiers({
      identifiers: attributeGroup.identifiers,
      nodeNames,
      markNames,
      tags
    });

    var _iterator7 = _createForOfIteratorHelper(identifiers),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _extraAttributes$iden;

        var identifier = _step7.value;
        var currentValue = (_extraAttributes$iden = extraAttributes[identifier]) !== null && _extraAttributes$iden !== void 0 ? _extraAttributes$iden : {};
        extraAttributes[identifier] = _objectSpread(_objectSpread({}, currentValue), attributeGroup.attributes);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }

  return extraAttributes;
}

/**
 * A predicate for checking if the passed in value is an `IdentifiersObject`.
 */
function isIdentifiersObject(value) {
  return coreHelpers.isPlainObject(value) && coreHelpers.isArray(value.tags);
}
/**
 * Get the array of names from the identifier that the extra attributes should
 * be applied to.
 */


function getIdentifiers(props) {
  var identifiers = props.identifiers,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;

  if (identifiers === 'nodes') {
    return nodeNames;
  }

  if (identifiers === 'marks') {
    return markNames;
  }

  if (identifiers === 'all') {
    return [...nodeNames, ...markNames];
  } // This is already an array of names to apply the attributes to.


  if (coreHelpers.isArray(identifiers)) {
    return identifiers;
  } // Make sure the object provides is valid.


  !isIdentifiersObject(identifiers) ? coreHelpers.invariant(false) : void 0; // Provide type aliases for easier readability.

  var _identifiers$tags = identifiers.tags,
      extensionTags = _identifiers$tags === void 0 ? [] : _identifiers$tags,
      _identifiers$names = identifiers.names,
      extensionNames = _identifiers$names === void 0 ? [] : _identifiers$names,
      _identifiers$behavior = identifiers.behavior,
      behavior = _identifiers$behavior === void 0 ? 'any' : _identifiers$behavior,
      excludeNames = identifiers.excludeNames,
      excludeTags = identifiers.excludeTags,
      type = identifiers.type; // Keep track of the set of stored names.

  var names = new Set(); // Collect the array of names that are supported.

  var acceptableNames = type === 'mark' ? markNames : type === 'node' ? nodeNames : [...markNames, ...nodeNames]; // Check if the name is valid

  var isNameValid = name => acceptableNames.includes(name) && !(excludeNames !== null && excludeNames !== void 0 && excludeNames.includes(name));

  var _iterator8 = _createForOfIteratorHelper(extensionNames),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _name2 = _step8.value;

      if (isNameValid(_name2)) {
        names.add(_name2);
      }
    } // Create a map of extension names to their set of included tags. Then check
    // that the length of the `TagSet` for each extension name is equal to the
    // provided extension tags in this identifier.

  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var taggedNamesMap = new Map(); // Loop through every extension

  var _iterator9 = _createForOfIteratorHelper(extensionTags),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var tag = _step9.value;

      if (excludeTags !== null && excludeTags !== void 0 && excludeTags.includes(tag)) {
        continue;
      }

      var _iterator11 = _createForOfIteratorHelper(tags[tag]),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _taggedNamesMap$get;

          var _name3 = _step11.value;

          if (!isNameValid(_name3)) {
            continue;
          } // When any tag can be an identifier simply add the name to names.


          if (behavior === 'any') {
            names.add(_name3);
            continue;
          }

          var tagSet = (_taggedNamesMap$get = taggedNamesMap.get(_name3)) !== null && _taggedNamesMap$get !== void 0 ? _taggedNamesMap$get : new Set();
          tagSet.add(tag);
          taggedNamesMap.set(_name3, tagSet);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    } // Only add the names that have a `TagSet` where `size` is equal to the number
    // of `extensionTags`

  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  var _iterator10 = _createForOfIteratorHelper(taggedNamesMap),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _step10$value = _slicedToArray(_step10.value, 2),
          _name4 = _step10$value[0],
          _tagSet = _step10$value[1];

      if (_tagSet.size === extensionTags.length) {
        names.add(_name4);
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return [...names];
}

/**
 * Create the scheme spec for a node or mark extension.
 *
 * @template Type - either a [[Mark]] or a [[ProsemirrorNode]]
 * @param props - the options object [[CreateSpecProps]]
 */
function createSpec(props) {
  var _spec$group$split, _spec$group;

  var createExtensionSpec = props.createExtensionSpec,
      extraAttributes = props.extraAttributes,
      ignoreExtraAttributes = props.ignoreExtraAttributes;
      props.name;
      var tags = props.tags,
      override = props.override; // Keep track of the dynamic attributes which are a part of this spec.

  var dynamic = coreHelpers.object();
  /** Called for every dynamic creator to track the dynamic attributes */

  function addDynamic(attributeName, creator) {
    dynamic[attributeName] = creator;
  } // Used to track whether the method has been called. If not called when the
  // extension spec is being set up then an error is thrown.


  var defaultsCalled = false;
  /** Called by createDefaults to track when the `defaults` has been called. */

  function onDefaultsCalled() {
    defaultsCalled = true;
  }

  var defaults = createDefaults(extraAttributes, ignoreExtraAttributes, onDefaultsCalled, addDynamic);
  var parse = createParseDOM(extraAttributes, ignoreExtraAttributes);
  var dom = createToDOM(extraAttributes, ignoreExtraAttributes);
  var spec = createExtensionSpec({
    defaults,
    parse,
    dom
  }, override);
  !(ignoreExtraAttributes || defaultsCalled) ? coreHelpers.invariant(false) : void 0; // Add the tags to the group of the created spec.

  spec.group = [...((_spec$group$split = (_spec$group = spec.group) === null || _spec$group === void 0 ? void 0 : _spec$group.split(' ')) !== null && _spec$group$split !== void 0 ? _spec$group$split : []), ...tags].join(' ') || undefined;
  return {
    spec,
    dynamic
  };
}
/**
 * Get the value of the extra attribute as an object.
 *
 * This is needed because the SchemaAttributes object can be configured as a
 * string or as an object.
 */


function getExtraAttributesObject(value) {
  if (coreHelpers.isString(value) || coreHelpers.isFunction(value)) {
    return {
      default: value
    };
  }

  !value ? coreHelpers.invariant(false) : void 0;
  return value;
}
/**
 * Create the `defaults()` method which is used for setting the property.
 *
 * @param extraAttributes - the extra attributes for this particular node
 * @param shouldIgnore - whether this attribute should be ignored
 * @param onCalled - the function which is called when this is run, to check
 * that it has been added to the attrs
 * @param addDynamic - A function called to add the dynamic creator and name to
 * the store
 */


function createDefaults(extraAttributes, shouldIgnore, onCalled, addDynamicCreator) {
  return () => {
    onCalled();
    var attributes = coreHelpers.object(); // Extra attributes can be ignored by the extension, check if that's the
    // case here.

    if (shouldIgnore) {
      return attributes;
    } // Loop through the extra attributes and attach to the attributes object.


    var _iterator12 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _step12$value = _slicedToArray(_step12.value, 2),
            _name5 = _step12$value[0],
            config = _step12$value[1];

        // Make sure this is an object and not a string.
        var attributesObject = getExtraAttributesObject(config);
        var defaultValue = attributesObject.default; // When true this is a dynamic attribute creator.

        if (coreHelpers.isFunction(defaultValue)) {
          // Store the name and method of the dynamic creator.
          addDynamicCreator(_name5, defaultValue); // Set the attributes for this dynamic creator to be null by default.

          defaultValue = null;
        } // When the `defaultValue` is set to `undefined`, it is set as an empty
        // object in order for ProseMirror to set it as a required attribute.


        attributes[_name5] = defaultValue === undefined ? {} : {
          default: defaultValue
        };
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return attributes;
  };
}
/**
 * Create the parseDOM method to be applied to the extension `createNodeSpec`.
 */


function createParseDOM(extraAttributes, shouldIgnore) {
  return domNode => {
    var attributes = coreHelpers.object();

    if (shouldIgnore) {
      return attributes;
    }

    var _iterator13 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step13;

    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var _domNode$getAttribute2;

        var _step13$value = _slicedToArray(_step13.value, 2),
            _name6 = _step13$value[0],
            config = _step13$value[1];

        var _getExtraAttributesOb = getExtraAttributesObject(config),
            parseDOM = _getExtraAttributesOb.parseDOM,
            other = _objectWithoutProperties(_getExtraAttributesOb, _excluded);

        if (!coreUtils.isElementDomNode(domNode)) {
          continue;
        }

        if (coreHelpers.isNullOrUndefined(parseDOM)) {
          var _domNode$getAttribute;

          attributes[_name6] = (_domNode$getAttribute = domNode.getAttribute(_name6)) !== null && _domNode$getAttribute !== void 0 ? _domNode$getAttribute : other.default;
          continue;
        }

        if (coreHelpers.isFunction(parseDOM)) {
          var _parseDOM;

          attributes[_name6] = (_parseDOM = parseDOM(domNode)) !== null && _parseDOM !== void 0 ? _parseDOM : other.default;
          continue;
        }

        attributes[_name6] = (_domNode$getAttribute2 = domNode.getAttribute(parseDOM)) !== null && _domNode$getAttribute2 !== void 0 ? _domNode$getAttribute2 : other.default;
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }

    return attributes;
  };
}
/**
 * Create the `toDOM` method to be applied to the extension `createNodeSpec`.
 */


function createToDOM(extraAttributes, shouldIgnore) {
  return item => {
    var domAttributes = coreHelpers.object();

    if (shouldIgnore) {
      return domAttributes;
    }

    function updateDomAttributes(value, name) {
      if (!value) {
        return;
      }

      if (coreHelpers.isString(value)) {
        domAttributes[name] = value;
        return;
      }

      if (coreHelpers.isArray(value)) {
        var _value = _slicedToArray(value, 2),
            attr = _value[0],
            val = _value[1];

        domAttributes[attr] = val !== null && val !== void 0 ? val : item.attrs[name];
        return;
      }

      var _iterator14 = _createForOfIteratorHelper(coreHelpers.entries(value)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var _step14$value = _slicedToArray(_step14.value, 2),
              _attr = _step14$value[0],
              _val = _step14$value[1];

          domAttributes[_attr] = _val;
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }

    var _iterator15 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step15;

    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _step15$value = _slicedToArray(_step15.value, 2),
            _name7 = _step15$value[0],
            config = _step15$value[1];

        var _getExtraAttributesOb2 = getExtraAttributesObject(config),
            toDOM = _getExtraAttributesOb2.toDOM,
            parseDOM = _getExtraAttributesOb2.parseDOM;

        if (coreHelpers.isNullOrUndefined(toDOM)) {
          var key = coreHelpers.isString(parseDOM) ? parseDOM : _name7;
          domAttributes[key] = item.attrs[_name7];
          continue;
        }

        if (coreHelpers.isFunction(toDOM)) {
          updateDomAttributes(toDOM(item.attrs, getNodeMarkOptions(item)), _name7);
          continue;
        }

        updateDomAttributes(toDOM, _name7);
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }

    return domAttributes;
  };
}
/**
 * Get the options object which applies should be used to obtain the node or
 * mark type.
 */


function getNodeMarkOptions(item) {
  if (coreUtils.isProsemirrorNode(item)) {
    return {
      node: item
    };
  }

  if (coreUtils.isProsemirrorMark(item)) {
    return {
      mark: item
    };
  }

  return {};
}
/**
 * Get the mark and node specs from provided schema.
 *
 * This is used when the user provides their own custom schema.
 */


function getSpecFromSchema(schema) {
  var nodes = coreHelpers.object();
  var marks = coreHelpers.object();

  for (var _i3 = 0, _Object$entries = Object.entries(schema.nodes); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        _name8 = _Object$entries$_i[0],
        type = _Object$entries$_i[1];

    nodes[_name8] = type.spec;
  }

  for (var _i4 = 0, _Object$entries2 = Object.entries(schema.marks); _i4 < _Object$entries2.length; _i4++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
        _name9 = _Object$entries2$_i[0],
        _type = _Object$entries2$_i[1];

    marks[_name9] = _type.spec;
  }

  return {
    nodes,
    marks
  };
}

var _dec$2, _dec2, _dec3, _dec4, _class$2, _class2;
var SuggestExtension = (_dec$2 = extension({
  customHandlerKeys: ['suggester']
}), _dec2 = helper(), _dec3 = helper(), _dec4 = helper(), _dec$2(_class$2 = (_class2 = class SuggestExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$managerSe;

      var suggester = _ref.suggester;

      if (!suggester || (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.suggesters) {
        return;
      } // Update the suggesters with the provided suggester. Returns the cleanup
      // method.


      return suggest.addSuggester(this.store.getState(), suggester);
    });
  }

  get name() {
    return 'suggest';
  }
  /**
   * Create the `addSuggester` method and `removeSuggester` methods to the
   * extension store.
   *
   * This can be used by extensions to conditionally add suggestion support.
   */


  onCreate() {
    this.store.setExtensionStore('addSuggester', suggester => suggest.addSuggester(this.store.getState(), suggester));
    this.store.setExtensionStore('removeSuggester', suggester => suggest.removeSuggester(this.store.getState(), suggester));
  }
  /**
   * Add the `prosemirror-suggest` plugin to the editor.
   */


  createExternalPlugins() {
    var suggesters = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe2, _extension$options$ex;

        var _extension = _step.value;

        if ((_this$store$managerSe2 = this.store.managerSettings.exclude) !== null && _this$store$managerSe2 !== void 0 && _this$store$managerSe2.suggesters) {
          // Exit the loop early when the manager is set to ignore suggesters.
          break;
        }

        if ( // Method doesn't exist
        !_extension.createSuggesters || // Extension settings exclude it from running
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.suggesters) {
          continue;
        }

        var _suggester = _extension.createSuggesters();

        var suggesterList = coreHelpers.isArray(_suggester) ? _suggester : [_suggester];
        suggesters.push(...suggesterList);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return [suggest.suggest(...suggesters)];
  }
  /**
   * Allow additional `Suggesters` to be added to the editor. This can be used
   * by `React` to create hooks.
   */


  /**
   * Get the suggest plugin state.
   *
   * This may be removed at a later time.
   *
   * @experimental
   */
  getSuggestState(state) {
    return suggest.getSuggestPluginState(state !== null && state !== void 0 ? state : this.store.getState());
  }
  /**
   * Get some helpful methods from the SuggestPluginState.
   */


  getSuggestMethods() {
    var _this$getSuggestState = this.getSuggestState(),
        addIgnored = _this$getSuggestState.addIgnored,
        clearIgnored = _this$getSuggestState.clearIgnored,
        removeIgnored = _this$getSuggestState.removeIgnored,
        ignoreNextExit = _this$getSuggestState.ignoreNextExit,
        setMarkRemoved = _this$getSuggestState.setMarkRemoved,
        findMatchAtPosition = _this$getSuggestState.findMatchAtPosition,
        findNextTextSelection = _this$getSuggestState.findNextTextSelection,
        setLastChangeFromAppend = _this$getSuggestState.setLastChangeFromAppend;

    return {
      addIgnored,
      clearIgnored,
      removeIgnored,
      ignoreNextExit,
      setMarkRemoved,
      findMatchAtPosition,
      findNextTextSelection,
      setLastChangeFromAppend
    };
  }
  /**
   * Check to see whether the provided name is the currently active
   * suggester.
   *
   * @param name - the name of the suggester to include
   */


  isSuggesterActive(name) {
    var _this$getSuggestState2;

    return coreHelpers.includes(coreHelpers.isArray(name) ? name : [name], (_this$getSuggestState2 = this.getSuggestState().match) === null || _this$getSuggestState2 === void 0 ? void 0 : _this$getSuggestState2.suggester.name);
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "getSuggestState", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestState"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "getSuggestMethods", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestMethods"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "isSuggesterActive", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "isSuggesterActive"), _class2.prototype)), _class2)) || _class$2);

var _dec$1, _class$1;
/**
 * Create the extension tags which are passed into each extensions method to
 * enable dynamically generated rules and commands.
 *
 * Tags on nodes and marks are automatically added to the schema as groups.
 *
 * @category Builtin Extension
 */

var TagsExtension = (_dec$1 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec$1(_class$1 = class TagsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "allTags", coreHelpers.object());

    _defineProperty(this, "plainTags", coreHelpers.object());

    _defineProperty(this, "markTags", coreHelpers.object());

    _defineProperty(this, "nodeTags", coreHelpers.object());
  }

  get name() {
    return 'tags';
  }
  /**
   * Track the tags which have been applied to the extensions in this editor.
   */


  /**
   * Create the tags which are used to identify extension with particular
   * behavioral traits.
   */
  onCreate() {
    this.resetTags();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.updateTagForExtension(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('tags', this.allTags);
    this.store.setExtensionStore('tags', this.allTags);
    this.store.setStoreKey('plainTags', this.plainTags);
    this.store.setExtensionStore('plainTags', this.plainTags);
    this.store.setStoreKey('markTags', this.markTags);
    this.store.setExtensionStore('markTags', this.markTags);
    this.store.setStoreKey('nodeTags', this.nodeTags);
    this.store.setExtensionStore('nodeTags', this.nodeTags);
  }
  /**
   * Reset the tags to the empty object with empty arrays.
   */


  resetTags() {
    var allTags = coreHelpers.object();
    var plainTags = coreHelpers.object();
    var markTags = coreHelpers.object();
    var nodeTags = coreHelpers.object();

    var _iterator2 = _createForOfIteratorHelper(coreHelpers.values(coreConstants.ExtensionTag)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var tagName = _step2.value;
        allTags[tagName] = [];
        plainTags[tagName] = [];
        markTags[tagName] = [];
        nodeTags[tagName] = [];
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.allTags = allTags;
    this.plainTags = plainTags;
    this.markTags = markTags;
    this.nodeTags = nodeTags;
  }
  /**
   * Update the tags object for each extension.
   */


  updateTagForExtension(extension) {
    var _extension$tags, _extension$createTags, _extension$createTags2, _extension$options$ex, _this$store$managerSe, _this$store$managerSe2;

    var allTags = new Set([// TODO remove `extension.tags` once all tags have been moved over to `createTags`
    ...((_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []), ...((_extension$createTags = (_extension$createTags2 = extension.createTags) === null || _extension$createTags2 === void 0 ? void 0 : _extension$createTags2.call(extension)) !== null && _extension$createTags !== void 0 ? _extension$createTags : []), ...((_extension$options$ex = extension.options.extraTags) !== null && _extension$options$ex !== void 0 ? _extension$options$ex : []), ...((_this$store$managerSe = (_this$store$managerSe2 = this.store.managerSettings.extraTags) === null || _this$store$managerSe2 === void 0 ? void 0 : _this$store$managerSe2[extension.name]) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : [])]);

    var _iterator3 = _createForOfIteratorHelper(allTags),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var tag = _step3.value;
        !isExtensionTag(tag) ?          false ? 0 : coreHelpers.invariant(false) : void 0; // Add tags to the combined tags stored here.

        this.allTags[tag].push(extension.name);

        if (isPlainExtension(extension)) {
          this.plainTags[tag].push(extension.name);
        }

        if (isMarkExtension(extension)) {
          this.markTags[tag].push(extension.name);
        }

        if (isNodeExtension(extension)) {
          this.nodeTags[tag].push(extension.name);
        }
      } // All tags available.

    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    extension.tags = [...allTags];
  }

}) || _class$1);
/**
 * Check if the provided string is an extension tag.
 */

function isExtensionTag(value) {
  return coreHelpers.includes(coreHelpers.values(coreConstants.ExtensionTag), value);
}
/**
 * The shape of the tag data stored by the extension manager.
 *
 * This data can be used by other extensions to dynamically determine which
 * nodes should affected by commands / plugins / keys etc...
 */

var ActionType;

(function (ActionType) {
  ActionType[ActionType["ADD_PLACEHOLDER"] = 0] = "ADD_PLACEHOLDER";
  ActionType[ActionType["REMOVE_PLACEHOLDER"] = 1] = "REMOVE_PLACEHOLDER";
})(ActionType || (ActionType = {}));

var key = new state.PluginKey('remirroFilePlaceholderPlugin');
function createUploadPlaceholderPlugin() {
  return new state.Plugin({
    key: key,
    state: {
      init() {
        return {
          set: view.DecorationSet.empty,
          payloads: new Map()
        };
      },

      apply(tr, _ref) {
        var set = _ref.set,
            payloads = _ref.payloads;
        // Adjust decoration positions to changes made by the transaction
        set = set.map(tr.mapping, tr.doc); // See if the transaction adds or removes any placeholders

        var action = tr.getMeta(this);

        if (action) {
          if (action.type === ActionType.ADD_PLACEHOLDER) {
            var widget = document.createElement('placeholder');
            var deco = view.Decoration.widget(action.pos, widget, {
              id: action.id
            });
            set = set.add(tr.doc, [deco]);
            payloads.set(action.id, action.payload);
          } else if (action.type === ActionType.REMOVE_PLACEHOLDER) {
            set = set.remove(set.find(undefined, undefined, spec => spec.id === action.id));
            payloads.delete(action.id);
          }
        }

        return {
          set,
          payloads
        };
      }

    },
    props: {
      decorations(state) {
        return this.getState(state).set;
      }

    }
  });
}
/**
 * Try to find the positon of the placeholder in the document based on the
 * upload placeholder id
 *
 * @remark
 *
 * This function will first try to find the position based on the decoration set.
 * However, in some cases (e.g. `ReplaceStep`) the decoration will not be
 * available. In that case, it will then try to find every node in the document
 * recursively, which is much slower than the decoration set way in a large
 * document.
 */

function findUploadPlaceholderPos(state, id) {
  var _key$getState;

  var set = (_key$getState = key.getState(state)) === null || _key$getState === void 0 ? void 0 : _key$getState.set;

  if (set) {
    var _decos$;

    var decos = set.find(undefined, undefined, spec => spec.id === id);
    var pos = decos === null || decos === void 0 ? void 0 : (_decos$ = decos[0]) === null || _decos$ === void 0 ? void 0 : _decos$.from;

    if (pos !== undefined) {
      return pos;
    }
  }

  var foundPos;
  state.doc.descendants((node, pos) => {
    if (node.attrs.id === id) {
      foundPos = pos;
    }

    return foundPos === undefined; // return false to stop the descent
  });
  return foundPos;
}
function findUploadPlaceholderPayload(state, id) {
  var _key$getState2;

  var payloads = (_key$getState2 = key.getState(state)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.payloads;

  if (!payloads) {
    return undefined;
  }

  return payloads.get(id);
}
/**
 * Determine if there are active file uploads in the given state
 *
 * @remarks
 * This utility is useful to warn users there are still active uploads before
 * exiting or saving a document.
 *
 * @see https://remirror.vercel.app/?path=/story/extensions-file--with-upload-incomplete-warning
 *
 * @param state - the editor state
 */

function hasUploadingFile(state) {
  var _key$getState$payload, _key$getState3, _key$getState3$payloa;

  var placeholderCount = (_key$getState$payload = (_key$getState3 = key.getState(state)) === null || _key$getState3 === void 0 ? void 0 : (_key$getState3$payloa = _key$getState3.payloads) === null || _key$getState3$payloa === void 0 ? void 0 : _key$getState3$payloa.size) !== null && _key$getState$payload !== void 0 ? _key$getState$payload : 0;
  return placeholderCount > 0;
}
function setUploadPlaceholderAction(tr, action) {
  return tr.setMeta(key, action);
}

function createUploadContext() {
  var values = {};
  var emitter = nanoevents.createNanoEvents();

  var get = key => {
    return values[key];
  };

  var set = (key, value) => {
    values[key] = value;
    emitter.emit('set', values);
  };

  var addListener = listener => {
    return emitter.on('set', listener);
  };

  return {
    set,
    get,
    addListener
  };
}

/**
 * Any `ProsemirrorNode` can use the `uploadFile` function in this file as long
 * as its attributes implement this interface.
 */

/**
 * Insert a file into the editor and upload it.
 */
function uploadFile(_ref) {
  var file = _ref.file,
      pos = _ref.pos,
      view = _ref.view,
      fileType = _ref.fileType,
      uploadHandler = _ref.uploadHandler;
  var id = coreHelpers.uniqueId('file-placeholder-');
  var context = createUploadContext();
  var fileUploader = createFilePlaceholder({
    id,
    context,
    file,
    pos,
    view,
    fileType,
    uploadHandler
  });
  fileUploader === null || fileUploader === void 0 ? void 0 : fileUploader.upload(context).then(attrs => onFileLoaded({
    id,
    fileType,
    view,
    attrs
  })).catch(error => onFileLoaded({
    id,
    fileType,
    view,
    attrs: {
      error: error.message
    }
  }));
}
/**
 * Try to find a point where a node of the given type can be inserted
 * near `pos`, by searching up the node hierarchy when `pos` itself
 * isn't a valid place. Return null if no position was found.
 *
 * This function is similar to `insertPoint` from `prosemirror-transform`,
 * but it will also search for a valid position even if the `pos` is in the
 * middle of a node.
 */

function insertFilePoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);

  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {
    return pos;
  }

  if ($pos.parentOffset === 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);

      if ($pos.node(d).canReplaceWith(index, index, nodeType)) {
        return $pos.before(d + 1);
      }

      if (index > 0) {
        return null;
      }
    }
  }

  for (var _d = $pos.depth - 1; _d >= 0; _d--) {
    var _index = $pos.indexAfter(_d);

    if ($pos.node(_d).canReplaceWith(_index, _index, nodeType)) {
      return $pos.after(_d + 1);
    }

    if (_index < $pos.node(_d).childCount) {
      return null;
    }
  }

  return null;
}

function createFilePlaceholder(_ref2) {
  var id = _ref2.id,
      context = _ref2.context,
      file = _ref2.file,
      pos = _ref2.pos,
      view = _ref2.view,
      fileType = _ref2.fileType,
      uploadHandler = _ref2.uploadHandler;
  var tr = view.state.tr;
  var insertPos = insertFilePoint(tr.doc, coreHelpers.isNumber(pos) ? pos : tr.selection.from, fileType);

  if (!coreHelpers.isNumber(insertPos)) {
    // failed to find a postition to insert the file node
    return;
  } // create a fileUploader, which will read and/or upload the file later


  var fileUploader = uploadHandler(); // insert the file node

  var attrs = _objectSpread(_objectSpread({}, fileUploader.insert(file)), {}, {
    id
  });

  tr.insert(insertPos, fileType.createChecked(attrs)); // insert the placeholder decoration

  var payload = {
    context,
    fileUploader
  };
  setUploadPlaceholderAction(tr, {
    type: ActionType.ADD_PLACEHOLDER,
    id,
    pos: insertPos,
    payload
  });
  view.dispatch(tr);
  return fileUploader;
}

function onFileLoaded(_ref3) {
  var id = _ref3.id,
      attrs = _ref3.attrs,
      fileType = _ref3.fileType,
      view = _ref3.view;
  var placeholderPos = findUploadPlaceholderPos(view.state, id); // unexpected

  if (placeholderPos == null) {
    return;
  }

  var $pos = view.state.doc.resolve(placeholderPos);
  var fileNode = $pos.nodeAfter; // if the file node around the placeholder has been deleted, then delete
  // the placeholder and drop the uploaded file.

  if (!fileNode || fileNode.type !== fileType || fileNode.attrs.id !== id) {
    var _tr = view.state.tr;
    setUploadPlaceholderAction(_tr, {
      type: ActionType.REMOVE_PLACEHOLDER,
      id
    });
    view.dispatch(_tr);
    return;
  } // Update the file node at the placeholder's position, and remove
  // the placeholder.


  var tr = view.state.tr;
  setUploadPlaceholderAction(tr, {
    type: ActionType.REMOVE_PLACEHOLDER,
    id
  });

  var fileAttrs = _objectSpread(_objectSpread(_objectSpread({}, fileNode.attrs), attrs), {}, {
    id: null
  }); // We need to update the node to trigger the render function, which will accept
  // differnt properties during and after the upload progress.


  tr.setNodeMarkup(placeholderPos, undefined, fileAttrs);
  view.dispatch(tr);
}

/**
 * `UploadExtension` handle the file upload process.
 */
class UploadExtension extends PlainExtension {
  get name() {
    return 'upload';
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createExternalPlugins() {
    return [createUploadPlaceholderPlugin()];
  }

}

/**
 * Provides all the builtin extensions to the editor.
 *
 * @remarks
 *
 * This is used automatically and (at the time of writing) can't be removed from
 * the editor. If you feel that there's a compelling reason to override these
 * extensions feel free to create a [discussion
 * here](https://github.com/remirror/remirror/discussions/category_choices) and
 * it can be addressed.
 *
 * @category Builtin Extension
 *
 * The order of these extension are important.
 *
 * - [[`TagsExtension`]] is places first because it provides tagging which is
 *   used by the schema extension.
 * - [[`SchemeExtension`]] goes next because it's super important to the editor
 *   functionality and needs to run before everything else which might depend
 *   on it.
 */
function builtinPreset() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultOptions = {
    exitMarksOnArrowPress: KeymapExtension.defaultOptions.exitMarksOnArrowPress,
    excludeBaseKeymap: KeymapExtension.defaultOptions.excludeBaseKeymap,
    selectParentNodeOnEscape: KeymapExtension.defaultOptions.selectParentNodeOnEscape,
    undoInputRuleOnBackspace: KeymapExtension.defaultOptions.undoInputRuleOnBackspace,
    persistentSelectionClass: DecorationsExtension.defaultOptions.persistentSelectionClass
  };
  options = _objectSpread(_objectSpread({}, defaultOptions), options);
  var keymapOptions = coreHelpers.pick(options, ['excludeBaseKeymap', 'selectParentNodeOnEscape', 'undoInputRuleOnBackspace']);
  var decorationsOptions = coreHelpers.pick(options, ['persistentSelectionClass']);
  return [// The order of these extension is important. First come first served.
  new TagsExtension(), new SchemaExtension(), new AttributesExtension(), new PluginsExtension(), new InputRulesExtension(), new PasteRulesExtension(), new NodeViewsExtension(), new SuggestExtension(), new CommandsExtension(), new HelpersExtension(), new KeymapExtension(keymapOptions), new DocChangedExtension(), new UploadExtension(), new DecorationsExtension(decorationsOptions)];
}

var _dec, _class;
var MetaExtension = (_dec = extension({
  defaultOptions: {
    capture:         "production" === 'development'
  },
  staticKeys: ['capture'],
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec(_class = class MetaExtension extends PlainExtension {
  get name() {
    return 'meta';
  }

  onCreate() {
    this.store.setStoreKey('getCommandMeta', this.getCommandMeta.bind(this));

    if (!this.options.capture) {
      return;
    }

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.captureCommands(_extension);
        this.captureKeybindings(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * This is here to provide a
   */


  createPlugin() {
    return {};
  }
  /**
   * Intercept command names and attributes.
   */


  captureCommands(extension) {
    var _extension$decoratedC,
        _this = this;

    var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
    var createCommands = extension.createCommands;

    var _loop = function _loop() {
      var name = _Object$keys[_i];
      var command = extension[name];

      extension[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return props => {
          var value = command(...args)(props);

          if (props.dispatch && value) {
            var _props$view;

            _this.setCommandMeta(props.tr, {
              type: 'command',
              chain: props.dispatch !== ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch),
              name: name,
              extension: extension.name,
              decorated: true
            });
          }

          return value;
        };
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(decoratedCommands); _i < _Object$keys.length; _i++) {
      _loop();
    }

    if (createCommands) {
      extension.createCommands = () => {
        var commandsObject = createCommands();

        var _loop2 = function _loop2() {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              name = _Object$entries$_i[0],
              command = _Object$entries$_i[1];

          commandsObject[name] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            return props => {
              var value = command(...args)(props);

              if (props.dispatch && value) {
                var _props$view2;

                _this.setCommandMeta(props.tr, {
                  type: 'command',
                  chain: props.dispatch !== ((_props$view2 = props.view) === null || _props$view2 === void 0 ? void 0 : _props$view2.dispatch),
                  name: name,
                  extension: extension.name,
                  decorated: false
                });
              }

              return value;
            };
          };
        };

        for (var _i2 = 0, _Object$entries = Object.entries(commandsObject); _i2 < _Object$entries.length; _i2++) {
          _loop2();
        }

        return commandsObject;
      };
    }
  }
  /**
   * Intercept command name and attributes.
   */


  captureKeybindings(_) {}
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    return (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : [];
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, [...meta, update]);
  }

}) || _class);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

var _uid = /*#__PURE__*/new WeakMap();

var _getProps = /*#__PURE__*/new WeakMap();

var _previousState = /*#__PURE__*/new WeakMap();

var _firstRender = /*#__PURE__*/new WeakMap();

var _events$1 = /*#__PURE__*/new WeakMap();

var _addHandler = /*#__PURE__*/new WeakMap();

var _initialEditorState = /*#__PURE__*/new WeakMap();

/**
 * This is the `Framework` class which is used to create an abstract class for
 * implementing `Remirror` into the framework of your choice.
 *
 * The best way to learn how to use it is to take a look at the [[`DomFramework`]]
 * and [[`ReactFramework`]] implementations.
 *
 * @remarks
 *
 * There are two methods and one getter property which must be implemented for this
 */
class Framework {
  /**
   * The schema available via the provided extensions.
   *
   * @internal
   */

  /**
   * A unique ID for the editor which can also be used as a key in frameworks
   * that need it.
   */

  /**
   * A method which enables retrieving the props from the editor.
   */

  /**
   * The private reference to the previous state.
   */

  /**
   * True when this is the first render.
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */
  get addHandler() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _addHandler)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _addHandler, _classPrivateFieldGet(this, _events$1).on.bind(_classPrivateFieldGet(this, _events$1)));
  }
  /**
   * The handler which is bound to the events listener object.
   */


  /**
   * The updatable view props.
   */
  get updatableViewProps() {
    return {
      attributes: () => this.getAttributes(),
      editable: () => {
        var _this$props$editable;

        return (_this$props$editable = this.props.editable) !== null && _this$props$editable !== void 0 ? _this$props$editable : true;
      }
    };
  }
  /**
   * True when this is the first render of the editor.
   */


  get firstRender() {
    return _classPrivateFieldGet(this, _firstRender);
  }
  /**
   * Store the name of the framework.
   */


  /**
   * The props passed in when creating or updating the `Framework` instance.
   */
  get props() {
    return _classPrivateFieldGet(this, _getProps).call(this);
  }
  /**
   * Returns the previous editor state. On the first render it defaults to
   * returning the current state. For the first render the previous state and
   * current state will always be equal.
   */


  get previousState() {
    var _ref, _this$previousStateOv;

    return (_ref = (_this$previousStateOv = this.previousStateOverride) !== null && _this$previousStateOv !== void 0 ? _this$previousStateOv : _classPrivateFieldGet(this, _previousState)) !== null && _ref !== void 0 ? _ref : this.initialEditorState;
  }
  /**
   * The instance of the [[`RemirrorManager`]].
   */


  get manager() {
    return this.props.manager;
  }
  /**
   * The ProseMirror [[`EditorView`]].
   */


  get view() {
    return this.manager.view;
  }
  /**
   * A unique id for the editor. Can be used to differentiate between editors.
   *
   * Please note that this ID is only locally unique, it should not be used as a
   * database key.
   */


  get uid() {
    return _classPrivateFieldGet(this, _uid);
  }

  /**
   * The initial editor state from when the editor was first created.
   */
  get initialEditorState() {
    return _classPrivateFieldGet(this, _initialEditorState);
  }

  constructor(options) {
    var _this = this;

    _classPrivateFieldInitSpec(this, _uid, {
      writable: true,
      value: coreHelpers.uniqueId()
    });

    _classPrivateFieldInitSpec(this, _getProps, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _previousState, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstRender, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _events$1, {
      writable: true,
      value: nanoevents.createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _addHandler, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _initialEditorState, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _this$view$state;

      return (_this$view$state = this.view.state) !== null && _this$view$state !== void 0 ? _this$view$state : this.initialEditorState;
    });

    _defineProperty(this, "getPreviousState", () => this.previousState);

    _defineProperty(this, "dispatchTransaction", tr => {
      var _this$props$onDispatc, _this$props$onDispatc2, _this$props;

      // This should never happen, but it may have slipped through in the certain places.
      !!this.manager.destroyed ? coreHelpers.invariant(false) : void 0;
      tr = (_this$props$onDispatc = (_this$props$onDispatc2 = (_this$props = this.props).onDispatchTransaction) === null || _this$props$onDispatc2 === void 0 ? void 0 : _this$props$onDispatc2.call(_this$props, tr, this.getState())) !== null && _this$props$onDispatc !== void 0 ? _this$props$onDispatc : tr;
      var previousState = this.getState();

      var _previousState$applyT = previousState.applyTransaction(tr),
          state = _previousState$applyT.state,
          transactions = _previousState$applyT.transactions;

      _classPrivateFieldSet(this, _previousState, previousState); // Use the abstract method to update the state.


      this.updateState({
        state,
        tr,
        transactions
      }); // Update the view props when an update is requested

      var forcedUpdates = this.manager.store.getForcedUpdates(tr);

      if (!coreHelpers.isEmptyArray(forcedUpdates)) {
        this.updateViewProps(...forcedUpdates);
      }
    });

    _defineProperty(this, "onChange", function () {
      var _this$props$onChange, _this$props2;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : coreHelpers.object();

      var onChangeProps = _this.eventListenerProps(props);

      if (_classPrivateFieldGet(_this, _firstRender)) {
        _classPrivateFieldSet(_this, _firstRender, false);
      }

      (_this$props$onChange = (_this$props2 = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props2, onChangeProps);
    });

    _defineProperty(this, "onBlur", event => {
      var _this$props$onBlur, _this$props3;

      var props = this.eventListenerProps();
      (_this$props$onBlur = (_this$props3 = this.props).onBlur) === null || _this$props$onBlur === void 0 ? void 0 : _this$props$onBlur.call(_this$props3, props, event);

      _classPrivateFieldGet(this, _events$1).emit('blur', props, event);
    });

    _defineProperty(this, "onFocus", event => {
      var _this$props$onFocus, _this$props4;

      var props = this.eventListenerProps();
      (_this$props$onFocus = (_this$props4 = this.props).onFocus) === null || _this$props$onFocus === void 0 ? void 0 : _this$props$onFocus.call(_this$props4, props, event);

      _classPrivateFieldGet(this, _events$1).emit('focus', props, event);
    });

    _defineProperty(this, "setContent", function (content) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$triggerChange = _ref2.triggerChange,
          triggerChange = _ref2$triggerChange === void 0 ? false : _ref2$triggerChange;

      var _this$manager$createS = _this.manager.createState({
        content
      }),
          doc = _this$manager$createS.doc;

      var previousState = _this.getState();

      var _this$getState$applyT = _this.getState().applyTransaction(previousState.tr.replaceRangeWith(0, previousState.doc.nodeSize - 2, doc)),
          state = _this$getState$applyT.state;

      if (triggerChange) {
        return _this.updateState({
          state,
          triggerChange
        });
      }

      _this.view.updateState(state);
    });

    _defineProperty(this, "clearContent", function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$triggerChange = _ref3.triggerChange,
          triggerChange = _ref3$triggerChange === void 0 ? false : _ref3$triggerChange;

      _this.setContent(_this.manager.createEmptyDoc(), {
        triggerChange
      });
    });

    _defineProperty(this, "createStateFromContent", (content, selection) => {
      return this.manager.createState({
        content,
        selection
      });
    });

    _defineProperty(this, "focus", position => {
      this.manager.store.commands.focus(position);
    });

    _defineProperty(this, "blur", position => {
      this.manager.store.commands.blur(position);
    });

    var getProps = options.getProps,
        initialEditorState = options.initialEditorState,
        element = options.element;

    _classPrivateFieldSet(this, _getProps, getProps);

    _classPrivateFieldSet(this, _initialEditorState, initialEditorState); // Attach the framework instance to the manager. The manager will set up the
    // update listener and manage updates to the instance of the framework
    // automatically.


    this.manager.attachFramework(this, this.updateListener.bind(this));

    if (this.manager.view) {
      return;
    } // Create the ProsemirrorView and initialize our editor manager with it.


    var view = this.createView(initialEditorState, element);
    this.manager.addView(view);
  }
  /**
   * Setup the manager event listeners which are disposed of when the manager is
   * destroyed.
   */


  updateListener(props) {
    var state = props.state,
        tr = props.tr;
    return _classPrivateFieldGet(this, _events$1).emit('updated', this.eventListenerProps({
      state,
      tr
    }));
  }
  /**
   * Update the constructor props passed in. Useful for frameworks like react
   * where props are constantly changing and when using hooks function closures
   * can become stale.
   *
   * You can call the update method with the new `props` to update the internal
   * state of this instance.
   */


  update(options) {
    var getProps = options.getProps;

    _classPrivateFieldSet(this, _getProps, getProps);

    return this;
  }
  /**
   * Retrieve the editor state.
   */


  /**
   * Update the view props.
   */
  updateViewProps() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    var props = coreHelpers.pick(this.updatableViewProps, keys);
    this.view.setProps(_objectSpread(_objectSpread({}, this.view.props), props));
  }
  /**
   * This sets the attributes for the ProseMirror Dom node.
   */


  getAttributes(ssr) {
    var _this$manager$store;

    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        autoFocus = _this$props5.autoFocus,
        _this$props5$classNam = _this$props5.classNames,
        classNames = _this$props5$classNam === void 0 ? [] : _this$props5$classNam,
        label = _this$props5.label,
        editable = _this$props5.editable;
    var managerAttributes = (_this$manager$store = this.manager.store) === null || _this$manager$store === void 0 ? void 0 : _this$manager$store.attributes; // The attributes which were passed in as props.

    var propAttributes = coreHelpers.isFunction(attributes) ? attributes(this.eventListenerProps()) : attributes; // Whether or not the editor is focused.

    var focus = {}; // In Chrome 84 when autofocus is set to any value including `"false"` it
    // will actually trigger the autofocus. This check makes sure there is no
    // `autofocus` attribute attached unless `autoFocus` is expressly a truthy
    // value.

    if (autoFocus || coreHelpers.isNumber(autoFocus)) {
      focus = ssr ? {
        autoFocus: true
      } : {
        autofocus: 'true'
      };
    }

    var uniqueClasses = coreHelpers.uniqueArray(coreHelpers.cx(ssr && 'Prosemirror', 'remirror-editor', managerAttributes === null || managerAttributes === void 0 ? void 0 : managerAttributes.class, ...classNames).split(' ')).join(' ');

    var defaultAttributes = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
      role: 'textbox'
    }, focus), {}, {
      'aria-multiline': 'true'
    }, !(editable !== null && editable !== void 0 ? editable : true) ? {
      'aria-readonly': 'true'
    } : {}), {}, {
      'aria-label': label !== null && label !== void 0 ? label : ''
    }, managerAttributes), {}, {
      class: uniqueClasses
    });

    return coreHelpers.omitUndefined(_objectSpread(_objectSpread({}, defaultAttributes), propAttributes));
  }
  /**
   * Part of the Prosemirror API and is called whenever there is state change in
   * the editor.
   *
   * @internalremarks
   * How does it work when transactions are dispatched one after the other.
   */


  /**
   * Adds `onBlur` and `onFocus` listeners.
   *
   * When extending this class make sure to call this method once
   * `ProsemirrorView` has been added to the dom.
   */
  addFocusListeners() {
    this.view.dom.addEventListener('blur', this.onBlur);
    this.view.dom.addEventListener('focus', this.onFocus);
  }
  /**
   * Remove `onBlur` and `onFocus` listeners.
   *
   * When extending this class in your framework, make sure to call this just
   * before the view is destroyed.
   */


  removeFocusListeners() {
    this.view.dom.removeEventListener('blur', this.onBlur);
    this.view.dom.removeEventListener('focus', this.onFocus);
  }
  /**
   * Called when the component unmounts and is responsible for cleanup.
   *
   * @remarks
   *
   * - Removes listeners for the editor `blur` and `focus` events
   */


  destroy() {
    // Let it clear that this instance has been destroyed.
    _classPrivateFieldGet(this, _events$1).emit('destroy');

    if (this.view) {
      // Remove the focus and blur listeners.
      this.removeFocusListeners();
    }
  }
  /**
   * Use this method in the `onUpdate` event to run all change handlers.
   */


  /**
   * Creates the props passed into all event listener handlers. e.g.
   * `onChange`
   */
  eventListenerProps() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : coreHelpers.object();
    var state = props.state,
        tr = props.tr,
        transactions = props.transactions;
    return {
      tr,
      transactions,
      internalUpdate: !tr,
      view: this.view,
      firstRender: _classPrivateFieldGet(this, _firstRender),
      state: state !== null && state !== void 0 ? state : this.getState(),
      createStateFromContent: this.createStateFromContent,
      previousState: this.previousState,
      helpers: this.manager.store.helpers
    };
  }

  /**
   * Methods and properties which are made available to all consumers of the
   * `Framework` class.
   */
  get baseOutput() {
    return _objectSpread(_objectSpread({
      manager: this.manager
    }, this.manager.store), {}, {
      addHandler: this.addHandler,
      // Commands
      focus: this.focus,
      blur: this.blur,
      // Properties
      uid: _classPrivateFieldGet(this, _uid),
      view: this.view,
      // Getter Methods
      getState: this.getState,
      getPreviousState: this.getPreviousState,
      getExtension: this.manager.getExtension.bind(this.manager),
      // Setter Methods
      clearContent: this.clearContent,
      setContent: this.setContent
    });
  }
  /**
   * Every framework implementation must provide it's own custom output.
   */


}

/**
 * Transforms the unsorted array of presets and extension into presets and
 * sorted extensions. Handles uniqueness of extensions and automatically throws
 * an error when required extensions are missing.
 *
 * @internalremarks Currently matching by constructor - what if different
 * versions exist in the same app
 *
 * @param initialExtensions - the extensions to be transformed. This includes
 * the extension that are parents to other extensions.
 *
 * @returns the list of extension instances sorted by priority
 */
function transformExtensions(initialExtensions, settings) {
  // This is the holder for the sorted and cleaned extensions returned by this
  // function.
  var extensions = [];
  var extensionMap = new WeakMap(); // All the extensions which provide child extensions.

  var parentExtensions = []; // Used to track duplicates and the extension holders they were added by.

  var duplicateMap = new WeakMap(); // The unsorted, de-duped, unrefined extensions.

  var gatheredExtensions = []; // The mutable objects and the manager settings which are used to gather all
  // the deeply nested extensions.

  var gatherRawExtensionConfig = {
    duplicateMap,
    parentExtensions,
    gatheredExtensions,
    settings
  };

  var _iterator = _createForOfIteratorHelper(initialExtensions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _extension = _step.value;
      gatherRawExtensions(gatherRawExtensionConfig, {
        extension: _extension
      });
    } // Sort the extensions.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  gatheredExtensions = coreHelpers.sort(gatheredExtensions, (a, z) => z.priority - a.priority); // Keep track of added constructors for uniqueness.

  var found = new WeakSet();
  var names = new Set(); // Remove extension duplicates and update the parent extension with the
  // highest priority identical extension.

  var _iterator2 = _createForOfIteratorHelper(gatheredExtensions),
      _step2;

  try {
    var _loop = function _loop() {
      var extension = _step2.value;
      var key = extension.constructor;
      var name = extension.name;
      var duplicates = duplicateMap.get(key);
      !duplicates ?          false ? 0 : coreHelpers.invariant(false) : void 0;

      if (found.has(key) || names.has(name)) {
        return "continue";
      }

      found.add(key);
      names.add(name);
      extensions.push(extension);
      extensionMap.set(key, extension); // Replace the extensions for all presets that referenced this constructor.

      duplicates.forEach(parent => parent === null || parent === void 0 ? void 0 : parent.replaceChildExtension(key, extension));
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var missing = []; // Throw if any required extensions are missing.

  for (var _i = 0, _extensions = extensions; _i < _extensions.length; _i++) {
    var extension = _extensions[_i];
    findMissingExtensions({
      extension,
      found,
      missing
    });
  }

  !coreHelpers.isEmptyArray(missing) ? coreHelpers.invariant(false) : void 0;
  return {
    extensions,
    extensionMap
  };
}

/**
 * Dive into the current extension and gather all child extensions including
 * those which are deeply nested.
 *
 * It also automatically handles circular dependencies. And logs a warning when
 * one is encountered.
 *
 * @param config - the configuration and mutable objects which are updated by
 * this function.
 * @param props - the extension, gathered names and parent extension.
 */
function gatherRawExtensions(config, props) {
  var _settings$priority;

  var gatheredExtensions = config.gatheredExtensions,
      duplicateMap = config.duplicateMap,
      parentExtensions = config.parentExtensions,
      settings = config.settings;
  var extension = props.extension,
      parentExtension = props.parentExtension; // Get the list of parent names of the current extension. This is used to
  // track circular dependencies.

  var _props$names = props.names,
      names = _props$names === void 0 ? [] : _props$names;
  !isExtension(extension) ? coreHelpers.invariant(false) : void 0; // The children provided by this extension.

  var childExtensions = extension.extensions; // Override the priority if the user has done so in the settings passed to the
  // [[`RemirrorManager`]].

  extension.setPriority((_settings$priority = settings.priority) === null || _settings$priority === void 0 ? void 0 : _settings$priority[extension.name]); // Update the gathered extension list in this block

  gatheredExtensions.push(extension); // Keep track of the extensions which have been added multiple times by
  // separate extension parents. Later on, the highest priority extension will
  // be added to each parent instead of the one that they may have been
  // configured with.

  updateExtensionDuplicates({
    duplicateMap,
    extension,
    parentExtension
  }); // Check if there are any children extensions to be added an if not move onto
  // the next provided extension.

  if (childExtensions.length === 0) {
    return;
  }

  if (names.includes(extension.name)) {
    return;
  }

  names = [...names, extension.name];
  parentExtensions.push(extension);

  var _iterator3 = _createForOfIteratorHelper(childExtensions),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var child = _step3.value;
      // Recursively gather all the children extension from the current extension
      // level.
      gatherRawExtensions(config, {
        names,
        extension: child,
        parentExtension: extension
      });
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

/**
 * Populate missing Constructors.
 *
 * If any missing extensions are identified then it is the responsibility of the
 * calling method to deal with the error. Currently the action is to `throw` an
 * error.
 */
function findMissingExtensions(props) {
  var _extension$requiredEx;

  var extension = props.extension,
      found = props.found,
      missing = props.missing;

  if (!extension.requiredExtensions) {
    return;
  }

  var _iterator4 = _createForOfIteratorHelper((_extension$requiredEx = extension.requiredExtensions) !== null && _extension$requiredEx !== void 0 ? _extension$requiredEx : []),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var Constructor = _step4.value;

      if (found.has(Constructor)) {
        continue;
      }

      missing.push({
        Constructor: Constructor,
        extension
      });
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}

/**
 * Adds the values to the duplicate map which identifies each unique extension
 * in the manager and tracks the presets responsible for adding them. This is
 * used to make sure that only one instance of each extension is shared amongst
 * the presets which require it.
 *
 * At the moment, the highest priority extension is the one that is to all
 * presets which require it. This is done by checking the `duplicateMap` for
 * each extension, and replacing the instance of the required extension within
 * the preset with the highest priority instance.
 */
function updateExtensionDuplicates(props) {
  var duplicateMap = props.duplicateMap,
      extension = props.extension,
      parentExtension = props.parentExtension; // The extension constructor is used as the identifier for lookups.

  var key = extension.constructor;
  var duplicate = duplicateMap.get(key);
  var parentToAdd = parentExtension ? [parentExtension] : [];
  duplicateMap.set(key, duplicate ? [...duplicate, ...parentToAdd] : parentToAdd);
}
/**
 * This is the object shape that is returned from the combined transformation.
 */


/**
 * This helper function extracts all the lifecycle methods from the provided
 * extension and adds them to the provided `handler` container.
 */
function extractLifecycleMethods(props) {
  var _extension$onCreate, _extension$onView, _extension$onStateUpd, _extension$onDestroy;

  var extension = props.extension,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      plainNames = props.plainNames,
      store = props.store,
      handlers = props.handlers; // Add the store to the extension. The store is used by extensions to access
  // all the data included in `Remirror.ExtensionStore`. I decided on this
  // pattern because passing around parameters into each call method was
  // tedious. Why not just access `this.store` within your extension to get
  // whatever you need? Also using the store allows developers to extend the
  // behaviour of their editor by adding different behaviour to the global
  // namespace [[`Remirror.ExtensionStore`]].

  extension.setStore(store); // Gather all the handlers and add them where they exist.

  var createHandler = (_extension$onCreate = extension.onCreate) === null || _extension$onCreate === void 0 ? void 0 : _extension$onCreate.bind(extension);
  var viewHandler = (_extension$onView = extension.onView) === null || _extension$onView === void 0 ? void 0 : _extension$onView.bind(extension);
  var stateUpdateHandler = (_extension$onStateUpd = extension.onStateUpdate) === null || _extension$onStateUpd === void 0 ? void 0 : _extension$onStateUpd.bind(extension);
  var destroyHandler = (_extension$onDestroy = extension.onDestroy) === null || _extension$onDestroy === void 0 ? void 0 : _extension$onDestroy.bind(extension);

  if (createHandler) {
    handlers.create.push(createHandler);
  }

  if (viewHandler) {
    handlers.view.push(viewHandler);
  }

  if (stateUpdateHandler) {
    handlers.update.push(stateUpdateHandler);
  }

  if (destroyHandler) {
    handlers.destroy.push(destroyHandler);
  } // Keep track of the names of the different types of extension held by this
  // manager. This is already in use by the [[`TagsExtension`]].


  if (isMarkExtension(extension)) {
    markNames.push(extension.name);
  } // Don't include the `doc` as a node since it is a requirement for all editors
  // and doesn't behave in the same way as other nodes.


  if (isNodeExtension(extension) && extension.name !== 'doc') {
    nodeNames.push(extension.name);
  }

  if (isPlainExtension(extension)) {
    plainNames.push(extension.name);
  }
}

/**
 * The `Manager` has multiple hook phases which are able to hook into the
 * extension manager flow and add new functionality to the editor.
 *
 * The `ExtensionEventMethod`s
 *
 * - onCreate - when the extension manager is created and after the schema is
 *   made available.
 * - onView - when the view has been received from the dom ref.
 */

/**
 * A class to manage the extensions and prosemirror interactions within the
 * editor.
 *
 * @remarks
 *
 * The RemirrorManager enables the lifecycle methods of the extensions by
 * calling each method in the distinct phases of the lifecycle.
 *
 * - `onCreate` - This happens when the manager is constructed. It calls on the
 *   extension which have an `onCreate` method and allows them to do their work.
 *
 * For the built in methods, this is when the `SchemaExtension` creates the
 * Schema and when the `TagsExtension` combines the tags for the editor
 * instance.
 *
 * ```ts
 * const manager = Manager.create(() => [
 *   new DocExtension(),
 *   new TextExtension(),
 *   new ParagraphExtension(),
 * ])
 * ```
 *
 * At this point all the `onCreate` methods have been called. Including the
 * `onCreate` for the `Schema`.
 *
 * - `onView` - This is called the framework instance connects the
 *   `RemirrorManager` to the ProseMirror EditorView.
 *
 * ```ts
 * manager.addView(new EditorView(...))
 * manager.store.commands.insertText('Hello world');.
 * ```
 *
 * - [[`onStateUpdate`]] - This is the method called every time the ProseMirror
 *   state changes. Both the extensions and the `Framework` listen to this event
 *   and can provide updates in response.
 */

var _extensionStore = /*#__PURE__*/new WeakMap();

var _stringHandlers = /*#__PURE__*/new WeakMap();

var _store = /*#__PURE__*/new WeakMap();

var _extensions = /*#__PURE__*/new WeakMap();

var _extensionMap = /*#__PURE__*/new WeakMap();

var _phase = /*#__PURE__*/new WeakMap();

var _settings = /*#__PURE__*/new WeakMap();

var _firstStateUpdate = /*#__PURE__*/new WeakMap();

var _handlers = /*#__PURE__*/new WeakMap();

var _disposers = /*#__PURE__*/new WeakMap();

var _events = /*#__PURE__*/new WeakMap();

var _framework = /*#__PURE__*/new WeakMap();

var _disposeFramework = /*#__PURE__*/new WeakMap();

class RemirrorManager {
  /**
   * Create the manager for your `Remirror` editor.
   */
  static create(extensions) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new RemirrorManager([...coreHelpers.getLazyArray(extensions), ...builtinPreset(settings.builtin)], settings);
  }
  /**
   * Utility getter for storing the base method props which is available to
   * all extensions.
   */


  /**
   * Identifies this as a `Manager`.
   *
   * @internal
   */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.Manager;
  }
  /**
   * Returns `true` if the manager has been destroyed.
   */


  get destroyed() {
    return _classPrivateFieldGet(this, _phase) === coreConstants.ManagerPhase.Destroy;
  }
  /**
   * `true` when the view has been added to the UI layer and the editor is
   * running.
   */


  get mounted() {
    return _classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView && _classPrivateFieldGet(this, _phase) < coreConstants.ManagerPhase.Destroy;
  }
  /**
   * Retrieve the framework output.
   *
   * This be undefined if the manager hasn't been provided to a framework yet
   * the manager.
   *
   * With synchronous frameworks this means that it should only be accessed
   * after the manager has been applied to the editor creation function.
   *
   * For frameworks like React it is only available when the manager is provided
   * to the `Remirror` component and after the very first render. This means it
   * is available within the `onRef` callback.
   *
   * ```tsx
   * import React, { useEffect } from 'react';
   * import { useRemirror, Remirror } from '@remirror/react';
   *
   * const Editor = () => {
   *   const { manager } = useRemirror();
   *
   *   const callback = () => {
   *     return manager.output; // ✅ This is fine.
   *   }
   *
   *   useEffect(() => {
   *     log(manager.output); // ✅  This is also fine.
   *   }, []);
   *
   *   log(manager.output); // ❌ This will be undefined on the first render.
   *
   *   return <Remirror manager={manager} />
   * }
   * ```
   */


  get output() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.frameworkOutput;
  }
  /**
   * Returns true when a framework is attached to the manager.
   *
   * This can be used to check if it is safe to call `manager.output`.
   */


  get frameworkAttached() {
    return !!_classPrivateFieldGet(this, _framework);
  }
  /**
   * The extensions stored by this manager
   */


  get extensions() {
    return _classPrivateFieldGet(this, _extensions);
  }
  /**
   * The registered string handlers provided by the extensions.
   *
   * By default this includes `html` and `plainText`
   */


  get stringHandlers() {
    return _classPrivateFieldGet(this, _stringHandlers);
  }
  /**
   * Get the extension manager store which is accessible at initialization.
   */


  get store() {
    return coreHelpers.freeze(_classPrivateFieldGet(this, _store));
  }
  /**
   * Provides access to the extension store.
   */


  get extensionStore() {
    return coreHelpers.freeze(_classPrivateFieldGet(this, _extensionStore));
  }
  /**
   * Shorthand access to the active transaction from the manager. This is the
   * shared transaction available to all commands and should be used when you
   * need to make your commands chainable.
   *
   * If working with react and setting up your editor as a controlled component
   * then this is the preferred way to run custom commands, otherwise your
   * commands will end up being non-chainable and be overwritten by anything
   * that comes after.
   */


  get tr() {
    return this.getExtension(CommandsExtension).transaction;
  }
  /**
   * Returns the stored nodes
   */


  get nodes() {
    return _classPrivateFieldGet(this, _store).nodes;
  }
  /**
   * Returns the store marks.
   */


  get marks() {
    return _classPrivateFieldGet(this, _store).marks;
  }
  /**
   * A shorthand method for retrieving the schema for this extension manager
   * from the data.
   */


  get schema() {
    return _classPrivateFieldGet(this, _store).schema;
  }
  /**
   * A shorthand getter for retrieving the tags from the extension manager.
   */


  get extensionTags() {
    return _classPrivateFieldGet(this, _store).tags;
  }
  /**
   * A shorthand way of retrieving the editor view.
   */


  get view() {
    return _classPrivateFieldGet(this, _store).view;
  }
  /**
   * Retrieve the settings used when creating the manager.
   */


  get settings() {
    return _classPrivateFieldGet(this, _settings);
  }
  /**
   * The document to use for rendering and outputting HTML.
   */


  get document() {
    var _classPrivateFieldGet3;

    return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _settings).document) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : coreUtils.getDocument(_classPrivateFieldGet(this, _settings).forceEnvironment);
  }
  /**
   * Creates the extension manager which is used to simplify the management of
   * the prosemirror editor.
   *
   * This is set to private to encourage using `RemirrorManager.create`
   * instead of the `new` keyword.
   */


  constructor(initialExtension) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classPrivateFieldInitSpec(this, _extensionStore, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _stringHandlers, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _store, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _extensions, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _extensionMap, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _phase, {
      writable: true,
      value: coreConstants.ManagerPhase.None
    });

    _classPrivateFieldInitSpec(this, _settings, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstStateUpdate, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _handlers, {
      writable: true,
      value: {
        create: [],
        view: [],
        update: [],
        destroy: []
      }
    });

    _classPrivateFieldInitSpec(this, _disposers, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _events, {
      writable: true,
      value: nanoevents.createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _framework, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _disposeFramework, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _classPrivateFieldGet4;

      if (_classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView) {
        return this.view.state;
      }

      !_classPrivateFieldGet(this, _framework) ? coreHelpers.invariant(false) : void 0;
      return (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.initialEditorState;
    });

    _defineProperty(this, "updateState", state => {
      var previousState = this.getState();
      this.view.updateState(state);
      this.onStateUpdate({
        previousState,
        state
      });
    });

    var _transformExtensions = transformExtensions(initialExtension, settings),
        extensions = _transformExtensions.extensions,
        extensionMap = _transformExtensions.extensionMap;

    _classPrivateFieldSet(this, _settings, settings);

    _classPrivateFieldSet(this, _extensions, coreHelpers.freeze(extensions));

    _classPrivateFieldSet(this, _extensionMap, extensionMap);

    _classPrivateFieldSet(this, _extensionStore, this.createExtensionStore());

    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Create);

    this.setupLifecycleHandlers();

    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).create),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _handler = _step.value;

        var disposer = _handler();

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Loops through all extensions to set up the lifecycle handlers.
   */


  setupLifecycleHandlers() {
    var store = _classPrivateFieldGet(this, _extensionStore);

    var handlers = _classPrivateFieldGet(this, _handlers);

    var nodeNames = [];
    var markNames = [];
    var plainNames = []; // The names are stored as readonly arrays - which is the reason for not
    // just saying `store.nodeNames = []`.

    store.nodeNames = nodeNames;
    store.markNames = markNames;
    store.plainNames = plainNames;

    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _extension = _step2.value;
        extractLifecycleMethods({
          extension: _extension,
          nodeNames,
          markNames,
          plainNames,
          handlers,
          store
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Set the string handler to use for a given name.
   *
   * This allows users to set the string handler
   */


  setStringHandler(name, handler) {
    _classPrivateFieldGet(this, _stringHandlers)[name] = handler;
  }
  /**
   * Set the manager value for the provided key. This is used by extensions to
   * add data to the manager.
   */


  setStoreKey(key, value) {
    _classPrivateFieldGet(this, _store)[key] = value;
  }
  /**
   * Get the manager value for the provided key. This is used by extensions to
   * get data from the manager.
   */


  getStoreKey(key) {
    var value = _classPrivateFieldGet(this, _store)[key];

    !!coreHelpers.isNullOrUndefined(value) ? coreHelpers.invariant(false) : void 0;
    return value;
  }
  /**
   * A method to set values in the extension store which is made available to
   * extension.
   *
   * **NOTE** This method should only be used in the `onCreate` extension method
   * or it will throw an error.
   */


  setExtensionStore(key, value) {
    !(_classPrivateFieldGet(this, _phase) <= coreConstants.ManagerPhase.EditorView) ? coreHelpers.invariant(false) : void 0;
    _classPrivateFieldGet(this, _extensionStore)[key] = value;
  }
  /**
   * Create the initial store.
   */


  createExtensionStore() {
    var store = coreHelpers.object();
    var enumerable = true; // Allow current state to default to `getState` for first access.
    // This fixed an issue with #814

    var currentState;
    var previousState;
    Object.defineProperties(store, {
      extensions: {
        get: () => _classPrivateFieldGet(this, _extensions),
        enumerable
      },
      phase: {
        get: () => _classPrivateFieldGet(this, _phase),
        enumerable
      },
      view: {
        get: () => this.view,
        enumerable
      },
      managerSettings: {
        get: () => coreHelpers.freeze(_classPrivateFieldGet(this, _settings)),
        enumerable
      },
      getState: {
        value: this.getState,
        enumerable
      },
      updateState: {
        value: this.updateState,
        enumerable
      },
      isMounted: {
        value: () => this.mounted,
        enumerable
      },
      getExtension: {
        value: this.getExtension.bind(this),
        enumerable
      },
      manager: {
        get: () => this,
        enumerable
      },
      document: {
        get: () => this.document,
        enumerable
      },
      stringHandlers: {
        get: () => _classPrivateFieldGet(this, _stringHandlers),
        enumerable
      },
      currentState: {
        get: () => {
          var _currentState;

          return (_currentState = currentState) !== null && _currentState !== void 0 ? _currentState : currentState = this.getState();
        },
        set: state => {
          currentState = state;
        },
        enumerable
      },
      previousState: {
        get: () => previousState,
        set: state => {
          previousState = state;
        },
        enumerable
      }
    });
    store.getStoreKey = this.getStoreKey.bind(this);
    store.setStoreKey = this.setStoreKey.bind(this);
    store.setExtensionStore = this.setExtensionStore.bind(this);
    store.setStringHandler = this.setStringHandler.bind(this);
    return store;
  }
  /**
   * A state getter method which is passed into the params.
   */


  /**
   * Stores the editor view on the manager
   *
   * @param view - the editor view
   */
  addView(view) {
    if (_classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView) {
      // Do nothing since a view has already been added.
      return this;
    }

    _classPrivateFieldSet(this, _firstStateUpdate, true); // Update the lifecycle phase.


    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.EditorView); // Store the view.


    _classPrivateFieldGet(this, _store).view = view;

    var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).view),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _handler2 = _step3.value;

        var disposer = _handler2(view);

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return this;
  }
  /**
   * Attach a framework to the manager.
   */


  attachFramework(framework, updateHandler) {
    if (_classPrivateFieldGet(this, _framework) === framework) {
      // Do nothing if the instances are identical.
      return;
    }

    if (_classPrivateFieldGet(this, _framework)) {
      var _classPrivateFieldGet5;

      // Destroy the old instance.
      _classPrivateFieldGet(this, _framework).destroy(); // Remove the event listener. This should exist.


      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.call(this);
    } // Replace with the new instance.


    _classPrivateFieldSet(this, _framework, framework);

    _classPrivateFieldSet(this, _disposeFramework, this.addHandler('stateUpdate', updateHandler));
  }
  /* Public Methods */

  /**
   * Create an empty document for the editor based on the current schema.
   *
   * This automatically looks at the supported content for the doc and the
   * available nodes which fulfil that content in order to create a document
   * with only the minimal required content.
   *
   * This can be used in conjunction with the create state to reset the current
   * value of the editor.
   */


  createEmptyDoc() {
    var _this$schema$nodes$do;

    var doc = (_this$schema$nodes$do = this.schema.nodes.doc) === null || _this$schema$nodes$do === void 0 ? void 0 : _this$schema$nodes$do.createAndFill(); // Make sure the `doc` was created.

    !doc ? coreHelpers.invariant(false) : void 0;
    return doc;
  }
  /**
   * Create the editor state from content passed to this extension manager.
   */


  createState() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _this$settings = this.settings,
        onError = _this$settings.onError,
        _this$settings$defaul = _this$settings.defaultSelection,
        defaultSelection = _this$settings$defaul === void 0 ? 'end' : _this$settings$defaul;
    var _props$content = props.content,
        content = _props$content === void 0 ? this.createEmptyDoc() : _props$content,
        _props$selection = props.selection,
        selection = _props$selection === void 0 ? defaultSelection : _props$selection,
        _props$stringHandler = props.stringHandler,
        stringHandler = _props$stringHandler === void 0 ? this.settings.stringHandler : _props$stringHandler;
    var _this$store = this.store,
        schema = _this$store.schema,
        plugins = _this$store.plugins;
    var doc = coreUtils.createDocumentNode({
      stringHandler: coreHelpers.isString(stringHandler) ? this.stringHandlers[stringHandler] : stringHandler,
      document: this.document,
      content,
      onError,
      schema,
      selection
    });
    return state.EditorState.create({
      schema,
      doc,
      plugins,
      selection: coreUtils.getTextSelection(selection, doc)
    });
  }
  /**
   * Add a handler to the manager.
   *
   * Currently the only event that can be listened to is the `destroy` event.
   */


  addHandler(event, cb) {
    return _classPrivateFieldGet(this, _events).on(event, cb);
  }
  /**
   * Update the state of the view and trigger the `onStateUpdate` lifecycle
   * method as well.
   */


  /**
   * This method should be called by the view layer every time the state is
   * updated.
   *
   * An example usage of this is within the collaboration extension.
   */
  onStateUpdate(props) {
    var firstUpdate = _classPrivateFieldGet(this, _firstStateUpdate);

    _classPrivateFieldGet(this, _extensionStore).currentState = props.state;
    _classPrivateFieldGet(this, _extensionStore).previousState = props.previousState;

    if (firstUpdate) {
      _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Runtime);

      _classPrivateFieldSet(this, _firstStateUpdate, false);
    }

    var propsWithUpdate = _objectSpread(_objectSpread({}, props), {}, {
      firstUpdate
    });

    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).update),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _handler3 = _step4.value;

        _handler3(propsWithUpdate);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    _classPrivateFieldGet(this, _events).emit('stateUpdate', propsWithUpdate);
  }
  /**
   * Get the extension instance matching the provided constructor from the
   * manager.
   *
   * This will throw an error if non existent.
   */


  getExtension(Constructor) {
    var extension = _classPrivateFieldGet(this, _extensionMap).get(Constructor); // Throws an error if attempting to get an extension which is not present in
    // the manager.


    !extension ? coreHelpers.invariant(false) : void 0;
    return extension;
  }
  /**
   * Make a clone of the manager.
   *
   * @internalremarks What about the state stored in the extensions and presets,
   * does this need to be recreated as well?
   */


  clone() {
    var extensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.options));

    var manager = RemirrorManager.create(() => extensions, _classPrivateFieldGet(this, _settings));

    _classPrivateFieldGet(this, _events).emit('clone', manager);

    return manager;
  }
  /**
   * Recreate the manager with new settings and extensions
   */


  recreate() {
    var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var currentExtensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.initialOptions));

    var manager = RemirrorManager.create(() => [...currentExtensions, ...extensions], settings);

    _classPrivateFieldGet(this, _events).emit('recreate', manager);

    return manager;
  }
  /**
   * This method should be called to destroy the manager and remove the view.
   */


  destroy() {
    var _classPrivateFieldGet6, _classPrivateFieldGet7, _this$view, _this$view$state$plug, _this$view2;

    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Destroy);

    var _iterator5 = _createForOfIteratorHelper((_this$view$state$plug = (_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.state.plugins) !== null && _this$view$state$plug !== void 0 ? _this$view$state$plug : []),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _plugin$getState, _plugin$getState$dest;

        var plugin = _step5.value;
        (_plugin$getState = plugin.getState(this.view.state)) === null || _plugin$getState === void 0 ? void 0 : (_plugin$getState$dest = _plugin$getState.destroy) === null || _plugin$getState$dest === void 0 ? void 0 : _plugin$getState$dest.call(_plugin$getState);
      } // Make sure to destroy the framework and it's state update listener if it
      // exists.

    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.destroy();
    (_classPrivateFieldGet7 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.call(this); // Run all cleanup methods returned by the `onView` and `onCreate` methods.

    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _disposers)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var dispose = _step6.value;
        dispose();
      } // TODO: prevent `dispatchTransaction` from being called again

    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).destroy),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var onDestroy = _step7.value;
        onDestroy();
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.destroy();

    _classPrivateFieldGet(this, _events).emit('destroy');
  }
  /**
   * Check whether the manager includes the names or constructors provided for
   * the preset and extensions.
   *
   * Returns true if all are included, returns false otherwise.
   */


  includes(mustIncludeList) {
    // Searches can be made by either the name of the extension / preset or the
    // names of the constructor. We gather the values to check in separate
    // arrays
    var names = [];
    var extensionsAndPresets = [];

    var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var item = _step8.value;
        names.push(item.name, item.constructorName);
        extensionsAndPresets.push(item.constructor);
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    return mustIncludeList.every(item => coreHelpers.isString(item) ? coreHelpers.includes(names, item) : coreHelpers.includes(extensionsAndPresets, item));
  }

}
/**
 * A function that returns the extension to be used in the RemirrorManager. This
 * is similar to a preset function except that it takes no arguments.
 *
 * ```ts
 * import { RemirrorManager } from 'remirror';
 * import { BoldExtension, ItalicExtension } from 'remirror/extensions';
 *
 * const template = () => [new BoldExtension(), new ItalicExtension()]
 * const manager = RemirrorManager.create(template);
 * ```
 *
 * If the template is mixed in with other manager creators it will add the
 * relevant extension provided.
 */

/**
 * Checks to see whether the provided value is a `RemirrorManager` instance.
 *
 * An optional parameter `mustIncludeList` is available if you want to check
 * that the manager includes all the listed extensions.
 *
 * @param value - the value to check
 * @param mustIncludeList - an array of presets and extension the manager must
 * include to pass the test. The identifier can either be the Extension / Preset
 * name e.g. `bold`, or the Extension / Preset constructor `BoldExtension`
 */
function isRemirrorManager(value, mustIncludeList) {
  if (!coreUtils.isRemirrorType(value) || !coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.Manager)) {
    return false;
  } // We can return true since there are no other checks to make.


  if (!mustIncludeList) {
    return true;
  }

  return value.includes(mustIncludeList);
}

exports.AttributesExtension = AttributesExtension;
exports.CommandsExtension = CommandsExtension;
exports.DEFAULT_SHORTCUTS = DEFAULT_SHORTCUTS;
exports.DecorationsExtension = DecorationsExtension;
exports.DelayedCommand = DelayedCommand;
exports.DocChangedExtension = DocChangedExtension;
exports.Framework = Framework;
exports.GOOGLE_DOC_SHORTCUTS = GOOGLE_DOC_SHORTCUTS;
exports.HelpersExtension = HelpersExtension;
exports.InputRulesExtension = InputRulesExtension;
exports.KeymapExtension = KeymapExtension;
exports.MarkExtension = MarkExtension;
exports.MetaExtension = MetaExtension;
exports.NodeExtension = NodeExtension;
exports.NodeViewsExtension = NodeViewsExtension;
exports.PasteRulesExtension = PasteRulesExtension;
exports.PlainExtension = PlainExtension;
exports.PluginsExtension = PluginsExtension;
exports.RemirrorManager = RemirrorManager;
exports.SchemaExtension = SchemaExtension;
exports.SuggestExtension = SuggestExtension;
exports.TagsExtension = TagsExtension;
exports.UploadExtension = UploadExtension;
exports.builtinPreset = builtinPreset;
exports.command = command;
exports.delayedCommand = delayedCommand;
exports.extension = extension;
exports.extensionDecorator = extensionDecorator;
exports.findUploadPlaceholderPayload = findUploadPlaceholderPayload;
exports.findUploadPlaceholderPos = findUploadPlaceholderPos;
exports.hasUploadingFile = hasUploadingFile;
exports.helper = helper;
exports.insertText = insertText;
exports.isDelayedValue = isDelayedValue;
exports.isExtension = isExtension;
exports.isExtensionConstructor = isExtensionConstructor;
exports.isExtensionTag = isExtensionTag;
exports.isMarkExtension = isMarkExtension;
exports.isNodeExtension = isNodeExtension;
exports.isPlainExtension = isPlainExtension;
exports.isRemirrorManager = isRemirrorManager;
exports.keyBinding = keyBinding;
exports.keyboardShortcuts = keyboardShortcuts;
exports.mutateDefaultExtensionOptions = mutateDefaultExtensionOptions;
exports.setUploadPlaceholderAction = setUploadPlaceholderAction;
exports.toggleMark = toggleMark;
exports.uploadFile = uploadFile;
Object.keys(coreConstants).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreConstants[k]; }
  });
});
Object.keys(coreHelpers).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreHelpers[k]; }
  });
});
Object.keys(coreUtils).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreUtils[k]; }
  });
});
Object.keys(coreTypes).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreTypes[k]; }
  });
});


/***/ }),
/* 8 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayWithHoles = __webpack_require__(9);

var iterableToArrayLimit = __webpack_require__(10);

var unsupportedIterableToArray = __webpack_require__(11);

var nonIterableRest = __webpack_require__(13);

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 9 */
/***/ ((module) => {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 10 */
/***/ ((module) => {

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeToArray = __webpack_require__(12);

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 12 */
/***/ ((module) => {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 13 */
/***/ ((module) => {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(15);

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

module.exports = _objectSpread2, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 15 */
/***/ ((module) => {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 16 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var unsupportedIterableToArray = __webpack_require__(11);

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = it.call(o);
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

module.exports = _createForOfIteratorHelper, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(18);
} else {
  module.exports = __webpack_require__(19);
}


/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/**
 * The css class added to a node that is selected.
 */
var SELECTED_NODE_CLASS_NAME = 'ProseMirror-selectednode';
/**
 * The css selector for a selected node.
 */

var SELECTED_NODE_CLASS_SELECTOR = ".".concat(SELECTED_NODE_CLASS_NAME);
/**
 * ProseMirror uses the Unicode Character 'OBJECT REPLACEMENT CHARACTER'
 * (U+FFFC) as text representation for leaf nodes, i.e. nodes that don't have
 * any content or text property (e.g. hardBreak, emoji, mention, rule) It was
 * introduced because of https://github.com/ProseMirror/prosemirror/issues/262
 * This can be used in an input rule regex to be able to include or exclude such
 * nodes.
 */

var LEAF_NODE_REPLACING_CHARACTER = "\uFFFC";
/**
 * The null character.
 *
 * See {@link https://stackoverflow.com/a/6380172}
 */

var NULL_CHARACTER = '\0';
/**
 * Indicates that a state update was caused by an override and not via
 * transactions or user commands.
 *
 * This is the case when `setContent` is called and for all `controlled` updates
 * within a `react` editor instance.
 */

var STATE_OVERRIDE = '__state_override__';
/**
 * The global name for the module exported by the remirror webview bundle.
 */

var REMIRROR_WEBVIEW_NAME = '$$__REMIRROR_WEBVIEW_BUNDLE__$$';
/**
 * A character useful for separating inline nodes.
 *
 * @remarks
 * Typically used in decorations as follows.
 *
 * ```ts
 * document.createTextNode(ZERO_WIDTH_SPACE_CHAR);
 * ```
 *
 * This produces the html entity '8203'
 */

var ZERO_WIDTH_SPACE_CHAR = "\u200B";
/**
 * The non breaking space character.
 */

var NON_BREAKING_SPACE_CHAR = "\xA0";
/**
 * A default empty object node. Useful for resetting the content of a
 * prosemirror document.
 */

var EMPTY_PARAGRAPH_NODE = {
  type: 'doc',
  content: [{
    type: 'paragraph'
  }]
};
var EMPTY_NODE = {
  type: 'doc',
  content: []
};
/**
 * The type for the extension tags..
 */

/**
 * A method for updating the extension tags.
 *
 * ```tsx
 * import { ExtensionTag, mutateTag } from 'remirror';
 *
 * mutateTag((tag) => {
 *   tag.SuperCustom = 'superCustom';
 * });
 *
 * declare global {
 *   namespace Remirror {
 *     interface ExtensionTag {
 *       SuperCustom: 'superCustom';
 *     }
 *   }
 * }
 *
 *
 * log(ExtensionTag.SuperCustom); // This is fine ✅
 * log(ExtensionTag.NotDefined); // This will throw ❌
 * ```
 */
function mutateTag(mutator) {
  mutator(BaseExtensionTag);
}
var BaseExtensionTag = {
  /**
   * Describes a node that can be used as the last node of a document and
   * doesn't need to have anything else rendered after itself.
   *
   * @remarks
   *
   * e.g. `paragraph`
   */
  LastNodeCompatible: 'lastNodeCompatible',

  /**
   * A mark that is used to change the formatting of the node it wraps.
   *
   * @remarks
   *
   * e.g. `bold`, `italic`
   */
  FormattingMark: 'formattingMark',

  /**
   * A node that formats text in a non-standard way.
   *
   * @remarks
   *
   * e.g. `codeBlock`, `heading`, `blockquote`
   */
  FormattingNode: 'formattingNode',

  /**
   * Identifies a node which has problems with cursor navigation.
   *
   * @remarks
   *
   * When this tag is added to an extension this will be picked up by
   * behavioural extensions such as the NodeCursorExtension which makes hard to
   * reach nodes reachable using keyboard arrows.
   */
  NodeCursor: 'nodeCursor',

  /**
   * Mark group for font styling (e.g. bold, italic, underline, superscript).
   */
  FontStyle: 'fontStyle',

  /**
   * Mark groups for links.
   */
  Link: 'link',

  /**
   * Mark groups for colors (text-color, background-color, etc).
   */
  Color: 'color',

  /**
   * Mark group for alignment.
   */
  Alignment: 'alignment',

  /**
   * Mark group for indentation.
   */
  Indentation: 'indentation',

  /**
   * Extension which affect the behaviour of the content. Can be nodes marks or
   * plain.
   */
  Behavior: 'behavior',

  /**
   * Marks and nodes which contain code.
   */
  Code: 'code',

  /**
   * Whether this node is an inline node.
   *
   * - `text` is an inline node, but `paragraph` is a block node.
   */
  InlineNode: 'inline',

  /**
   * This is a node that can contain list items.
   */
  ListContainerNode: 'listContainer',

  /**
   * Tags the extension as a list item node which can be contained by
   * [[`ExtensionTag.ListNode`]].
   */
  ListItemNode: 'listItemNode',

  /**
   * Sets this as a block level node.
   */
  Block: 'block',

  /**
   * @deprecate use `ExtensionTags.Block` instead.
   */
  BlockNode: 'block',

  /**
   * Set this as a text block
   */
  TextBlock: 'textBlock',

  /**
   * A tag that excludes this from input rules.
   */
  ExcludeInputRules: 'excludeFromInputRules',

  /**
   * A mark or node that can't  be exited when at the end and beginning of the
   * document with an arrow key or backspace key.
   */
  PreventExits: 'preventsExits',

  /**
   * Represents a media compatible node.
   */
  Media: 'media'
};
/**
 * These are the default supported tag strings which help categorize different
 * behaviors that extensions can exhibit.
 *
 * @remarks
 *
 * Any extension can register itself with multiple such behaviors and these
 * categorizations can be used by other extensions when running commands and
 * updating the document.
 */

var ExtensionTag = BaseExtensionTag;
/**
 * The string values which can be used as extension tags.
 */

/**
 * The identifier key which is used to check objects for whether they are a
 * certain type.
 *
 * @remarks
 *
 * Just pretend you don't know this exists.
 *
 * @internal
 */
var __INTERNAL_REMIRROR_IDENTIFIER_KEY__ = Symbol.for('__remirror__');
/**
 * These constants are stored on the `REMIRROR_IDENTIFIER_KEY` property of
 * `remirror` related constructors and instances in order to identify them as
 * being internal to Remirror.
 *
 * @remarks
 *
 * This helps to prevent issues around check types via `instanceof` which can
 * lead to false negatives.
 *
 * @internal
 */

exports.RemirrorIdentifier = void 0;
/**
 * The priority of extension which determines what order it is loaded into the
 * editor.
 *
 * @remarks
 *
 * Higher priority extension (higher numberic value) will ensure the extension
 * has a higher preference in your editor. In the case where you load two
 * identical extensions into your editor (same name, or same constructor), the
 * extension with the  higher priority is the one that will be loaded.
 *
 * The higher the numeric value the higher the priority. The priority can also
 * be passed a number but naming things in this `enum` should help provide some
 * context to the numbers.
 *
 * By default all extensions are created with a `ExtensionPriority.Default`.
 */

(function (RemirrorIdentifier) {
  RemirrorIdentifier["PlainExtension"] = "RemirrorPlainExtension";
  RemirrorIdentifier["NodeExtension"] = "RemirrorNodeExtension";
  RemirrorIdentifier["MarkExtension"] = "RemirrorMarkExtension";
  RemirrorIdentifier["PlainExtensionConstructor"] = "RemirrorPlainExtensionConstructor";
  RemirrorIdentifier["NodeExtensionConstructor"] = "RemirrorNodeExtensionConstructor";
  RemirrorIdentifier["MarkExtensionConstructor"] = "RemirrorMarkExtensionConstructor";
  RemirrorIdentifier["Manager"] = "RemirrorManager";
  RemirrorIdentifier["Preset"] = "RemirrorPreset";
  RemirrorIdentifier["PresetConstructor"] = "RemirrorPresetConstructor";
})(exports.RemirrorIdentifier || (exports.RemirrorIdentifier = {}));

exports.ExtensionPriority = void 0;
/**
 * Identifies the stage the extension manager is at.
 */

(function (ExtensionPriority) {
  ExtensionPriority[ExtensionPriority["Critical"] = 1000000] = "Critical";
  ExtensionPriority[ExtensionPriority["Highest"] = 100000] = "Highest";
  ExtensionPriority[ExtensionPriority["High"] = 10000] = "High";
  ExtensionPriority[ExtensionPriority["Medium"] = 1000] = "Medium";
  ExtensionPriority[ExtensionPriority["Default"] = 100] = "Default";
  ExtensionPriority[ExtensionPriority["Low"] = 10] = "Low";
  ExtensionPriority[ExtensionPriority["Lowest"] = 0] = "Lowest";
})(exports.ExtensionPriority || (exports.ExtensionPriority = {}));

exports.ManagerPhase = void 0;
/**
 * The named shortcuts that can be used to update multiple commands.
 */

(function (ManagerPhase) {
  ManagerPhase[ManagerPhase["None"] = 0] = "None";
  ManagerPhase[ManagerPhase["Create"] = 1] = "Create";
  ManagerPhase[ManagerPhase["EditorView"] = 2] = "EditorView";
  ManagerPhase[ManagerPhase["Runtime"] = 3] = "Runtime";
  ManagerPhase[ManagerPhase["Destroy"] = 4] = "Destroy";
})(exports.ManagerPhase || (exports.ManagerPhase = {}));

exports.NamedShortcut = void 0;
/**
 * Helpful empty array for use when a default array value is needed.
 *
 * DO NOT MUTATE!
 */

(function (NamedShortcut) {
  NamedShortcut["Undo"] = "_|undo|_";
  NamedShortcut["Redo"] = "_|redo|_";
  NamedShortcut["Bold"] = "_|bold|_";
  NamedShortcut["Italic"] = "_|italic|_";
  NamedShortcut["Underline"] = "_|underline|_";
  NamedShortcut["Strike"] = "_|strike|_";
  NamedShortcut["Code"] = "_|code|_";
  NamedShortcut["Paragraph"] = "_|paragraph|_";
  NamedShortcut["H1"] = "_|h1|_";
  NamedShortcut["H2"] = "_|h2|_";
  NamedShortcut["H3"] = "_|h3|_";
  NamedShortcut["H4"] = "_|h4|_";
  NamedShortcut["H5"] = "_|h5|_";
  NamedShortcut["H6"] = "_|h6|_";
  NamedShortcut["TaskList"] = "_|task|_";
  NamedShortcut["BulletList"] = "_|bullet|_";
  NamedShortcut["OrderedList"] = "_|number|_";
  NamedShortcut["Quote"] = "_|quote|_";
  NamedShortcut["Divider"] = "_|divider|_";
  NamedShortcut["Codeblock"] = "_|codeblock|_";
  NamedShortcut["ClearFormatting"] = "_|clear|_";
  NamedShortcut["Superscript"] = "_|sup|_";
  NamedShortcut["Subscript"] = "_|sub|_";
  NamedShortcut["LeftAlignment"] = "_|left-align|_";
  NamedShortcut["CenterAlignment"] = "_|center-align|_";
  NamedShortcut["RightAlignment"] = "_|right-align|_";
  NamedShortcut["JustifyAlignment"] = "_|justify-align|_";
  NamedShortcut["InsertLink"] = "_|link|_";
  NamedShortcut["Find"] = "_|find|_";
  NamedShortcut["FindBackwards"] = "_|find-backwards|_";
  NamedShortcut["FindReplace"] = "_|find-replace|_";
  NamedShortcut["AddFootnote"] = "_|footnote|_";
  NamedShortcut["AddComment"] = "_|comment|_";
  NamedShortcut["ContextMenu"] = "_|context-menu|_";
  NamedShortcut["IncreaseFontSize"] = "_|inc-font-size|_";
  NamedShortcut["DecreaseFontSize"] = "_|dec-font-size|_";
  NamedShortcut["IncreaseIndent"] = "_|indent|_";
  NamedShortcut["DecreaseIndent"] = "_|dedent|_";
  NamedShortcut["Shortcuts"] = "_|shortcuts|_";
  NamedShortcut["Copy"] = "_|copy|_";
  NamedShortcut["Cut"] = "_|cut|_";
  NamedShortcut["Paste"] = "_|paste|_";
  NamedShortcut["PastePlain"] = "_|paste-plain|_";
  NamedShortcut["SelectAll"] = "_|select-all|_";
  NamedShortcut["Format"] = "_|format|_";
})(exports.NamedShortcut || (exports.NamedShortcut = {}));

var EMPTY_ARRAY = [];

/**
 * The error codes for errors used throughout the codebase.
 *
 * @remarks
 *
 * They can be removed but should never be changed since they are also used to
 * reference the errors within search engines.
 */
exports.ErrorConstant = void 0;

(function (ErrorConstant) {
  ErrorConstant["PROD"] = "RMR0000";
  ErrorConstant["UNKNOWN"] = "RMR0001";
  ErrorConstant["INVALID_COMMAND_ARGUMENTS"] = "RMR0002";
  ErrorConstant["CUSTOM"] = "RMR0003";
  ErrorConstant["CORE_HELPERS"] = "RMR0004";
  ErrorConstant["MUTATION"] = "RMR0005";
  ErrorConstant["INTERNAL"] = "RMR0006";
  ErrorConstant["MISSING_REQUIRED_EXTENSION"] = "RMR0007";
  ErrorConstant["MANAGER_PHASE_ERROR"] = "RMR0008";
  ErrorConstant["INVALID_GET_EXTENSION"] = "RMR0010";
  ErrorConstant["INVALID_MANAGER_ARGUMENTS"] = "RMR0011";
  ErrorConstant["SCHEMA"] = "RMR0012";
  ErrorConstant["HELPERS_CALLED_IN_OUTER_SCOPE"] = "RMR0013";
  ErrorConstant["INVALID_MANAGER_EXTENSION"] = "RMR0014";
  ErrorConstant["DUPLICATE_COMMAND_NAMES"] = "RMR0016";
  ErrorConstant["DUPLICATE_HELPER_NAMES"] = "RMR0017";
  ErrorConstant["NON_CHAINABLE_COMMAND"] = "RMR0018";
  ErrorConstant["INVALID_EXTENSION"] = "RMR0019";
  ErrorConstant["INVALID_CONTENT"] = "RMR0021";
  ErrorConstant["INVALID_NAME"] = "RMR0050";
  ErrorConstant["EXTENSION"] = "RMR0100";
  ErrorConstant["EXTENSION_SPEC"] = "RMR0101";
  ErrorConstant["EXTENSION_EXTRA_ATTRIBUTES"] = "RMR0102";
  ErrorConstant["INVALID_SET_EXTENSION_OPTIONS"] = "RMR0103";
  ErrorConstant["REACT_PROVIDER_CONTEXT"] = "RMR0200";
  ErrorConstant["REACT_GET_ROOT_PROPS"] = "RMR0201";
  ErrorConstant["REACT_EDITOR_VIEW"] = "RMR0202";
  ErrorConstant["REACT_CONTROLLED"] = "RMR0203";
  ErrorConstant["REACT_NODE_VIEW"] = "RMR0204";
  ErrorConstant["REACT_GET_CONTEXT"] = "RMR0205";
  ErrorConstant["REACT_COMPONENTS"] = "RMR0206";
  ErrorConstant["REACT_HOOKS"] = "RMR0207";
  ErrorConstant["I18N_CONTEXT"] = "RMR0300";
})(exports.ErrorConstant || (exports.ErrorConstant = {}));

exports.EMPTY_ARRAY = EMPTY_ARRAY;
exports.EMPTY_NODE = EMPTY_NODE;
exports.EMPTY_PARAGRAPH_NODE = EMPTY_PARAGRAPH_NODE;
exports.ExtensionTag = ExtensionTag;
exports.LEAF_NODE_REPLACING_CHARACTER = LEAF_NODE_REPLACING_CHARACTER;
exports.NON_BREAKING_SPACE_CHAR = NON_BREAKING_SPACE_CHAR;
exports.NULL_CHARACTER = NULL_CHARACTER;
exports.REMIRROR_WEBVIEW_NAME = REMIRROR_WEBVIEW_NAME;
exports.SELECTED_NODE_CLASS_NAME = SELECTED_NODE_CLASS_NAME;
exports.SELECTED_NODE_CLASS_SELECTOR = SELECTED_NODE_CLASS_SELECTOR;
exports.STATE_OVERRIDE = STATE_OVERRIDE;
exports.ZERO_WIDTH_SPACE_CHAR = ZERO_WIDTH_SPACE_CHAR;
exports.__INTERNAL_REMIRROR_IDENTIFIER_KEY__ = __INTERNAL_REMIRROR_IDENTIFIER_KEY__;
exports.mutateTag = mutateTag;


/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/**
 * The css class added to a node that is selected.
 */
var SELECTED_NODE_CLASS_NAME = 'ProseMirror-selectednode';
/**
 * The css selector for a selected node.
 */

var SELECTED_NODE_CLASS_SELECTOR = ".".concat(SELECTED_NODE_CLASS_NAME);
/**
 * ProseMirror uses the Unicode Character 'OBJECT REPLACEMENT CHARACTER'
 * (U+FFFC) as text representation for leaf nodes, i.e. nodes that don't have
 * any content or text property (e.g. hardBreak, emoji, mention, rule) It was
 * introduced because of https://github.com/ProseMirror/prosemirror/issues/262
 * This can be used in an input rule regex to be able to include or exclude such
 * nodes.
 */

var LEAF_NODE_REPLACING_CHARACTER = "\uFFFC";
/**
 * The null character.
 *
 * See {@link https://stackoverflow.com/a/6380172}
 */

var NULL_CHARACTER = '\0';
/**
 * Indicates that a state update was caused by an override and not via
 * transactions or user commands.
 *
 * This is the case when `setContent` is called and for all `controlled` updates
 * within a `react` editor instance.
 */

var STATE_OVERRIDE = '__state_override__';
/**
 * The global name for the module exported by the remirror webview bundle.
 */

var REMIRROR_WEBVIEW_NAME = '$$__REMIRROR_WEBVIEW_BUNDLE__$$';
/**
 * A character useful for separating inline nodes.
 *
 * @remarks
 * Typically used in decorations as follows.
 *
 * ```ts
 * document.createTextNode(ZERO_WIDTH_SPACE_CHAR);
 * ```
 *
 * This produces the html entity '8203'
 */

var ZERO_WIDTH_SPACE_CHAR = "\u200B";
/**
 * The non breaking space character.
 */

var NON_BREAKING_SPACE_CHAR = "\xA0";
/**
 * A default empty object node. Useful for resetting the content of a
 * prosemirror document.
 */

var EMPTY_PARAGRAPH_NODE = {
  type: 'doc',
  content: [{
    type: 'paragraph'
  }]
};
var EMPTY_NODE = {
  type: 'doc',
  content: []
};
/**
 * The type for the extension tags..
 */

/**
 * A method for updating the extension tags.
 *
 * ```tsx
 * import { ExtensionTag, mutateTag } from 'remirror';
 *
 * mutateTag((tag) => {
 *   tag.SuperCustom = 'superCustom';
 * });
 *
 * declare global {
 *   namespace Remirror {
 *     interface ExtensionTag {
 *       SuperCustom: 'superCustom';
 *     }
 *   }
 * }
 *
 *
 * log(ExtensionTag.SuperCustom); // This is fine ✅
 * log(ExtensionTag.NotDefined); // This will throw ❌
 * ```
 */
function mutateTag(mutator) {
  mutator(BaseExtensionTag);
}
var BaseExtensionTag = {
  /**
   * Describes a node that can be used as the last node of a document and
   * doesn't need to have anything else rendered after itself.
   *
   * @remarks
   *
   * e.g. `paragraph`
   */
  LastNodeCompatible: 'lastNodeCompatible',

  /**
   * A mark that is used to change the formatting of the node it wraps.
   *
   * @remarks
   *
   * e.g. `bold`, `italic`
   */
  FormattingMark: 'formattingMark',

  /**
   * A node that formats text in a non-standard way.
   *
   * @remarks
   *
   * e.g. `codeBlock`, `heading`, `blockquote`
   */
  FormattingNode: 'formattingNode',

  /**
   * Identifies a node which has problems with cursor navigation.
   *
   * @remarks
   *
   * When this tag is added to an extension this will be picked up by
   * behavioural extensions such as the NodeCursorExtension which makes hard to
   * reach nodes reachable using keyboard arrows.
   */
  NodeCursor: 'nodeCursor',

  /**
   * Mark group for font styling (e.g. bold, italic, underline, superscript).
   */
  FontStyle: 'fontStyle',

  /**
   * Mark groups for links.
   */
  Link: 'link',

  /**
   * Mark groups for colors (text-color, background-color, etc).
   */
  Color: 'color',

  /**
   * Mark group for alignment.
   */
  Alignment: 'alignment',

  /**
   * Mark group for indentation.
   */
  Indentation: 'indentation',

  /**
   * Extension which affect the behaviour of the content. Can be nodes marks or
   * plain.
   */
  Behavior: 'behavior',

  /**
   * Marks and nodes which contain code.
   */
  Code: 'code',

  /**
   * Whether this node is an inline node.
   *
   * - `text` is an inline node, but `paragraph` is a block node.
   */
  InlineNode: 'inline',

  /**
   * This is a node that can contain list items.
   */
  ListContainerNode: 'listContainer',

  /**
   * Tags the extension as a list item node which can be contained by
   * [[`ExtensionTag.ListNode`]].
   */
  ListItemNode: 'listItemNode',

  /**
   * Sets this as a block level node.
   */
  Block: 'block',

  /**
   * @deprecate use `ExtensionTags.Block` instead.
   */
  BlockNode: 'block',

  /**
   * Set this as a text block
   */
  TextBlock: 'textBlock',

  /**
   * A tag that excludes this from input rules.
   */
  ExcludeInputRules: 'excludeFromInputRules',

  /**
   * A mark or node that can't  be exited when at the end and beginning of the
   * document with an arrow key or backspace key.
   */
  PreventExits: 'preventsExits',

  /**
   * Represents a media compatible node.
   */
  Media: 'media'
};
/**
 * These are the default supported tag strings which help categorize different
 * behaviors that extensions can exhibit.
 *
 * @remarks
 *
 * Any extension can register itself with multiple such behaviors and these
 * categorizations can be used by other extensions when running commands and
 * updating the document.
 */

var ExtensionTag = BaseExtensionTag;
/**
 * The string values which can be used as extension tags.
 */

/**
 * The identifier key which is used to check objects for whether they are a
 * certain type.
 *
 * @remarks
 *
 * Just pretend you don't know this exists.
 *
 * @internal
 */
var __INTERNAL_REMIRROR_IDENTIFIER_KEY__ = Symbol.for('__remirror__');
/**
 * These constants are stored on the `REMIRROR_IDENTIFIER_KEY` property of
 * `remirror` related constructors and instances in order to identify them as
 * being internal to Remirror.
 *
 * @remarks
 *
 * This helps to prevent issues around check types via `instanceof` which can
 * lead to false negatives.
 *
 * @internal
 */

exports.RemirrorIdentifier = void 0;
/**
 * The priority of extension which determines what order it is loaded into the
 * editor.
 *
 * @remarks
 *
 * Higher priority extension (higher numberic value) will ensure the extension
 * has a higher preference in your editor. In the case where you load two
 * identical extensions into your editor (same name, or same constructor), the
 * extension with the  higher priority is the one that will be loaded.
 *
 * The higher the numeric value the higher the priority. The priority can also
 * be passed a number but naming things in this `enum` should help provide some
 * context to the numbers.
 *
 * By default all extensions are created with a `ExtensionPriority.Default`.
 */

(function (RemirrorIdentifier) {
  RemirrorIdentifier["PlainExtension"] = "RemirrorPlainExtension";
  RemirrorIdentifier["NodeExtension"] = "RemirrorNodeExtension";
  RemirrorIdentifier["MarkExtension"] = "RemirrorMarkExtension";
  RemirrorIdentifier["PlainExtensionConstructor"] = "RemirrorPlainExtensionConstructor";
  RemirrorIdentifier["NodeExtensionConstructor"] = "RemirrorNodeExtensionConstructor";
  RemirrorIdentifier["MarkExtensionConstructor"] = "RemirrorMarkExtensionConstructor";
  RemirrorIdentifier["Manager"] = "RemirrorManager";
  RemirrorIdentifier["Preset"] = "RemirrorPreset";
  RemirrorIdentifier["PresetConstructor"] = "RemirrorPresetConstructor";
})(exports.RemirrorIdentifier || (exports.RemirrorIdentifier = {}));

exports.ExtensionPriority = void 0;
/**
 * Identifies the stage the extension manager is at.
 */

(function (ExtensionPriority) {
  ExtensionPriority[ExtensionPriority["Critical"] = 1000000] = "Critical";
  ExtensionPriority[ExtensionPriority["Highest"] = 100000] = "Highest";
  ExtensionPriority[ExtensionPriority["High"] = 10000] = "High";
  ExtensionPriority[ExtensionPriority["Medium"] = 1000] = "Medium";
  ExtensionPriority[ExtensionPriority["Default"] = 100] = "Default";
  ExtensionPriority[ExtensionPriority["Low"] = 10] = "Low";
  ExtensionPriority[ExtensionPriority["Lowest"] = 0] = "Lowest";
})(exports.ExtensionPriority || (exports.ExtensionPriority = {}));

exports.ManagerPhase = void 0;
/**
 * The named shortcuts that can be used to update multiple commands.
 */

(function (ManagerPhase) {
  ManagerPhase[ManagerPhase["None"] = 0] = "None";
  ManagerPhase[ManagerPhase["Create"] = 1] = "Create";
  ManagerPhase[ManagerPhase["EditorView"] = 2] = "EditorView";
  ManagerPhase[ManagerPhase["Runtime"] = 3] = "Runtime";
  ManagerPhase[ManagerPhase["Destroy"] = 4] = "Destroy";
})(exports.ManagerPhase || (exports.ManagerPhase = {}));

exports.NamedShortcut = void 0;
/**
 * Helpful empty array for use when a default array value is needed.
 *
 * DO NOT MUTATE!
 */

(function (NamedShortcut) {
  NamedShortcut["Undo"] = "_|undo|_";
  NamedShortcut["Redo"] = "_|redo|_";
  NamedShortcut["Bold"] = "_|bold|_";
  NamedShortcut["Italic"] = "_|italic|_";
  NamedShortcut["Underline"] = "_|underline|_";
  NamedShortcut["Strike"] = "_|strike|_";
  NamedShortcut["Code"] = "_|code|_";
  NamedShortcut["Paragraph"] = "_|paragraph|_";
  NamedShortcut["H1"] = "_|h1|_";
  NamedShortcut["H2"] = "_|h2|_";
  NamedShortcut["H3"] = "_|h3|_";
  NamedShortcut["H4"] = "_|h4|_";
  NamedShortcut["H5"] = "_|h5|_";
  NamedShortcut["H6"] = "_|h6|_";
  NamedShortcut["TaskList"] = "_|task|_";
  NamedShortcut["BulletList"] = "_|bullet|_";
  NamedShortcut["OrderedList"] = "_|number|_";
  NamedShortcut["Quote"] = "_|quote|_";
  NamedShortcut["Divider"] = "_|divider|_";
  NamedShortcut["Codeblock"] = "_|codeblock|_";
  NamedShortcut["ClearFormatting"] = "_|clear|_";
  NamedShortcut["Superscript"] = "_|sup|_";
  NamedShortcut["Subscript"] = "_|sub|_";
  NamedShortcut["LeftAlignment"] = "_|left-align|_";
  NamedShortcut["CenterAlignment"] = "_|center-align|_";
  NamedShortcut["RightAlignment"] = "_|right-align|_";
  NamedShortcut["JustifyAlignment"] = "_|justify-align|_";
  NamedShortcut["InsertLink"] = "_|link|_";
  NamedShortcut["Find"] = "_|find|_";
  NamedShortcut["FindBackwards"] = "_|find-backwards|_";
  NamedShortcut["FindReplace"] = "_|find-replace|_";
  NamedShortcut["AddFootnote"] = "_|footnote|_";
  NamedShortcut["AddComment"] = "_|comment|_";
  NamedShortcut["ContextMenu"] = "_|context-menu|_";
  NamedShortcut["IncreaseFontSize"] = "_|inc-font-size|_";
  NamedShortcut["DecreaseFontSize"] = "_|dec-font-size|_";
  NamedShortcut["IncreaseIndent"] = "_|indent|_";
  NamedShortcut["DecreaseIndent"] = "_|dedent|_";
  NamedShortcut["Shortcuts"] = "_|shortcuts|_";
  NamedShortcut["Copy"] = "_|copy|_";
  NamedShortcut["Cut"] = "_|cut|_";
  NamedShortcut["Paste"] = "_|paste|_";
  NamedShortcut["PastePlain"] = "_|paste-plain|_";
  NamedShortcut["SelectAll"] = "_|select-all|_";
  NamedShortcut["Format"] = "_|format|_";
})(exports.NamedShortcut || (exports.NamedShortcut = {}));

var EMPTY_ARRAY = [];

/**
 * The error codes for errors used throughout the codebase.
 *
 * @remarks
 *
 * They can be removed but should never be changed since they are also used to
 * reference the errors within search engines.
 */
exports.ErrorConstant = void 0;

(function (ErrorConstant) {
  ErrorConstant["PROD"] = "RMR0000";
  ErrorConstant["UNKNOWN"] = "RMR0001";
  ErrorConstant["INVALID_COMMAND_ARGUMENTS"] = "RMR0002";
  ErrorConstant["CUSTOM"] = "RMR0003";
  ErrorConstant["CORE_HELPERS"] = "RMR0004";
  ErrorConstant["MUTATION"] = "RMR0005";
  ErrorConstant["INTERNAL"] = "RMR0006";
  ErrorConstant["MISSING_REQUIRED_EXTENSION"] = "RMR0007";
  ErrorConstant["MANAGER_PHASE_ERROR"] = "RMR0008";
  ErrorConstant["INVALID_GET_EXTENSION"] = "RMR0010";
  ErrorConstant["INVALID_MANAGER_ARGUMENTS"] = "RMR0011";
  ErrorConstant["SCHEMA"] = "RMR0012";
  ErrorConstant["HELPERS_CALLED_IN_OUTER_SCOPE"] = "RMR0013";
  ErrorConstant["INVALID_MANAGER_EXTENSION"] = "RMR0014";
  ErrorConstant["DUPLICATE_COMMAND_NAMES"] = "RMR0016";
  ErrorConstant["DUPLICATE_HELPER_NAMES"] = "RMR0017";
  ErrorConstant["NON_CHAINABLE_COMMAND"] = "RMR0018";
  ErrorConstant["INVALID_EXTENSION"] = "RMR0019";
  ErrorConstant["INVALID_CONTENT"] = "RMR0021";
  ErrorConstant["INVALID_NAME"] = "RMR0050";
  ErrorConstant["EXTENSION"] = "RMR0100";
  ErrorConstant["EXTENSION_SPEC"] = "RMR0101";
  ErrorConstant["EXTENSION_EXTRA_ATTRIBUTES"] = "RMR0102";
  ErrorConstant["INVALID_SET_EXTENSION_OPTIONS"] = "RMR0103";
  ErrorConstant["REACT_PROVIDER_CONTEXT"] = "RMR0200";
  ErrorConstant["REACT_GET_ROOT_PROPS"] = "RMR0201";
  ErrorConstant["REACT_EDITOR_VIEW"] = "RMR0202";
  ErrorConstant["REACT_CONTROLLED"] = "RMR0203";
  ErrorConstant["REACT_NODE_VIEW"] = "RMR0204";
  ErrorConstant["REACT_GET_CONTEXT"] = "RMR0205";
  ErrorConstant["REACT_COMPONENTS"] = "RMR0206";
  ErrorConstant["REACT_HOOKS"] = "RMR0207";
  ErrorConstant["I18N_CONTEXT"] = "RMR0300";
})(exports.ErrorConstant || (exports.ErrorConstant = {}));

exports.EMPTY_ARRAY = EMPTY_ARRAY;
exports.EMPTY_NODE = EMPTY_NODE;
exports.EMPTY_PARAGRAPH_NODE = EMPTY_PARAGRAPH_NODE;
exports.ExtensionTag = ExtensionTag;
exports.LEAF_NODE_REPLACING_CHARACTER = LEAF_NODE_REPLACING_CHARACTER;
exports.NON_BREAKING_SPACE_CHAR = NON_BREAKING_SPACE_CHAR;
exports.NULL_CHARACTER = NULL_CHARACTER;
exports.REMIRROR_WEBVIEW_NAME = REMIRROR_WEBVIEW_NAME;
exports.SELECTED_NODE_CLASS_NAME = SELECTED_NODE_CLASS_NAME;
exports.SELECTED_NODE_CLASS_SELECTOR = SELECTED_NODE_CLASS_SELECTOR;
exports.STATE_OVERRIDE = STATE_OVERRIDE;
exports.ZERO_WIDTH_SPACE_CHAR = ZERO_WIDTH_SPACE_CHAR;
exports.__INTERNAL_REMIRROR_IDENTIFIER_KEY__ = __INTERNAL_REMIRROR_IDENTIFIER_KEY__;
exports.mutateTag = mutateTag;


/***/ }),
/* 20 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(21);
} else {
  module.exports = __webpack_require__(35);
}


/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var makeError = __webpack_require__(22);
var coreConstants = __webpack_require__(17);
var _slicedToArray = __webpack_require__(8);
var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var _defineProperty = __webpack_require__(15);
var core = __webpack_require__(23);
var deepmerge = __webpack_require__(26);
var fastDeepEqual = __webpack_require__(27);
var omit = __webpack_require__(28);
var object_pick = __webpack_require__(32);
var caseAnything = __webpack_require__(33);
var throttleDebounce = __webpack_require__(34);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var deepmerge__default = /*#__PURE__*/_interopDefault(deepmerge);
var fastDeepEqual__default = /*#__PURE__*/_interopDefault(fastDeepEqual);
var omit__default = /*#__PURE__*/_interopDefault(omit);
var object_pick__default = /*#__PURE__*/_interopDefault(object_pick);

/**
 * Type cast an argument. If no type is provided it will default to any.
 *
 * @param arg - the arg to typecast
 */
function Cast(value) {
  return value;
}
/**
 * Get the key from a given value. Throw an error if the referenced property is
 * `undefined`.
 */

function assertGet(value, key, message) {
  var prop = value[key];
  assert(!isUndefined(prop), message);
  return prop;
}
/**
 * Assert the value is `truthy`. Good for defensive programming, especially
 * after enabling `noUncheckedIndexedAccess` in the tsconfig `compilerOptions`.
 */

function assert(testValue, message) {
  if (!testValue) {
    throw new AssertionError(message);
  }
}

class AssertionError extends makeError.BaseError {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'AssertionError');
  }

}
/**
 * A typesafe implementation of `Object.entries()`
 *
 * Taken from
 * https://github.com/biggyspender/ts-entries/blob/master/src/ts-entries.ts
 */


function entries(value) {
  return Object.entries(value);
}
/**
 * A typesafe implementation of `Object.keys()`
 */

function keys(value) {
  return Object.keys(value);
}
/**
 * A typesafe implementation of `Object.values()`
 */

function values(value) {
  return Object.values(value);
}
/**
 * A more lenient typed version of `Array.prototype.includes` which allow less
 * specific types to be checked.
 */

function includes(array, item, fromIndex) {
  return array.includes(item, fromIndex);
}
/**
 * Creates an object with the null prototype.
 *
 * @param value - the object to create
 */

function object(value) {
  return Object.assign(Object.create(null), value);
}
/**
 * A type name matcher for object types.
 *
 * @private
 */

var TypeName;
/**
 * Alias of toString for non-dom environments.
 *
 * This is a safe way of calling `toString` on objects created with
 * `Object.create(null)`.
 */

(function (TypeName) {
  TypeName["Object"] = "Object";
  TypeName["RegExp"] = "RegExp";
  TypeName["Date"] = "Date";
  TypeName["Promise"] = "Promise";
  TypeName["Error"] = "Error";
  TypeName["Map"] = "Map";
  TypeName["Set"] = "Set";
})(TypeName || (TypeName = {}));

function toString(value) {
  return Object.prototype.toString.call(value);
}
/**
 * Retrieve the object type of a value via it's string reference. This is safer
 * than relying on instanceof checks which fail on cross-frame values.
 *
 * @param value - the object to inspect
 */

function getObjectType(value) {
  var objectName = toString(value).slice(8, -1);
  return objectName;
}
/**
 * A helper for building type predicates
 *
 * @param type -  the name of the type to check for
 * @returns a predicate function for checking the value type
 */


function isOfType(type, predicate) {
  return value => {
    if (typeof value !== type) {
      return false;
    }

    return predicate ? predicate(value) : true;
  };
}
/**
 * Get the object type of passed in value. This avoids the reliance on
 * `instanceof` checks which are subject to cross frame issues as outlined in
 * this link https://bit.ly/1Qds27W
 *
 * @param type - the name of the object type to check for
 *
 * @private
 */


function isObjectOfType(type) {
  return value => getObjectType(value) === type;
}
/**
 * Check if an instance is the direct instance of the provided class.
 */


function isDirectInstanceOf(instance, Constructor) {
  return Object.getPrototypeOf(instance) === Constructor.prototype;
}
/**
 * Predicate check that value is undefined
 *
 * @param value - the value to check
 *
 */

var isUndefined = isOfType('undefined');
/**
 * Predicate check that value is a string
 *
 * @param value - the value to check
 *
 */

var isString = isOfType('string');
/**
 * Predicate check that value is a number.
 *
 * Also by default doesn't include NaN as a valid number.
 *
 * @param value - the value to check
 *
 */

var isNumber = isOfType('number', value => {
  return !Number.isNaN(value);
});
/**
 * Predicate check that value is a function
 *
 * @param value - the value to check
 *
 */

var isFunction = isOfType('function');
/**
 * Predicate check that value is null
 *
 * @param value - the value to check
 *
 */

function isNull(value) {
  return value === null;
}
/**
 * Predicate check that value is a class
 *
 * @deprecated Due to the current build process stripping out classes
 *
 * @param value - the value to check
 *
 */

function isClass(value) {
  return isFunction(value) && value.toString().startsWith('class ');
}
/**
 * Predicate check that value is boolean
 *
 * @param value - the value to check
 *
 */

function isBoolean(value) {
  return value === true || value === false;
}
/**
 * Predicate check that value is a symbol
 *
 * @param value - the value to check
 *
 */

var isSymbol = isOfType('symbol');
/**
 * Helper function for Number.isInteger check allowing non numbers to be tested
 *
 * @param value - the value to check
 *
 */

function isInteger(value) {
  return Number.isInteger(value);
}
/**
 * Helper function for Number.isSafeInteger allowing for unknown values to be
 * tested
 *
 * @param value - the value to check
 *
 */

function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
/**
 * Predicate check for whether passed in value is a plain object
 *
 * @param value - the value to check
 *
 */

function isPlainObject(value) {
  if (getObjectType(value) !== TypeName.Object) {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
}
/**
 * Predicate check for whether passed in value is a primitive value
 */

function isPrimitive(value) {
  return value == null || /^[bns]/.test(typeof value);
}
/**
 * Predicate check for whether passed in value is a JSON primitive value
 */

function isJSONPrimitive(value) {
  return value === null || ['boolean', 'number', 'string'].includes(typeof value);
}
/**
 * Utility predicate check that value is either null or undefined
 *
 * @param value - the value to check
 *
 */

function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
/**
 * Predicate check that value is an object.
 *
 * @param value - the value to check
 *
 */

function isObject(value) {
  return !isNullOrUndefined(value) && (isFunction(value) || isOfType('object')(value));
}
/**
 * A shorthand method for creating instance of checks.
 */

function isInstanceOf(Constructor) {
  return value => isObject(value) && value instanceof Constructor;
}
/**
 * Predicate check that value is a native promise
 *
 * @param value - the value to check
 *
 */

function isNativePromise(value) {
  return isObjectOfType(TypeName.Promise)(value);
}
/**
 * Check to see if a value has the built in promise API.
 *
 * @param value - the value to check
 *
 */

var hasPromiseAPI = value => {
  return !!(!isNull(value) && isObject(value) && isFunction(value.then) && isFunction(value.catch));
};
/**
 * Predicate check that value has the promise api implemented
 *
 * @param value - the value to check
 *
 */


function isPromise(value) {
  return isNativePromise(value) || hasPromiseAPI(value);
}
/**
 * Predicate check that value is a RegExp
 *
 * @param value - the value to check
 *
 */

var isRegExp = isObjectOfType(TypeName.RegExp);
/**
 * Predicate check that value is a date
 *
 * @param value - the value to check
 *
 */

var isDate = isObjectOfType(TypeName.Date);
/**
 * Predicate check that value is an error
 *
 * @param value - the value to check
 *
 */

var isError = isObjectOfType(TypeName.Error);
/**
 * Predicate check that value is a `Map`
 *
 * @param value - the value to check
 *
 */

function isMap(value) {
  return isObjectOfType(TypeName.Map)(value);
}
/**
 * Predicate check that value is a `Set`
 *
 * @param value - the value to check
 *
 */

function isSet(value) {
  return isObjectOfType(TypeName.Set)(value);
}
/**
 * Predicate check that value is an empty object
 *
 * @param value - the value to check
 *
 */

function isEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
/**
 * Alias the isArray method.
 */

var isArray = Array.isArray;
/**
 * Predicate check that value is an empty array
 *
 * @param value - the value to check
 *
 */

function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
/**
 * Predicate check that value is a non-empty.
 *
 * @param value - the value to check
 *
 */

function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
/**
 * Capitalizes a string value.
 *
 * @param str - the string to capitalize.
 */

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * Trim and conditionally capitalize string values.
 *
 * @param str - the string to format.
 *
 */

function format(value) {
  value = value.trim();
  return /^(?:webOS|i(?:OS|P))/.test(value) ? value : capitalize(value);
}
/**
 * Calls a function if defined and provides compile time type checking for the
 * passed in parameters.
 *
 * @param fn - the function to call if it exists
 * @param args - the rest of the parameters with types
 */

function callIfDefined(fn) {
  if (isFunction(fn)) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn(...args);
  }
}
/**
 * Finds all the regex matches for a string
 *
 * @param text - the text to check against
 * @param regexp - the regex (which should include a 'g' flag)
 *
 */

function findMatches(text, regexp) {
  var runWhile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : match => !!match;
  regexp.lastIndex = 0;
  var results = [];
  var flags = regexp.flags;
  var match;

  if (!flags.includes('g')) {
    regexp = new RegExp(regexp.source, "g".concat(flags));
  }

  do {
    match = regexp.exec(text);

    if (match) {
      results.push(match);
    }
  } while (runWhile(match));

  regexp.lastIndex = 0;
  return results;
}
/**
 * A utility function to clean up the Operating System name.
 *
 * @param os - the OS name to clean up.
 * @param pattern - a `RegExp` pattern matching the OS name.
 * @param label - a label for the OS.
 * @returns a cleaned up Operating System name
 */

function cleanupOS(os, pattern, label) {
  var _os$replace$replace$r;

  if (pattern && label) {
    os = os.replace(new RegExp(pattern, 'i'), label);
  }

  return format((_os$replace$replace$r = os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_powerpc\b/i, ' OS').replace(/\b(os x) [^\d ]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: bepc|[ .]*fc[\d .]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1').split(' on ')[0]) !== null && _os$replace$replace$r !== void 0 ? _os$replace$replace$r : '');
}
/**
 * A utility function to check whether the current browser is running on the
 * android platform.
 */

function isAndroidOS() {
  var _match$;

  var ua = navigator.userAgent;
  var match = new RegExp('\\b' + 'Android' + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua);

  if (!match) {
    return false;
  }

  return cleanupOS((_match$ = match[0]) !== null && _match$ !== void 0 ? _match$ : '', 'Android', 'Android').includes('Android');
}
/**
 * Generate a random float between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomFloat(min, max) {
  if (!max) {
    max = min;
    min = 0;
  }

  return Math.random() * (max - min + 1) + min;
}
/**
 * Generate a random integer between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomInt(min, max) {
  return Math.floor(randomFloat(min, max));
}
/**
 * Converts a string, including strings in camelCase or snake_case, into Start
 * Case (a variant of Title case where all words start with a capital letter),
 * it keeps original single quote and hyphen in the word.
 *
 *   'management_companies' to 'Management Companies' 'managementCompanies' to
 *   'Management Companies' `hell's kitchen` to `Hell's Kitchen` `co-op` to
 *   `Co-op`
 *
 * @param str - the string to examine
 */

function startCase(string) {
  return string.replace(/_/g, ' ').replace(/([a-z])([A-Z])/g, (_, $1, $2) => "".concat($1, " ").concat($2)).replace(/(\s|^)(\w)/g, (_, $1, $2) => "".concat($1).concat($2.toUpperCase()));
}
/**
 * Returns a number that is unique during the runtime of this code.
 */

function n() {
  var time = Date.now();
  var last = n.last || time;
  return n.last = time > last ? time : last + 1;
}

n.last = 0;
/**
 * Generate a unique id
 *
 * @param prefix - a prefix for the generated id.
 * @returns a unique string of specified length
 *
 */

function uniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix).concat(n().toString(36));
}
/**
 * Takes a number of elements from the provided array starting from the
 * zero-index
 *
 * @param arr - the array to take from
 * @param num - the number of items to take
 *
 */

function take(array, number) {
  number = Math.max(Math.min(0, number), number);
  return array.slice(0, number);
}
/**
 * Remove the undefined values from an object.
 */

function omitUndefined(object) {
  return omit__default["default"](object, value => !isUndefined(value));
}
/**
 * Clones a plain object using object spread notation
 *
 * @param value - the value to check
 *
 */

function clone(value) {
  if (!isPlainObject(value)) {
    throw new Error('An invalid value was passed into this clone utility. Expected a plain object');
  }

  return _objectSpread({}, value);
}
/**
 * Shallow clone an object while preserving it's getters and setters. This is a
 * an alternative to the spread clone.
 */

function shallowClone(value) {
  var clone = Object.create(Object.getPrototypeOf(value));
  var descriptors = Object.getOwnPropertyDescriptors(value);
  Object.defineProperties(clone, descriptors);
  return clone;
}
/**
 * Alias for fast deep equal
 */

var isEqual = fastDeepEqual__default["default"];
/**
 * Create a unique array in a non-mutating manner
 *
 * @param array - the array which will be reduced to its unique elements
 * @param fromStart - when set to true the duplicates will be removed from the
 * beginning of the array. This defaults to false.
 *
 * @returns a new array containing only unique elements (by reference)
 *
 */

function uniqueArray(array) {
  var fromStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var array_ = fromStart ? [...array].reverse() : array;
  var set = new Set(array_);
  return fromStart ? [...set].reverse() : [...set];
}
/**
 * Flattens an array.
 *
 * @param array
 *
 */

function flattenArray(array) {
  var flattened = [];

  var _iterator = _createForOfIteratorHelper(array),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;
      var itemsToInsert = isArray(_item) ? flattenArray(_item) : [_item];
      flattened.push(...itemsToInsert);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return flattened;
}
/**
 * noop is a shorthand way of saying `No Operation` and is a function that does
 * nothing.
 *
 * And Sometimes doing nothing is the best policy.
 */

function noop() {
  return;
}
/**
 * A deep merge which only merges plain objects and Arrays. It clones the object
 * before the merge so will not mutate any of the passed in values.
 *
 * To completely remove a key you can use the `Merge` helper class which
 * replaces it's key with a completely new object
 */

function deepMerge() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  return deepmerge__default["default"].all(objects, {
    isMergeableObject: isPlainObject
  });
}

/**
 * Clamps the value to the provided range.
 */
function clamp(_ref) {
  var min = _ref.min,
      max = _ref.max,
      value = _ref.value;

  if (value < min) {
    return min;
  }

  return value > max ? max : value;
}
/**
 * Get the last element of the array.
 */

function last(array) {
  return array[array.length - 1];
}
/**
 * Sorts an array while retaining the original order when the compare method
 * identifies the items as equal.
 *
 * `Array.prototype.sort()` is unstable and so values that are the same will
 * jump around in a non deterministic manner. Here I'm using the index as a
 * fallback. If two elements have the same priority the element with the lower
 * index is placed first hence retaining the original order.
 *
 * @param array - the array to sort
 * @param compareFn - compare the two value arguments `a` and `z` - return 0 for
 *                  equal - return number > 0 for a > z - return number < 0 for
 *                  z > a
 */

function sort(array, compareFn) {
  return [...array].map((value, index) => ({
    value,
    index
  })).sort((a, z) => compareFn(a.value, z.value) || a.index - z.index).map(_ref2 => {
    var value = _ref2.value;
    return value;
  });
}
/**
 * Get a property from an object or array by a string path or an array path.
 *
 * @param obj - object to retrieve property from
 * @param path - path to property
 */

function get(root, path, defaultValue) {
  try {
    if (isString(path) && path in root) {
      return root[path];
    }

    if (isArray(path)) {
      path = "['".concat(path.join("']['"), "']");
    }

    var obj = root;
    path.replace(/\[\s*(["'])(.*?)\1\s*]|^\s*(\w+)\s*(?=\.|\[|$)|\.\s*(\w*)\s*(?=\.|\[|$)|\[\s*(-?\d+)\s*]/g, (_, __, quotedProp, firstLevel, namedProp, index) => {
      obj = obj[quotedProp || firstLevel || namedProp || index];
      return '';
    });
    return obj === undefined ? defaultValue : obj;
  } catch (_unused) {
    return defaultValue;
  }
}

function setPropInternal(path, obj, value, index) {
  if (path.length === index) {
    return value;
  } // Create things as we go down if they don't exist


  obj = obj || {};
  var key = path[index];
  assert(key);
  return setClone(obj, key, setPropInternal(path, obj[key], value, ++index));
}

function setClone(obj, key, value) {
  var newObj = clone(obj);
  newObj[key] = value;
  return newObj;
}
/**
 * Set the value of a given path for the provided object. Does not mutate the
 * original object.
 */


function set(path, obj, value) {
  if (isNumber(path)) {
    return setClone(obj, path, value);
  }

  if (isString(path)) {
    path = path.split('.');
  }

  return setPropInternal(path, obj, value, 0);
}
/**
 * Unset the value of a given path within an object.
 */

function unset(path, target) {
  var clonedObject = clone(target);
  var value = clonedObject;

  var _iterator2 = _createForOfIteratorHelper(path.entries()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          index = _step2$value[0],
          key = _step2$value[1];

      var shouldDelete = index >= path.length - 1;
      var _item2 = value[key];

      if (shouldDelete) {
        if (isArray(value)) {
          var indexKey = Number.parseInt(key.toString(), 10);

          if (isNumber(indexKey)) {
            value.splice(indexKey, 1);
          }
        } else {
          Reflect.deleteProperty(value, key);
        }

        return clonedObject;
      }

      if (isPrimitive(_item2)) {
        return clonedObject;
      }

      _item2 = isArray(_item2) ? [..._item2] : _objectSpread({}, _item2);
      value[key] = _item2;
      value = _item2;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return clonedObject;
}

function makeFunctionForUniqueBy(value) {
  return item => {
    return get(item, value);
  };
}
/**
 * Create a unique array of objects from a getter function or a property list.
 *
 * @param array - the array to extract unique values from
 * @param getValue - a getter function or a string with the path to the item
 * that is being used as a a test for uniqueness.
 * @param fromStart - when true will remove duplicates from the start rather
 * than from the end
 *
 * ```ts
 * import { uniqueBy } from '@remirror/core-helpers';
 *
 * const values = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], item => item.id);
 * log(values) // => [{id: 'a', value: 'Awesome'}]
 *
 * const byKey = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], 'id')
 * // Same as above
 * ```
 */


function uniqueBy(array, getValue) {
  var fromStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var unique = [];
  var found = new Set();
  var getter = isFunction(getValue) ? getValue : makeFunctionForUniqueBy(getValue);
  var list = fromStart ? [...array].reverse() : array;

  var _iterator3 = _createForOfIteratorHelper(list),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _item3 = _step3.value;

      var _value = getter(_item3);

      if (!found.has(_value)) {
        found.add(_value);
        unique.push(_item3);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return fromStart ? unique.reverse() : unique;
}
/**
 * Create a range from start to end.
 *
 * If only start is provided it creates an array of the size provided. if start
 * and end are provided it creates an array who's first position is start and
 * final position is end. i.e. `length = (end - start) + 1`.
 *
 * If you'd like to create a typed tuple of up to `40` items then pass in a
 * `[number]` tuple as the first argument.
 */

function range(start, end) {
  var startValue = isArray(start) ? start[0] : start;

  if (!isNumber(end)) {
    return Array.from({
      length: Math.abs(startValue)
    }, (_, index) => (startValue < 0 ? -1 : 1) * index);
  }

  if (startValue <= end) {
    return Array.from({
      length: end + 1 - startValue
    }, (_, index) => index + startValue);
  }

  return Array.from({
    length: startValue + 1 - end
  }, (_, index) => -1 * index + startValue);
}
/**
 * Check that a number is within the minimum and maximum bounds of a set of
 * numbers.
 *
 * @param value - the number to test
 */

function within(value) {
  for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    rest[_key3 - 1] = arguments[_key3];
  }

  var numbers = rest.filter(isNumber);
  return value >= Math.min(...numbers) && value <= Math.max(...numbers);
}
/**
 * Safe implementation of hasOwnProperty with typechecking.
 *
 * @remarks
 *
 * See {@link https://eslint.org/docs/rules/no-prototype-builtins}
 *
 * @param obj - the object to check
 * @param key - the property to check
 *
 * @template Obj - the object type
 * @template Property - the property which can be a string | number | symbol
 */

function hasOwnProperty(object_, key) {
  return Object.prototype.hasOwnProperty.call(object_, key);
}
/**
 * Helper for getting an array from a function or array.
 */

function getLazyArray(value) {
  if (isFunction(value)) {
    return value();
  }

  return value;
}
function cx() {
  return uniqueArray(core.cx(...arguments).split(' ')).join(' ');
} // The following are forward exports for other libraries. I've structured it

/**
 * Errors have their own URL which will be logged to the console for simpler
 * debugging.
 */

var ERROR_INFORMATION_URL = 'https://remirror.io/docs/errors';
var errorMessageMap = {
  [coreConstants.ErrorConstant.UNKNOWN]: "An error occurred but we're not quite sure why. 🧐",
  [coreConstants.ErrorConstant.INVALID_COMMAND_ARGUMENTS]: 'The arguments passed to the command method were invalid.',
  [coreConstants.ErrorConstant.CUSTOM]: 'This is a custom error, possibly thrown by an external library.',
  [coreConstants.ErrorConstant.CORE_HELPERS]: 'An error occurred in a function called from the `@remirror/core-helpers` library.',
  [coreConstants.ErrorConstant.MUTATION]: 'Mutation of immutable value detected.',
  [coreConstants.ErrorConstant.INTERNAL]: 'This is an error which should not occur and is internal to the remirror codebase.',
  [coreConstants.ErrorConstant.MISSING_REQUIRED_EXTENSION]: 'Your editor is missing a required extension.',
  [coreConstants.ErrorConstant.MANAGER_PHASE_ERROR]: 'This occurs when accessing a method or property before it is available.',
  [coreConstants.ErrorConstant.INVALID_GET_EXTENSION]: 'The user requested an invalid extension from the getExtensions method. Please check the `createExtensions` return method is returning an extension with the defined constructor.',
  [coreConstants.ErrorConstant.INVALID_MANAGER_ARGUMENTS]: 'Invalid value(s) passed into `Manager` constructor. Only `Presets` and `Extensions` are supported.',
  [coreConstants.ErrorConstant.SCHEMA]: "There is a problem with the schema or you are trying to access a node / mark that doesn't exists.",
  [coreConstants.ErrorConstant.HELPERS_CALLED_IN_OUTER_SCOPE]: 'The `helpers` method which is passed into the ``create*` method should only be called within returned method since it relies on an active view (not present in the outer scope).',
  [coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION]: 'You requested an invalid extension from the manager.',
  [coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'Command method names must be unique within the editor.',
  [coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES]: 'Helper method names must be unique within the editor.',
  [coreConstants.ErrorConstant.NON_CHAINABLE_COMMAND]: 'Attempted to chain a non chainable command.',
  [coreConstants.ErrorConstant.INVALID_EXTENSION]: 'The provided extension is invalid.',
  [coreConstants.ErrorConstant.INVALID_CONTENT]: 'The content provided to the editor is not supported.',
  [coreConstants.ErrorConstant.INVALID_NAME]: 'An invalid name was used for the extension.',
  [coreConstants.ErrorConstant.EXTENSION]: 'An error occurred within an extension. More details should be made available.',
  [coreConstants.ErrorConstant.EXTENSION_SPEC]: 'The spec was defined without calling the `defaults`, `parse` or `dom` methods.',
  [coreConstants.ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES]: 'Extra attributes must either be a string or an object.',
  [coreConstants.ErrorConstant.INVALID_SET_EXTENSION_OPTIONS]: 'A call to `extension.setOptions` was made with invalid keys.',
  [coreConstants.ErrorConstant.REACT_PROVIDER_CONTEXT]: '`useRemirrorContext` was called outside of the `remirror` context. It can only be used within an active remirror context created by the `<Remirror />`.',
  [coreConstants.ErrorConstant.REACT_GET_ROOT_PROPS]: '`getRootProps` has been attached to the DOM more than once. It should only be attached to the dom once per editor.',
  [coreConstants.ErrorConstant.REACT_EDITOR_VIEW]: 'A problem occurred adding the editor view to the dom.',
  [coreConstants.ErrorConstant.REACT_CONTROLLED]: 'There is a problem with your controlled editor setup.',
  [coreConstants.ErrorConstant.REACT_NODE_VIEW]: 'Something went wrong with your custom ReactNodeView Component.',
  [coreConstants.ErrorConstant.REACT_GET_CONTEXT]: 'You attempted to call `getContext` provided by the `useRemirror` prop during the first render of the editor. This is not possible and should only be after the editor first mounts.',
  [coreConstants.ErrorConstant.REACT_COMPONENTS]: 'An error occurred within a remirror component.',
  [coreConstants.ErrorConstant.REACT_HOOKS]: 'An error occurred within a remirror hook.',
  [coreConstants.ErrorConstant.I18N_CONTEXT]: 'You called `useI18n()` outside of an `I18nProvider` context.'
};
/**
 * Checks whether the passed code is an `ErrorConstant`.
 */

function isErrorConstant(code) {
  return isString(code) && includes(values(coreConstants.ErrorConstant), code);
}
/**
 * Create an error message from the provided error code.
 */


function createErrorMessage(code, extraMessage) {
  var message = errorMessageMap[code];
  var prefix = message ? "".concat(message, "\n\n") : '';
  var customMessage = extraMessage ? "".concat(extraMessage, "\n\n") : '';
  return "".concat(prefix).concat(customMessage, "For more information visit ").concat(ERROR_INFORMATION_URL, "#").concat(code.toLowerCase());
}
/**
 * This marks the error as a remirror specific error, with enhanced stack
 * tracing capabilities.
 *
 * @remarks
 *
 * Use this when creating your own extensions and notifying the user that
 * something has gone wrong.
 */


class RemirrorError extends makeError.BaseError {
  /**
   * A shorthand way of creating an error message.
   */
  static create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new RemirrorError(options);
  }
  /**
   * The error code used to create this error message.
   */


  /**
   * The constructor is intentionally kept private to prevent being extended from.
   */
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        code = _ref.code,
        message = _ref.message,
        _ref$disableLogging = _ref.disableLogging,
        disableLogging = _ref$disableLogging === void 0 ? false : _ref$disableLogging;

    var errorCode;

    if (isErrorConstant(code)) {
      errorCode = code;
      super(createErrorMessage(errorCode, message));
    } else {
      errorCode = coreConstants.ErrorConstant.CUSTOM;
      super(createErrorMessage(errorCode, message));
    }

    this.errorCode = errorCode;
    this.url = "".concat(ERROR_INFORMATION_URL, "#").concat(errorCode.toLowerCase());

    if (!disableLogging) {
      // Log the error.
      // eslint-disable-next-line no-console
      console.error(this.message);
    }
  }

}
/**
 * Throw an error if the condition fails. Strip out error messages for
 * production. Adapted from `tiny-invariant`.
 */

function invariant(condition, options) {
  if (condition) {
    return;
  }

  throw RemirrorError.create(options);
}
/**
 * The invariant options which only show up during development.
 */

/// <reference types="node" />
/**
 * A freeze method for objects that only runs in development. Helps prevent code
 * that shouldn't be mutated from being mutated during development.
 *
 * @remarks
 *
 * This function passes the value back unchanged when in a production
 * environment. It's purpose is to help prevent bad practice while developing
 * by avoiding mutation of values that shouldn't be mutated.
 */

function freeze(target) {

  {
    return target;
  }
}

Object.defineProperty(exports, "omit", ({
  enumerable: true,
  get: function () { return omit__default["default"]; }
}));
Object.defineProperty(exports, "pick", ({
  enumerable: true,
  get: function () { return object_pick__default["default"]; }
}));
Object.defineProperty(exports, "camelCase", ({
  enumerable: true,
  get: function () { return caseAnything.camelCase; }
}));
Object.defineProperty(exports, "capitalCase", ({
  enumerable: true,
  get: function () { return caseAnything.capitalCase; }
}));
Object.defineProperty(exports, "constantCase", ({
  enumerable: true,
  get: function () { return caseAnything.constantCase; }
}));
Object.defineProperty(exports, "kebabCase", ({
  enumerable: true,
  get: function () { return caseAnything.kebabCase; }
}));
Object.defineProperty(exports, "pascalCase", ({
  enumerable: true,
  get: function () { return caseAnything.pascalCase; }
}));
Object.defineProperty(exports, "pathCase", ({
  enumerable: true,
  get: function () { return caseAnything.pathCase; }
}));
Object.defineProperty(exports, "snakeCase", ({
  enumerable: true,
  get: function () { return caseAnything.snakeCase; }
}));
Object.defineProperty(exports, "spaceCase", ({
  enumerable: true,
  get: function () { return caseAnything.spaceCase; }
}));
Object.defineProperty(exports, "debounce", ({
  enumerable: true,
  get: function () { return throttleDebounce.debounce; }
}));
Object.defineProperty(exports, "throttle", ({
  enumerable: true,
  get: function () { return throttleDebounce.throttle; }
}));
exports.Cast = Cast;
exports.RemirrorError = RemirrorError;
exports.assert = assert;
exports.assertGet = assertGet;
exports.callIfDefined = callIfDefined;
exports.capitalize = capitalize;
exports.clamp = clamp;
exports.cleanupOS = cleanupOS;
exports.clone = clone;
exports.cx = cx;
exports.deepMerge = deepMerge;
exports.entries = entries;
exports.findMatches = findMatches;
exports.flattenArray = flattenArray;
exports.format = format;
exports.freeze = freeze;
exports.get = get;
exports.getLazyArray = getLazyArray;
exports.hasOwnProperty = hasOwnProperty;
exports.includes = includes;
exports.invariant = invariant;
exports.isAndroidOS = isAndroidOS;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isClass = isClass;
exports.isDate = isDate;
exports.isDirectInstanceOf = isDirectInstanceOf;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyObject = isEmptyObject;
exports.isEqual = isEqual;
exports.isError = isError;
exports.isFunction = isFunction;
exports.isInstanceOf = isInstanceOf;
exports.isInteger = isInteger;
exports.isJSONPrimitive = isJSONPrimitive;
exports.isMap = isMap;
exports.isNativePromise = isNativePromise;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isNull = isNull;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPrimitive = isPrimitive;
exports.isPromise = isPromise;
exports.isRegExp = isRegExp;
exports.isSafeInteger = isSafeInteger;
exports.isSet = isSet;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.isUndefined = isUndefined;
exports.keys = keys;
exports.last = last;
exports.noop = noop;
exports.object = object;
exports.omitUndefined = omitUndefined;
exports.randomFloat = randomFloat;
exports.randomInt = randomInt;
exports.range = range;
exports.set = set;
exports.shallowClone = shallowClone;
exports.sort = sort;
exports.startCase = startCase;
exports.take = take;
exports.toString = toString;
exports.uniqueArray = uniqueArray;
exports.uniqueBy = uniqueBy;
exports.uniqueId = uniqueId;
exports.unset = unset;
exports.values = values;
exports.within = within;


/***/ }),
/* 22 */
/***/ ((module, exports) => {

"use strict";
// ISC @ Julien Fontanet



// ===================================================================

var construct = typeof Reflect !== "undefined" ? Reflect.construct : undefined;
var defineProperty = Object.defineProperty;

// -------------------------------------------------------------------

var captureStackTrace = Error.captureStackTrace;
if (captureStackTrace === undefined) {
  captureStackTrace = function captureStackTrace(error) {
    var container = new Error();

    defineProperty(error, "stack", {
      configurable: true,
      get: function getStack() {
        var stack = container.stack;

        // Replace property with value for faster future accesses.
        defineProperty(this, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });

        return stack;
      },
      set: function setStack(stack) {
        defineProperty(error, "stack", {
          configurable: true,
          value: stack,
          writable: true,
        });
      },
    });
  };
}

// -------------------------------------------------------------------

function BaseError(message) {
  if (message !== undefined) {
    defineProperty(this, "message", {
      configurable: true,
      value: message,
      writable: true,
    });
  }

  var cname = this.constructor.name;
  if (cname !== undefined && cname !== this.name) {
    defineProperty(this, "name", {
      configurable: true,
      value: cname,
      writable: true,
    });
  }

  captureStackTrace(this, this.constructor);
}

BaseError.prototype = Object.create(Error.prototype, {
  // See: https://github.com/JsCommunity/make-error/issues/4
  constructor: {
    configurable: true,
    value: BaseError,
    writable: true,
  },
});

// -------------------------------------------------------------------

// Sets the name of a function if possible (depends of the JS engine).
var setFunctionName = (function() {
  function setFunctionName(fn, name) {
    return defineProperty(fn, "name", {
      configurable: true,
      value: name,
    });
  }
  try {
    var f = function() {};
    setFunctionName(f, "foo");
    if (f.name === "foo") {
      return setFunctionName;
    }
  } catch (_) {}
})();

// -------------------------------------------------------------------

function makeError(constructor, super_) {
  if (super_ == null || super_ === Error) {
    super_ = BaseError;
  } else if (typeof super_ !== "function") {
    throw new TypeError("super_ should be a function");
  }

  var name;
  if (typeof constructor === "string") {
    name = constructor;
    constructor =
      construct !== undefined
        ? function() {
            return construct(super_, arguments, this.constructor);
          }
        : function() {
            super_.apply(this, arguments);
          };

    // If the name can be set, do it once and for all.
    if (setFunctionName !== undefined) {
      setFunctionName(constructor, name);
      name = undefined;
    }
  } else if (typeof constructor !== "function") {
    throw new TypeError("constructor should be either a string or a function");
  }

  // Also register the super constructor also as `constructor.super_` just
  // like Node's `util.inherits()`.
  //
  // eslint-disable-next-line dot-notation
  constructor.super_ = constructor["super"] = super_;

  var properties = {
    constructor: {
      configurable: true,
      value: constructor,
      writable: true,
    },
  };

  // If the name could not be set on the constructor, set it on the
  // prototype.
  if (name !== undefined) {
    properties.name = {
      configurable: true,
      value: name,
      writable: true,
    };
  }
  constructor.prototype = Object.create(super_.prototype, properties);

  return constructor;
}
exports = module.exports = makeError;
exports.BaseError = BaseError;


/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "css": () => (/* reexport safe */ _css__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "cx": () => (/* reexport safe */ _cx__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24);
/* harmony import */ var _cx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);


//# sourceMappingURL=index.js.map

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const css = () => {
  throw new Error('Using the "css" tag in runtime is not supported. Make sure you have set up the Babel plugin correctly.');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (css);
//# sourceMappingURL=css.js.map

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const cx = function cx() {
  const result = Array.prototype.slice.call(arguments).filter(Boolean).join(' ');
  return result;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (cx);
//# sourceMappingURL=cx.js.map

/***/ }),
/* 26 */
/***/ ((module) => {

"use strict";


var isMergeableObject = function isMergeableObject(value) {
	return isNonNullObject(value)
		&& !isSpecial(value)
};

function isNonNullObject(value) {
	return !!value && typeof value === 'object'
}

function isSpecial(value) {
	var stringValue = Object.prototype.toString.call(value);

	return stringValue === '[object RegExp]'
		|| stringValue === '[object Date]'
		|| isReactElement(value)
}

// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

function isReactElement(value) {
	return value.$$typeof === REACT_ELEMENT_TYPE
}

function emptyTarget(val) {
	return Array.isArray(val) ? [] : {}
}

function cloneUnlessOtherwiseSpecified(value, options) {
	return (options.clone !== false && options.isMergeableObject(value))
		? deepmerge(emptyTarget(value), value, options)
		: value
}

function defaultArrayMerge(target, source, options) {
	return target.concat(source).map(function(element) {
		return cloneUnlessOtherwiseSpecified(element, options)
	})
}

function getMergeFunction(key, options) {
	if (!options.customMerge) {
		return deepmerge
	}
	var customMerge = options.customMerge(key);
	return typeof customMerge === 'function' ? customMerge : deepmerge
}

function getEnumerableOwnPropertySymbols(target) {
	return Object.getOwnPropertySymbols
		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
			return target.propertyIsEnumerable(symbol)
		})
		: []
}

function getKeys(target) {
	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
}

function propertyIsOnObject(object, property) {
	try {
		return property in object
	} catch(_) {
		return false
	}
}

// Protects from prototype poisoning and unexpected merging up the prototype chain.
function propertyIsUnsafe(target, key) {
	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
}

function mergeObject(target, source, options) {
	var destination = {};
	if (options.isMergeableObject(target)) {
		getKeys(target).forEach(function(key) {
			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
		});
	}
	getKeys(source).forEach(function(key) {
		if (propertyIsUnsafe(target, key)) {
			return
		}

		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
		} else {
			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
		}
	});
	return destination
}

function deepmerge(target, source, options) {
	options = options || {};
	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
	// implementations can use it. The caller may not replace it.
	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

	var sourceIsArray = Array.isArray(source);
	var targetIsArray = Array.isArray(target);
	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

	if (!sourceAndTargetTypesMatch) {
		return cloneUnlessOtherwiseSpecified(source, options)
	} else if (sourceIsArray) {
		return options.arrayMerge(target, source, options)
	} else {
		return mergeObject(target, source, options)
	}
}

deepmerge.all = function deepmergeAll(array, options) {
	if (!Array.isArray(array)) {
		throw new Error('first argument should be an array')
	}

	return array.reduce(function(prev, next) {
		return deepmerge(prev, next, options)
	}, {})
};

var deepmerge_1 = deepmerge;

module.exports = deepmerge_1;


/***/ }),
/* 27 */
/***/ ((module) => {

"use strict";


// do not edit .js files directly - edit src/index.jst



module.exports = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};


/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * object.omit <https://github.com/jonschlinkert/object.omit>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isObject = __webpack_require__(29);

module.exports = function omit(obj, props, fn) {
  if (!isObject(obj)) return {};

  if (typeof props === 'function') {
    fn = props;
    props = [];
  }

  if (typeof props === 'string') {
    props = [props];
  }

  var isFunction = typeof fn === 'function';
  var keys = Object.keys(obj);
  var res = {};

  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];

    if (!props || (props.indexOf(key) === -1 && (!isFunction || fn(val, key, obj)))) {
      res[key] = val;
    }
  }
  return res;
};


/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * is-extendable <https://github.com/jonschlinkert/is-extendable>
 *
 * Copyright (c) 2015-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isPlainObject = __webpack_require__(30);

module.exports = function isExtendable(val) {
  return isPlainObject(val) || typeof val === 'function' || Array.isArray(val);
};


/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



var isObject = __webpack_require__(31);

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

module.exports = function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};


/***/ }),
/* 31 */
/***/ ((module) => {

"use strict";
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */



module.exports = function isObject(val) {
  return val != null && typeof val === 'object' && Array.isArray(val) === false;
};


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*!
 * object.pick <https://github.com/jonschlinkert/object.pick>
 *
 * Copyright (c) 2014-2015 Jon Schlinkert, contributors.
 * Licensed under the MIT License
 */



var isObject = __webpack_require__(31);

module.exports = function pick(obj, keys) {
  if (!isObject(obj) && typeof obj !== 'function') {
    return {};
  }

  var res = {};
  if (typeof keys === 'string') {
    if (keys in obj) {
      res[keys] = obj[keys];
    }
    return res;
  }

  var len = keys.length;
  var idx = -1;

  while (++idx < len) {
    var key = keys[idx];
    if (key in obj) {
      res[key] = obj[key];
    }
  }
  return res;
};


/***/ }),
/* 33 */
/***/ (function(__unused_webpack_module, exports) {

(function (global, factory) {
   true ? factory(exports) :
  0;
})(this, (function (exports) { 'use strict';

  // Latin-1 Supplement
  // upper case ranges
  // [À-ÖØ-ß]
  // lower case ranges
  // [à-öø-ÿ]
  /**
   * A string.match function that will return an array of "string parts"
   *
   * @param {string} string
   * @returns {string[]}
   */
  function splitOnSpecialChars(string) {
      return string.match(/^[a-zà-öø-ÿ]+|[A-ZÀ-ÖØ-ß][a-zà-öø-ÿ]+|[a-zà-öø-ÿ]+|[0-9]+|[A-ZÀ-ÖØ-ß]+(?![a-zà-öø-ÿ])/g);
  }
  /**
   * A string.match function that will return an array of "string parts"
   *
   * @param {string} string
   * @returns {string[]}
   */
  function getParts(string, noSpecialChars) {
      if (noSpecialChars === void 0) { noSpecialChars = false; }
      var target = string.trim().normalize('NFC');
      var parts = target.includes(' ') ? target.split(' ').filter(Boolean) : splitOnSpecialChars(target);
      return noSpecialChars ? parts.map(function (part) { return part.normalize('NFD').replace(/[^a-zA-ZØßø0-9]/g, ''); }) : parts;
  }
  /**
   * Capitalises a single word
   *
   * @export
   * @param {string} string the word
   * @returns {string} the word with the first character in uppercase and the rest in lowercase
   */
  function capitaliseWord(string) {
      return string[0].toUpperCase() + string.slice(1).toLowerCase();
  }

  var noSpecialChars = true;
  /**
   * converts strings to camelCase
   *
   * @export
   * @param {string} string
   * @returns {string} in camelCase
   */
  function camelCase(string) {
      return getParts(string, noSpecialChars).reduce(function (result, match, index) {
          return index === 0 ? match.toLowerCase() : result + capitaliseWord(match);
      }, '');
  }
  /**
   * converts strings to PascalCase
   *
   * @export
   * @param {string} string
   * @returns {string} in PascalCase
   */
  function pascalCase(string) {
      return getParts(string, noSpecialChars).reduce(function (result, match) {
          return result + capitaliseWord(match);
      }, '');
  }
  /**
   * converts strings to kebab-case
   *
   * @export
   * @param {string} string
   * @returns {string} in kebab-case
   */
  function kebabCase(string) {
      return getParts(string, noSpecialChars).join('-').toLowerCase();
  }
  /**
   * converts strings to snake_case
   *
   * @export
   * @param {string} string
   * @returns {string} in snake_case
   */
  function snakeCase(string) {
      return getParts(string, noSpecialChars).join('_').toLowerCase();
  }
  /**
   * converts strings to CONSTANT_CASE
   *
   * @export
   * @param {string} string
   * @returns {string} in CONSTANT_CASE
   */
  function constantCase(string) {
      return getParts(string, noSpecialChars).join('_').toUpperCase();
  }
  /**
   * converts strings to path/case
   *
   * @export
   * @param {string} string
   * @returns {string} in path/case
   */
  function pathCase(string) {
      return getParts(string).join('/');
  }
  /**
   * converts strings to space case (will add spaces but not change casing)
   *
   * @export
   * @param {string} string
   * @returns {string} in path case
   */
  function spaceCase(string) {
      return getParts(string).join(' ');
  }
  /**
   * converts strings to Capital Case (with spaces)
   *
   * @export
   * @param {string} string
   * @returns {string} in Capital Case (with spaces)
   */
  function capitalCase(string) {
      return getParts(string)
          .reduce(function (result, match) {
          return "".concat(result, " ").concat(capitaliseWord(match));
      }, '')
          .trim();
  }
  /**
   * converts strings to lower case (with spaces)
   *
   * @export
   * @param {string} string
   * @returns {string} in lower case (with spaces)
   */
  function lowerCase(string) {
      return getParts(string).join(' ').toLowerCase();
  }
  /**
   * converts strings to UPPER CASE (with spaces)
   *
   * @export
   * @param {string} string
   * @returns {string} in UPPER CASE (with spaces)
   */
  function upperCase(string) {
      return getParts(string).join(' ').toUpperCase();
  }

  exports.camelCase = camelCase;
  exports.capitalCase = capitalCase;
  exports.constantCase = constantCase;
  exports.kebabCase = kebabCase;
  exports.lowerCase = lowerCase;
  exports.pascalCase = pascalCase;
  exports.pathCase = pathCase;
  exports.snakeCase = snakeCase;
  exports.spaceCase = spaceCase;
  exports.upperCase = upperCase;

  Object.defineProperty(exports, '__esModule', { value: true });

}));


/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset).
 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function}  A new, throttled, function.
 */
function throttle (delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  } // `noTrailing` defaults to falsy.


  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}

/* eslint-disable no-undefined */
/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @returns {Function} A new, debounced function.
 */

function debounce (delay, atBegin, callback) {
  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);
}

exports.debounce = debounce;
exports.throttle = throttle;
//# sourceMappingURL=index.js.map


/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var makeError = __webpack_require__(22);
var coreConstants = __webpack_require__(17);
var _slicedToArray = __webpack_require__(8);
var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var _defineProperty = __webpack_require__(15);
var core = __webpack_require__(23);
var deepmerge = __webpack_require__(26);
var fastDeepEqual = __webpack_require__(27);
var omit = __webpack_require__(28);
var object_pick = __webpack_require__(32);
var caseAnything = __webpack_require__(33);
var throttleDebounce = __webpack_require__(34);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var deepmerge__default = /*#__PURE__*/_interopDefault(deepmerge);
var fastDeepEqual__default = /*#__PURE__*/_interopDefault(fastDeepEqual);
var omit__default = /*#__PURE__*/_interopDefault(omit);
var object_pick__default = /*#__PURE__*/_interopDefault(object_pick);

/**
 * Type cast an argument. If no type is provided it will default to any.
 *
 * @param arg - the arg to typecast
 */
function Cast(value) {
  return value;
}
/**
 * Get the key from a given value. Throw an error if the referenced property is
 * `undefined`.
 */

function assertGet(value, key, message) {
  var prop = value[key];
  assert(!isUndefined(prop), message);
  return prop;
}
/**
 * Assert the value is `truthy`. Good for defensive programming, especially
 * after enabling `noUncheckedIndexedAccess` in the tsconfig `compilerOptions`.
 */

function assert(testValue, message) {
  if (!testValue) {
    throw new AssertionError(message);
  }
}

class AssertionError extends makeError.BaseError {
  constructor() {
    super(...arguments);

    _defineProperty(this, "name", 'AssertionError');
  }

}
/**
 * A typesafe implementation of `Object.entries()`
 *
 * Taken from
 * https://github.com/biggyspender/ts-entries/blob/master/src/ts-entries.ts
 */


function entries(value) {
  return Object.entries(value);
}
/**
 * A typesafe implementation of `Object.keys()`
 */

function keys(value) {
  return Object.keys(value);
}
/**
 * A typesafe implementation of `Object.values()`
 */

function values(value) {
  return Object.values(value);
}
/**
 * A more lenient typed version of `Array.prototype.includes` which allow less
 * specific types to be checked.
 */

function includes(array, item, fromIndex) {
  return array.includes(item, fromIndex);
}
/**
 * Creates an object with the null prototype.
 *
 * @param value - the object to create
 */

function object(value) {
  return Object.assign(Object.create(null), value);
}
/**
 * A type name matcher for object types.
 *
 * @private
 */

var TypeName;
/**
 * Alias of toString for non-dom environments.
 *
 * This is a safe way of calling `toString` on objects created with
 * `Object.create(null)`.
 */

(function (TypeName) {
  TypeName["Object"] = "Object";
  TypeName["RegExp"] = "RegExp";
  TypeName["Date"] = "Date";
  TypeName["Promise"] = "Promise";
  TypeName["Error"] = "Error";
  TypeName["Map"] = "Map";
  TypeName["Set"] = "Set";
})(TypeName || (TypeName = {}));

function toString(value) {
  return Object.prototype.toString.call(value);
}
/**
 * Retrieve the object type of a value via it's string reference. This is safer
 * than relying on instanceof checks which fail on cross-frame values.
 *
 * @param value - the object to inspect
 */

function getObjectType(value) {
  var objectName = toString(value).slice(8, -1);
  return objectName;
}
/**
 * A helper for building type predicates
 *
 * @param type -  the name of the type to check for
 * @returns a predicate function for checking the value type
 */


function isOfType(type, predicate) {
  return value => {
    if (typeof value !== type) {
      return false;
    }

    return predicate ? predicate(value) : true;
  };
}
/**
 * Get the object type of passed in value. This avoids the reliance on
 * `instanceof` checks which are subject to cross frame issues as outlined in
 * this link https://bit.ly/1Qds27W
 *
 * @param type - the name of the object type to check for
 *
 * @private
 */


function isObjectOfType(type) {
  return value => getObjectType(value) === type;
}
/**
 * Check if an instance is the direct instance of the provided class.
 */


function isDirectInstanceOf(instance, Constructor) {
  return Object.getPrototypeOf(instance) === Constructor.prototype;
}
/**
 * Predicate check that value is undefined
 *
 * @param value - the value to check
 *
 */

var isUndefined = isOfType('undefined');
/**
 * Predicate check that value is a string
 *
 * @param value - the value to check
 *
 */

var isString = isOfType('string');
/**
 * Predicate check that value is a number.
 *
 * Also by default doesn't include NaN as a valid number.
 *
 * @param value - the value to check
 *
 */

var isNumber = isOfType('number', value => {
  return !Number.isNaN(value);
});
/**
 * Predicate check that value is a function
 *
 * @param value - the value to check
 *
 */

var isFunction = isOfType('function');
/**
 * Predicate check that value is null
 *
 * @param value - the value to check
 *
 */

function isNull(value) {
  return value === null;
}
/**
 * Predicate check that value is a class
 *
 * @deprecated Due to the current build process stripping out classes
 *
 * @param value - the value to check
 *
 */

function isClass(value) {
  return isFunction(value) && value.toString().startsWith('class ');
}
/**
 * Predicate check that value is boolean
 *
 * @param value - the value to check
 *
 */

function isBoolean(value) {
  return value === true || value === false;
}
/**
 * Predicate check that value is a symbol
 *
 * @param value - the value to check
 *
 */

var isSymbol = isOfType('symbol');
/**
 * Helper function for Number.isInteger check allowing non numbers to be tested
 *
 * @param value - the value to check
 *
 */

function isInteger(value) {
  return Number.isInteger(value);
}
/**
 * Helper function for Number.isSafeInteger allowing for unknown values to be
 * tested
 *
 * @param value - the value to check
 *
 */

function isSafeInteger(value) {
  return Number.isSafeInteger(value);
}
/**
 * Predicate check for whether passed in value is a plain object
 *
 * @param value - the value to check
 *
 */

function isPlainObject(value) {
  if (getObjectType(value) !== TypeName.Object) {
    return false;
  }

  var prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.getPrototypeOf({});
}
/**
 * Predicate check for whether passed in value is a primitive value
 */

function isPrimitive(value) {
  return value == null || /^[bns]/.test(typeof value);
}
/**
 * Predicate check for whether passed in value is a JSON primitive value
 */

function isJSONPrimitive(value) {
  return value === null || ['boolean', 'number', 'string'].includes(typeof value);
}
/**
 * Utility predicate check that value is either null or undefined
 *
 * @param value - the value to check
 *
 */

function isNullOrUndefined(value) {
  return isNull(value) || isUndefined(value);
}
/**
 * Predicate check that value is an object.
 *
 * @param value - the value to check
 *
 */

function isObject(value) {
  return !isNullOrUndefined(value) && (isFunction(value) || isOfType('object')(value));
}
/**
 * A shorthand method for creating instance of checks.
 */

function isInstanceOf(Constructor) {
  return value => isObject(value) && value instanceof Constructor;
}
/**
 * Predicate check that value is a native promise
 *
 * @param value - the value to check
 *
 */

function isNativePromise(value) {
  return isObjectOfType(TypeName.Promise)(value);
}
/**
 * Check to see if a value has the built in promise API.
 *
 * @param value - the value to check
 *
 */

var hasPromiseAPI = value => {
  return !!(!isNull(value) && isObject(value) && isFunction(value.then) && isFunction(value.catch));
};
/**
 * Predicate check that value has the promise api implemented
 *
 * @param value - the value to check
 *
 */


function isPromise(value) {
  return isNativePromise(value) || hasPromiseAPI(value);
}
/**
 * Predicate check that value is a RegExp
 *
 * @param value - the value to check
 *
 */

var isRegExp = isObjectOfType(TypeName.RegExp);
/**
 * Predicate check that value is a date
 *
 * @param value - the value to check
 *
 */

var isDate = isObjectOfType(TypeName.Date);
/**
 * Predicate check that value is an error
 *
 * @param value - the value to check
 *
 */

var isError = isObjectOfType(TypeName.Error);
/**
 * Predicate check that value is a `Map`
 *
 * @param value - the value to check
 *
 */

function isMap(value) {
  return isObjectOfType(TypeName.Map)(value);
}
/**
 * Predicate check that value is a `Set`
 *
 * @param value - the value to check
 *
 */

function isSet(value) {
  return isObjectOfType(TypeName.Set)(value);
}
/**
 * Predicate check that value is an empty object
 *
 * @param value - the value to check
 *
 */

function isEmptyObject(value) {
  return isObject(value) && !isMap(value) && !isSet(value) && Object.keys(value).length === 0;
}
/**
 * Alias the isArray method.
 */

var isArray = Array.isArray;
/**
 * Predicate check that value is an empty array
 *
 * @param value - the value to check
 *
 */

function isEmptyArray(value) {
  return isArray(value) && value.length === 0;
}
/**
 * Predicate check that value is a non-empty.
 *
 * @param value - the value to check
 *
 */

function isNonEmptyArray(value) {
  return isArray(value) && value.length > 0;
}
/**
 * Capitalizes a string value.
 *
 * @param str - the string to capitalize.
 */

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * Trim and conditionally capitalize string values.
 *
 * @param str - the string to format.
 *
 */

function format(value) {
  value = value.trim();
  return /^(?:webOS|i(?:OS|P))/.test(value) ? value : capitalize(value);
}
/**
 * Calls a function if defined and provides compile time type checking for the
 * passed in parameters.
 *
 * @param fn - the function to call if it exists
 * @param args - the rest of the parameters with types
 */

function callIfDefined(fn) {
  if (isFunction(fn)) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    fn(...args);
  }
}
/**
 * Finds all the regex matches for a string
 *
 * @param text - the text to check against
 * @param regexp - the regex (which should include a 'g' flag)
 *
 */

function findMatches(text, regexp) {
  var runWhile = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : match => !!match;
  regexp.lastIndex = 0;
  var results = [];
  var flags = regexp.flags;
  var match;

  if (!flags.includes('g')) {
    regexp = new RegExp(regexp.source, "g".concat(flags));
  }

  do {
    match = regexp.exec(text);

    if (match) {
      results.push(match);
    }
  } while (runWhile(match));

  regexp.lastIndex = 0;
  return results;
}
/**
 * A utility function to clean up the Operating System name.
 *
 * @param os - the OS name to clean up.
 * @param pattern - a `RegExp` pattern matching the OS name.
 * @param label - a label for the OS.
 * @returns a cleaned up Operating System name
 */

function cleanupOS(os, pattern, label) {
  var _os$replace$replace$r;

  if (pattern && label) {
    os = os.replace(new RegExp(pattern, 'i'), label);
  }

  return format((_os$replace$replace$r = os.replace(/ ce$/i, ' CE').replace(/\bhpw/i, 'web').replace(/\bMacintosh\b/, 'Mac OS').replace(/_powerpc\b/i, ' OS').replace(/\b(os x) [^\d ]+/i, '$1').replace(/\bMac (OS X)\b/, '$1').replace(/\/(\d)/, ' $1').replace(/_/g, '.').replace(/(?: bepc|[ .]*fc[\d .]+)$/i, '').replace(/\bx86\.64\b/gi, 'x86_64').replace(/\b(Windows Phone) OS\b/, '$1').replace(/\b(Chrome OS \w+) [\d.]+\b/, '$1').split(' on ')[0]) !== null && _os$replace$replace$r !== void 0 ? _os$replace$replace$r : '');
}
/**
 * A utility function to check whether the current browser is running on the
 * android platform.
 */

function isAndroidOS() {
  var _match$;

  var ua = navigator.userAgent;
  var match = new RegExp('\\b' + 'Android' + '(?:/[\\d.]+|[ \\w.]*)', 'i').exec(ua);

  if (!match) {
    return false;
  }

  return cleanupOS((_match$ = match[0]) !== null && _match$ !== void 0 ? _match$ : '', 'Android', 'Android').includes('Android');
}
/**
 * Generate a random float between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomFloat(min, max) {
  if (!max) {
    max = min;
    min = 0;
  }

  return Math.random() * (max - min + 1) + min;
}
/**
 * Generate a random integer between min and max. If only one parameter is
 * provided minimum is set to 0.
 *
 * @param min - the minimum value
 * @param max - the maximum value
 *
 */

function randomInt(min, max) {
  return Math.floor(randomFloat(min, max));
}
/**
 * Converts a string, including strings in camelCase or snake_case, into Start
 * Case (a variant of Title case where all words start with a capital letter),
 * it keeps original single quote and hyphen in the word.
 *
 *   'management_companies' to 'Management Companies' 'managementCompanies' to
 *   'Management Companies' `hell's kitchen` to `Hell's Kitchen` `co-op` to
 *   `Co-op`
 *
 * @param str - the string to examine
 */

function startCase(string) {
  return string.replace(/_/g, ' ').replace(/([a-z])([A-Z])/g, (_, $1, $2) => "".concat($1, " ").concat($2)).replace(/(\s|^)(\w)/g, (_, $1, $2) => "".concat($1).concat($2.toUpperCase()));
}
/**
 * Returns a number that is unique during the runtime of this code.
 */

function n() {
  var time = Date.now();
  var last = n.last || time;
  return n.last = time > last ? time : last + 1;
}

n.last = 0;
/**
 * Generate a unique id
 *
 * @param prefix - a prefix for the generated id.
 * @returns a unique string of specified length
 *
 */

function uniqueId() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return "".concat(prefix).concat(n().toString(36));
}
/**
 * Takes a number of elements from the provided array starting from the
 * zero-index
 *
 * @param arr - the array to take from
 * @param num - the number of items to take
 *
 */

function take(array, number) {
  number = Math.max(Math.min(0, number), number);
  return array.slice(0, number);
}
/**
 * Remove the undefined values from an object.
 */

function omitUndefined(object) {
  return omit__default["default"](object, value => !isUndefined(value));
}
/**
 * Clones a plain object using object spread notation
 *
 * @param value - the value to check
 *
 */

function clone(value) {
  if (!isPlainObject(value)) {
    throw new Error('An invalid value was passed into this clone utility. Expected a plain object');
  }

  return _objectSpread({}, value);
}
/**
 * Shallow clone an object while preserving it's getters and setters. This is a
 * an alternative to the spread clone.
 */

function shallowClone(value) {
  var clone = Object.create(Object.getPrototypeOf(value));
  var descriptors = Object.getOwnPropertyDescriptors(value);
  Object.defineProperties(clone, descriptors);
  return clone;
}
/**
 * Alias for fast deep equal
 */

var isEqual = fastDeepEqual__default["default"];
/**
 * Create a unique array in a non-mutating manner
 *
 * @param array - the array which will be reduced to its unique elements
 * @param fromStart - when set to true the duplicates will be removed from the
 * beginning of the array. This defaults to false.
 *
 * @returns a new array containing only unique elements (by reference)
 *
 */

function uniqueArray(array) {
  var fromStart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var array_ = fromStart ? [...array].reverse() : array;
  var set = new Set(array_);
  return fromStart ? [...set].reverse() : [...set];
}
/**
 * Flattens an array.
 *
 * @param array
 *
 */

function flattenArray(array) {
  var flattened = [];

  var _iterator = _createForOfIteratorHelper(array),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;
      var itemsToInsert = isArray(_item) ? flattenArray(_item) : [_item];
      flattened.push(...itemsToInsert);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return flattened;
}
/**
 * noop is a shorthand way of saying `No Operation` and is a function that does
 * nothing.
 *
 * And Sometimes doing nothing is the best policy.
 */

function noop() {
  return;
}
/**
 * A deep merge which only merges plain objects and Arrays. It clones the object
 * before the merge so will not mutate any of the passed in values.
 *
 * To completely remove a key you can use the `Merge` helper class which
 * replaces it's key with a completely new object
 */

function deepMerge() {
  for (var _len2 = arguments.length, objects = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    objects[_key2] = arguments[_key2];
  }

  return deepmerge__default["default"].all(objects, {
    isMergeableObject: isPlainObject
  });
}

/**
 * Clamps the value to the provided range.
 */
function clamp(_ref) {
  var min = _ref.min,
      max = _ref.max,
      value = _ref.value;

  if (value < min) {
    return min;
  }

  return value > max ? max : value;
}
/**
 * Get the last element of the array.
 */

function last(array) {
  return array[array.length - 1];
}
/**
 * Sorts an array while retaining the original order when the compare method
 * identifies the items as equal.
 *
 * `Array.prototype.sort()` is unstable and so values that are the same will
 * jump around in a non deterministic manner. Here I'm using the index as a
 * fallback. If two elements have the same priority the element with the lower
 * index is placed first hence retaining the original order.
 *
 * @param array - the array to sort
 * @param compareFn - compare the two value arguments `a` and `z` - return 0 for
 *                  equal - return number > 0 for a > z - return number < 0 for
 *                  z > a
 */

function sort(array, compareFn) {
  return [...array].map((value, index) => ({
    value,
    index
  })).sort((a, z) => compareFn(a.value, z.value) || a.index - z.index).map(_ref2 => {
    var value = _ref2.value;
    return value;
  });
}
/**
 * Get a property from an object or array by a string path or an array path.
 *
 * @param obj - object to retrieve property from
 * @param path - path to property
 */

function get(root, path, defaultValue) {
  try {
    if (isString(path) && path in root) {
      return root[path];
    }

    if (isArray(path)) {
      path = "['".concat(path.join("']['"), "']");
    }

    var obj = root;
    path.replace(/\[\s*(["'])(.*?)\1\s*]|^\s*(\w+)\s*(?=\.|\[|$)|\.\s*(\w*)\s*(?=\.|\[|$)|\[\s*(-?\d+)\s*]/g, (_, __, quotedProp, firstLevel, namedProp, index) => {
      obj = obj[quotedProp || firstLevel || namedProp || index];
      return '';
    });
    return obj === undefined ? defaultValue : obj;
  } catch (_unused) {
    return defaultValue;
  }
}

function setPropInternal(path, obj, value, index) {
  if (path.length === index) {
    return value;
  } // Create things as we go down if they don't exist


  obj = obj || {};
  var key = path[index];
  assert(key);
  return setClone(obj, key, setPropInternal(path, obj[key], value, ++index));
}

function setClone(obj, key, value) {
  var newObj = clone(obj);
  newObj[key] = value;
  return newObj;
}
/**
 * Set the value of a given path for the provided object. Does not mutate the
 * original object.
 */


function set(path, obj, value) {
  if (isNumber(path)) {
    return setClone(obj, path, value);
  }

  if (isString(path)) {
    path = path.split('.');
  }

  return setPropInternal(path, obj, value, 0);
}
/**
 * Unset the value of a given path within an object.
 */

function unset(path, target) {
  var clonedObject = clone(target);
  var value = clonedObject;

  var _iterator2 = _createForOfIteratorHelper(path.entries()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          index = _step2$value[0],
          key = _step2$value[1];

      var shouldDelete = index >= path.length - 1;
      var _item2 = value[key];

      if (shouldDelete) {
        if (isArray(value)) {
          var indexKey = Number.parseInt(key.toString(), 10);

          if (isNumber(indexKey)) {
            value.splice(indexKey, 1);
          }
        } else {
          Reflect.deleteProperty(value, key);
        }

        return clonedObject;
      }

      if (isPrimitive(_item2)) {
        return clonedObject;
      }

      _item2 = isArray(_item2) ? [..._item2] : _objectSpread({}, _item2);
      value[key] = _item2;
      value = _item2;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return clonedObject;
}

function makeFunctionForUniqueBy(value) {
  return item => {
    return get(item, value);
  };
}
/**
 * Create a unique array of objects from a getter function or a property list.
 *
 * @param array - the array to extract unique values from
 * @param getValue - a getter function or a string with the path to the item
 * that is being used as a a test for uniqueness.
 * @param fromStart - when true will remove duplicates from the start rather
 * than from the end
 *
 * ```ts
 * import { uniqueBy } from '@remirror/core-helpers';
 *
 * const values = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], item => item.id);
 * log(values) // => [{id: 'a', value: 'Awesome'}]
 *
 * const byKey = uniqueBy([{ id: 'a', value: 'Awesome' }, { id: 'a', value: 'ignored' }], 'id')
 * // Same as above
 * ```
 */


function uniqueBy(array, getValue) {
  var fromStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var unique = [];
  var found = new Set();
  var getter = isFunction(getValue) ? getValue : makeFunctionForUniqueBy(getValue);
  var list = fromStart ? [...array].reverse() : array;

  var _iterator3 = _createForOfIteratorHelper(list),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _item3 = _step3.value;

      var _value = getter(_item3);

      if (!found.has(_value)) {
        found.add(_value);
        unique.push(_item3);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return fromStart ? unique.reverse() : unique;
}
/**
 * Create a range from start to end.
 *
 * If only start is provided it creates an array of the size provided. if start
 * and end are provided it creates an array who's first position is start and
 * final position is end. i.e. `length = (end - start) + 1`.
 *
 * If you'd like to create a typed tuple of up to `40` items then pass in a
 * `[number]` tuple as the first argument.
 */

function range(start, end) {
  var startValue = isArray(start) ? start[0] : start;

  if (!isNumber(end)) {
    return Array.from({
      length: Math.abs(startValue)
    }, (_, index) => (startValue < 0 ? -1 : 1) * index);
  }

  if (startValue <= end) {
    return Array.from({
      length: end + 1 - startValue
    }, (_, index) => index + startValue);
  }

  return Array.from({
    length: startValue + 1 - end
  }, (_, index) => -1 * index + startValue);
}
/**
 * Check that a number is within the minimum and maximum bounds of a set of
 * numbers.
 *
 * @param value - the number to test
 */

function within(value) {
  for (var _len3 = arguments.length, rest = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    rest[_key3 - 1] = arguments[_key3];
  }

  var numbers = rest.filter(isNumber);
  return value >= Math.min(...numbers) && value <= Math.max(...numbers);
}
/**
 * Safe implementation of hasOwnProperty with typechecking.
 *
 * @remarks
 *
 * See {@link https://eslint.org/docs/rules/no-prototype-builtins}
 *
 * @param obj - the object to check
 * @param key - the property to check
 *
 * @template Obj - the object type
 * @template Property - the property which can be a string | number | symbol
 */

function hasOwnProperty(object_, key) {
  return Object.prototype.hasOwnProperty.call(object_, key);
}
/**
 * Helper for getting an array from a function or array.
 */

function getLazyArray(value) {
  if (isFunction(value)) {
    return value();
  }

  return value;
}
function cx() {
  return uniqueArray(core.cx(...arguments).split(' ')).join(' ');
} // The following are forward exports for other libraries. I've structured it

/**
 * Errors have their own URL which will be logged to the console for simpler
 * debugging.
 */

var ERROR_INFORMATION_URL = 'https://remirror.io/docs/errors';
var errorMessageMap = {
  [coreConstants.ErrorConstant.UNKNOWN]: "An error occurred but we're not quite sure why. 🧐",
  [coreConstants.ErrorConstant.INVALID_COMMAND_ARGUMENTS]: 'The arguments passed to the command method were invalid.',
  [coreConstants.ErrorConstant.CUSTOM]: 'This is a custom error, possibly thrown by an external library.',
  [coreConstants.ErrorConstant.CORE_HELPERS]: 'An error occurred in a function called from the `@remirror/core-helpers` library.',
  [coreConstants.ErrorConstant.MUTATION]: 'Mutation of immutable value detected.',
  [coreConstants.ErrorConstant.INTERNAL]: 'This is an error which should not occur and is internal to the remirror codebase.',
  [coreConstants.ErrorConstant.MISSING_REQUIRED_EXTENSION]: 'Your editor is missing a required extension.',
  [coreConstants.ErrorConstant.MANAGER_PHASE_ERROR]: 'This occurs when accessing a method or property before it is available.',
  [coreConstants.ErrorConstant.INVALID_GET_EXTENSION]: 'The user requested an invalid extension from the getExtensions method. Please check the `createExtensions` return method is returning an extension with the defined constructor.',
  [coreConstants.ErrorConstant.INVALID_MANAGER_ARGUMENTS]: 'Invalid value(s) passed into `Manager` constructor. Only `Presets` and `Extensions` are supported.',
  [coreConstants.ErrorConstant.SCHEMA]: "There is a problem with the schema or you are trying to access a node / mark that doesn't exists.",
  [coreConstants.ErrorConstant.HELPERS_CALLED_IN_OUTER_SCOPE]: 'The `helpers` method which is passed into the ``create*` method should only be called within returned method since it relies on an active view (not present in the outer scope).',
  [coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION]: 'You requested an invalid extension from the manager.',
  [coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'Command method names must be unique within the editor.',
  [coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES]: 'Helper method names must be unique within the editor.',
  [coreConstants.ErrorConstant.NON_CHAINABLE_COMMAND]: 'Attempted to chain a non chainable command.',
  [coreConstants.ErrorConstant.INVALID_EXTENSION]: 'The provided extension is invalid.',
  [coreConstants.ErrorConstant.INVALID_CONTENT]: 'The content provided to the editor is not supported.',
  [coreConstants.ErrorConstant.INVALID_NAME]: 'An invalid name was used for the extension.',
  [coreConstants.ErrorConstant.EXTENSION]: 'An error occurred within an extension. More details should be made available.',
  [coreConstants.ErrorConstant.EXTENSION_SPEC]: 'The spec was defined without calling the `defaults`, `parse` or `dom` methods.',
  [coreConstants.ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES]: 'Extra attributes must either be a string or an object.',
  [coreConstants.ErrorConstant.INVALID_SET_EXTENSION_OPTIONS]: 'A call to `extension.setOptions` was made with invalid keys.',
  [coreConstants.ErrorConstant.REACT_PROVIDER_CONTEXT]: '`useRemirrorContext` was called outside of the `remirror` context. It can only be used within an active remirror context created by the `<Remirror />`.',
  [coreConstants.ErrorConstant.REACT_GET_ROOT_PROPS]: '`getRootProps` has been attached to the DOM more than once. It should only be attached to the dom once per editor.',
  [coreConstants.ErrorConstant.REACT_EDITOR_VIEW]: 'A problem occurred adding the editor view to the dom.',
  [coreConstants.ErrorConstant.REACT_CONTROLLED]: 'There is a problem with your controlled editor setup.',
  [coreConstants.ErrorConstant.REACT_NODE_VIEW]: 'Something went wrong with your custom ReactNodeView Component.',
  [coreConstants.ErrorConstant.REACT_GET_CONTEXT]: 'You attempted to call `getContext` provided by the `useRemirror` prop during the first render of the editor. This is not possible and should only be after the editor first mounts.',
  [coreConstants.ErrorConstant.REACT_COMPONENTS]: 'An error occurred within a remirror component.',
  [coreConstants.ErrorConstant.REACT_HOOKS]: 'An error occurred within a remirror hook.',
  [coreConstants.ErrorConstant.I18N_CONTEXT]: 'You called `useI18n()` outside of an `I18nProvider` context.'
};
/**
 * Checks whether the passed code is an `ErrorConstant`.
 */

function isErrorConstant(code) {
  return isString(code) && includes(values(coreConstants.ErrorConstant), code);
}
/**
 * Create an error message from the provided error code.
 */


function createErrorMessage(code, extraMessage) {
  var message = errorMessageMap[code];
  var prefix = message ? "".concat(message, "\n\n") : '';
  var customMessage = extraMessage ? "".concat(extraMessage, "\n\n") : '';
  return "".concat(prefix).concat(customMessage, "For more information visit ").concat(ERROR_INFORMATION_URL, "#").concat(code.toLowerCase());
}
/**
 * This marks the error as a remirror specific error, with enhanced stack
 * tracing capabilities.
 *
 * @remarks
 *
 * Use this when creating your own extensions and notifying the user that
 * something has gone wrong.
 */


class RemirrorError extends makeError.BaseError {
  /**
   * A shorthand way of creating an error message.
   */
  static create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    return new RemirrorError(options);
  }
  /**
   * The error code used to create this error message.
   */


  /**
   * The constructor is intentionally kept private to prevent being extended from.
   */
  constructor() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        code = _ref.code,
        message = _ref.message,
        _ref$disableLogging = _ref.disableLogging,
        disableLogging = _ref$disableLogging === void 0 ? false : _ref$disableLogging;

    var errorCode;

    if (isErrorConstant(code)) {
      errorCode = code;
      super(createErrorMessage(errorCode, message));
    } else {
      errorCode = coreConstants.ErrorConstant.CUSTOM;
      super(createErrorMessage(errorCode, message));
    }

    this.errorCode = errorCode;
    this.url = "".concat(ERROR_INFORMATION_URL, "#").concat(errorCode.toLowerCase());

    if (!disableLogging) {
      // Log the error.
      // eslint-disable-next-line no-console
      console.error(this.message);
    }
  }

}
/**
 * Throw an error if the condition fails. Strip out error messages for
 * production. Adapted from `tiny-invariant`.
 */

function invariant(condition, options) {
  if (condition) {
    return;
  }

  throw RemirrorError.create(options);
}
/**
 * The invariant options which only show up during development.
 */

/// <reference types="node" />
/**
 * A freeze method for objects that only runs in development. Helps prevent code
 * that shouldn't be mutated from being mutated during development.
 *
 * @remarks
 *
 * This function passes the value back unchanged when in a production
 * environment. It's purpose is to help prevent bad practice while developing
 * by avoiding mutation of values that shouldn't be mutated.
 */

function freeze(target) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (process.env.NODE_ENV === 'production') {
    return target;
  }

  !(isObject(target) || isArray(target)) ? process.env.NODE_ENV !== "production" ? invariant(false, {
    message: '`freeze` only supports objects and arrays.',
    code: coreConstants.ErrorConstant.CORE_HELPERS
  }) : invariant(false) : void 0;
  return new Proxy(target, {
    get: (target, prop, receiver) => {
      !(prop in target || !options.requireKeys) ? process.env.NODE_ENV !== "production" ? invariant(false, {
        message: "The prop: '".concat(prop.toString(), "' you are trying to access does not yet exist on the target.")
      }) : invariant(false) : void 0;
      return Reflect.get(target, prop, receiver);
    },
    set: (_, prop) => {
      process.env.NODE_ENV !== "production" ? invariant(false, {
        message: "It seems you're trying to set the value of the property (".concat(String(prop), ") on a frozen object. For your protection this object does not allow direct mutation."),
        code: coreConstants.ErrorConstant.MUTATION
      }) : invariant(false) ;
    }
  });
}

Object.defineProperty(exports, "omit", ({
  enumerable: true,
  get: function () { return omit__default["default"]; }
}));
Object.defineProperty(exports, "pick", ({
  enumerable: true,
  get: function () { return object_pick__default["default"]; }
}));
Object.defineProperty(exports, "camelCase", ({
  enumerable: true,
  get: function () { return caseAnything.camelCase; }
}));
Object.defineProperty(exports, "capitalCase", ({
  enumerable: true,
  get: function () { return caseAnything.capitalCase; }
}));
Object.defineProperty(exports, "constantCase", ({
  enumerable: true,
  get: function () { return caseAnything.constantCase; }
}));
Object.defineProperty(exports, "kebabCase", ({
  enumerable: true,
  get: function () { return caseAnything.kebabCase; }
}));
Object.defineProperty(exports, "pascalCase", ({
  enumerable: true,
  get: function () { return caseAnything.pascalCase; }
}));
Object.defineProperty(exports, "pathCase", ({
  enumerable: true,
  get: function () { return caseAnything.pathCase; }
}));
Object.defineProperty(exports, "snakeCase", ({
  enumerable: true,
  get: function () { return caseAnything.snakeCase; }
}));
Object.defineProperty(exports, "spaceCase", ({
  enumerable: true,
  get: function () { return caseAnything.spaceCase; }
}));
Object.defineProperty(exports, "debounce", ({
  enumerable: true,
  get: function () { return throttleDebounce.debounce; }
}));
Object.defineProperty(exports, "throttle", ({
  enumerable: true,
  get: function () { return throttleDebounce.throttle; }
}));
exports.Cast = Cast;
exports.RemirrorError = RemirrorError;
exports.assert = assert;
exports.assertGet = assertGet;
exports.callIfDefined = callIfDefined;
exports.capitalize = capitalize;
exports.clamp = clamp;
exports.cleanupOS = cleanupOS;
exports.clone = clone;
exports.cx = cx;
exports.deepMerge = deepMerge;
exports.entries = entries;
exports.findMatches = findMatches;
exports.flattenArray = flattenArray;
exports.format = format;
exports.freeze = freeze;
exports.get = get;
exports.getLazyArray = getLazyArray;
exports.hasOwnProperty = hasOwnProperty;
exports.includes = includes;
exports.invariant = invariant;
exports.isAndroidOS = isAndroidOS;
exports.isArray = isArray;
exports.isBoolean = isBoolean;
exports.isClass = isClass;
exports.isDate = isDate;
exports.isDirectInstanceOf = isDirectInstanceOf;
exports.isEmptyArray = isEmptyArray;
exports.isEmptyObject = isEmptyObject;
exports.isEqual = isEqual;
exports.isError = isError;
exports.isFunction = isFunction;
exports.isInstanceOf = isInstanceOf;
exports.isInteger = isInteger;
exports.isJSONPrimitive = isJSONPrimitive;
exports.isMap = isMap;
exports.isNativePromise = isNativePromise;
exports.isNonEmptyArray = isNonEmptyArray;
exports.isNull = isNull;
exports.isNullOrUndefined = isNullOrUndefined;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isPlainObject = isPlainObject;
exports.isPrimitive = isPrimitive;
exports.isPromise = isPromise;
exports.isRegExp = isRegExp;
exports.isSafeInteger = isSafeInteger;
exports.isSet = isSet;
exports.isString = isString;
exports.isSymbol = isSymbol;
exports.isUndefined = isUndefined;
exports.keys = keys;
exports.last = last;
exports.noop = noop;
exports.object = object;
exports.omitUndefined = omitUndefined;
exports.randomFloat = randomFloat;
exports.randomInt = randomInt;
exports.range = range;
exports.set = set;
exports.shallowClone = shallowClone;
exports.sort = sort;
exports.startCase = startCase;
exports.take = take;
exports.toString = toString;
exports.uniqueArray = uniqueArray;
exports.uniqueBy = uniqueBy;
exports.uniqueId = uniqueId;
exports.unset = unset;
exports.values = values;
exports.within = within;


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(37);
} else {
  module.exports = __webpack_require__(115);
}


/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);
var state = __webpack_require__(38);
var transform = __webpack_require__(45);
var _objectWithoutProperties = __webpack_require__(48);
var _slicedToArray = __webpack_require__(8);
var cssInJsUtils = __webpack_require__(50);
var model = __webpack_require__(64);
var parse = __webpack_require__(67);
var messages = __webpack_require__(68);
var inputrules = __webpack_require__(83);
var suggest = __webpack_require__(87);
var pm = __webpack_require__(100);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var parse__default = /*#__PURE__*/_interopDefault(parse);

/// <reference types="node" />

/**
 * A object with flags identifying the current environment.
 */
var environment = {
  /**
   * Verifies that the environment has both a window and window.document
   */
  get isBrowser() {
    return !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && window.navigator && window.navigator.userAgent);
  },

  /**
   * Verifies that the environment is JSDOM
   */
  get isJSDOM() {
    return environment.isBrowser && window.navigator.userAgent.includes('jsdom');
  },

  /**
   * Verifies that the environment has a nodejs process and is therefore a node environment
   */
  get isNode() {
    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
  },

  /**
   * True when on an iOS device.
   */
  get isIos() {
    return environment.isBrowser && /iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * True when running on macOS
   */
  get isMac() {
    return environment.isBrowser && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * Verify that this is an apple device either on the client or server.
   */
  get isApple() {
    return environment.isNode ? process.platform === 'darwin' : environment.isBrowser ? /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) : false;
  },

  /**
   * True when running in DEVELOPMENT environment
   */
  get isDevelopment() {
    return         "production" === 'development';
  },

  /**
   * True when running unit tests
   */
  get isTest() {
    return         "production" === 'test';
  },

  /**
   * True when running in PRODUCTION environment
   */
  get isProduction() {
    return         "production" === 'production';
  }

};

/**
 * Get the styles for a given property of an element.
 */

function getStyle(element, property) {
  var _element$ownerDocumen, _element$ownerDocumen2;

  var view = (_element$ownerDocumen = (_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.defaultView) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : window;
  var style = view.getComputedStyle(element);
  return style.getPropertyValue(property);
}
/**
 * Set more styles to the given element.
 */

function setStyle(target, styles) {
  return Object.assign(target.style, styles);
}
var DOM_SIZE_UNITS = ['px', 'rem', 'em', 'in', 'q', 'mm', 'cm', 'pt', 'pc', 'vh', 'vw', 'vmin', 'vmax'];

/**
 * Matches a CSS dimension returning a group containing the unit name
 * i.e. '10rem' returns the group 'rem'
 */
var CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
/**
 * Parse the font size and font unit from the provided value. When the value
 * type is unsupported it default to `px`.
 */

function parseSizeUnit() {
  var _match$;

  var fontSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
  var length = fontSize || '0';
  var value = Number.parseFloat(length);
  var match = length.match(CSS_DIMENSION_REGEX);
  var unit = ((_match$ = match === null || match === void 0 ? void 0 : match[1]) !== null && _match$ !== void 0 ? _match$ : 'px').toLowerCase(); // Defaults to pixels

  return [value, coreHelpers.includes(DOM_SIZE_UNITS, unit) ? unit : 'px'];
}
var PIXELS_PER_INCH = 96;
var MILLIMETERS_PER_INCH = 25.4;
var POINTS_PER_INCH = 72;
var PICAS_PER_INCH = 6;
function getFontSize(element) {
  return isElementDomNode(element) ? getStyle(element, 'font-size') || getFontSize(element.parentElement) : getStyle(window.document.documentElement, 'font-size');
}

function createUnitConverter(element) {
  var _element$ownerDocumen3, _element$ownerDocumen4;

  var view = (_element$ownerDocumen3 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.defaultView) !== null && _element$ownerDocumen3 !== void 0 ? _element$ownerDocumen3 : window;
  var root = view.document.documentElement || view.document.body;
  return (value, unit) => {
    switch (unit) {
      case 'rem':
        return value * extractPixelSize(getFontSize(root));

      case 'em':
        return value * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

      case 'in':
        return value * PIXELS_PER_INCH;

      case 'q':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH / 4;

      case 'mm':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH;

      case 'cm':
        return value * PIXELS_PER_INCH * 10 / MILLIMETERS_PER_INCH;

      case 'pt':
        return value * PIXELS_PER_INCH / POINTS_PER_INCH;

      case 'pc':
        return value * PIXELS_PER_INCH / PICAS_PER_INCH;

      case 'vh':
        return (value * view.innerHeight || root.clientWidth) / 100;

      case 'vw':
        return (value * view.innerWidth || root.clientHeight) / 100;

      case 'vmin':
        return value * Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      case 'vmax':
        return value * Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      default:
        return value;
    }
  };
}
/**
 * Matches a CSS function returning groups containing the function name and arguments
 * i.e. 'min(10px, 20px)' returns groups 'min' and '10px, 20px'
 */


var CSS_FUNCTION_REGEX = /^([a-z]+)\((.+)\)$/i;
/**
 * Recursively evaluates CSS functions by parsing into bracket groups
 *
 * Does not support the `calc` function
 *
 * @param cssFunc a string matching CSS_FUNCTION_REGEX
 * @param unitConvertor
 */

function parseCSSFunction(cssFunc, unitConvertor) {
  if (!CSS_FUNCTION_REGEX.test(cssFunc)) {
    return Number.NaN;
  }

  var tokens = parse__default["default"](cssFunc, {
    brackets: ['()'],
    escape: '_',
    flat: true
  });

  if (!tokens || tokens.length === 0) {
    return Number.NaN;
  }

  function replaceTokenReferences(str) {
    return str.replace(/_(\d+)_/g, (_, refIndex) => {
      var _tokens$tokenIndex;

      var tokenIndex = Number.parseFloat(refIndex);
      return (_tokens$tokenIndex = tokens[tokenIndex]) !== null && _tokens$tokenIndex !== void 0 ? _tokens$tokenIndex : '';
    });
  }

  var firstToken = getMatchString(tokens, 0);

  var _iterator = _createForOfIteratorHelper(coreHelpers.findMatches(firstToken, CSS_FUNCTION_REGEX)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var match = _step.value;
      var funcName = getMatchString(match, 1);
      var funcArgs = replaceTokenReferences(getMatchString(match, 2));
      var args = funcArgs.split(/\s*,\s*/);
      var values = args.map(arg => {
        if (CSS_FUNCTION_REGEX.test(arg)) {
          var nestedFunction = replaceTokenReferences(arg);
          return parseCSSFunction(nestedFunction, unitConvertor);
        }

        return parseCSSDimension(arg, unitConvertor);
      });

      switch (funcName) {
        case 'min':
          return Math.min(...values);

        case 'max':
          return Math.max(...values);

        case 'clamp':
          {
            var _values = _slicedToArray(values, 3),
                min = _values[0],
                _value = _values[1],
                max = _values[2];

            if (coreHelpers.isNumber(min) && coreHelpers.isNumber(_value) && coreHelpers.isNumber(max)) {
              return coreHelpers.clamp({
                min,
                max,
                value: _value
              });
            }

            break;
          }

        case 'calc':
          // Not practical to implement calc due to the vast amount of operations possible
          return Number.NaN;

        default:
          return Number.NaN;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return Number.NaN;
}

function parseCSSDimension(dimension, unitConvertor) {
  var _parseSizeUnit = parseSizeUnit(dimension),
      _parseSizeUnit2 = _slicedToArray(_parseSizeUnit, 2),
      value = _parseSizeUnit2[0],
      unit = _parseSizeUnit2[1];

  return unitConvertor(value, unit);
}
/**
 * Extract the pixel value from a dimension string or CSS function.
 *
 * Supports the CSS functions `min`, `max` and `clamp` even when nested.
 *
 * Does not support percentage units or the `calc` function.
 *
 * Adapted from https://github.com/PacoteJS/pacote/blob/20cb1e3a999ed47a8d52b03b750290cf36b8e270/packages/pixels/src/index.ts
 */


function extractPixelSize(size, element) {
  var unitConvertor = createUnitConverter(element);
  return CSS_FUNCTION_REGEX.test(size) ? parseCSSFunction(size.toLowerCase(), unitConvertor) : parseCSSDimension(size, unitConvertor);
}
/**
 * Convert the received font size to a valid unit
 */

function convertPixelsToDomUnit(size, to, element) {
  var _element$ownerDocumen5, _element$ownerDocumen6;

  var view = (_element$ownerDocumen5 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.defaultView) !== null && _element$ownerDocumen5 !== void 0 ? _element$ownerDocumen5 : window;
  var root = view.document.documentElement || view.document.body;
  var pixelValue = extractPixelSize(size, element);

  switch (to) {
    case 'px':
      return pixelValue;

    case 'rem':
      return pixelValue / extractPixelSize(getFontSize(root));

    case 'em':
      return pixelValue * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

    case 'in':
      return pixelValue / PIXELS_PER_INCH;

    case 'q':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH * 4;

    case 'mm':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH;

    case 'cm':
      return pixelValue / PIXELS_PER_INCH / 10 * MILLIMETERS_PER_INCH;

    case 'pt':
      return pixelValue / PIXELS_PER_INCH * POINTS_PER_INCH;

    case 'pc':
      return pixelValue / PIXELS_PER_INCH * PICAS_PER_INCH;

    case 'vh':
      return pixelValue / (view.innerHeight || root.clientWidth) * 100;

    case 'vw':
      return pixelValue / (view.innerWidth || root.clientHeight) * 100;

    case 'vmin':
      return pixelValue / Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    case 'vmax':
      return pixelValue / Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    default:
      return pixelValue;
  }
}
/**
 * Checks whether the passed value is a valid dom node
 *
 * @param domNode - the dom node
 */

function isDomNode(domNode) {
  return typeof document !== 'undefined' && (coreHelpers.isObject(Node) ? domNode instanceof Node : coreHelpers.isObject(domNode) && coreHelpers.isNumber(coreHelpers.Cast(domNode).nodeType) && coreHelpers.isString(coreHelpers.Cast(domNode).nodeName));
}
/**
 * Checks for an element node like `<p>` or `<div>`.
 *
 * @param domNode - the dom node
 */

function isElementDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.ELEMENT_NODE;
}
/**
 * Checks for a text node.
 *
 * @param domNode - the dom node
 */

function isTextDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.TEXT_NODE;
}

/**
 * Checks if the type a given `node` has a given `nodeType`.
 */
function isNodeOfType(props) {
  var types = props.types,
      node = props.node;

  if (!node) {
    return false;
  }

  var matches = type => {
    return type === node.type || type === node.type.name;
  };

  if (coreHelpers.isArray(types)) {
    return types.some(matches);
  }

  return matches(types);
}

/**
 * Creates a new transaction object from a given transaction. This is useful
 * when applying changes to a transaction, that you may want to rollback.
 *
 * ```ts
 * function() applyUpdateIfValid(state: EditorState) {
 *   const tr = cloneTransaction(state.tr);
 *
 *   tr.insertText('hello');
 *
 *   if (!checkValid(tr)) {
 *     return;
 *   }
 *
 *   applyClonedTransaction({ clone: tr, tr: state.tr });
 * }
 * ```
 *
 * The above example applies a transaction to the cloned transaction then checks
 * to see if the changes are still valid and if they are applies the mutative
 * changes to the original state transaction.
 *
 * @param tr - the prosemirror transaction
 */
function cloneTransaction(tr) {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
}

/**
 * Get the diff between two ordered arrays with a reference equality check.
 */
function diff(primary, other) {
  return primary.filter((item, index) => item !== other[index]);
}
/**
 * Apply the steps of a cloned transaction to the original transaction `tr`.
 */


function applyClonedTransaction(props) {
  var clone = props.clone,
      tr = props.tr;
  var steps = diff(clone.steps, tr.steps);

  var _iterator = _createForOfIteratorHelper(steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      tr.step(step);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/**
 * Returns a new transaction by combining all steps of the passed transactions onto the previous state
 */

function composeTransactionSteps(transactions, oldState) {
  var tr = oldState.tr;
  transactions.forEach(transaction => {
    transaction.steps.forEach(step => {
      tr.step(step);
    });
  });
  return tr;
}
/**
 * Checks if the type a given `node` has a given `nodeType`.
 */

function markEqualsType(props) {
  var types = props.types,
      mark = props.mark;
  return mark ? Array.isArray(types) && types.includes(mark.type) || mark.type === types : false;
}

/**
 * Performs a `delete` transaction that removes a node at a given position with
 * the given `node`. `position` should point at the position immediately before
 * the node.
 *
 * @param position - the prosemirror position
 */
function removeNodeAtPosition(_ref) {
  var pos = _ref.pos,
      tr = _ref.tr;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.delete(pos, pos + node.nodeSize);
  }

  return tr;
}

/**
 * Replaces the node at the provided position with the provided content.
 */
function replaceNodeAtPosition(_ref2) {
  var pos = _ref2.pos,
      tr = _ref2.tr,
      content = _ref2.content;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.replaceWith(pos, pos + node.nodeSize, content);
  }

  return tr;
}
/**
 * Returns DOM reference of a node at a given `position`.
 *
 * @remarks
 *
 * If the node type is of type `TEXT_NODE` it will return the reference of the
 * parent node.
 *
 * A simple use case
 *
 * ```ts
 * const element = findElementAtPosition($from.pos, view);
 * ```
 *
 * @param position - the prosemirror position
 * @param view - the editor view
 */

function findElementAtPosition(position, view) {
  var dom = view.domAtPos(position);
  var node = dom.node.childNodes[dom.offset];

  if (isTextDomNode(dom.node)) {
    return dom.node.parentNode;
  }

  if (coreHelpers.isNullOrUndefined(node) || isTextDomNode(node)) {
    return dom.node;
  }

  return node;
}
/**
 * Iterates over parent nodes, returning the closest node and its start position
 * that the `predicate` returns truthy for. `start` points to the start position
 * of the node, `pos` points directly before the node.
 *
 * ```ts
 * const predicate = node => node.type === schema.nodes.blockquote;
 * const parent = findParentNode({ predicate, selection });
 * ```
 */

function findParentNode(props) {
  var predicate = props.predicate,
      selection = props.selection;
  var $pos = isEditorState(selection) ? selection.selection.$from : isSelection(selection) ? selection.$from : selection;

  for (var depth = $pos.depth; depth > 0; depth--) {
    var _node = $pos.node(depth);

    var _pos = depth > 0 ? $pos.before(depth) : 0;

    var start = $pos.start(depth);
    var end = _pos + _node.nodeSize;

    if (predicate(_node, _pos)) {
      return {
        pos: _pos,
        depth,
        node: _node,
        start,
        end
      };
    }
  }

  return;
}
/**
 * Finds the node at the resolved position.
 *
 * @param $pos - the resolve position in the document
 */

function findNodeAtPosition($pos) {
  var depth = $pos.depth;
  var pos = depth > 0 ? $pos.before(depth) : 0;
  var node = $pos.node(depth);
  var start = $pos.start(depth);
  var end = pos + node.nodeSize;
  return {
    pos,
    start,
    node,
    end,
    depth
  };
}
/**
 * Finds the node at the passed selection.
 */

function findNodeAtSelection(selection) {
  var parentNode = findParentNode({
    predicate: () => true,
    selection
  });
  !parentNode ? coreHelpers.invariant(false) : void 0;
  return parentNode;
}

/**
 *  Iterates over parent nodes, returning closest node of a given `nodeType`.
 *  `start` points to the start position of the node, `pos` points directly
 *  before the node.
 *
 *  ```ts
 *  const parent = findParentNodeOfType({types: schema.nodes.paragraph, selection});
 *  ```
 */
function findParentNodeOfType(props) {
  var types = props.types,
      selection = props.selection;
  return findParentNode({
    predicate: node => isNodeOfType({
      types,
      node
    }),
    selection
  });
}
/**
 * Returns position of the previous node.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */

function findPositionOfNodeBefore(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeBefore = $pos.nodeBefore;
  var selection = state.Selection.findFrom($pos, -1);

  if (!selection || !nodeBefore) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeBefore.type,
    selection
  });
  return parent ? parent : {
    node: nodeBefore,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Updates the provided transaction to remove the node before.
 *
 * ```ts
 * dispatch(
 *    removeNodeBefore(state.tr)
 * );
 * ```
 *
 * @param tr
 */

function removeNodeBefore(tr) {
  var result = findPositionOfNodeBefore(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}

/**
 * Returns a node of a given `nodeType` if it is selected. `start` points to the
 * start position of the node, `pos` points directly before the node.
 *
 * ```ts
 * const { extension, inlineExtension, bodiedExtension } = schema.nodes;
 *
 * const selectedNode = findSelectedNodeOfType({
 *   types: [extension, inlineExtension, bodiedExtension],
 *   selection,
 * });
 * ```
 */
function findSelectedNodeOfType(props) {
  var types = props.types,
      selection = props.selection;

  if (!isNodeSelection(selection) || !isNodeOfType({
    types,
    node: selection.node
  })) {
    return;
  }

  return {
    pos: selection.$from.pos,
    depth: selection.$from.depth,
    start: selection.$from.start(),
    end: selection.$from.pos + selection.node.nodeSize,
    node: selection.node
  };
}

/**
 * Returns the position of the node after the current position, selection or
 * state.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */
function findPositionOfNodeAfter(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeAfter = $pos.nodeAfter;
  var selection = state.Selection.findFrom($pos, 1);

  if (!selection || !nodeAfter) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeAfter.type,
    selection
  });
  return parent ? parent : {
    node: nodeAfter,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Update the transaction to delete the node after the current selection.
 *
 * ```ts
 * dispatch(removeNodeBefore(state.tr));
 * ```
 *
 * @param tr
 */

function removeNodeAfter(tr) {
  var result = findPositionOfNodeAfter(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}
/**
 * Checks whether the selection or state is currently empty.
 *
 * @param value - the transaction selection or state
 */

function isSelectionEmpty(value) {
  return isSelection(value) ? value.empty : value.selection.empty;
}
/**
 * Check to see if a transaction has changed either the document or the current
 * selection.
 *
 * @param tr - the transaction to check
 */

function hasTransactionChanged(tr) {
  return tr.docChanged || tr.selectionSet;
}
/**
 * Checks whether the node type passed in is active within the region. Used by
 * extensions to implement the `active` method.
 *
 * To ignore `attrs` just leave the attrs object empty or undefined.
 *
 * @param props - see [[`GetActiveAttrsProps`]]
 */

function isNodeActive(props) {
  return !!getActiveNode(props);
}

/**
 * Get node of a provided type with the provided attributes if it exists as a
 * parent. Returns positional data for the node that was found.
 */
function getActiveNode(props) {
  var _findSelectedNodeOfTy;

  var state = props.state,
      type = props.type,
      attrs = props.attrs;
  var selection = state.selection,
      doc = state.doc;
  var nodeType = coreHelpers.isString(type) ? doc.type.schema.nodes[type] : type;
  !nodeType ? coreHelpers.invariant(false) : void 0;
  var active = (_findSelectedNodeOfTy = findSelectedNodeOfType({
    selection,
    types: type
  })) !== null && _findSelectedNodeOfTy !== void 0 ? _findSelectedNodeOfTy : findParentNode({
    predicate: node => node.type === nodeType,
    selection
  });

  if (!attrs || coreHelpers.isEmptyObject(attrs) || !active) {
    return active;
  }

  return active.node.hasMarkup(nodeType, _objectSpread(_objectSpread({}, active.node.attrs), attrs)) ? active : undefined;
}
/**
 * The ProseMirror `Schema` as a JSON object.
 */

/**
 * Converts a `schema` to a JSON compatible object.
 */
function schemaToJSON(schema) {
  var nodes = coreHelpers.object();
  var marks = coreHelpers.object();

  var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(schema.nodes)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          key = _step2$value[0],
          spec = _step2$value[1].spec;

      nodes[key] = spec;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var _iterator3 = _createForOfIteratorHelper(coreHelpers.entries(schema.marks)),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _key = _step3$value[0],
          _spec = _step3$value[1].spec;

      marks[_key] = _spec;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return {
    nodes,
    marks
  };
}
/**
 * Chains together keybindings, allowing for the same key binding to be used
 * across multiple extensions without overriding behavior.
 *
 * @remarks
 *
 * When `next` is called it hands over full control of the keybindings to the
 * function that invokes it.
 */

function chainKeyBindingCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    commands[_key2] = arguments[_key2];
  }

  return props => {
    // When no commands are passed just ignore and continue.
    if (!coreHelpers.isNonEmptyArray(commands)) {
      return false;
    }

    var command = commands[0],
        rest = commands.slice(1); // Keeps track of whether the `next` method has been called. If it has been
    // called we return the result and skip the rest of the downstream commands.

    var calledNext = false;
    /**
     * Create the next function call. Updates the outer closure when the next
     * method has been called.
     */

    var createNext = function createNext() {
      for (var _len2 = arguments.length, nextCommands = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        nextCommands[_key3] = arguments[_key3];
      }

      return () => {
        // If there are no commands then this can be ignored and continued.
        if (!coreHelpers.isNonEmptyArray(nextCommands)) {
          return false;
        } // Update the closure with information that the next method was invoked by
        // this command.


        calledNext = true;
        var nextRest = nextCommands.slice(1); // Recursively call the key bindings method.

        return chainKeyBindingCommands(...nextCommands)(_objectSpread(_objectSpread({}, props), {}, {
          next: createNext(...nextRest)
        }));
      };
    };

    var next = createNext(...rest);
    var exitEarly = command(_objectSpread(_objectSpread({}, props), {}, {
      next
    })); // Exit the chain of commands early if either:
    // - a) next was called
    // - b) the command returned true

    if (calledNext || exitEarly) {
      return exitEarly;
    } // Continue to the next function in the chain of commands.


    return next();
  };
}
/**
 * Used to merge key bindings together in a sensible way. Identical key bindings
 * likely have the same key. as a result a naive merge would result in the
 * binding added later in the merge being the only one the editor sees.
 *
 * This creator is used to create a merge that steps from the highest priority
 * to the lowest priority giving each keybinding in the chain an opportunity to
 * be run, and defer to the next command in the chain or choose not to.
 *
 * - It is used to create the [[`mergeKeyBindings`]] function helper.
 * - It is used to create the [[`mergeProsemirrorKeyBindings`]] function helper.
 *
 * @template [Schema] - the schema that is being used to create this command.
 * @template [Type] - the mapper type signature which is what the `mapper`
 * param transforms the [[`KeyBindingCommandFunction`]]  into.
 *
 * @param extensionKeymaps - the list of extension keymaps similar to the
 * following:
 *   ```ts
 *     [{ Enter: () => false}, { Escape: () => true }, { Enter: () => true }]
 *   ```
 * @param mapper - used to convert the [[`KeyBindingCommandFunction`]] into a
 * function with a different signature. It's application can be seen in
 * [[`mergeKeyBindings`]] and [[`mergeProsemirrorKeyBindings`]].
 *
 */

function mergeKeyBindingCreator(extensionKeymaps, mapper) {
  // Keep track of the previous commands as we loop through the `extensionKeymaps`.
  var previousCommandsMap = new Map(); // This is the combined mapping of commands. Essentially this function turns
  // the `extensionKeymaps` array into a single object `extensionKeymap` which
  // composes each function to give full control to the developer.

  var mappedCommands = coreHelpers.object(); // Outer loop iterates over each object keybinding.

  var _iterator4 = _createForOfIteratorHelper(extensionKeymaps),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var extensionKeymap = _step4.value;

      // Inner loop checks each keybinding on the keybinding object. `key` refers
      // to the name of the keyboard combination, like `Shift-Enter` or
      // `Cmd-Escape`.
      var _iterator5 = _createForOfIteratorHelper(coreHelpers.entries(extensionKeymap)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _previousCommandsMap$;

          var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              newCommand = _step5$value[1];

          // Get the previous commands for this key if it already exists
          var previousCommands = (_previousCommandsMap$ = previousCommandsMap.get(key)) !== null && _previousCommandsMap$ !== void 0 ? _previousCommandsMap$ : []; // Update the commands array. This will be added to the
          // `previousCommandsMap` to track the current keyboard combination.

          var commands = [...previousCommands, newCommand]; // Chain the keyboard binding so that you have all the niceties, like
          // being able to call `next` to run the remaining commands in the chain.

          var _command = chainKeyBindingCommands(...commands); // Update the previous commands with the new commands that are now being used.


          previousCommandsMap.set(key, commands); // Store a copy of the mapped commands. If this was the last time this
          // loop ran, then this is the command that would be called when a users
          // enters the keyboard combination specified by the `key` in this context.

          mappedCommands[key] = mapper(_command);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return mappedCommands;
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This is for use on remirror keybindings. See `mergeProsemirrorKeyBindings`
 * for transforming the methods into `ProsemirrorCommandFunction`'s.
 */


function mergeKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, command => command);
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This supports the [[ProsemirrorCommandFunction]] type signature where the
 * `state`, `dispatch` and `view` are passed as separate arguments.
 */

function mergeProsemirrorKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, // Convert the command to have a signature of the
  // [[`ProsemirrorCommandFunction`]].
  command => (state, dispatch, view) => {
    return command({
      state,
      dispatch,
      view,
      tr: state.tr,
      next: () => false
    });
  });
}
/**
 * Determines if a Node or Mark contains the given attributes in its attributes set
 *
 * @param nodeOrMark - The Node or Mark to check
 * @param attrs - The set of attributes it must contain
 */

function containsAttributes(nodeOrMark, attrs) {
  var _nodeOrMark$attrs;

  var currentAttrs = (_nodeOrMark$attrs = nodeOrMark.attrs) !== null && _nodeOrMark$attrs !== void 0 ? _nodeOrMark$attrs : {};
  return Object.entries(attrs).every(_ref3 => {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        value = _ref4[1];

    return currentAttrs[name] === value;
  });
}

var _excluded$1 = ["content", "schema", "document", "fragment"],
    _excluded2$1 = ["json", "schema"];

function isRangeStep(step) {
  return isValidStep(step, [transform.AddMarkStep, transform.ReplaceAroundStep, transform.ReplaceStep, transform.RemoveMarkStep]);
}
/**
 * Identifies the value as having a remirror identifier. This is the core
 * predicate check for the remirror library.
 *
 * @param value - the value to be checked
 *
 * @internal
 */


function isRemirrorType(value) {
  return coreHelpers.isObject(value);
}
/**
 * Checks that the provided remirror shape is of a given type.
 *
 * @param value - any remirror shape
 * @param type - the remirror identifier type to check for
 *
 * @internal
 */

function isIdentifierOfType(value, type) {
  return coreHelpers.isArray(type) ? coreHelpers.includes(type, value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]) : type === value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__];
}
/**
 * Check to see if the passed value is a NodeType.
 *
 * @param value - the value to check
 */

function isNodeType(value) {
  return coreHelpers.isObject(value) && value instanceof model.NodeType;
}
/**
 * Get the node type from a potential string value.
 */

function getNodeType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.nodes, type) : type;
}
/**
 * Check to see if the passed value is a MarkType.
 *
 * @param value - the value to check
 */

function isMarkType(value) {
  return coreHelpers.isObject(value) && value instanceof model.MarkType;
}
/**
 * Get the mark type from a potential string value.
 */

function getMarkType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.marks, type) : type;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorNode(value) {
  return coreHelpers.isObject(value) && value instanceof model.Node;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorFragment(value) {
  return coreHelpers.isObject(value) && value instanceof model.Fragment;
}
/**
 * Checks to see if the passed value is a ProsemirrorMark
 *
 * @param value - the value to check
 */

function isProsemirrorMark(value) {
  return coreHelpers.isObject(value) && value instanceof model.Mark;
}
/**
 * Checks to see if the passed value is a Prosemirror Editor State
 *
 * @param value - the value to check
 */

function isEditorState(value) {
  return coreHelpers.isObject(value) && value instanceof state.EditorState;
}
/**
 * Checks to see if the passed value is a Prosemirror Transaction
 *
 * @param value - the value to check
 */

function isTransaction(value) {
  return coreHelpers.isObject(value) && value instanceof state.Transaction;
}
/**
 * Checks to see if the passed value is an instance of the editor schema
 *
 * @param value - the value to check
 */

function isEditorSchema(value) {
  return coreHelpers.isObject(value) && value instanceof model.Schema;
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.TextSelection;
}
/**
 * Predicate checking whether the selection is an `AllSelection`.
 *
 * @param value - the value to check
 */

function isAllSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.AllSelection;
}
/**
 * Predicate checking whether the value is a Selection
 *
 * @param value - the value to check
 */

function isSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.Selection;
}
/**
 * Predicate checking whether the value is a ResolvedPosition.
 *
 * @param value - the value to check
 */

function isResolvedPos(value) {
  return coreHelpers.isObject(value) && value instanceof model.ResolvedPos;
}

/**
 * A wrapper for ProsemirrorNode.rangeHasMark that can also compare mark attributes (if supplied)
 *
 * @param props - see [[`RangeHasMarkProps`]] for options
 */
function rangeHasMark(props) {
  var trState = props.trState,
      from = props.from,
      to = props.to,
      type = props.type,
      _props$attrs = props.attrs,
      attrs = _props$attrs === void 0 ? {} : _props$attrs;
  var doc = trState.doc;
  var markType = getMarkType(type, doc.type.schema);

  if (Object.keys(attrs).length === 0) {
    return doc.rangeHasMark(from, to, markType);
  }

  var found = false;

  if (to > from) {
    doc.nodesBetween(from, to, node => {
      var _node$marks;

      if (found) {
        return false;
      }

      var marks = (_node$marks = node.marks) !== null && _node$marks !== void 0 ? _node$marks : [];
      found = marks.some(mark => {
        if (mark.type !== markType) {
          return false;
        }

        return containsAttributes(mark, attrs);
      }); // Don't descend if found

      return !found;
    });
  }

  return found;
}
/**
 * Predicate checking whether the selection is a NodeSelection
 *
 * @param value - the value to check
 */

function isNodeSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.NodeSelection;
}

/**
 * Checks that a mark is active within the selected region, or the current
 * selection point is within a region with the mark active. Used by extensions
 * to implement their active methods.
 *
 * @param props - see [[`IsMarkActiveProps`]] for options
 */
function isMarkActive(props) {
  var trState = props.trState,
      type = props.type,
      _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      from = props.from,
      to = props.to;
  var selection = trState.selection,
      doc = trState.doc,
      storedMarks = trState.storedMarks;
  var markType = coreHelpers.isString(type) ? doc.type.schema.marks[type] : type;
  !markType ? coreHelpers.invariant(false) : void 0;

  if (from && to) {
    try {
      return Math.max(from, to) < doc.nodeSize && rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
        from,
        to
      }));
    } catch (_unused) {
      return false;
    }
  }

  if (selection.empty) {
    var marks = storedMarks !== null && storedMarks !== void 0 ? storedMarks : selection.$from.marks();
    return marks.some(mark => {
      if (mark.type !== type) {
        return false;
      }

      return containsAttributes(mark, attrs !== null && attrs !== void 0 ? attrs : {});
    });
  }

  return rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
    from: selection.from,
    to: selection.to
  }));
}
/**
 * Check if the specified type (NodeType) can be inserted at the current
 * selection point.
 *
 * @param state - the editor state
 * @param type - the node type
 */

function canInsertNode(state, type) {
  var $from = state.selection.$from;

  for (var depth = $from.depth; depth >= 0; depth--) {
    var index = $from.index(depth);

    try {
      if ($from.node(depth).canReplaceWith(index, index, type)) {
        return true;
      }
    } catch (_unused2) {
      return false;
    }
  }

  return false;
}
/**
 * Checks if a node looks like an empty document.
 *
 * @param node - the prosemirror node
 */

function isDocNodeEmpty(node) {
  var nodeChild = node.content.firstChild;

  if (node.childCount !== 1 || !nodeChild) {
    return false;
  }

  return nodeChild.type.isBlock && !nodeChild.childCount && nodeChild.nodeSize === 2 && (coreHelpers.isNullOrUndefined(nodeChild.marks) || nodeChild.marks.length === 0);
}

/**
 * Check whether the provided doc node has the same value as the default empty
 * node for the document. Basically checks that the document is untouched.
 *
 * This is useful for extensions like the placeholder which only should be shown
 * when the document matches the default empty state.
 */
function isDefaultDocNode(doc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaultDoc = getDefaultDocNode(doc.type.schema); // Make sure the `doc` was created.

  if (!defaultDoc) {
    // No default doc exists for the current schema.
    return false;
  }

  var ignoreAttributes = options.ignoreAttributes,
      ignoreDocAttributes = options.ignoreDocAttributes;

  if (ignoreAttributes) {
    return prosemirrorNodeEquals(defaultDoc, doc);
  }

  if (ignoreDocAttributes) {
    return defaultDoc.content.eq(doc.content);
  }

  return defaultDoc.eq(doc);
}
/**
 * Check that two nodes are equal while ignoring all attributes.
 *
 * This is an alternative to the `node.eq()` method.
 */

function prosemirrorNodeEquals(node, other) {
  // The values are equivalent so return `true` early.
  if (node === other) {
    return true;
  } // Check if the markup is the same (ignoring attributes)


  var identicalMarkup = node.type === other.type && model.Mark.sameSet(node.marks, other.marks);

  function contentEquals() {
    if (node.content === other.content) {
      return true;
    }

    if (node.content.size !== other.content.size) {
      return false;
    }

    var nodeChildren = [];
    var otherChildren = [];
    node.content.forEach(node => nodeChildren.push(node));
    other.content.forEach(node => otherChildren.push(node));

    var _iterator = _createForOfIteratorHelper(nodeChildren.entries()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            index = _step$value[0],
            nodeChild = _step$value[1];

        var otherChild = otherChildren[index];

        if (!otherChild) {
          return false;
        }

        if (!prosemirrorNodeEquals(nodeChild, otherChild)) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return identicalMarkup && contentEquals();
}
/**
 * Get the default `doc` node for a given schema.
 */

function getDefaultDocNode(schema) {
  var _schema$nodes$doc$cre, _schema$nodes$doc;

  return (_schema$nodes$doc$cre = (_schema$nodes$doc = schema.nodes.doc) === null || _schema$nodes$doc === void 0 ? void 0 : _schema$nodes$doc.createAndFill()) !== null && _schema$nodes$doc$cre !== void 0 ? _schema$nodes$doc$cre : undefined;
}
/**
 * Get the default block node from the schema.
 */

function getDefaultBlockNode(schema) {
  // Set the default block node from the schema.
  for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
    var type = _Object$values[_i];

    if (type.name === 'doc') {
      continue;
    } // Break as soon as the first non 'doc' block node is encountered.


    if (type.isBlock || type.isTextblock) {
      return type;
    }
  }

  coreHelpers.invariant(false) ;
}
/**
 * Check if the provided node is a default block node.
 */

function isDefaultBlockNode(node) {
  return node.type === getDefaultBlockNode(node.type.schema);
}
/**
 * Checks if the current node is a block node and empty.
 *
 * @param node - the prosemirror node
 */

function isEmptyBlockNode(node) {
  return !!node && node.type.isBlock && !node.textContent && !node.childCount;
}
/**
 * Retrieve the attributes for a mark.
 *
 * @param trState - the editor state or a transaction
 * @param type - the mark type
 */

function getMarkAttributes(trState, type) {
  // Get the current range of the cursor selection.
  var _trState$selection = trState.selection,
      from = _trState$selection.from,
      to = _trState$selection.to; // The container which will be used to store the marks.

  var marks = []; // Find the nodes and add all the marks contained to the above mark container.

  trState.doc.nodesBetween(from, to, node => {
    marks.push(...node.marks);
  }); // Search for the first mark with the same type as requested

  var mark = marks.find(markItem => markItem.type.name === type.name); // Return the mark attrs when found.

  if (mark) {
    return mark.attrs;
  } // Return false to denote the mark could not be found.


  return false;
}

/**
 * Retrieve the `start` and `end` position of a mark. The `$pos` value should be
 * calculated via `tr.doc.resolve(number)`.
 *
 * @remarks
 *
 * @param $pos - the resolved ProseMirror position
 * @param type - the mark type
 * @param $end - the end position to search until. When this is provided the
 * mark will be checked for all point up until the `$end`. The first mark within
 * the range will be returned.
 *
 * To find all marks within a selection use [[`getMarkRanges`]].
 */
function getMarkRange($pos, type, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var typeName = coreHelpers.isString(type) ? type : type.name; // Find the mark if it exists.

  var mark = start.node.marks.find(_ref => {
    var markType = _ref.type;
    return markType.name === typeName;
  });
  var startIndex = $pos.index();
  var startPos = $pos.start() + start.offset;
  var endIndex = startIndex + 1;
  var endPos = startPos + start.node.nodeSize; // If the mark wasn't found then no range can be calculated. Exit early.

  if (!mark) {
    if ($end && endPos < $end.pos) {
      return getMarkRange($pos.doc.resolve(endPos + 1), type, $end);
    }

    return;
  }

  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }

  while (endIndex < $pos.parent.childCount && mark.isInSet($pos.parent.child(endIndex).marks)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }

  var text = $pos.doc.textBetween(startPos, endPos, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from: startPos,
    to: endPos,
    text,
    mark
  };
}
/**
 * Get all the ranges which contain marks for the provided selection.
 */

function getMarkRanges(selection, type) {
  var markRanges = [];
  var $from = selection.$from,
      $to = selection.$to;
  var $pos = $from;

  while (true) {
    var range = getMarkRange($pos, type, $to);

    if (!range) {
      return markRanges;
    }

    markRanges.push(range);

    if (range.to < $to.pos) {
      $pos = $from.doc.resolve(range.to + 1);
      continue;
    }

    return markRanges;
  }
}
/**
 * Return true if the step provided an instance of any of the provided step
 * constructors.
 *
 * @param step - the step to check
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function isValidStep(step, StepTypes) {
  return StepTypes.length === 0 || StepTypes.some(Constructor => step instanceof Constructor);
}

/**
 * Get all the ranges of changes for the provided transaction.
 *
 * This can be used to gather specific parts of the document which require
 * decorations to be recalculated or where nodes should be updated.
 *
 * This is adapted from the answer
 * [here](https://discuss.prosemirror.net/t/find-new-node-instances-and-track-them/96/7)
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */
function getChangedRanges(tr) {
  var StepTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // The holder for the ranges value which will be returned from this function.
  var ranges = [];
  var rawRanges = [];

  var _iterator2 = _createForOfIteratorHelper(tr.steps),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var step = _step2.value;

      if (!isValidStep(step, StepTypes)) {
        continue;
      }

      var stepMap = step.getMap(); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore @see https://github.com/ProseMirror/prosemirror/issues/1075

      if (stepMap.ranges.length === 0 && isRangeStep(step)) {
        var from = step.from,
            to = step.to;

        if (from === undefined || to === undefined) {
          continue;
        }

        rawRanges.push({
          from,
          to
        });
      } else {
        step.getMap().forEach((from, to) => {
          rawRanges.push({
            from,
            to
          });
        });
      }
    } // Sort the ranges.

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var sortedRanges = coreHelpers.sort(rawRanges, (a, z) => a.from - z.from); // Merge sorted ranges into the new range.

  var _iterator3 = _createForOfIteratorHelper(sortedRanges),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          _from = _step3$value.from,
          _to = _step3$value.to;
      // The last item in the accumulated `ranges`.
      var lastRange = ranges[ranges.length - 1]; // True when range added has no overlap with the previous end value.

      var noOverlap = !lastRange || lastRange.to < _from;

      if (noOverlap) {
        // Add the new range when no overlap is found.
        var newFrom = tr.mapping.map(_from, -1);
        var newTo = tr.mapping.map(_to);
        ranges.push({
          from: newFrom,
          to: newTo,
          prevFrom: tr.mapping.invert().map(newFrom, -1),
          prevTo: tr.mapping.invert().map(newTo)
        });
      } else if (lastRange) {
        // Update the lastRange's end value.
        lastRange.to = Math.max(lastRange.from, _to);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return coreHelpers.uniqueBy(ranges, _ref2 => {
    var from = _ref2.from,
        to = _ref2.to,
        prevFrom = _ref2.prevFrom,
        prevTo = _ref2.prevTo;
    return "".concat(from, "_").concat(to, "_").concat(prevFrom, "_").concat(prevTo);
  });
}
/**
 * Get all the changed node ranges for a provided transaction.
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function getChangedNodeRanges(tr, StepTypes) {
  // The container of the ranges to be returned from this function.
  var nodeRanges = [];
  var ranges = getChangedRanges(tr, StepTypes);

  var _iterator4 = _createForOfIteratorHelper(ranges),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var range = _step4.value;

      try {
        var $from = tr.doc.resolve(range.from);
        var $to = tr.doc.resolve(range.to); // Find the node range for this provided range.

        var nodeRange = $from.blockRange($to); // Make sure a valid node is available.

        if (nodeRange) {
          nodeRanges.push(nodeRange);
        }
      } catch (_unused3) {// Changed ranged outside the document
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return nodeRanges;
}
/**
 * Retrieves the text content from a slice
 *
 * @remarks
 * A utility that's useful for pulling text content from a slice which is
 * usually created via `selection.content()`
 *
 * @param slice - the prosemirror slice
 */

function getTextContentFromSlice(slice) {
  var _slice$content$firstC, _slice$content$firstC2;

  return (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
}

/**
 * Takes an empty selection and expands it out to the nearest group not matching
 * the excluded characters.
 *
 * @remarks
 *
 * Can be used to find the nearest selected word. See {@link getSelectedWord}
 *
 * @param state - the editor state or a transaction
 * @param exclude - the regex pattern to exclude
 * @returns false if not a text selection or if no expansion available
 */
function getSelectedGroup(state$1, exclude) {
  if (!isTextSelection(state$1.selection)) {
    return;
  }

  var _state$selection = state$1.selection,
      from = _state$selection.from,
      to = _state$selection.to;

  var getChar = (start, end) => getTextContentFromSlice(state.TextSelection.create(state$1.doc, start, end).content());

  for (var char = getChar(from - 1, from); char && !exclude.test(char); from--, char = getChar(from - 1, from)) {// Step backwards until reaching first excluded character or empty text
    // content.
  }

  for (var _char = getChar(to, to + 1); _char && !exclude.test(_char); to++, _char = getChar(to, to + 1)) {// Step forwards until reaching the first excluded character or empty text
    // content
  }

  if (from === to) {
    return;
  }

  var text = state$1.doc.textBetween(from, to, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from,
    to,
    text
  };
}
/**
 * Retrieves the nearest space separated word from the current selection.
 *
 * @remarks
 *
 * This always expands outward so that given: `The tw<start>o words<end>` The
 * selection would become `The <start>two words<end>`
 *
 * In other words it expands until it meets an invalid character.
 *
 * @param state - the editor state or transaction.
 */

function getSelectedWord(state) {
  return getSelectedGroup(state, /\W/);
}
/**
 * Get matching string from a list or single value
 *
 * @remarks
 * Get attrs can be called with a direct match string or array of string
 * matches. This method should be used to retrieve the required string.
 *
 * The index of the matched array used defaults to 0 but can be updated via the
 * second parameter.
 *
 * @param match - the match(es)
 * @param index - the zero-index point from which to start
 */

function getMatchString(match) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var value = coreHelpers.isArray(match) ? match[index] : match; // Throw an error if value is not defined for the index.

  coreHelpers.assert(coreHelpers.isString(value), "No match string found for match ".concat(match));
  return value !== null && value !== void 0 ? value : '';
}
/**
 * Checks whether the cursor is at the end of the state.doc
 *
 * @param state - the editor state
 */

function atDocEnd(state) {
  return state.doc.nodeSize - state.selection.$to.pos - 2 === state.selection.$to.depth;
}
/**
 * Checks whether the cursor is at the beginning of the state.doc
 *
 * @param state - the editor state
 */

function atDocStart(state) {
  return state.selection.$from.pos === state.selection.$from.depth;
}
/**
 * Get the start position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function startPositionOfParent($pos) {
  return $pos.start($pos.depth);
}
/**
 * Get the end position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function endPositionOfParent($pos) {
  return $pos.end($pos.depth) + 1;
}
/**
 * Retrieve the current position of the cursor
 *
 * @param selection - the editor selection
 * @returns a resolved position only when the selection is a text selection
 */

function getCursor(selection) {
  return isTextSelection(selection) ? selection.$cursor : undefined;
}
/**
 * Checks whether a Prosemirror node is the top level `doc` node
 *
 * @param node - the prosemirror node
 * @param schema - the prosemirror schema to check against
 */

function isDocNode(node, schema) {
  if (!isProsemirrorNode(node)) {
    return false;
  }

  if (schema) {
    return node.type === schema.nodes.doc;
  }

  return node.type.name === 'doc';
}
/**
 * Checks whether the passed in JSON is a valid object node
 *
 * @param value - the value to check
 */

function isRemirrorJSON(value) {
  return coreHelpers.isObject(value) && value.type === 'doc' && Array.isArray(value.content);
}
/**
 * This type is the combination of all the registered string handlers for the
 * extension. This is used rather than the `StringHandlers` in order to enforce
 * the type signature of the handler method, which isn't possible with the
 * interface.
 */

/**
 * Return true when the provided value is an anchor / head selection property
 */
function isAnchorHeadObject(value) {
  return coreHelpers.isObject(value) && coreHelpers.isNumber(value.anchor) && coreHelpers.isNumber(value.head);
}
/**
 * Get the nearest valid text selection to the provided selection parameter.
 */

function getTextSelection(selection, doc) {
  var max = doc.nodeSize - 2;
  var min = 0;
  var pos;
  /** Ensure the selection is within the current document range */

  var clampToDocument = value => coreHelpers.clamp({
    min,
    max,
    value
  });

  if (isSelection(selection)) {
    return selection;
  }

  if (selection === 'all') {
    return new state.AllSelection(doc);
  }

  if (selection === 'start') {
    pos = min;
  } else if (selection === 'end') {
    pos = max;
  } else if (isResolvedPos(selection)) {
    pos = selection.pos;
  } else {
    pos = selection;
  }

  if (coreHelpers.isNumber(pos)) {
    pos = clampToDocument(pos);
    return state.TextSelection.near(doc.resolve(pos));
  }

  if (isAnchorHeadObject(pos)) {
    var _anchor = clampToDocument(pos.anchor);

    var _head = clampToDocument(pos.head);

    return state.TextSelection.create(doc, _anchor, _head);
  } // In this case assume that `from` is the fixed anchor and `to` is the movable
  // head.


  var anchor = clampToDocument(pos.from);
  var head = clampToDocument(pos.to);
  return state.TextSelection.create(doc, anchor, head);
}
/**
 * A function that converts a string into a `ProsemirrorNode`.
 */

// The maximum attempts to check invalid content before throwing an an error.
var MAX_ATTEMPTS = 3;
/**
 * Creates a document node from the passed in content and schema.
 *
 * @remirror
 *
 * This supports a primitive form of error handling. When an error occurs, the
 * `onError` handler will be called along with the error produced by the Schema
 * and it is up to you as a developer to decide how to transform the invalid
 * content into valid content.
 *
 * Please note that the `onError` is only called when the content is a JSON
 * object. It is not called for a `string`, the `ProsemirrorNode` or the
 * `EditorState`. The reason for this is that the `string` requires a `stringHandler`
 * which is defined by the developer and transforms the content. That is the
 * point that error's should be handled. The editor state and the
 * `ProsemirrorNode` are similar. They need to be created by the developer and
 * as a result, the errors should be handled at the point of creation rather
 * than when the document is being applied to the editor.
 */

function createDocumentNode(props) {
  var content = props.content,
      schema = props.schema,
      document = props.document,
      stringHandler = props.stringHandler,
      onError = props.onError,
      _props$attempts = props.attempts,
      attempts = _props$attempts === void 0 ? 0 : _props$attempts; // If there is an `onError` handler then check the attempts does not exceed
  // the maximum, otherwise only allow one attempt.

  var attemptsRemaining = onError && attempts <= MAX_ATTEMPTS || attempts === 0;
  !attemptsRemaining ? coreHelpers.invariant(false) : void 0;

  if (coreHelpers.isString(content)) {
    !stringHandler ? coreHelpers.invariant(false) : void 0;
    var options = {
      document,
      content,
      schema
    }; // With string content it is up to you the developer to ensure there are no
    // errors in the produced content.

    return stringHandler(options);
  } // If passing in an editor state, it is left to the developer to make sure the
  // state they created is valid.


  if (isEditorState(content)) {
    return content.doc;
  } // When passing the prosemirror no error checking is done. Before creating the
  // node you should manually ensure that it is valid.


  if (isProsemirrorNode(content)) {
    return content;
  } // At this point the only possible solution is that the content is a json
  // object so we try to convert the json to a valid object.


  try {
    // This will throw an error for invalid content.
    return schema.nodeFromJSON(content);
  } catch (error) {
    var details = getInvalidContent({
      schema,
      error,
      json: content
    });
    var transformedContent = onError === null || onError === void 0 ? void 0 : onError(details);
    !transformedContent ? coreHelpers.invariant(false) : void 0;
    return createDocumentNode(_objectSpread(_objectSpread({}, props), {}, {
      content: transformedContent,
      attempts: attempts + 1
    }));
  }
}
/**
 * Checks which environment should be used. Returns true when we are in the dom
 * environment.
 *
 * @param forceEnvironment - force a specific environment to override the
 * outcome
 */

function shouldUseDomEnvironment(forceEnvironment) {
  return forceEnvironment === 'dom' || environment.isBrowser && !forceEnvironment;
}
/**
 * Get the document implementation within a node environment. This is only
 * included in the build when using node.
 */

function getDocumentForNodeEnvironment() {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'jsdom'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
        JSDOM = _require.JSDOM;

    return new JSDOM('').window.document;
  } catch (_unused4) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      return Object(function webpackMissingModule() { var e = new Error("Cannot find module 'domino'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())();
    } catch (_unused5) {
      return __webpack_require__(103);
    }
  }
}
/**
 * Retrieves the document based on the environment we are currently in.
 *
 * @param forceEnvironment - force a specific environment
 */


function getDocument(forceEnvironment) {
  if (typeof document !== 'undefined') {
    return document;
  }

  return shouldUseDomEnvironment(forceEnvironment) ? document : getDocumentForNodeEnvironment();
}

/**
 * Convert a node into its DOM representative
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 */
function prosemirrorNodeToDom(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var fragment = isDocNode(node, node.type.schema) ? node.content : model.Fragment.from(node);
  return model.DOMSerializer.fromSchema(node.type.schema).serializeFragment(fragment, {
    document
  });
}

function elementFromString(html, document) {
  var _defaultView, _ref3;

  var parser = new ((_defaultView = (_ref3 = document !== null && document !== void 0 ? document : getDocument()) === null || _ref3 === void 0 ? void 0 : _ref3.defaultView) !== null && _defaultView !== void 0 ? _defaultView : window).DOMParser();
  return parser.parseFromString("<body>".concat(html, "</body>"), 'text/html').body;
}
/**
 * Convert the provided `node` to a html string.
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 *
 * ```ts
 * import { EditorState, prosemirrorNodeToHtml } from 'remirror';
 *
 * function convertStateToHtml(state: EditorState): string {
 *   return prosemirrorNodeToHtml(state.doc);
 * }
 * ```
 */


function prosemirrorNodeToHtml(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var element = document.createElement('div');
  element.append(prosemirrorNodeToDom(node, document));
  return element.innerHTML;
}
function htmlToProsemirrorNode(props) {
  var content = props.content,
      schema = props.schema;
      props.document;
      var _props$fragment = props.fragment,
      fragment = _props$fragment === void 0 ? false : _props$fragment,
      parseOptions = _objectWithoutProperties(props, _excluded$1);

  var element = elementFromString(content);
  var parser = model.DOMParser.fromSchema(schema);
  return fragment ? parser.parseSlice(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions)).content : parser.parse(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions));
}
var defaultParseOptions = {
  preserveWhitespace: false
};
/**
 * A wrapper around `state.doc.toJSON` which returns the state as a
 * `RemirrorJSON` object.
 */

function getRemirrorJSON(content) {
  return isProsemirrorNode(content) ? content.toJSON() : content.doc.toJSON();
}

/**
 * Check if two states are equal.
 */
function areStatesEqual(stateA, stateB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // The states are identical, so they're equal.
  if (stateA === stateB) {
    return true;
  } // If the content is different then, no, not equal.


  if (!stateA.doc.eq(stateB.doc)) {
    return false;
  } // If we care about selection and selection is not the same, then not equal.


  if (options.checkSelection && !stateA.selection.eq(stateB.selection)) {
    return false;
  } // If the schema are not compatible then no, not equal.


  if (!areSchemasCompatible(stateA.schema, stateB.schema)) {
    return false;
  }

  return true;
}
/**
 * Check that the nodes and marks present on `schemaA` are also present on
 * `schemaB`.
 */

function areSchemasCompatible(schemaA, schemaB) {
  if (schemaA === schemaB) {
    return true;
  }

  var marksA = coreHelpers.keys(schemaA.marks);
  var marksB = coreHelpers.keys(schemaB.marks);
  var nodesA = coreHelpers.keys(schemaA.nodes);
  var nodesB = coreHelpers.keys(schemaB.nodes);

  if (marksA.length !== marksB.length || nodesA.length !== nodesB.length) {
    return false;
  }

  var _iterator5 = _createForOfIteratorHelper(marksA),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var mark = _step5.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!marksB.includes(mark)) {
        return false;
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  var _iterator6 = _createForOfIteratorHelper(nodesA),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var node = _step6.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!nodesB.includes(node)) {
        return false;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return true;
}
/**
 * Return attributes for a node excluding those that were provided as extra
 * attributes.
 *
 * @param attrs - The source attributes
 * @param extra - The extra attribute schema for this node
 */

function omitExtraAttributes(attrs, extra) {
  var extraAttributeNames = coreHelpers.keys(extra.defaults());
  return coreHelpers.omit(_objectSpread({}, attrs), extraAttributeNames);
}
/**
 * Take the `style` string attribute and combine it with the provided style
 * object.
 */

function joinStyles(styleObject, initialStyles) {
  var start = '';

  if (initialStyles) {
    start = "".concat(initialStyles.trim());
  }

  var end = cssInJsUtils.cssifyObject(styleObject);

  if (!end) {
    return start;
  }

  var separator = start.endsWith(';') ? ' ' : ' ';
  return "".concat(start).concat(separator).concat(end);
}

/**
 * Find the different ranges of text between a provided range with support for
 * traversing multiple nodes.
 */
function textBetween(props) {
  var from = props.from,
      to = props.to,
      doc = props.doc;
  var positions = [];
  doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isText || !node.text) {
      return;
    }

    var offset = Math.max(from, pos) - pos;
    positions.push({
      pos: pos + offset,
      text: node.text.slice(offset, to - pos)
    });
  });
  return positions;
}
/**
 * Get the full range of the selectable content in the ProseMirror `doc`.
 */

function getDocRange(doc) {
  var _AllSelection = new state.AllSelection(doc),
      from = _AllSelection.from,
      to = _AllSelection.to;

  return {
    from,
    to
  };
}
/**
 * A description of an invalid content block (representing a node or a mark).
 */

var transformers = {
  /**
   * Remove every invalid block from the editor. This is a destructive action
   * and should only be applied if you're sure it's the best strategy.
   *
   * @param json - the content as a json object.
   * @param invalidContent - the list of invalid items as passed to the error
   * handler.
   */
  remove(json, invalidContent) {
    var newJSON = json;

    var _iterator7 = _createForOfIteratorHelper(invalidContent),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var block = _step7.value;

        if (block.invalidParentNode) {
          continue;
        }

        newJSON = coreHelpers.unset(block.path, newJSON);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return newJSON;
  }

};

/**
 * Get the invalid parameter which is passed to the `onError` handler.
 */
function getInvalidContent(_ref4) {
  var json = _ref4.json,
      schema = _ref4.schema,
      extra = _objectWithoutProperties(_ref4, _excluded2$1);

  var validMarks = new Set(coreHelpers.keys(schema.marks));
  var validNodes = new Set(coreHelpers.keys(schema.nodes));
  var invalidContent = checkForInvalidContent({
    json,
    path: [],
    validNodes,
    validMarks
  });
  return _objectSpread({
    json,
    invalidContent,
    transformers
  }, extra);
}

/**
 * Get the invalid content from the `RemirrorJSON`.
 */
function checkForInvalidContent(props) {
  var json = props.json,
      validMarks = props.validMarks,
      validNodes = props.validNodes,
      _props$path = props.path,
      path = _props$path === void 0 ? [] : _props$path;
  var valid = {
    validMarks,
    validNodes
  };
  var invalidNodes = [];
  var type = json.type,
      marks = json.marks,
      content = json.content;
  var _props$invalidParentM = props.invalidParentMark,
      invalidParentMark = _props$invalidParentM === void 0 ? false : _props$invalidParentM,
      _props$invalidParentN = props.invalidParentNode,
      invalidParentNode = _props$invalidParentN === void 0 ? false : _props$invalidParentN;

  if (marks) {
    var invalidMarks = [];

    var _iterator8 = _createForOfIteratorHelper(marks.entries()),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _step8$value = _slicedToArray(_step8.value, 2),
            index = _step8$value[0],
            mark = _step8$value[1];

        var name = coreHelpers.isString(mark) ? mark : mark.type;

        if (validMarks.has(name)) {
          continue;
        }

        invalidMarks.unshift({
          name,
          path: [...path, 'marks', "".concat(index)],
          type: 'mark',
          invalidParentMark,
          invalidParentNode
        });
        invalidParentMark = true;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    invalidNodes.push(...invalidMarks);
  }

  if (!validNodes.has(type)) {
    invalidNodes.push({
      name: type,
      type: 'node',
      path,
      invalidParentMark,
      invalidParentNode
    });
    invalidParentNode = true;
  }

  if (content) {
    var invalidContent = [];

    var _iterator9 = _createForOfIteratorHelper(content.entries()),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var _step9$value = _slicedToArray(_step9.value, 2),
            _index = _step9$value[0],
            value = _step9$value[1];

        invalidContent.unshift(...checkForInvalidContent(_objectSpread(_objectSpread({}, valid), {}, {
          json: value,
          path: [...path, 'content', "".concat(_index)],
          invalidParentMark,
          invalidParentNode
        })));
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    invalidNodes.unshift(...invalidContent);
  }

  return invalidNodes;
}
/**
 * Checks that the selection is an empty text selection at the end of its parent
 * node.
 */


function isEndOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset >= selection.$cursor.parent.content.size);
}
/**
 * Checks that the selection is an empty text selection at the start of its
 * parent node.
 */

function isStartOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset <= 0);
}
/**
 * Returns true when the selection is a text selection at the start of the
 * document.
 */

function isStartOfDoc(selection) {
  var selectionAtStart = state.Selection.atStart(selection.$anchor.doc);
  return !!(isStartOfTextBlock(selection) && selectionAtStart.anchor === selection.anchor);
}

/**
 * Update the selection with the provided MarkType.
 *
 * @param props - see [[`UpdateMarkProps`]] for options
 */
function updateMark(props) {
  return _ref => {
    var dispatch = _ref.dispatch,
        tr = _ref.tr;
    var type = props.type,
        _props$attrs = props.attrs,
        attrs = _props$attrs === void 0 ? coreHelpers.object() : _props$attrs,
        appendText = props.appendText,
        range = props.range;
    var selection = range ? state.TextSelection.create(tr.doc, range.from, range.to) : tr.selection;
    var $from = selection.$from,
        from = selection.from,
        to = selection.to;
    var applicable = $from.depth === 0 ? tr.doc.type.allowsMarkType(type) : false;
    tr.doc.nodesBetween(from, to, node => {
      if (applicable) {
        return false;
      }

      if (node.inlineContent && node.type.allowsMarkType(type)) {
        applicable = true;
        return;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, type.create(attrs)) && appendText ? tr.insertText(appendText) : tr);
    return true;
  };
}
/**
 * Lift the selected block, or the closest ancestor block of the selection that
 * can be lifted, out of its parent node.
 *
 * Adapted from
 * https://github.com/ProseMirror/prosemirror-commands/blob/3126d5c625953ba590c5d3a0db7f1009f46f1571/src/commands.js#L212-L221
 */

function lift(_ref2) {
  var tr = _ref2.tr,
      dispatch = _ref2.dispatch;
  var _tr$selection = tr.selection,
      $from = _tr$selection.$from,
      $to = _tr$selection.$to;
  var range = $from.blockRange($to);
  var target = range && transform.liftTarget(range);

  if (!coreHelpers.isNumber(target) || !range) {
    return false;
  }

  dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.lift(range, target).scrollIntoView());
  return true;
}
/**
 * Wrap the selection or the provided text in a node of the given type with the
 * given attributes.
 */

function wrapIn(type) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var nodeType = coreHelpers.isString(type) ? coreHelpers.assertGet(state.schema.nodes, type) : type;

    var _getTextSelection = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection.from,
        to = _getTextSelection.to;

    var $from = tr.doc.resolve(from);
    var $to = tr.doc.resolve(to);
    var blockRange = $from.blockRange($to);
    var wrapping = blockRange && transform.findWrapping(blockRange, nodeType, attrs);

    if (!wrapping || !blockRange) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.wrap(blockRange, wrapping).scrollIntoView());
    return true;
  };
}
/**
 * Toggle between wrapping an inactive node with the provided node type, and
 * lifting it up into it's parent.
 *
 * @param nodeType - the node type to toggle
 * @param attrs - the attrs to use for the node
 */

function toggleWrap(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return props => {
    var tr = props.tr,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });

    if (activeNode) {
      return lift(props);
    }

    return wrapIn(nodeType, attrs, selection)(props);
  };
}
/**
 * Returns a command that tries to set the selected textblocks to the
 * given node type with the given attributes.
 *
 * @param nodeType - the name of the node or the [[`NodeType`]].
 */

function setBlockType(nodeType, attrs, selection) {
  var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;

    var _getTextSelection2 = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection2.from,
        to = _getTextSelection2.to;

    var applicable = false;
    var activeAttrs;
    tr.doc.nodesBetween(from, to, (node, pos) => {
      if (applicable) {
        // Exit early and don't descend.
        return false;
      }

      if (!node.isTextblock || node.hasMarkup(type, attrs)) {
        return;
      }

      if (node.type === type) {
        applicable = true;
        activeAttrs = node.attrs;
        return;
      }

      var $pos = tr.doc.resolve(pos);
      var index = $pos.index();
      applicable = $pos.parent.canReplaceWith(index, index + 1, type);

      if (applicable) {
        activeAttrs = $pos.parent.attrs;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setBlockType(from, to, type, _objectSpread(_objectSpread({}, preserveAttrs ? activeAttrs : {}), attrs)).scrollIntoView());
    return true;
  };
}

/**
 * Toggle a block between the provided type and toggleType.
 *
 * @param toggleProps - see [[`ToggleBlockItemProps`]] for available options
 */
function toggleBlockItem(toggleProps) {
  return props => {
    var _toggleProps$toggleTy;

    var tr = props.tr,
        state = props.state;
    var type = toggleProps.type,
        attrs = toggleProps.attrs,
        _toggleProps$preserve = toggleProps.preserveAttrs,
        preserveAttrs = _toggleProps$preserve === void 0 ? true : _toggleProps$preserve;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });
    var toggleType = (_toggleProps$toggleTy = toggleProps.toggleType) !== null && _toggleProps$toggleTy !== void 0 ? _toggleProps$toggleTy : getDefaultBlockNode(state.schema);

    if (activeNode) {
      return setBlockType(toggleType, _objectSpread(_objectSpread({}, preserveAttrs ? activeNode.node.attrs : {}), attrs))(props);
    }

    var toggleNode = getActiveNode({
      state: tr,
      type: toggleType,
      attrs
    });
    return setBlockType(type, _objectSpread(_objectSpread({}, preserveAttrs ? toggleNode === null || toggleNode === void 0 ? void 0 : toggleNode.node.attrs : {}), attrs))(props);
  };
}

/**
 * Taken from https://stackoverflow.com/a/4900484
 *
 * Check that the browser is chrome. Supports passing a minimum version to check
 * that it is a greater than or equal to this version.
 */
function isChrome() {
  var minVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var parsedAgent = navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./);
  return parsedAgent ? Number.parseInt(coreHelpers.assertGet(parsedAgent, 2), 10) >= minVersion : false;
}
/**
 * Checks the selection for the current state and updates the active transaction
 * to a selection that is consistent with the initial selection.
 *
 * @param state - the editor state before any updates
 * @param tr - the transaction which has been updated and may have impacted the
 * selection.
 */

function preserveSelection(selection, tr) {
  // Get the previous movable part of the cursor selection.
  var head = selection.head,
      empty = selection.empty,
      anchor = selection.anchor; // Map this movable cursor selection through each of the steps that have happened in
  // the transaction.

  var _iterator = _createForOfIteratorHelper(tr.steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      var map = step.getMap();
      head = map.map(head);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (empty) {
    // Update the transaction with the new text selection.
    tr.setSelection(state.TextSelection.create(tr.doc, head));
  } else {
    tr.setSelection(state.TextSelection.create(tr.doc, anchor, head));
  }
}
/**
 * Replaces text with an optional appended string at the end.
 *
 * @param props - see [[`ReplaceTextProps`]]
 */

function replaceText(props) {
  var _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      _props$appendText = props.appendText,
      appendText = _props$appendText === void 0 ? '' : _props$appendText,
      _props$content = props.content,
      content = _props$content === void 0 ? '' : _props$content,
      _props$keepSelection = props.keepSelection,
      keepSelection = _props$keepSelection === void 0 ? false : _props$keepSelection,
      range = props.range;
  return _ref3 => {
    var _ref4, _props$selection, _schema$nodes$props$t;

    var state = _ref3.state,
        tr = _ref3.tr,
        dispatch = _ref3.dispatch;
    var schema = state.schema;
    var selection = getTextSelection((_ref4 = (_props$selection = props.selection) !== null && _props$selection !== void 0 ? _props$selection : range) !== null && _ref4 !== void 0 ? _ref4 : tr.selection, tr.doc);
    var index = selection.$from.index();
    var from = selection.from,
        to = selection.to,
        $from = selection.$from;
    var type = coreHelpers.isString(props.type) ? (_schema$nodes$props$t = schema.nodes[props.type]) !== null && _schema$nodes$props$t !== void 0 ? _schema$nodes$props$t : schema.marks[props.type] : props.type;
    !(coreHelpers.isString(props.type) ? type : true) ? coreHelpers.invariant(false) : void 0;

    if (isNodeType(type)) {
      if (!$from.parent.canReplaceWith(index, index, type)) {
        return false;
      }

      tr.replaceWith(from, to, type.create(attrs, content ? schema.text(content) : undefined));
    } else {
      !content ? coreHelpers.invariant(false) : void 0;
      tr.replaceWith(from, to, schema.text(content, isMarkType(type) ? [type.create(attrs)] : undefined));
    } // Only append the text if text is provided (ignore the empty string).


    if (appendText) {
      tr.insertText(appendText);
    }

    if (keepSelection) {
      preserveSelection(state.selection, tr);
    }

    if (dispatch) {
      // A workaround for a chrome bug
      // https://github.com/ProseMirror/prosemirror/issues/710#issuecomment-338047650
      if (isChrome(60)) {
        var _document$getSelectio;

        (_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.empty();
      }

      dispatch(tr);
    }

    return true;
  };
}
/**
 * Retrieve the first mark at a given resolved position `$pos` or range
 *
 * @remarks
 *
 * If multiple marks are present, the returned mark will be the mark with highest priority.
 *
 * @param $pos - the resolved ProseMirror position
 * @param $end - the end position to search until. When this is provided
 * it will search for a mark until the `$end`. The first mark within
 * the range will be returned.
 */

function getFirstMark($pos, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var _start$node = start.node,
      marks = _start$node.marks,
      nodeSize = _start$node.nodeSize;

  if (marks[0]) {
    return marks[0].type;
  }

  var startPos = $pos.start() + start.offset;
  var endPos = startPos + nodeSize;
  return getFirstMark($pos.doc.resolve(endPos + 1));
}

/**
 * Removes a mark from the current selection or provided range.
 *
 * @param props - see [[`RemoveMarkProps`]] for options
 */
function removeMark(props) {
  return _ref5 => {
    var _ref6, _props$selection2;

    var dispatch = _ref5.dispatch,
        tr = _ref5.tr,
        state = _ref5.state;
    var type = props.type,
        _props$expand = props.expand,
        expand = _props$expand === void 0 ? true : _props$expand,
        range = props.range;
    var selection = getTextSelection((_ref6 = (_props$selection2 = props.selection) !== null && _props$selection2 !== void 0 ? _props$selection2 : range) !== null && _ref6 !== void 0 ? _ref6 : tr.selection, tr.doc);
    var from = selection.from,
        to = selection.to,
        $from = selection.$from,
        $to = selection.$to;
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;

    if (markType !== null) {
      !markType ? coreHelpers.invariant(false) : void 0;
    } // If no mark type was supplied, get the first mark present on this node to determine a mark range


    var rangeMark = markType !== null && markType !== void 0 ? markType : getFirstMark($from);

    if (!rangeMark) {
      return false;
    }

    var markRange = getMarkRange($from, rangeMark, $to);

    if (expand && markRange) {
      // Expand the from position to the mark range (if it is smaller) - keep bound within doc
      from = Math.max(0, Math.min(from, markRange.from)); // Expand the to position to the mark range (if it is larger) - keep bound within doc

      to = Math.min(Math.max(to, markRange.to), tr.doc.nodeSize - 2);
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, coreHelpers.isNumber(to) ? to : from, isMarkType(markType) ? markType : undefined));
    return true;
  };
}

/**
 * Return true when the provided key is the the Command (⌘) key. Takes into
 * account the platform.
 */

function isCommandKey(key) {
  var allowedKeys = ['command', 'cmd', 'meta'];

  if (environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}
/**
 * Return true when the provided key is the the Control (⌃) key. Takes into
 * account the platform.
 */


function isControlKey(key) {
  var allowedKeys = ['control', 'ctrl'];

  if (!environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}

/**
 * Convert a keyboard shortcut into symbols which and keys.
 */
function getShortcutSymbols(shortcut) {
  var symbols = [];

  var _iterator = _createForOfIteratorHelper(shortcut.split('-')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      key = key.toLowerCase();

      if (isCommandKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '⌘',
          key: 'command',
          i18n: messages.CoreUtilsMessages.COMMAND_KEY
        });
        continue;
      }

      if (isControlKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '⌃',
          key: 'control',
          i18n: messages.CoreUtilsMessages.CONTROL_KEY
        });
        continue;
      }

      switch (key) {
        case 'shift':
          symbols.push({
            type: 'modifier',
            symbol: '⇧',
            key,
            i18n: messages.CoreUtilsMessages.SHIFT_KEY
          });
          continue;

        case 'alt':
          symbols.push({
            type: 'modifier',
            symbol: '⌥',
            key,
            i18n: messages.CoreUtilsMessages.ALT_KEY
          });
          continue;

        case '\n':
        case '\r':
        case 'enter':
          symbols.push({
            type: 'named',
            symbol: '↵',
            key,
            i18n: messages.CoreUtilsMessages.ENTER_KEY
          });
          continue;

        case 'backspace':
          symbols.push({
            type: 'named',
            symbol: '⌫',
            key,
            i18n: messages.CoreUtilsMessages.BACKSPACE_KEY
          });
          continue;

        case 'delete':
          symbols.push({
            type: 'named',
            symbol: '⌦',
            key,
            i18n: messages.CoreUtilsMessages.DELETE_KEY
          });
          continue;

        case 'escape':
          symbols.push({
            type: 'named',
            symbol: '␛',
            key,
            i18n: messages.CoreUtilsMessages.ESCAPE_KEY
          });
          continue;

        case 'tab':
          symbols.push({
            type: 'named',
            symbol: '⇥',
            key,
            i18n: messages.CoreUtilsMessages.TAB_KEY
          });
          continue;

        case 'capslock':
          symbols.push({
            type: 'named',
            symbol: '⇪',
            key,
            i18n: messages.CoreUtilsMessages.CAPS_LOCK_KEY
          });
          continue;

        case 'space':
          symbols.push({
            type: 'named',
            symbol: '␣',
            key,
            i18n: messages.CoreUtilsMessages.SPACE_KEY
          });
          continue;

        case 'pageup':
          symbols.push({
            type: 'named',
            symbol: '⤒',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_UP_KEY
          });
          continue;

        case 'pagedown':
          symbols.push({
            type: 'named',
            symbol: '⤓',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_DOWN_KEY
          });
          continue;

        case 'home':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.HOME_KEY
          });
          continue;

        case 'end':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.END_KEY
          });
          continue;

        case 'arrowleft':
          symbols.push({
            type: 'named',
            symbol: '←',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_LEFT_KEY
          });
          continue;

        case 'arrowright':
          symbols.push({
            type: 'named',
            symbol: '→',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_RIGHT_KEY
          });
          continue;

        case 'arrowup':
          symbols.push({
            type: 'named',
            symbol: '→',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_UP_KEY
          });
          continue;

        case 'arrowdown':
          symbols.push({
            type: 'named',
            symbol: '↓',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_DOWN_KEY
          });
          continue;

        default:
          symbols.push({
            type: 'char',
            key
          });
          continue;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return symbols;
}

var _excluded = ["attrs"],
    _excluded2 = ["type"],
    _excluded3 = ["type"];

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findChildren({
 *   node: state.doc,
 *   predicate: child => child.isText,
 *   descend: false
 * });
 * ```
 */
function findChildren(props) {
  var node = props.node,
      predicate = props.predicate,
      _props$descend = props.descend,
      descend = _props$descend === void 0 ? true : _props$descend,
      action = props.action; // Ensure that the node provided is a `ProsemirrorNode`.

  !isProsemirrorNode(node) ? coreHelpers.invariant(false) : void 0; // Ensure that the predicate is a function.

  !coreHelpers.isFunction(predicate) ? coreHelpers.invariant(false) : void 0; // This is used to keep track of all the node positions.

  var result = []; // Start descending into the provided node. This can be an expensive operation
  // if the document is very large or deeply nested.

  node.descendants((child, pos) => {
    var nodeWithPosition = {
      node: child,
      pos
    }; // True when this call matches the required condition - returns `true`.

    var isMatch = predicate(nodeWithPosition);

    if (!isMatch) {
      // Move onto the next node or descendant depending on the value of
      // `descend`.
      return descend;
    } // Store the result and run the provided action if it exists.


    result.push(nodeWithPosition);
    action === null || action === void 0 ? void 0 : action(nodeWithPosition);
    return descend;
  });
  return result;
}
/**
 * A utility for creating methods that find a node by a specific condition.
 */

function findNodeByPredicate(_ref) {
  var predicate = _ref.predicate;
  return props => findChildren(_objectSpread(_objectSpread({}, props), {}, {
    predicate
  }));
}
/**
 * Returns text nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findTextNodes({ node });
 * ```
 */


var findTextNodes = findNodeByPredicate({
  predicate: child => child.node.isText
});
/**
 * Returns inline nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const inlineNodes = findInlineNodes(node);
 * ```
 */

var findInlineNodes = findNodeByPredicate({
  predicate: child => child.node.isInline
});
/**
 * Returns block descendants of a given `node`.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const blockNodes = findBlockNodes(node);
 * ```
 */

var findBlockNodes = findNodeByPredicate({
  predicate: child => child.node.isBlock
});

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * The following will match any node with an `id` of any value (as long as the
 * attribute exists) and a `colspan` of `2`.
 *
 * ```ts
 * const mergedCells = findChildrenByAttribute({
 *   node: table,
 *   attrs: { colspan: 2, id: (_, exists) => exists }
 * });
 * ```
 */
function findChildrenByAttribute(props) {
  var attrs = props.attrs,
      rest = _objectWithoutProperties(props, _excluded);
  /**
   * The predicate function which loops through the provided attributes check if
   * they are valid.
   */


  function predicate(nodeWithPos) {
    var attributeKeys = new Set(coreHelpers.keys(nodeWithPos.node.attrs));

    var _iterator = _createForOfIteratorHelper(coreHelpers.entries(attrs)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            attr = _step$value[0],
            expectedValue = _step$value[1];

        var value = nodeWithPos.node.attrs[attr];

        if ( // The user has passed in a predicate checking function.
        coreHelpers.isFunction(expectedValue)) {
          var exists = attributeKeys.has(attr);

          if ( // Check if the predicate checker returns false, in which case we can
          // exit early.
          !expectedValue({
            value,
            exists
          })) {
            return false;
          }

          continue;
        }

        if ( // If the value doesn't match the expected value, exit early.
        value !== expectedValue) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes of a given
 * nodeType.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const cells = findChildrenByNode({ node: state.doc, type: state.schema.nodes.tableCell });
 * ```
 */
function findChildrenByNode(props) {
  var type = props.type,
      rest = _objectWithoutProperties(props, _excluded2);

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => child.node.type === type
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes that have
 * a mark of a given markType.
 *
 * @remarks
 *
 * It doesn't descend into a `node` when descend argument is `false` (defaults
 * to `true`).
 *
 * ```ts
 * const nodes = findChildrenByMark({ node: state.doc, type: schema.marks.strong });
 * ```
 */
function findChildrenByMark(paramter) {
  var type = paramter.type,
      rest = _objectWithoutProperties(paramter, _excluded3);

  var markType;
  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => {
      if (!markType) {
        markType = coreHelpers.isString(type) ? child.node.type.schema.marks[type] : type;
        !markType ? coreHelpers.invariant(false) : void 0;
      }

      return !!markType.isInSet(child.node.marks);
    }
  }));
}

/**
 * Returns `true` if a given node contains nodes of a given `nodeType`.
 *
 * @remarks
 *
 * ```ts
 * if (containsNodesOfType({ node: state.doc, type: schema.nodes.listItem })) {
 *   log('contained')
 * }
 * ```
 */
function containsNodesOfType(props) {
  var node = props.node,
      type = props.type;
  return findChildrenByNode({
    node,
    type
  }).length > 0;
}

/**
 * Get all the changed nodes from the provided transaction.
 *
 * The following example will give us all the text nodes in the provided
 * transaction.
 *
 * ```ts
 * import { getChangedNodes } from 'remirror/core';
 *
 * const changedTextNodes = getChangeNodes(tr, { descend: true, predicate: (node) => node.isText });
 * ```
 */
function getChangedNodes(tr) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$descend = options.descend,
      descend = _options$descend === void 0 ? false : _options$descend,
      predicate = options.predicate,
      StepTypes = options.StepTypes;
  var nodeRange = getChangedNodeRanges(tr, StepTypes); // The container for the nodes which have been added..

  var nodes = [];

  var _iterator2 = _createForOfIteratorHelper(nodeRange),
      _step2;

  try {
    var _loop = function _loop() {
      var range = _step2.value;
      var start = range.start,
          end = range.end; // Find all the nodes between the provided node range.

      tr.doc.nodesBetween(start, end, (node, pos) => {
        var _predicate;

        // Check wether this is a node that should be added.
        var shouldAdd = (_predicate = predicate === null || predicate === void 0 ? void 0 : predicate(node, pos, range)) !== null && _predicate !== void 0 ? _predicate : true;

        if (shouldAdd) {
          nodes.push({
            node,
            pos
          });
        }

        return descend;
      });
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return nodes;
}

/**
 * Creates an input rule based on the provided regex for the provided mark type.
 */
function markInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      _props$ignoreWhitespa = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa === void 0 ? false : _props$ignoreWhitespa,
      beforeDispatch = props.beforeDispatch,
      updateCaptured = props.updateCaptured,
      shouldSkip = props.shouldSkip,
      invalidMarks = props.invalidMarks;
  var markType;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var tr = state.tr,
        schema = state.schema;

    if (!markType) {
      markType = coreHelpers.isString(type) ? schema.marks[type] : type;
      !markType ? coreHelpers.invariant(false) : void 0;
    }

    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var markEnd = end;
    var initialStoredMarks = [];

    if (captureGroup) {
      var _tr$storedMarks;

      var startSpaces = fullMatch.search(/\S/);
      var textStart = start + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      initialStoredMarks = (_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : [];

      if (textEnd < end) {
        tr.delete(textEnd, end);
      }

      if (textStart > start) {
        tr.delete(start + startSpaces, textStart);
      }

      markEnd = start + startSpaces + captureGroup.length;
    }

    tr.addMark(start, markEnd, markType.create(attributes)); // Make sure not to reactivate any marks which had previously been
    // deactivated. By keeping track of the initial stored marks we are able to
    // discard any unintended consequences of deleting text and adding it again.

    tr.setStoredMarks(initialStoredMarks); // Allow the caller of this method to update the transaction before it is
    // returned and dispatched by ProseMirror.

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}
/**
 * Creates a node input rule based on the provided regex for the provided node
 * type.
 *
 * Input rules transform content as the user types based on whether a match is
 * found with a sequence of characters.
 */

function nodeInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa2 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa2 === void 0 ? false : _props$ignoreWhitespa2,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var tr = state.tr,
        schema = state.schema;
    var nodeType = coreHelpers.isString(type) ? schema.nodes[type] : type;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    !nodeType ? coreHelpers.invariant(false) : void 0;
    var content = nodeType.createAndFill(attributes);

    if (content) {
      var _captureGroup;

      tr.replaceRangeWith(nodeType.isBlock ? tr.doc.resolve(start).before() : start, end, content);
      beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
        tr,
        match: [fullMatch, (_captureGroup = captureGroup) !== null && _captureGroup !== void 0 ? _captureGroup : ''],
        start,
        end
      });
    }

    return tr;
  });
  return rule;
}
/**
 * Creates a plain rule based on the provided regex. You can see this being used
 * in the `@remirror/extension-emoji` when it is setup to use plain text.
 */

function plainInputRule(props) {
  var regexp = props.regexp,
      transformMatch = props.transformMatch,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa3 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa3 === void 0 ? false : _props$ignoreWhitespa3,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var value = transformMatch(match);

    if (coreHelpers.isNullOrUndefined(value)) {
      return null;
    }

    var tr = state.tr,
        schema = state.schema;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;

    if (value === '') {
      tr.delete(start, end);
    } else {
      tr.replaceWith(start, end, schema.text(value));
    }

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}

/**
 * This is a monster of a function.
 *
 * TODO make it make sense.
 */
function gatherDetails(_ref) {
  var _updateCaptured, _details$captureGroup, _details$fullMatch, _details$start, _details$end, _captureGroup2, _rule$shouldSkip;

  var captureGroup = _ref.captureGroup,
      fullMatch = _ref.fullMatch,
      end = _ref.end,
      start = _ref.start,
      rule = _ref.rule,
      ignoreWhitespace = _ref.ignoreWhitespace,
      shouldSkip = _ref.shouldSkip,
      updateCaptured = _ref.updateCaptured,
      state = _ref.state,
      invalidMarks = _ref.invalidMarks;

  if (fullMatch == null) {
    return null;
  } // Update the internal values with the user provided method.


  var details = (_updateCaptured = updateCaptured === null || updateCaptured === void 0 ? void 0 : updateCaptured({
    captureGroup,
    fullMatch,
    start,
    end
  })) !== null && _updateCaptured !== void 0 ? _updateCaptured : {}; // Store the updated values or the original.

  captureGroup = (_details$captureGroup = details.captureGroup) !== null && _details$captureGroup !== void 0 ? _details$captureGroup : captureGroup;
  fullMatch = (_details$fullMatch = details.fullMatch) !== null && _details$fullMatch !== void 0 ? _details$fullMatch : fullMatch;
  start = (_details$start = details.start) !== null && _details$start !== void 0 ? _details$start : start;
  end = (_details$end = details.end) !== null && _details$end !== void 0 ? _details$end : end;
  var $from = state.doc.resolve(start);
  var $to = state.doc.resolve(end);

  if ( // Skip when the range contains an excluded mark.
  invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, invalidMarks) || rule.invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, rule.invalidMarks) || // Skip pure whitespace updates
  ignoreWhitespace && ((_captureGroup2 = captureGroup) === null || _captureGroup2 === void 0 ? void 0 : _captureGroup2.trim()) === '' || // Skip when configured to do
  shouldSkip !== null && shouldSkip !== void 0 && shouldSkip({
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  }) || (_rule$shouldSkip = rule.shouldSkip) !== null && _rule$shouldSkip !== void 0 && _rule$shouldSkip.call(rule, {
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  })) {
    return null;
  }

  return {
    captureGroup,
    end,
    fullMatch,
    start
  };
}

Object.defineProperty(exports, "chainCommands", ({
  enumerable: true,
  get: function () { return pm.chainCommands; }
}));
Object.defineProperty(exports, "chainableEditorState", ({
  enumerable: true,
  get: function () { return pm.chainableEditorState; }
}));
Object.defineProperty(exports, "convertCommand", ({
  enumerable: true,
  get: function () { return pm.convertCommand; }
}));
Object.defineProperty(exports, "nonChainable", ({
  enumerable: true,
  get: function () { return pm.nonChainable; }
}));
exports.DOM_SIZE_UNITS = DOM_SIZE_UNITS;
exports.applyClonedTransaction = applyClonedTransaction;
exports.areSchemasCompatible = areSchemasCompatible;
exports.areStatesEqual = areStatesEqual;
exports.atDocEnd = atDocEnd;
exports.atDocStart = atDocStart;
exports.canInsertNode = canInsertNode;
exports.chainKeyBindingCommands = chainKeyBindingCommands;
exports.cloneTransaction = cloneTransaction;
exports.composeTransactionSteps = composeTransactionSteps;
exports.containsAttributes = containsAttributes;
exports.containsNodesOfType = containsNodesOfType;
exports.convertPixelsToDomUnit = convertPixelsToDomUnit;
exports.createDocumentNode = createDocumentNode;
exports.endPositionOfParent = endPositionOfParent;
exports.environment = environment;
exports.extractPixelSize = extractPixelSize;
exports.findBlockNodes = findBlockNodes;
exports.findChildren = findChildren;
exports.findChildrenByAttribute = findChildrenByAttribute;
exports.findChildrenByMark = findChildrenByMark;
exports.findChildrenByNode = findChildrenByNode;
exports.findElementAtPosition = findElementAtPosition;
exports.findInlineNodes = findInlineNodes;
exports.findNodeAtPosition = findNodeAtPosition;
exports.findNodeAtSelection = findNodeAtSelection;
exports.findParentNode = findParentNode;
exports.findParentNodeOfType = findParentNodeOfType;
exports.findPositionOfNodeAfter = findPositionOfNodeAfter;
exports.findPositionOfNodeBefore = findPositionOfNodeBefore;
exports.findSelectedNodeOfType = findSelectedNodeOfType;
exports.findTextNodes = findTextNodes;
exports.getActiveNode = getActiveNode;
exports.getChangedNodeRanges = getChangedNodeRanges;
exports.getChangedNodes = getChangedNodes;
exports.getChangedRanges = getChangedRanges;
exports.getCursor = getCursor;
exports.getDefaultBlockNode = getDefaultBlockNode;
exports.getDefaultDocNode = getDefaultDocNode;
exports.getDocRange = getDocRange;
exports.getDocument = getDocument;
exports.getFontSize = getFontSize;
exports.getInvalidContent = getInvalidContent;
exports.getMarkAttributes = getMarkAttributes;
exports.getMarkRange = getMarkRange;
exports.getMarkRanges = getMarkRanges;
exports.getMarkType = getMarkType;
exports.getMatchString = getMatchString;
exports.getNodeType = getNodeType;
exports.getRemirrorJSON = getRemirrorJSON;
exports.getSelectedGroup = getSelectedGroup;
exports.getSelectedWord = getSelectedWord;
exports.getShortcutSymbols = getShortcutSymbols;
exports.getStyle = getStyle;
exports.getTextContentFromSlice = getTextContentFromSlice;
exports.getTextSelection = getTextSelection;
exports.hasTransactionChanged = hasTransactionChanged;
exports.htmlToProsemirrorNode = htmlToProsemirrorNode;
exports.isAllSelection = isAllSelection;
exports.isChrome = isChrome;
exports.isDefaultBlockNode = isDefaultBlockNode;
exports.isDefaultDocNode = isDefaultDocNode;
exports.isDocNode = isDocNode;
exports.isDocNodeEmpty = isDocNodeEmpty;
exports.isDomNode = isDomNode;
exports.isEditorSchema = isEditorSchema;
exports.isEditorState = isEditorState;
exports.isElementDomNode = isElementDomNode;
exports.isEmptyBlockNode = isEmptyBlockNode;
exports.isEndOfTextBlock = isEndOfTextBlock;
exports.isIdentifierOfType = isIdentifierOfType;
exports.isMarkActive = isMarkActive;
exports.isMarkType = isMarkType;
exports.isNodeActive = isNodeActive;
exports.isNodeOfType = isNodeOfType;
exports.isNodeSelection = isNodeSelection;
exports.isNodeType = isNodeType;
exports.isProsemirrorFragment = isProsemirrorFragment;
exports.isProsemirrorMark = isProsemirrorMark;
exports.isProsemirrorNode = isProsemirrorNode;
exports.isRemirrorJSON = isRemirrorJSON;
exports.isRemirrorType = isRemirrorType;
exports.isResolvedPos = isResolvedPos;
exports.isSelection = isSelection;
exports.isSelectionEmpty = isSelectionEmpty;
exports.isStartOfDoc = isStartOfDoc;
exports.isStartOfTextBlock = isStartOfTextBlock;
exports.isTextDomNode = isTextDomNode;
exports.isTextSelection = isTextSelection;
exports.isTransaction = isTransaction;
exports.joinStyles = joinStyles;
exports.lift = lift;
exports.markEqualsType = markEqualsType;
exports.markInputRule = markInputRule;
exports.mergeKeyBindings = mergeKeyBindings;
exports.mergeProsemirrorKeyBindings = mergeProsemirrorKeyBindings;
exports.nodeInputRule = nodeInputRule;
exports.omitExtraAttributes = omitExtraAttributes;
exports.parseSizeUnit = parseSizeUnit;
exports.plainInputRule = plainInputRule;
exports.preserveSelection = preserveSelection;
exports.prosemirrorNodeToDom = prosemirrorNodeToDom;
exports.prosemirrorNodeToHtml = prosemirrorNodeToHtml;
exports.rangeHasMark = rangeHasMark;
exports.removeMark = removeMark;
exports.removeNodeAfter = removeNodeAfter;
exports.removeNodeAtPosition = removeNodeAtPosition;
exports.removeNodeBefore = removeNodeBefore;
exports.replaceNodeAtPosition = replaceNodeAtPosition;
exports.replaceText = replaceText;
exports.schemaToJSON = schemaToJSON;
exports.setBlockType = setBlockType;
exports.setStyle = setStyle;
exports.shouldUseDomEnvironment = shouldUseDomEnvironment;
exports.startPositionOfParent = startPositionOfParent;
exports.textBetween = textBetween;
exports.toggleBlockItem = toggleBlockItem;
exports.toggleWrap = toggleWrap;
exports.updateMark = updateMark;
exports.wrapIn = wrapIn;


/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(39);
} else {
  module.exports = __webpack_require__(44);
}


/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorState = __webpack_require__(40);



Object.keys(prosemirrorState).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorState[k]; }
	});
});


/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AllSelection": () => (/* binding */ AllSelection),
/* harmony export */   "EditorState": () => (/* binding */ EditorState),
/* harmony export */   "NodeSelection": () => (/* binding */ NodeSelection),
/* harmony export */   "Plugin": () => (/* binding */ Plugin),
/* harmony export */   "PluginKey": () => (/* binding */ PluginKey),
/* harmony export */   "Selection": () => (/* binding */ Selection),
/* harmony export */   "SelectionRange": () => (/* binding */ SelectionRange),
/* harmony export */   "TextSelection": () => (/* binding */ TextSelection),
/* harmony export */   "Transaction": () => (/* binding */ Transaction)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);



var classesById = Object.create(null);

// ::- Superclass for editor selections. Every selection type should
// extend this. Should not be instantiated directly.
var Selection = function Selection($anchor, $head, ranges) {
  // :: [SelectionRange]
  // The ranges covered by the selection.
  this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  // :: ResolvedPos
  // The resolved anchor of the selection (the side that stays in
  // place when the selection is modified).
  this.$anchor = $anchor;
  // :: ResolvedPos
  // The resolved head of the selection (the side that moves when
  // the selection is modified).
  this.$head = $head;
};

var prototypeAccessors = { anchor: { configurable: true },head: { configurable: true },from: { configurable: true },to: { configurable: true },$from: { configurable: true },$to: { configurable: true },empty: { configurable: true } };

// :: number
// The selection's anchor, as an unresolved position.
prototypeAccessors.anchor.get = function () { return this.$anchor.pos };

// :: number
// The selection's head.
prototypeAccessors.head.get = function () { return this.$head.pos };

// :: number
// The lower bound of the selection's main range.
prototypeAccessors.from.get = function () { return this.$from.pos };

// :: number
// The upper bound of the selection's main range.
prototypeAccessors.to.get = function () { return this.$to.pos };

// :: ResolvedPos
// The resolved lowerbound of the selection's main range.
prototypeAccessors.$from.get = function () {
  return this.ranges[0].$from
};

// :: ResolvedPos
// The resolved upper bound of the selection's main range.
prototypeAccessors.$to.get = function () {
  return this.ranges[0].$to
};

// :: bool
// Indicates whether the selection contains any content.
prototypeAccessors.empty.get = function () {
  var ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++)
    { if (ranges[i].$from.pos != ranges[i].$to.pos) { return false } }
  return true
};

// eq:: (Selection) → bool
// Test whether the selection is the same as another selection.

// map:: (doc: Node, mapping: Mappable) → Selection
// Map this selection through a [mappable](#transform.Mappable) thing. `doc`
// should be the new document to which we are mapping.

// :: () → Slice
// Get the content of this selection as a slice.
Selection.prototype.content = function content () {
  return this.$from.node(0).slice(this.from, this.to, true)
};

// :: (Transaction, ?Slice)
// Replace the selection with a slice or, if no slice is given,
// delete the selection. Will append to the given transaction.
Selection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  // Put the new selection at the position after the inserted
  // content. When that ended in an inline node, search backwards,
  // to get the position after that node. If not, search forward.
  var lastNode = content.content.lastChild, lastParent = null;
  for (var i = 0; i < content.openEnd; i++) {
    lastParent = lastNode;
    lastNode = lastNode.lastChild;
  }

  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i$1 = 0; i$1 < ranges.length; i$1++) {
    var ref = ranges[i$1];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i$1 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);
    if (i$1 == 0)
      { selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1); }
  }
};

// :: (Transaction, Node)
// Replace the selection with the given node, appending the changes
// to the given transaction.
Selection.prototype.replaceWith = function replaceWith (tr, node) {
  var mapFrom = tr.steps.length, ranges = this.ranges;
  for (var i = 0; i < ranges.length; i++) {
    var ref = ranges[i];
      var $from = ref.$from;
      var $to = ref.$to;
      var mapping = tr.mapping.slice(mapFrom);
    var from = mapping.map($from.pos), to = mapping.map($to.pos);
    if (i) {
      tr.deleteRange(from, to);
    } else {
      tr.replaceRangeWith(from, to, node);
      selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
    }
  }
};

// toJSON:: () → Object
// Convert the selection to a JSON representation. When implementing
// this for a custom selection class, make sure to give the object a
// `type` property whose value matches the ID under which you
// [registered](#state.Selection^jsonID) your class.

// :: (ResolvedPos, number, ?bool) → ?Selection
// Find a valid cursor or leaf node selection starting at the given
// position and searching back if `dir` is negative, and forward if
// positive. When `textOnly` is true, only consider cursor
// selections. Will return null when no valid selection position is
// found.
Selection.findFrom = function findFrom ($pos, dir, textOnly) {
  var inner = $pos.parent.inlineContent ? new TextSelection($pos)
      : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
  if (inner) { return inner }

  for (var depth = $pos.depth - 1; depth >= 0; depth--) {
    var found = dir < 0
        ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)
        : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
    if (found) { return found }
  }
};

// :: (ResolvedPos, ?number) → Selection
// Find a valid cursor or leaf node selection near the given
// position. Searches forward first by default, but if `bias` is
// negative, it will search backwards first.
Selection.near = function near ($pos, bias) {
    if ( bias === void 0 ) bias = 1;

  return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0))
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the start of
// the given document. Will return an
// [`AllSelection`](#state.AllSelection) if no valid position
// exists.
Selection.atStart = function atStart (doc) {
  return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc)
};

// :: (Node) → Selection
// Find the cursor or leaf node selection closest to the end of the
// given document.
Selection.atEnd = function atEnd (doc) {
  return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc)
};

// :: (Node, Object) → Selection
// Deserialize the JSON representation of a selection. Must be
// implemented for custom classes (as a static class method).
Selection.fromJSON = function fromJSON (doc, json) {
  if (!json || !json.type) { throw new RangeError("Invalid input for Selection.fromJSON") }
  var cls = classesById[json.type];
  if (!cls) { throw new RangeError(("No selection type " + (json.type) + " defined")) }
  return cls.fromJSON(doc, json)
};

// :: (string, constructor<Selection>)
// To be able to deserialize selections from JSON, custom selection
// classes must register themselves with an ID string, so that they
// can be disambiguated. Try to pick something that's unlikely to
// clash with classes from other modules.
Selection.jsonID = function jsonID (id, selectionClass) {
  if (id in classesById) { throw new RangeError("Duplicate use of selection JSON ID " + id) }
  classesById[id] = selectionClass;
  selectionClass.prototype.jsonID = id;
  return selectionClass
};

// :: () → SelectionBookmark
// Get a [bookmark](#state.SelectionBookmark) for this selection,
// which is a value that can be mapped without having access to a
// current document, and later resolved to a real selection for a
// given document again. (This is used mostly by the history to
// track and restore old selections.) The default implementation of
// this method just converts the selection to a text selection and
// returns the bookmark for that.
Selection.prototype.getBookmark = function getBookmark () {
  return TextSelection.between(this.$anchor, this.$head).getBookmark()
};

Object.defineProperties( Selection.prototype, prototypeAccessors );

// :: bool
// Controls whether, when a selection of this type is active in the
// browser, the selected range should be visible to the user. Defaults
// to `true`.
Selection.prototype.visible = true;

// SelectionBookmark:: interface
// A lightweight, document-independent representation of a selection.
// You can define a custom bookmark type for a custom selection class
// to make the history handle it well.
//
//   map:: (mapping: Mapping) → SelectionBookmark
//   Map the bookmark through a set of changes.
//
//   resolve:: (doc: Node) → Selection
//   Resolve the bookmark to a real selection again. This may need to
//   do some error checking and may fall back to a default (usually
//   [`TextSelection.between`](#state.TextSelection^between)) if
//   mapping made the bookmark invalid.

// ::- Represents a selected range in a document.
var SelectionRange = function SelectionRange($from, $to) {
  // :: ResolvedPos
  // The lower bound of the range.
  this.$from = $from;
  // :: ResolvedPos
  // The upper bound of the range.
  this.$to = $to;
};

// ::- A text selection represents a classical editor selection, with
// a head (the moving side) and anchor (immobile side), both of which
// point into textblock nodes. It can be empty (a regular cursor
// position).
var TextSelection = /*@__PURE__*/(function (Selection) {
  function TextSelection($anchor, $head) {
    if ( $head === void 0 ) $head = $anchor;

    Selection.call(this, $anchor, $head);
  }

  if ( Selection ) TextSelection.__proto__ = Selection;
  TextSelection.prototype = Object.create( Selection && Selection.prototype );
  TextSelection.prototype.constructor = TextSelection;

  var prototypeAccessors$1 = { $cursor: { configurable: true } };

  // :: ?ResolvedPos
  // Returns a resolved position if this is a cursor selection (an
  // empty text selection), and null otherwise.
  prototypeAccessors$1.$cursor.get = function () { return this.$anchor.pos == this.$head.pos ? this.$head : null };

  TextSelection.prototype.map = function map (doc, mapping) {
    var $head = doc.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent) { return Selection.near($head) }
    var $anchor = doc.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head)
  };

  TextSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    Selection.prototype.replace.call(this, tr, content);
    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      var marks = this.$from.marksAcross(this.$to);
      if (marks) { tr.ensureMarks(marks); }
    }
  };

  TextSelection.prototype.eq = function eq (other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head
  };

  TextSelection.prototype.getBookmark = function getBookmark () {
    return new TextBookmark(this.anchor, this.head)
  };

  TextSelection.prototype.toJSON = function toJSON () {
    return {type: "text", anchor: this.anchor, head: this.head}
  };

  TextSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      { throw new RangeError("Invalid input for TextSelection.fromJSON") }
    return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head))
  };

  // :: (Node, number, ?number) → TextSelection
  // Create a text selection from non-resolved positions.
  TextSelection.create = function create (doc, anchor, head) {
    if ( head === void 0 ) head = anchor;

    var $anchor = doc.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc.resolve(head))
  };

  // :: (ResolvedPos, ResolvedPos, ?number) → Selection
  // Return a text selection that spans the given positions or, if
  // they aren't text positions, find a text selection near them.
  // `bias` determines whether the method searches forward (default)
  // or backwards (negative number) first. Will fall back to calling
  // [`Selection.near`](#state.Selection^near) when the document
  // doesn't contain a valid text position.
  TextSelection.between = function between ($anchor, $head, bias) {
    var dPos = $anchor.pos - $head.pos;
    if (!bias || dPos) { bias = dPos >= 0 ? 1 : -1; }
    if (!$head.parent.inlineContent) {
      var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found) { $head = found.$head; }
      else { return Selection.near($head, bias) }
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if (($anchor.pos < $head.pos) != (dPos < 0)) { $anchor = $head; }
      }
    }
    return new TextSelection($anchor, $head)
  };

  Object.defineProperties( TextSelection.prototype, prototypeAccessors$1 );

  return TextSelection;
}(Selection));

Selection.jsonID("text", TextSelection);

var TextBookmark = function TextBookmark(anchor, head) {
  this.anchor = anchor;
  this.head = head;
};
TextBookmark.prototype.map = function map (mapping) {
  return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head))
};
TextBookmark.prototype.resolve = function resolve (doc) {
  return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head))
};

// ::- A node selection is a selection that points at a single node.
// All nodes marked [selectable](#model.NodeSpec.selectable) can be
// the target of a node selection. In such a selection, `from` and
// `to` point directly before and after the selected node, `anchor`
// equals `from`, and `head` equals `to`..
var NodeSelection = /*@__PURE__*/(function (Selection) {
  function NodeSelection($pos) {
    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    Selection.call(this, $pos, $end);
    // :: Node The selected node.
    this.node = node;
  }

  if ( Selection ) NodeSelection.__proto__ = Selection;
  NodeSelection.prototype = Object.create( Selection && Selection.prototype );
  NodeSelection.prototype.constructor = NodeSelection;

  NodeSelection.prototype.map = function map (doc, mapping) {
    var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
    var $pos = doc.resolve(pos);
    if (deleted) { return Selection.near($pos) }
    return new NodeSelection($pos)
  };

  NodeSelection.prototype.content = function content () {
    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0)
  };

  NodeSelection.prototype.eq = function eq (other) {
    return other instanceof NodeSelection && other.anchor == this.anchor
  };

  NodeSelection.prototype.toJSON = function toJSON () {
    return {type: "node", anchor: this.anchor}
  };

  NodeSelection.prototype.getBookmark = function getBookmark () { return new NodeBookmark(this.anchor) };

  NodeSelection.fromJSON = function fromJSON (doc, json) {
    if (typeof json.anchor != "number")
      { throw new RangeError("Invalid input for NodeSelection.fromJSON") }
    return new NodeSelection(doc.resolve(json.anchor))
  };

  // :: (Node, number) → NodeSelection
  // Create a node selection from non-resolved positions.
  NodeSelection.create = function create (doc, from) {
    return new this(doc.resolve(from))
  };

  // :: (Node) → bool
  // Determines whether the given node may be selected as a node
  // selection.
  NodeSelection.isSelectable = function isSelectable (node) {
    return !node.isText && node.type.spec.selectable !== false
  };

  return NodeSelection;
}(Selection));

NodeSelection.prototype.visible = false;

Selection.jsonID("node", NodeSelection);

var NodeBookmark = function NodeBookmark(anchor) {
  this.anchor = anchor;
};
NodeBookmark.prototype.map = function map (mapping) {
  var ref = mapping.mapResult(this.anchor);
    var deleted = ref.deleted;
    var pos = ref.pos;
  return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos)
};
NodeBookmark.prototype.resolve = function resolve (doc) {
  var $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;
  if (node && NodeSelection.isSelectable(node)) { return new NodeSelection($pos) }
  return Selection.near($pos)
};

// ::- A selection type that represents selecting the whole document
// (which can not necessarily be expressed with a text selection, when
// there are for example leaf block nodes at the start or end of the
// document).
var AllSelection = /*@__PURE__*/(function (Selection) {
  function AllSelection(doc) {
    Selection.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  if ( Selection ) AllSelection.__proto__ = Selection;
  AllSelection.prototype = Object.create( Selection && Selection.prototype );
  AllSelection.prototype.constructor = AllSelection;

  AllSelection.prototype.replace = function replace (tr, content) {
    if ( content === void 0 ) content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

    if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      var sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection)) { tr.setSelection(sel); }
    } else {
      Selection.prototype.replace.call(this, tr, content);
    }
  };

  AllSelection.prototype.toJSON = function toJSON () { return {type: "all"} };

  AllSelection.fromJSON = function fromJSON (doc) { return new AllSelection(doc) };

  AllSelection.prototype.map = function map (doc) { return new AllSelection(doc) };

  AllSelection.prototype.eq = function eq (other) { return other instanceof AllSelection };

  AllSelection.prototype.getBookmark = function getBookmark () { return AllBookmark };

  return AllSelection;
}(Selection));

Selection.jsonID("all", AllSelection);

var AllBookmark = {
  map: function map() { return this },
  resolve: function resolve(doc) { return new AllSelection(doc) }
};

// FIXME we'll need some awareness of text direction when scanning for selections

// Try to find a selection inside the given node. `pos` points at the
// position where the search starts. When `text` is true, only return
// text selections.
function findSelectionIn(doc, node, pos, index, dir, text) {
  if (node.inlineContent) { return TextSelection.create(doc, pos) }
  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);
    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) { return inner }
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0))
    }
    pos += child.nodeSize * dir;
  }
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) { return }
  var step = tr.steps[last];
  if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep)) { return }
  var map = tr.mapping.maps[last], end;
  map.forEach(function (_from, _to, _newFrom, newTo) { if (end == null) { end = newTo; } });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;

// ::- An editor state transaction, which can be applied to a state to
// create an updated state. Use
// [`EditorState.tr`](#state.EditorState.tr) to create an instance.
//
// Transactions track changes to the document (they are a subclass of
// [`Transform`](#transform.Transform)), but also other state changes,
// like selection updates and adjustments of the set of [stored
// marks](#state.EditorState.storedMarks). In addition, you can store
// metadata properties in a transaction, which are extra pieces of
// information that client code or plugins can use to describe what a
// transacion represents, so that they can update their [own
// state](#state.StateField) accordingly.
//
// The [editor view](#view.EditorView) uses a few metadata properties:
// it will attach a property `"pointer"` with the value `true` to
// selection transactions directly caused by mouse or touch input, and
// a `"uiEvent"` property of that may be `"paste"`, `"cut"`, or `"drop"`.
var Transaction = /*@__PURE__*/(function (Transform) {
  function Transaction(state) {
    Transform.call(this, state.doc);
    // :: number
    // The timestamp associated with this transaction, in the same
    // format as `Date.now()`.
    this.time = Date.now();
    this.curSelection = state.selection;
    // The step count for which the current selection is valid.
    this.curSelectionFor = 0;
    // :: ?[Mark]
    // The stored marks set by this transaction, if any.
    this.storedMarks = state.storedMarks;
    // Bitfield to track which aspects of the state were updated by
    // this transaction.
    this.updated = 0;
    // Object used to store metadata properties for the transaction.
    this.meta = Object.create(null);
  }

  if ( Transform ) Transaction.__proto__ = Transform;
  Transaction.prototype = Object.create( Transform && Transform.prototype );
  Transaction.prototype.constructor = Transaction;

  var prototypeAccessors = { selection: { configurable: true },selectionSet: { configurable: true },storedMarksSet: { configurable: true },isGeneric: { configurable: true },scrolledIntoView: { configurable: true } };

  // :: Selection
  // The transaction's current selection. This defaults to the editor
  // selection [mapped](#state.Selection.map) through the steps in the
  // transaction, but can be overwritten with
  // [`setSelection`](#state.Transaction.setSelection).
  prototypeAccessors.selection.get = function () {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection
  };

  // :: (Selection) → Transaction
  // Update the transaction's current selection. Will determine the
  // selection that the editor gets when the transaction is applied.
  Transaction.prototype.setSelection = function setSelection (selection) {
    if (selection.$from.doc != this.doc)
      { throw new RangeError("Selection passed to setSelection must point at the current document") }
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this
  };

  // :: bool
  // Whether the selection was explicitly updated by this transaction.
  prototypeAccessors.selectionSet.get = function () {
    return (this.updated & UPDATED_SEL) > 0
  };

  // :: (?[Mark]) → Transaction
  // Set the current stored marks.
  Transaction.prototype.setStoredMarks = function setStoredMarks (marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this
  };

  // :: ([Mark]) → Transaction
  // Make sure the current stored marks or, if that is null, the marks
  // at the selection, match the given set of marks. Does nothing if
  // this is already the case.
  Transaction.prototype.ensureMarks = function ensureMarks (marks) {
    if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      { this.setStoredMarks(marks); }
    return this
  };

  // :: (Mark) → Transaction
  // Add a mark to the set of stored marks.
  Transaction.prototype.addStoredMark = function addStoredMark (mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: (union<Mark, MarkType>) → Transaction
  // Remove a mark or mark type from the set of stored marks.
  Transaction.prototype.removeStoredMark = function removeStoredMark (mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()))
  };

  // :: bool
  // Whether the stored marks were explicitly set for this transaction.
  prototypeAccessors.storedMarksSet.get = function () {
    return (this.updated & UPDATED_MARKS) > 0
  };

  Transaction.prototype.addStep = function addStep (step, doc) {
    Transform.prototype.addStep.call(this, step, doc);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  };

  // :: (number) → Transaction
  // Update the timestamp for the transaction.
  Transaction.prototype.setTime = function setTime (time) {
    this.time = time;
    return this
  };

  // :: (Slice) → Transaction
  // Replace the current selection with the given slice.
  Transaction.prototype.replaceSelection = function replaceSelection (slice) {
    this.selection.replace(this, slice);
    return this
  };

  // :: (Node, ?bool) → Transaction
  // Replace the selection with the given node. When `inheritMarks` is
  // true and the content is inline, it inherits the marks from the
  // place where it is inserted.
  Transaction.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {
    var selection = this.selection;
    if (inheritMarks !== false)
      { node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none))); }
    selection.replaceWith(this, node);
    return this
  };

  // :: () → Transaction
  // Delete the selection.
  Transaction.prototype.deleteSelection = function deleteSelection () {
    this.selection.replace(this);
    return this
  };

  // :: (string, from: ?number, to: ?number) → Transaction
  // Replace the given range, or the selection if no range is given,
  // with a text node containing the given string.
  Transaction.prototype.insertText = function insertText (text, from, to) {
    if ( to === void 0 ) to = from;

    var schema = this.doc.type.schema;
    if (from == null) {
      if (!text) { return this.deleteSelection() }
      return this.replaceSelectionWith(schema.text(text), true)
    } else {
      if (!text) { return this.deleteRange(from, to) }
      var marks = this.storedMarks;
      if (!marks) {
        var $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty) { this.setSelection(Selection.near(this.selection.$to)); }
      return this
    }
  };

  // :: (union<string, Plugin, PluginKey>, any) → Transaction
  // Store a metadata property in this transaction, keyed either by
  // name or by plugin.
  Transaction.prototype.setMeta = function setMeta (key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this
  };

  // :: (union<string, Plugin, PluginKey>) → any
  // Retrieve a metadata property for a given name or plugin.
  Transaction.prototype.getMeta = function getMeta (key) {
    return this.meta[typeof key == "string" ? key : key.key]
  };

  // :: bool
  // Returns true if this transaction doesn't contain any metadata,
  // and can thus safely be extended.
  prototypeAccessors.isGeneric.get = function () {
    for (var _ in this.meta) { return false }
    return true
  };

  // :: () → Transaction
  // Indicate that the editor should scroll the selection into view
  // when updated to the state produced by this transaction.
  Transaction.prototype.scrollIntoView = function scrollIntoView () {
    this.updated |= UPDATED_SCROLL;
    return this
  };

  prototypeAccessors.scrolledIntoView.get = function () {
    return (this.updated & UPDATED_SCROLL) > 0
  };

  Object.defineProperties( Transaction.prototype, prototypeAccessors );

  return Transaction;
}(prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform));

function bind(f, self) {
  return !self || !f ? f : f.bind(self)
}

var FieldDesc = function FieldDesc(name, desc, self) {
  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
};

var baseFields = [
  new FieldDesc("doc", {
    init: function init(config) { return config.doc || config.schema.topNodeType.createAndFill() },
    apply: function apply(tr) { return tr.doc }
  }),

  new FieldDesc("selection", {
    init: function init(config, instance) { return config.selection || Selection.atStart(instance.doc) },
    apply: function apply(tr) { return tr.selection }
  }),

  new FieldDesc("storedMarks", {
    init: function init(config) { return config.storedMarks || null },
    apply: function apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null }
  }),

  new FieldDesc("scrollToSelection", {
    init: function init() { return 0 },
    apply: function apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev }
  })
];

// Object wrapping the part of a state object that stays the same
// across transactions. Stored in the state's `config` property.
var Configuration = function Configuration(schema, plugins) {
  var this$1 = this;

  this.schema = schema;
  this.fields = baseFields.concat();
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  if (plugins) { plugins.forEach(function (plugin) {
    if (this$1.pluginsByKey[plugin.key])
      { throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")") }
    this$1.plugins.push(plugin);
    this$1.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state)
      { this$1.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin)); }
  }); }
};

// ::- The state of a ProseMirror editor is represented by an object
// of this type. A state is a persistent data structure—it isn't
// updated, but rather a new state value is computed from an old one
// using the [`apply`](#state.EditorState.apply) method.
//
// A state holds a number of built-in fields, and plugins can
// [define](#state.PluginSpec.state) additional fields.
var EditorState = function EditorState(config) {
  this.config = config;
};

var prototypeAccessors$1 = { schema: { configurable: true },plugins: { configurable: true },tr: { configurable: true } };

// doc:: Node
// The current document.

// selection:: Selection
// The selection.

// storedMarks:: ?[Mark]
// A set of marks to apply to the next input. Will be null when
// no explicit marks have been set.

// :: Schema
// The schema of the state's document.
prototypeAccessors$1.schema.get = function () {
  return this.config.schema
};

// :: [Plugin]
// The plugins that are active in this state.
prototypeAccessors$1.plugins.get = function () {
  return this.config.plugins
};

// :: (Transaction) → EditorState
// Apply the given transaction to produce a new state.
EditorState.prototype.apply = function apply (tr) {
  return this.applyTransaction(tr).state
};

// : (Transaction) → bool
EditorState.prototype.filterTransaction = function filterTransaction (tr, ignore) {
    if ( ignore === void 0 ) ignore = -1;

  for (var i = 0; i < this.config.plugins.length; i++) { if (i != ignore) {
    var plugin = this.config.plugins[i];
    if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
      { return false }
  } }
  return true
};

// :: (Transaction) → {state: EditorState, transactions: [Transaction]}
// Verbose variant of [`apply`](#state.EditorState.apply) that
// returns the precise transactions that were applied (which might
// be influenced by the [transaction
// hooks](#state.PluginSpec.filterTransaction) of
// plugins) along with the new state.
EditorState.prototype.applyTransaction = function applyTransaction (rootTr) {
  if (!this.filterTransaction(rootTr)) { return {state: this, transactions: []} }

  var trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
  // This loop repeatedly gives plugins a chance to respond to
  // transactions as new transactions are added, making sure to only
  // pass the transactions the plugin did not see before.
   for (;;) {
    var haveNew = false;
    for (var i = 0; i < this.config.plugins.length; i++) {
      var plugin = this.config.plugins[i];
      if (plugin.spec.appendTransaction) {
        var n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
        var tr = n < trs.length &&
            plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
        if (tr && newState.filterTransaction(tr, i)) {
          tr.setMeta("appendedTransaction", rootTr);
          if (!seen) {
            seen = [];
            for (var j = 0; j < this.config.plugins.length; j++)
              { seen.push(j < i ? {state: newState, n: trs.length} : {state: this, n: 0}); }
          }
          trs.push(tr);
          newState = newState.applyInner(tr);
          haveNew = true;
        }
        if (seen) { seen[i] = {state: newState, n: trs.length}; }
      }
    }
    if (!haveNew) { return {state: newState, transactions: trs} }
  }
};

// : (Transaction) → EditorState
EditorState.prototype.applyInner = function applyInner (tr) {
  if (!tr.before.eq(this.doc)) { throw new RangeError("Applying a mismatched transaction") }
  var newInstance = new EditorState(this.config), fields = this.config.fields;
  for (var i = 0; i < fields.length; i++) {
    var field = fields[i];
    newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
  }
  for (var i$1 = 0; i$1 < applyListeners.length; i$1++) { applyListeners[i$1](this, tr, newInstance); }
  return newInstance
};

// :: Transaction
// Start a [transaction](#state.Transaction) from this state.
prototypeAccessors$1.tr.get = function () { return new Transaction(this) };

// :: (Object) → EditorState
// Create a new state.
//
// config::- Configuration options. Must contain `schema` or `doc` (or both).
//
//    schema:: ?Schema
//    The schema to use (only relevant if no `doc` is specified).
//
//    doc:: ?Node
//    The starting document.
//
//    selection:: ?Selection
//    A valid selection in the document.
//
//    storedMarks:: ?[Mark]
//    The initial set of [stored marks](#state.EditorState.storedMarks).
//
//    plugins:: ?[Plugin]
//    The plugins that should be active in this state.
EditorState.create = function create (config) {
  var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
  var instance = new EditorState($config);
  for (var i = 0; i < $config.fields.length; i++)
    { instance[$config.fields[i].name] = $config.fields[i].init(config, instance); }
  return instance
};

// :: (Object) → EditorState
// Create a new state based on this one, but with an adjusted set of
// active plugins. State fields that exist in both sets of plugins
// are kept unchanged. Those that no longer exist are dropped, and
// those that are new are initialized using their
// [`init`](#state.StateField.init) method, passing in the new
// configuration object..
//
// config::- configuration options
//
//   plugins:: [Plugin]
//   New set of active plugins.
EditorState.prototype.reconfigure = function reconfigure (config) {
  var $config = new Configuration(this.schema, config.plugins);
  var fields = $config.fields, instance = new EditorState($config);
  for (var i = 0; i < fields.length; i++) {
    var name = fields[i].name;
    instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
  }
  return instance
};

// :: (?union<Object<Plugin>, string, number>) → Object
// Serialize this state to JSON. If you want to serialize the state
// of plugins, pass an object mapping property names to use in the
// resulting JSON object to plugin objects. The argument may also be
// a string or number, in which case it is ignored, to support the
// way `JSON.stringify` calls `toString` methods.
EditorState.prototype.toJSON = function toJSON (pluginFields) {
  var result = {doc: this.doc.toJSON(), selection: this.selection.toJSON()};
  if (this.storedMarks) { result.storedMarks = this.storedMarks.map(function (m) { return m.toJSON(); }); }
  if (pluginFields && typeof pluginFields == 'object') { for (var prop in pluginFields) {
    if (prop == "doc" || prop == "selection")
      { throw new RangeError("The JSON fields `doc` and `selection` are reserved") }
    var plugin = pluginFields[prop], state = plugin.spec.state;
    if (state && state.toJSON) { result[prop] = state.toJSON.call(plugin, this[plugin.key]); }
  } }
  return result
};

// :: (Object, Object, ?Object<Plugin>) → EditorState
// Deserialize a JSON representation of a state. `config` should
// have at least a `schema` field, and should contain array of
// plugins to initialize the state with. `pluginFields` can be used
// to deserialize the state of plugins, by associating plugin
// instances with the property names they use in the JSON object.
//
// config::- configuration options
//
//   schema:: Schema
//   The schema to use.
//
//   plugins:: ?[Plugin]
//   The set of active plugins.
EditorState.fromJSON = function fromJSON (config, json, pluginFields) {
  if (!json) { throw new RangeError("Invalid input for EditorState.fromJSON") }
  if (!config.schema) { throw new RangeError("Required config field 'schema' missing") }
  var $config = new Configuration(config.schema, config.plugins);
  var instance = new EditorState($config);
  $config.fields.forEach(function (field) {
    if (field.name == "doc") {
      instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);
    } else if (field.name == "selection") {
      instance.selection = Selection.fromJSON(instance.doc, json.selection);
    } else if (field.name == "storedMarks") {
      if (json.storedMarks) { instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON); }
    } else {
      if (pluginFields) { for (var prop in pluginFields) {
        var plugin = pluginFields[prop], state = plugin.spec.state;
        if (plugin.key == field.name && state && state.fromJSON &&
            Object.prototype.hasOwnProperty.call(json, prop)) {
          // This field belongs to a plugin mapped to a JSON field, read it from there.
          instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
          return
        }
      } }
      instance[field.name] = field.init(config, instance);
    }
  });
  return instance
};

// Kludge to allow the view to track mappings between different
// instances of a state.
//
// FIXME this is no longer needed as of prosemirror-view 1.9.0,
// though due to backwards-compat we should probably keep it around
// for a while (if only as a no-op)
EditorState.addApplyListener = function addApplyListener (f) {
  applyListeners.push(f);
};
EditorState.removeApplyListener = function removeApplyListener (f) {
  var found = applyListeners.indexOf(f);
  if (found > -1) { applyListeners.splice(found, 1); }
};

Object.defineProperties( EditorState.prototype, prototypeAccessors$1 );

var applyListeners = [];

// PluginSpec:: interface
//
// This is the type passed to the [`Plugin`](#state.Plugin)
// constructor. It provides a definition for a plugin.
//
//   props:: ?EditorProps
//   The [view props](#view.EditorProps) added by this plugin. Props
//   that are functions will be bound to have the plugin instance as
//   their `this` binding.
//
//   state:: ?StateField<any>
//   Allows a plugin to define a [state field](#state.StateField), an
//   extra slot in the state object in which it can keep its own data.
//
//   key:: ?PluginKey
//   Can be used to make this a keyed plugin. You can have only one
//   plugin with a given key in a given state, but it is possible to
//   access the plugin's configuration and state through the key,
//   without having access to the plugin instance object.
//
//   view:: ?(EditorView) → Object
//   When the plugin needs to interact with the editor view, or
//   set something up in the DOM, use this field. The function
//   will be called when the plugin's state is associated with an
//   editor view.
//
//     return::-
//     Should return an object with the following optional
//     properties:
//
//       update:: ?(view: EditorView, prevState: EditorState)
//       Called whenever the view's state is updated.
//
//       destroy:: ?()
//       Called when the view is destroyed or receives a state
//       with different plugins.
//
//   filterTransaction:: ?(Transaction, EditorState) → bool
//   When present, this will be called before a transaction is
//   applied by the state, allowing the plugin to cancel it (by
//   returning false).
//
//   appendTransaction:: ?(transactions: [Transaction], oldState: EditorState, newState: EditorState) → ?Transaction
//   Allows the plugin to append another transaction to be applied
//   after the given array of transactions. When another plugin
//   appends a transaction after this was called, it is called again
//   with the new state and new transactions—but only the new
//   transactions, i.e. it won't be passed transactions that it
//   already saw.

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) { val = val.bind(self); }
    else if (prop == "handleDOMEvents") { val = bindProps(val, self, {}); }
    target[prop] = val;
  }
  return target
}

// ::- Plugins bundle functionality that can be added to an editor.
// They are part of the [editor state](#state.EditorState) and
// may influence that state and the view that contains it.
var Plugin = function Plugin(spec) {
  // :: EditorProps
  // The [props](#view.EditorProps) exported by this plugin.
  this.props = {};
  if (spec.props) { bindProps(spec.props, this, this.props); }
  // :: Object
  // The plugin's [spec object](#state.PluginSpec).
  this.spec = spec;
  this.key = spec.key ? spec.key.key : createKey("plugin");
};

// :: (EditorState) → any
// Extract the plugin's state field from an editor state.
Plugin.prototype.getState = function getState (state) { return state[this.key] };

// StateField:: interface<T>
// A plugin spec may provide a state field (under its
// [`state`](#state.PluginSpec.state) property) of this type, which
// describes the state it wants to keep. Functions provided here are
// always called with the plugin instance as their `this` binding.
//
//   init:: (config: Object, instance: EditorState) → T
//   Initialize the value of the field. `config` will be the object
//   passed to [`EditorState.create`](#state.EditorState^create). Note
//   that `instance` is a half-initialized state instance, and will
//   not have values for plugin fields initialized after this one.
//
//   apply:: (tr: Transaction, value: T, oldState: EditorState, newState: EditorState) → T
//   Apply the given transaction to this state field, producing a new
//   field value. Note that the `newState` argument is again a partially
//   constructed state does not yet contain the state from plugins
//   coming after this one.
//
//   toJSON:: ?(value: T) → *
//   Convert this field to JSON. Optional, can be left off to disable
//   JSON serialization for the field.
//
//   fromJSON:: ?(config: Object, value: *, state: EditorState) → T
//   Deserialize the JSON representation of this field. Note that the
//   `state` argument is again a half-initialized state.

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) { return name + "$" + ++keys[name] }
  keys[name] = 0;
  return name + "$"
}

// ::- A key is used to [tag](#state.PluginSpec.key)
// plugins in a way that makes it possible to find them, given an
// editor state. Assigning a key does mean only one plugin of that
// type can be active in a state.
var PluginKey = function PluginKey(name) {
if ( name === void 0 ) name = "key";
 this.key = createKey(name); };

// :: (EditorState) → ?Plugin
// Get the active plugin with this key, if any, from an editor
// state.
PluginKey.prototype.get = function get (state) { return state.config.pluginsByKey[this.key] };

// :: (EditorState) → ?any
// Get the plugin's state from an editor state.
PluginKey.prototype.getState = function getState (state) { return state[this.key] };


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentMatch": () => (/* binding */ ContentMatch),
/* harmony export */   "DOMParser": () => (/* binding */ DOMParser),
/* harmony export */   "DOMSerializer": () => (/* binding */ DOMSerializer),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "Mark": () => (/* binding */ Mark),
/* harmony export */   "MarkType": () => (/* binding */ MarkType),
/* harmony export */   "Node": () => (/* binding */ Node),
/* harmony export */   "NodeRange": () => (/* binding */ NodeRange),
/* harmony export */   "NodeType": () => (/* binding */ NodeType),
/* harmony export */   "ReplaceError": () => (/* binding */ ReplaceError),
/* harmony export */   "ResolvedPos": () => (/* binding */ ResolvedPos),
/* harmony export */   "Schema": () => (/* binding */ Schema),
/* harmony export */   "Slice": () => (/* binding */ Slice)
/* harmony export */ });
/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(42);


function findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount)
      { return a.childCount == b.childCount ? null : pos }

    var childA = a.child(i), childB = b.child(i);
    if (childA == childB) { pos += childA.nodeSize; continue }

    if (!childA.sameMarkup(childB)) { return pos }

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++)
        { pos++; }
      return pos
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null) { return inner }
    }
    pos += childA.nodeSize;
  }
}

function findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0)
      { return iA == iB ? null : {a: posA, b: posB} }

    var childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size; posB -= size;
      continue
    }

    if (!childA.sameMarkup(childB)) { return {a: posA, b: posB} }

    if (childA.isText && childA.text != childB.text) {
      var same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++; posA--; posB--;
      }
      return {a: posA, b: posB}
    }
    if (childA.content.size || childB.content.size) {
      var inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner) { return inner }
    }
    posA -= size; posB -= size;
  }
}

// ::- A fragment represents a node's collection of child nodes.
//
// Like nodes, fragments are persistent data structures, and you
// should not mutate them or their content. Rather, you create new
// instances whenever needed. The API tries to make this easy.
var Fragment = function Fragment(content, size) {
  this.content = content;
  // :: number
  // The size of the fragment, which is the total of the size of its
  // content nodes.
  this.size = size || 0;
  if (size == null) { for (var i = 0; i < content.length; i++)
    { this.size += content[i].nodeSize; } }
};

var prototypeAccessors = { firstChild: { configurable: true },lastChild: { configurable: true },childCount: { configurable: true } };

// :: (number, number, (node: Node, start: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes between the given two
// positions (relative to start of this fragment). Doesn't descend
// into a node when the callback returns `false`.
Fragment.prototype.nodesBetween = function nodesBetween (from, to, f, nodeStart, parent) {
    if ( nodeStart === void 0 ) nodeStart = 0;

  for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from && f(child, nodeStart + pos, parent, i) !== false && child.content.size) {
      var start = pos + 1;
      child.nodesBetween(Math.max(0, from - start),
                         Math.min(child.content.size, to - start),
                         f, nodeStart + start);
    }
    pos = end;
  }
};

// :: ((node: Node, pos: number, parent: Node) → ?bool)
// Call the given callback for every descendant node. The callback
// may return `false` to prevent traversal of a given node's children.
Fragment.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.size, f);
};

// :: (number, number, ?string, ?union<string, (leafNode: Node) → string>) → string
// Extract the text between `from` and `to`. See the same method on
// [`Node`](#model.Node.textBetween).
Fragment.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  var text = "", separated = true;
  this.nodesBetween(from, to, function (node, pos) {
    if (node.isText) {
      text += node.text.slice(Math.max(from, pos) - pos, to - pos);
      separated = !blockSeparator;
    } else if (node.isLeaf && leafText) {
      text += typeof leafText === 'function' ? leafText(node): leafText;
      separated = !blockSeparator;
    } else if (!separated && node.isBlock) {
      text += blockSeparator;
      separated = true;
    }
  }, 0);
  return text
};

// :: (Fragment) → Fragment
// Create a new fragment containing the combined content of this
// fragment and the other.
Fragment.prototype.append = function append (other) {
  if (!other.size) { return this }
  if (!this.size) { return other }
  var last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
  if (last.isText && last.sameMarkup(first)) {
    content[content.length - 1] = last.withText(last.text + first.text);
    i = 1;
  }
  for (; i < other.content.length; i++) { content.push(other.content[i]); }
  return new Fragment(content, this.size + other.size)
};

// :: (number, ?number) → Fragment
// Cut out the sub-fragment between the two given positions.
Fragment.prototype.cut = function cut (from, to) {
  if (to == null) { to = this.size; }
  if (from == 0 && to == this.size) { return this }
  var result = [], size = 0;
  if (to > from) { for (var i = 0, pos = 0; pos < to; i++) {
    var child = this.content[i], end = pos + child.nodeSize;
    if (end > from) {
      if (pos < from || end > to) {
        if (child.isText)
          { child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos)); }
        else
          { child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1)); }
      }
      result.push(child);
      size += child.nodeSize;
    }
    pos = end;
  } }
  return new Fragment(result, size)
};

Fragment.prototype.cutByIndex = function cutByIndex (from, to) {
  if (from == to) { return Fragment.empty }
  if (from == 0 && to == this.content.length) { return this }
  return new Fragment(this.content.slice(from, to))
};

// :: (number, Node) → Fragment
// Create a new fragment in which the node at the given index is
// replaced by the given node.
Fragment.prototype.replaceChild = function replaceChild (index, node) {
  var current = this.content[index];
  if (current == node) { return this }
  var copy = this.content.slice();
  var size = this.size + node.nodeSize - current.nodeSize;
  copy[index] = node;
  return new Fragment(copy, size)
};

// : (Node) → Fragment
// Create a new fragment by prepending the given node to this
// fragment.
Fragment.prototype.addToStart = function addToStart (node) {
  return new Fragment([node].concat(this.content), this.size + node.nodeSize)
};

// : (Node) → Fragment
// Create a new fragment by appending the given node to this
// fragment.
Fragment.prototype.addToEnd = function addToEnd (node) {
  return new Fragment(this.content.concat(node), this.size + node.nodeSize)
};

// :: (Fragment) → bool
// Compare this fragment to another one.
Fragment.prototype.eq = function eq (other) {
  if (this.content.length != other.content.length) { return false }
  for (var i = 0; i < this.content.length; i++)
    { if (!this.content[i].eq(other.content[i])) { return false } }
  return true
};

// :: ?Node
// The first child of the fragment, or `null` if it is empty.
prototypeAccessors.firstChild.get = function () { return this.content.length ? this.content[0] : null };

// :: ?Node
// The last child of the fragment, or `null` if it is empty.
prototypeAccessors.lastChild.get = function () { return this.content.length ? this.content[this.content.length - 1] : null };

// :: number
// The number of child nodes in this fragment.
prototypeAccessors.childCount.get = function () { return this.content.length };

// :: (number) → Node
// Get the child node at the given index. Raise an error when the
// index is out of range.
Fragment.prototype.child = function child (index) {
  var found = this.content[index];
  if (!found) { throw new RangeError("Index " + index + " out of range for " + this) }
  return found
};

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Fragment.prototype.maybeChild = function maybeChild (index) {
  return this.content[index]
};

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Fragment.prototype.forEach = function forEach (f) {
  for (var i = 0, p = 0; i < this.content.length; i++) {
    var child = this.content[i];
    f(child, p, i);
    p += child.nodeSize;
  }
};

// :: (Fragment) → ?number
// Find the first position at which this fragment and another
// fragment differ, or `null` if they are the same.
Fragment.prototype.findDiffStart = function findDiffStart$1 (other, pos) {
    if ( pos === void 0 ) pos = 0;

  return findDiffStart(this, other, pos)
};

// :: (Fragment) → ?{a: number, b: number}
// Find the first position, searching from the end, at which this
// fragment and the given fragment differ, or `null` if they are the
// same. Since this position will not be the same in both nodes, an
// object with two separate positions is returned.
Fragment.prototype.findDiffEnd = function findDiffEnd$1 (other, pos, otherPos) {
    if ( pos === void 0 ) pos = this.size;
    if ( otherPos === void 0 ) otherPos = other.size;

  return findDiffEnd(this, other, pos, otherPos)
};

// : (number, ?number) → {index: number, offset: number}
// Find the index and inner offset corresponding to a given relative
// position in this fragment. The result object will be reused
// (overwritten) the next time the function is called. (Not public.)
Fragment.prototype.findIndex = function findIndex (pos, round) {
    if ( round === void 0 ) round = -1;

  if (pos == 0) { return retIndex(0, pos) }
  if (pos == this.size) { return retIndex(this.content.length, pos) }
  if (pos > this.size || pos < 0) { throw new RangeError(("Position " + pos + " outside of fragment (" + (this) + ")")) }
  for (var i = 0, curPos = 0;; i++) {
    var cur = this.child(i), end = curPos + cur.nodeSize;
    if (end >= pos) {
      if (end == pos || round > 0) { return retIndex(i + 1, end) }
      return retIndex(i, curPos)
    }
    curPos = end;
  }
};

// :: () → string
// Return a debugging string that describes this fragment.
Fragment.prototype.toString = function toString () { return "<" + this.toStringInner() + ">" };

Fragment.prototype.toStringInner = function toStringInner () { return this.content.join(", ") };

// :: () → ?Object
// Create a JSON-serializeable representation of this fragment.
Fragment.prototype.toJSON = function toJSON () {
  return this.content.length ? this.content.map(function (n) { return n.toJSON(); }) : null
};

// :: (Schema, ?Object) → Fragment
// Deserialize a fragment from its JSON representation.
Fragment.fromJSON = function fromJSON (schema, value) {
  if (!value) { return Fragment.empty }
  if (!Array.isArray(value)) { throw new RangeError("Invalid input for Fragment.fromJSON") }
  return new Fragment(value.map(schema.nodeFromJSON))
};

// :: ([Node]) → Fragment
// Build a fragment from an array of nodes. Ensures that adjacent
// text nodes with the same marks are joined together.
Fragment.fromArray = function fromArray (array) {
  if (!array.length) { return Fragment.empty }
  var joined, size = 0;
  for (var i = 0; i < array.length; i++) {
    var node = array[i];
    size += node.nodeSize;
    if (i && node.isText && array[i - 1].sameMarkup(node)) {
      if (!joined) { joined = array.slice(0, i); }
      joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
    } else if (joined) {
      joined.push(node);
    }
  }
  return new Fragment(joined || array, size)
};

// :: (?union<Fragment, Node, [Node]>) → Fragment
// Create a fragment from something that can be interpreted as a set
// of nodes. For `null`, it returns the empty fragment. For a
// fragment, the fragment itself. For a node or array of nodes, a
// fragment containing those nodes.
Fragment.from = function from (nodes) {
  if (!nodes) { return Fragment.empty }
  if (nodes instanceof Fragment) { return nodes }
  if (Array.isArray(nodes)) { return this.fromArray(nodes) }
  if (nodes.attrs) { return new Fragment([nodes], nodes.nodeSize) }
  throw new RangeError("Can not convert " + nodes + " to a Fragment" +
                       (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""))
};

Object.defineProperties( Fragment.prototype, prototypeAccessors );

var found = {index: 0, offset: 0};
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found
}

// :: Fragment
// An empty fragment. Intended to be reused whenever a node doesn't
// contain anything (rather than allocating a new empty fragment for
// each leaf node).
Fragment.empty = new Fragment([], 0);

function compareDeep(a, b) {
  if (a === b) { return true }
  if (!(a && typeof a == "object") ||
      !(b && typeof b == "object")) { return false }
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) { return false }
  if (array) {
    if (a.length != b.length) { return false }
    for (var i = 0; i < a.length; i++) { if (!compareDeep(a[i], b[i])) { return false } }
  } else {
    for (var p in a) { if (!(p in b) || !compareDeep(a[p], b[p])) { return false } }
    for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  }
  return true
}

// ::- A mark is a piece of information that can be attached to a node,
// such as it being emphasized, in code font, or a link. It has a type
// and optionally a set of attributes that provide further information
// (such as the target of the link). Marks are created through a
// `Schema`, which controls which types exist and which
// attributes they have.
var Mark = function Mark(type, attrs) {
  // :: MarkType
  // The type of this mark.
  this.type = type;
  // :: Object
  // The attributes associated with this mark.
  this.attrs = attrs;
};

// :: ([Mark]) → [Mark]
// Given a set of marks, create a new set which contains this one as
// well, in the right position. If this mark is already in the set,
// the set itself is returned. If any marks that are set to be
// [exclusive](#model.MarkSpec.excludes) with this mark are present,
// those are replaced by this one.
Mark.prototype.addToSet = function addToSet (set) {
  var copy, placed = false;
  for (var i = 0; i < set.length; i++) {
    var other = set[i];
    if (this.eq(other)) { return set }
    if (this.type.excludes(other.type)) {
      if (!copy) { copy = set.slice(0, i); }
    } else if (other.type.excludes(this.type)) {
      return set
    } else {
      if (!placed && other.type.rank > this.type.rank) {
        if (!copy) { copy = set.slice(0, i); }
        copy.push(this);
        placed = true;
      }
      if (copy) { copy.push(other); }
    }
  }
  if (!copy) { copy = set.slice(); }
  if (!placed) { copy.push(this); }
  return copy
};

// :: ([Mark]) → [Mark]
// Remove this mark from the given set, returning a new set. If this
// mark is not in the set, the set itself is returned.
Mark.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i]))
      { return set.slice(0, i).concat(set.slice(i + 1)) } }
  return set
};

// :: ([Mark]) → bool
// Test whether this mark is in the given set of marks.
Mark.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (this.eq(set[i])) { return true } }
  return false
};

// :: (Mark) → bool
// Test whether this mark has the same type and attributes as
// another mark.
Mark.prototype.eq = function eq (other) {
  return this == other ||
    (this.type == other.type && compareDeep(this.attrs, other.attrs))
};

// :: () → Object
// Convert this mark to a JSON-serializeable representation.
Mark.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  return obj
};

// :: (Schema, Object) → Mark
Mark.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Mark.fromJSON") }
  var type = schema.marks[json.type];
  if (!type) { throw new RangeError(("There is no mark type " + (json.type) + " in this schema")) }
  return type.create(json.attrs)
};

// :: ([Mark], [Mark]) → bool
// Test whether two sets of marks are identical.
Mark.sameSet = function sameSet (a, b) {
  if (a == b) { return true }
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++)
    { if (!a[i].eq(b[i])) { return false } }
  return true
};

// :: (?union<Mark, [Mark]>) → [Mark]
// Create a properly sorted mark set from null, a single mark, or an
// unsorted array of marks.
Mark.setFrom = function setFrom (marks) {
  if (!marks || marks.length == 0) { return Mark.none }
  if (marks instanceof Mark) { return [marks] }
  var copy = marks.slice();
  copy.sort(function (a, b) { return a.type.rank - b.type.rank; });
  return copy
};

// :: [Mark] The empty set of marks.
Mark.none = [];

// ReplaceError:: class extends Error
// Error type raised by [`Node.replace`](#model.Node.replace) when
// given an invalid replacement.

function ReplaceError(message) {
  var err = Error.call(this, message);
  err.__proto__ = ReplaceError.prototype;
  return err
}

ReplaceError.prototype = Object.create(Error.prototype);
ReplaceError.prototype.constructor = ReplaceError;
ReplaceError.prototype.name = "ReplaceError";

// ::- A slice represents a piece cut out of a larger document. It
// stores not only a fragment, but also the depth up to which nodes on
// both side are ‘open’ (cut through).
var Slice = function Slice(content, openStart, openEnd) {
  // :: Fragment The slice's content.
  this.content = content;
  // :: number The open depth at the start.
  this.openStart = openStart;
  // :: number The open depth at the end.
  this.openEnd = openEnd;
};

var prototypeAccessors$1 = { size: { configurable: true } };

// :: number
// The size this slice would add when inserted into a document.
prototypeAccessors$1.size.get = function () {
  return this.content.size - this.openStart - this.openEnd
};

Slice.prototype.insertAt = function insertAt (pos, fragment) {
  var content = insertInto(this.content, pos + this.openStart, fragment, null);
  return content && new Slice(content, this.openStart, this.openEnd)
};

Slice.prototype.removeBetween = function removeBetween (from, to) {
  return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd)
};

// :: (Slice) → bool
// Tests whether this slice is equal to another slice.
Slice.prototype.eq = function eq (other) {
  return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd
};

Slice.prototype.toString = function toString () {
  return this.content + "(" + this.openStart + "," + this.openEnd + ")"
};

// :: () → ?Object
// Convert a slice to a JSON-serializable representation.
Slice.prototype.toJSON = function toJSON () {
  if (!this.content.size) { return null }
  var json = {content: this.content.toJSON()};
  if (this.openStart > 0) { json.openStart = this.openStart; }
  if (this.openEnd > 0) { json.openEnd = this.openEnd; }
  return json
};

// :: (Schema, ?Object) → Slice
// Deserialize a slice from its JSON representation.
Slice.fromJSON = function fromJSON (schema, json) {
  if (!json) { return Slice.empty }
  var openStart = json.openStart || 0, openEnd = json.openEnd || 0;
  if (typeof openStart != "number" || typeof openEnd != "number")
    { throw new RangeError("Invalid input for Slice.fromJSON") }
  return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd)
};

// :: (Fragment, ?bool) → Slice
// Create a slice from a fragment by taking the maximum possible
// open value on both side of the fragment.
Slice.maxOpen = function maxOpen (fragment, openIsolating) {
    if ( openIsolating === void 0 ) openIsolating=true;

  var openStart = 0, openEnd = 0;
  for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) { openStart++; }
  for (var n$1 = fragment.lastChild; n$1 && !n$1.isLeaf && (openIsolating || !n$1.type.spec.isolating); n$1 = n$1.lastChild) { openEnd++; }
  return new Slice(fragment, openStart, openEnd)
};

Object.defineProperties( Slice.prototype, prototypeAccessors$1 );

function removeRange(content, from, to) {
  var ref = content.findIndex(from);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  var ref$1 = content.findIndex(to);
  var indexTo = ref$1.index;
  var offsetTo = ref$1.offset;
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) { throw new RangeError("Removing non-flat range") }
    return content.cut(0, from).append(content.cut(to))
  }
  if (index != indexTo) { throw new RangeError("Removing non-flat range") }
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)))
}

function insertInto(content, dist, insert, parent) {
  var ref = content.findIndex(dist);
  var index = ref.index;
  var offset = ref.offset;
  var child = content.maybeChild(index);
  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) { return null }
    return content.cut(0, dist).append(insert).append(content.cut(dist))
  }
  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner))
}

// :: Slice
// The empty slice.
Slice.empty = new Slice(Fragment.empty, 0, 0);

function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    { throw new ReplaceError("Inserted content deeper than insertion position") }
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    { throw new ReplaceError("Inconsistent open depths") }
  return replaceOuter($from, $to, slice, 0)
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth), node = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner))
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth))
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case
    var parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)))
  } else {
    var ref = prepareSliceForReplace(slice, $from);
    var start = ref.start;
    var end = ref.end;
    return close(node, replaceThreeWay($from, start, end, $to, depth))
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    { throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name) }
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    { target[last] = child.withText(target[last].text + child.text); }
  else
    { target.push(child); }
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (var i = startIndex; i < endIndex; i++) { addNode(node.child(i), target); }
  if ($end && $end.depth == depth && $end.textOffset)
    { addNode($end.nodeBefore, target); }
}

function close(node, content) {
  if (!node.type.validContent(content))
    { throw new ReplaceError("Invalid content for node " + node.type.name) }
  return node.copy(content)
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);

  var content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      { addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content); }
    addRange($start, $end, depth, content);
    if (openEnd)
      { addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content); }
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content)
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart, parent = $along.node(extra);
  var node = parent.copy(slice.content);
  for (var i = extra - 1; i >= 0; i--)
    { node = $along.node(i).copy(Fragment.from(node)); }
  return {start: node.resolveNoCache(slice.openStart + extra),
          end: node.resolveNoCache(node.content.size - slice.openEnd - extra)}
}

// ::- You can [_resolve_](#model.Node.resolve) a position to get more
// information about it. Objects of this class represent such a
// resolved position, providing various pieces of context information,
// and some helper methods.
//
// Throughout this interface, methods that take an optional `depth`
// parameter will interpret undefined as `this.depth` and negative
// numbers as `this.depth + value`.
var ResolvedPos = function ResolvedPos(pos, path, parentOffset) {
  // :: number The position that was resolved.
  this.pos = pos;
  this.path = path;
  // :: number
  // The number of levels the parent node is from the root. If this
  // position points directly into the root node, it is 0. If it
  // points into a top-level paragraph, 1, and so on.
  this.depth = path.length / 3 - 1;
  // :: number The offset this position has into its parent node.
  this.parentOffset = parentOffset;
};

var prototypeAccessors$2 = { parent: { configurable: true },doc: { configurable: true },textOffset: { configurable: true },nodeAfter: { configurable: true },nodeBefore: { configurable: true } };

ResolvedPos.prototype.resolveDepth = function resolveDepth (val) {
  if (val == null) { return this.depth }
  if (val < 0) { return this.depth + val }
  return val
};

// :: Node
// The parent node that the position points into. Note that even if
// a position points into a text node, that node is not considered
// the parent—text nodes are ‘flat’ in this model, and have no content.
prototypeAccessors$2.parent.get = function () { return this.node(this.depth) };

// :: Node
// The root node in which the position was resolved.
prototypeAccessors$2.doc.get = function () { return this.node(0) };

// :: (?number) → Node
// The ancestor node at the given level. `p.node(p.depth)` is the
// same as `p.parent`.
ResolvedPos.prototype.node = function node (depth) { return this.path[this.resolveDepth(depth) * 3] };

// :: (?number) → number
// The index into the ancestor at the given level. If this points at
// the 3rd node in the 2nd paragraph on the top level, for example,
// `p.index(0)` is 1 and `p.index(1)` is 2.
ResolvedPos.prototype.index = function index (depth) { return this.path[this.resolveDepth(depth) * 3 + 1] };

// :: (?number) → number
// The index pointing after this position into the ancestor at the
// given level.
ResolvedPos.prototype.indexAfter = function indexAfter (depth) {
  depth = this.resolveDepth(depth);
  return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1)
};

// :: (?number) → number
// The (absolute) position at the start of the node at the given
// level.
ResolvedPos.prototype.start = function start (depth) {
  depth = this.resolveDepth(depth);
  return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1
};

// :: (?number) → number
// The (absolute) position at the end of the node at the given
// level.
ResolvedPos.prototype.end = function end (depth) {
  depth = this.resolveDepth(depth);
  return this.start(depth) + this.node(depth).content.size
};

// :: (?number) → number
// The (absolute) position directly before the wrapping node at the
// given level, or, when `depth` is `this.depth + 1`, the original
// position.
ResolvedPos.prototype.before = function before (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position before the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1]
};

// :: (?number) → number
// The (absolute) position directly after the wrapping node at the
// given level, or the original position when `depth` is `this.depth + 1`.
ResolvedPos.prototype.after = function after (depth) {
  depth = this.resolveDepth(depth);
  if (!depth) { throw new RangeError("There is no position after the top-level node") }
  return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize
};

// :: number
// When this position points into a text node, this returns the
// distance between the position and the start of the text node.
// Will be zero for positions that point between nodes.
prototypeAccessors$2.textOffset.get = function () { return this.pos - this.path[this.path.length - 1] };

// :: ?Node
// Get the node directly after the position, if any. If the position
// points into a text node, only the part of that node after the
// position is returned.
prototypeAccessors$2.nodeAfter.get = function () {
  var parent = this.parent, index = this.index(this.depth);
  if (index == parent.childCount) { return null }
  var dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
  return dOff ? parent.child(index).cut(dOff) : child
};

// :: ?Node
// Get the node directly before the position, if any. If the
// position points into a text node, only the part of that node
// before the position is returned.
prototypeAccessors$2.nodeBefore.get = function () {
  var index = this.index(this.depth);
  var dOff = this.pos - this.path[this.path.length - 1];
  if (dOff) { return this.parent.child(index).cut(0, dOff) }
  return index == 0 ? null : this.parent.child(index - 1)
};

// :: (number, ?number) → number
// Get the position at the given index in the parent node at the
// given depth (which defaults to `this.depth`).
ResolvedPos.prototype.posAtIndex = function posAtIndex (index, depth) {
  depth = this.resolveDepth(depth);
  var node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  for (var i = 0; i < index; i++) { pos += node.child(i).nodeSize; }
  return pos
};

// :: () → [Mark]
// Get the marks at this position, factoring in the surrounding
// marks' [`inclusive`](#model.MarkSpec.inclusive) property. If the
// position is at the start of a non-empty node, the marks of the
// node after it (if any) are returned.
ResolvedPos.prototype.marks = function marks () {
  var parent = this.parent, index = this.index();

  // In an empty parent, return the empty array
  if (parent.content.size == 0) { return Mark.none }

  // When inside a text node, just return the text node's marks
  if (this.textOffset) { return parent.child(index).marks }

  var main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
  // If the `after` flag is true of there is no node before, make
  // the node after this position the main reference.
  if (!main) { var tmp = main; main = other; other = tmp; }

  // Use all marks in the main node, except those that have
  // `inclusive` set to false and are not present in the other node.
  var marks = main.marks;
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
      { marks = marks[i--].removeFromSet(marks); } }

  return marks
};

// :: (ResolvedPos) → ?[Mark]
// Get the marks after the current position, if any, except those
// that are non-inclusive and not present at position `$end`. This
// is mostly useful for getting the set of marks to preserve after a
// deletion. Will return `null` if this position is at the end of
// its parent node or its parent node isn't a textblock (in which
// case no marks should be preserved).
ResolvedPos.prototype.marksAcross = function marksAcross ($end) {
  var after = this.parent.maybeChild(this.index());
  if (!after || !after.isInline) { return null }

  var marks = after.marks, next = $end.parent.maybeChild($end.index());
  for (var i = 0; i < marks.length; i++)
    { if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
      { marks = marks[i--].removeFromSet(marks); } }
  return marks
};

// :: (number) → number
// The depth up to which this position and the given (non-resolved)
// position share the same parent nodes.
ResolvedPos.prototype.sharedDepth = function sharedDepth (pos) {
  for (var depth = this.depth; depth > 0; depth--)
    { if (this.start(depth) <= pos && this.end(depth) >= pos) { return depth } }
  return 0
};

// :: (?ResolvedPos, ?(Node) → bool) → ?NodeRange
// Returns a range based on the place where this position and the
// given position diverge around block content. If both point into
// the same textblock, for example, a range around that textblock
// will be returned. If they point into different blocks, the range
// around those blocks in their shared ancestor is returned. You can
// pass in an optional predicate that will be called with a parent
// node to see if a range into that parent is acceptable.
ResolvedPos.prototype.blockRange = function blockRange (other, pred) {
    if ( other === void 0 ) other = this;

  if (other.pos < this.pos) { return other.blockRange(this) }
  for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)
    { if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))
      { return new NodeRange(this, other, d) } }
};

// :: (ResolvedPos) → bool
// Query whether the given position shares the same parent node.
ResolvedPos.prototype.sameParent = function sameParent (other) {
  return this.pos - this.parentOffset == other.pos - other.parentOffset
};

// :: (ResolvedPos) → ResolvedPos
// Return the greater of this and the given position.
ResolvedPos.prototype.max = function max (other) {
  return other.pos > this.pos ? other : this
};

// :: (ResolvedPos) → ResolvedPos
// Return the smaller of this and the given position.
ResolvedPos.prototype.min = function min (other) {
  return other.pos < this.pos ? other : this
};

ResolvedPos.prototype.toString = function toString () {
  var str = "";
  for (var i = 1; i <= this.depth; i++)
    { str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1); }
  return str + ":" + this.parentOffset
};

ResolvedPos.resolve = function resolve (doc, pos) {
  if (!(pos >= 0 && pos <= doc.content.size)) { throw new RangeError("Position " + pos + " out of range") }
  var path = [];
  var start = 0, parentOffset = pos;
  for (var node = doc;;) {
    var ref = node.content.findIndex(parentOffset);
      var index = ref.index;
      var offset = ref.offset;
    var rem = parentOffset - offset;
    path.push(node, index, start + offset);
    if (!rem) { break }
    node = node.child(index);
    if (node.isText) { break }
    parentOffset = rem - 1;
    start += offset + 1;
  }
  return new ResolvedPos(pos, path, parentOffset)
};

ResolvedPos.resolveCached = function resolveCached (doc, pos) {
  for (var i = 0; i < resolveCache.length; i++) {
    var cached = resolveCache[i];
    if (cached.pos == pos && cached.doc == doc) { return cached }
  }
  var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
  resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
  return result
};

Object.defineProperties( ResolvedPos.prototype, prototypeAccessors$2 );

var resolveCache = [], resolveCachePos = 0, resolveCacheSize = 12;

// ::- Represents a flat range of content, i.e. one that starts and
// ends in the same node.
var NodeRange = function NodeRange($from, $to, depth) {
  // :: ResolvedPos A resolved position along the start of the
  // content. May have a `depth` greater than this object's `depth`
  // property, since these are the positions that were used to
  // compute the range, not re-resolved positions directly at its
  // boundaries.
  this.$from = $from;
  // :: ResolvedPos A position along the end of the content. See
  // caveat for [`$from`](#model.NodeRange.$from).
  this.$to = $to;
  // :: number The depth of the node that this range points into.
  this.depth = depth;
};

var prototypeAccessors$1$1 = { start: { configurable: true },end: { configurable: true },parent: { configurable: true },startIndex: { configurable: true },endIndex: { configurable: true } };

// :: number The position at the start of the range.
prototypeAccessors$1$1.start.get = function () { return this.$from.before(this.depth + 1) };
// :: number The position at the end of the range.
prototypeAccessors$1$1.end.get = function () { return this.$to.after(this.depth + 1) };

// :: Node The parent node that the range points into.
prototypeAccessors$1$1.parent.get = function () { return this.$from.node(this.depth) };
// :: number The start index of the range in the parent node.
prototypeAccessors$1$1.startIndex.get = function () { return this.$from.index(this.depth) };
// :: number The end index of the range in the parent node.
prototypeAccessors$1$1.endIndex.get = function () { return this.$to.indexAfter(this.depth) };

Object.defineProperties( NodeRange.prototype, prototypeAccessors$1$1 );

var emptyAttrs = Object.create(null);

// ::- This class represents a node in the tree that makes up a
// ProseMirror document. So a document is an instance of `Node`, with
// children that are also instances of `Node`.
//
// Nodes are persistent data structures. Instead of changing them, you
// create new ones with the content you want. Old ones keep pointing
// at the old document shape. This is made cheaper by sharing
// structure between the old and new data as much as possible, which a
// tree shape like this (without back pointers) makes easy.
//
// **Do not** directly mutate the properties of a `Node` object. See
// [the guide](/docs/guide/#doc) for more information.
var Node = function Node(type, attrs, content, marks) {
  // :: NodeType
  // The type of node that this is.
  this.type = type;

  // :: Object
  // An object mapping attribute names to values. The kind of
  // attributes allowed and required are
  // [determined](#model.NodeSpec.attrs) by the node type.
  this.attrs = attrs;

  // :: Fragment
  // A container holding the node's children.
  this.content = content || Fragment.empty;

  // :: [Mark]
  // The marks (things like whether it is emphasized or part of a
  // link) applied to this node.
  this.marks = marks || Mark.none;
};

var prototypeAccessors$3 = { nodeSize: { configurable: true },childCount: { configurable: true },textContent: { configurable: true },firstChild: { configurable: true },lastChild: { configurable: true },isBlock: { configurable: true },isTextblock: { configurable: true },inlineContent: { configurable: true },isInline: { configurable: true },isText: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true } };

// text:: ?string
// For text nodes, this contains the node's text content.

// :: number
// The size of this node, as defined by the integer-based [indexing
// scheme](/docs/guide/#doc.indexing). For text nodes, this is the
// amount of characters. For other leaf nodes, it is one. For
// non-leaf nodes, it is the size of the content plus two (the start
// and end token).
prototypeAccessors$3.nodeSize.get = function () { return this.isLeaf ? 1 : 2 + this.content.size };

// :: number
// The number of children that the node has.
prototypeAccessors$3.childCount.get = function () { return this.content.childCount };

// :: (number) → Node
// Get the child node at the given index. Raises an error when the
// index is out of range.
Node.prototype.child = function child (index) { return this.content.child(index) };

// :: (number) → ?Node
// Get the child node at the given index, if it exists.
Node.prototype.maybeChild = function maybeChild (index) { return this.content.maybeChild(index) };

// :: ((node: Node, offset: number, index: number))
// Call `f` for every child node, passing the node, its offset
// into this parent node, and its index.
Node.prototype.forEach = function forEach (f) { this.content.forEach(f); };

// :: (number, number, (node: Node, pos: number, parent: Node, index: number) → ?bool, ?number)
// Invoke a callback for all descendant nodes recursively between
// the given two positions that are relative to start of this node's
// content. The callback is invoked with the node, its
// parent-relative position, its parent node, and its child index.
// When the callback returns false for a given node, that node's
// children will not be recursed over. The last parameter can be
// used to specify a starting position to count from.
Node.prototype.nodesBetween = function nodesBetween (from, to, f, startPos) {
    if ( startPos === void 0 ) startPos = 0;

  this.content.nodesBetween(from, to, f, startPos, this);
};

// :: ((node: Node, pos: number, parent: Node, index: number) → ?bool)
// Call the given callback for every descendant node. Doesn't
// descend into a node when the callback returns `false`.
Node.prototype.descendants = function descendants (f) {
  this.nodesBetween(0, this.content.size, f);
};

// :: string
// Concatenates all the text nodes found in this fragment and its
// children.
prototypeAccessors$3.textContent.get = function () { return this.textBetween(0, this.content.size, "") };

// :: (number, number, ?string, ?union<string, ?(leafNode: Node) -> string>) → string
// Get all text between positions `from` and `to`. When
// `blockSeparator` is given, it will be inserted to separate text
// from different block nodes. When `leafText` is given, it'll be
// inserted for every non-text leaf node encountered.
Node.prototype.textBetween = function textBetween (from, to, blockSeparator, leafText) {
  return this.content.textBetween(from, to, blockSeparator, leafText)
};

// :: ?Node
// Returns this node's first child, or `null` if there are no
// children.
prototypeAccessors$3.firstChild.get = function () { return this.content.firstChild };

// :: ?Node
// Returns this node's last child, or `null` if there are no
// children.
prototypeAccessors$3.lastChild.get = function () { return this.content.lastChild };

// :: (Node) → bool
// Test whether two nodes represent the same piece of document.
Node.prototype.eq = function eq (other) {
  return this == other || (this.sameMarkup(other) && this.content.eq(other.content))
};

// :: (Node) → bool
// Compare the markup (type, attributes, and marks) of this node to
// those of another. Returns `true` if both have the same markup.
Node.prototype.sameMarkup = function sameMarkup (other) {
  return this.hasMarkup(other.type, other.attrs, other.marks)
};

// :: (NodeType, ?Object, ?[Mark]) → bool
// Check whether this node's markup correspond to the given type,
// attributes, and marks.
Node.prototype.hasMarkup = function hasMarkup (type, attrs, marks) {
  return this.type == type &&
    compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&
    Mark.sameSet(this.marks, marks || Mark.none)
};

// :: (?Fragment) → Node
// Create a new node with the same markup as this node, containing
// the given content (or empty, if no content is given).
Node.prototype.copy = function copy (content) {
    if ( content === void 0 ) content = null;

  if (content == this.content) { return this }
  return new this.constructor(this.type, this.attrs, content, this.marks)
};

// :: ([Mark]) → Node
// Create a copy of this node, with the given set of marks instead
// of the node's own marks.
Node.prototype.mark = function mark (marks) {
  return marks == this.marks ? this : new this.constructor(this.type, this.attrs, this.content, marks)
};

// :: (number, ?number) → Node
// Create a copy of this node with only the content between the
// given positions. If `to` is not given, it defaults to the end of
// the node.
Node.prototype.cut = function cut (from, to) {
  if (from == 0 && to == this.content.size) { return this }
  return this.copy(this.content.cut(from, to))
};

// :: (number, ?number) → Slice
// Cut out the part of the document between the given positions, and
// return it as a `Slice` object.
Node.prototype.slice = function slice (from, to, includeParents) {
    if ( to === void 0 ) to = this.content.size;
    if ( includeParents === void 0 ) includeParents = false;

  if (from == to) { return Slice.empty }

  var $from = this.resolve(from), $to = this.resolve(to);
  var depth = includeParents ? 0 : $from.sharedDepth(to);
  var start = $from.start(depth), node = $from.node(depth);
  var content = node.content.cut($from.pos - start, $to.pos - start);
  return new Slice(content, $from.depth - depth, $to.depth - depth)
};

// :: (number, number, Slice) → Node
// Replace the part of the document between the given positions with
// the given slice. The slice must 'fit', meaning its open sides
// must be able to connect to the surrounding content, and its
// content nodes must be valid children for the node they are placed
// into. If any of this is violated, an error of type
// [`ReplaceError`](#model.ReplaceError) is thrown.
Node.prototype.replace = function replace$1 (from, to, slice) {
  return replace(this.resolve(from), this.resolve(to), slice)
};

// :: (number) → ?Node
// Find the node directly after the given position.
Node.prototype.nodeAt = function nodeAt (pos) {
  for (var node = this;;) {
    var ref = node.content.findIndex(pos);
      var index = ref.index;
      var offset = ref.offset;
    node = node.maybeChild(index);
    if (!node) { return null }
    if (offset == pos || node.isText) { return node }
    pos -= offset + 1;
  }
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node after the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childAfter = function childAfter (pos) {
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  return {node: this.content.maybeChild(index), index: index, offset: offset}
};

// :: (number) → {node: ?Node, index: number, offset: number}
// Find the (direct) child node before the given offset, if any,
// and return it along with its index and offset relative to this
// node.
Node.prototype.childBefore = function childBefore (pos) {
  if (pos == 0) { return {node: null, index: 0, offset: 0} }
  var ref = this.content.findIndex(pos);
    var index = ref.index;
    var offset = ref.offset;
  if (offset < pos) { return {node: this.content.child(index), index: index, offset: offset} }
  var node = this.content.child(index - 1);
  return {node: node, index: index - 1, offset: offset - node.nodeSize}
};

// :: (number) → ResolvedPos
// Resolve the given position in the document, returning an
// [object](#model.ResolvedPos) with information about its context.
Node.prototype.resolve = function resolve (pos) { return ResolvedPos.resolveCached(this, pos) };

Node.prototype.resolveNoCache = function resolveNoCache (pos) { return ResolvedPos.resolve(this, pos) };

// :: (number, number, union<Mark, MarkType>) → bool
// Test whether a given mark or mark type occurs in this document
// between the two given positions.
Node.prototype.rangeHasMark = function rangeHasMark (from, to, type) {
  var found = false;
  if (to > from) { this.nodesBetween(from, to, function (node) {
    if (type.isInSet(node.marks)) { found = true; }
    return !found
  }); }
  return found
};

// :: bool
// True when this is a block (non-inline node)
prototypeAccessors$3.isBlock.get = function () { return this.type.isBlock };

// :: bool
// True when this is a textblock node, a block node with inline
// content.
prototypeAccessors$3.isTextblock.get = function () { return this.type.isTextblock };

// :: bool
// True when this node allows inline content.
prototypeAccessors$3.inlineContent.get = function () { return this.type.inlineContent };

// :: bool
// True when this is an inline node (a text node or a node that can
// appear among text).
prototypeAccessors$3.isInline.get = function () { return this.type.isInline };

// :: bool
// True when this is a text node.
prototypeAccessors$3.isText.get = function () { return this.type.isText };

// :: bool
// True when this is a leaf node.
prototypeAccessors$3.isLeaf.get = function () { return this.type.isLeaf };

// :: bool
// True when this is an atom, i.e. when it does not have directly
// editable content. This is usually the same as `isLeaf`, but can
// be configured with the [`atom` property](#model.NodeSpec.atom) on
// a node's spec (typically used when the node is displayed as an
// uneditable [node view](#view.NodeView)).
prototypeAccessors$3.isAtom.get = function () { return this.type.isAtom };

// :: () → string
// Return a string representation of this node for debugging
// purposes.
Node.prototype.toString = function toString () {
  if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
  var name = this.type.name;
  if (this.content.size)
    { name += "(" + this.content.toStringInner() + ")"; }
  return wrapMarks(this.marks, name)
};

// :: (number) → ContentMatch
// Get the content match in this node at the given index.
Node.prototype.contentMatchAt = function contentMatchAt (index) {
  var match = this.type.contentMatch.matchFragment(this.content, 0, index);
  if (!match) { throw new Error("Called contentMatchAt on a node with invalid content") }
  return match
};

// :: (number, number, ?Fragment, ?number, ?number) → bool
// Test whether replacing the range between `from` and `to` (by
// child index) with the given replacement fragment (which defaults
// to the empty fragment) would leave the node's content valid. You
// can optionally pass `start` and `end` indices into the
// replacement fragment.
Node.prototype.canReplace = function canReplace (from, to, replacement, start, end) {
    if ( replacement === void 0 ) replacement = Fragment.empty;
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = replacement.childCount;

  var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
  var two = one && one.matchFragment(this.content, to);
  if (!two || !two.validEnd) { return false }
  for (var i = start; i < end; i++) { if (!this.type.allowsMarks(replacement.child(i).marks)) { return false } }
  return true
};

// :: (number, number, NodeType, ?[Mark]) → bool
// Test whether replacing the range `from` to `to` (by index) with a
// node of the given type would leave the node's content valid.
Node.prototype.canReplaceWith = function canReplaceWith (from, to, type, marks) {
  if (marks && !this.type.allowsMarks(marks)) { return false }
  var start = this.contentMatchAt(from).matchType(type);
  var end = start && start.matchFragment(this.content, to);
  return end ? end.validEnd : false
};

// :: (Node) → bool
// Test whether the given node's content could be appended to this
// node. If that node is empty, this will only return true if there
// is at least one node type that can appear in both nodes (to avoid
// merging completely incompatible nodes).
Node.prototype.canAppend = function canAppend (other) {
  if (other.content.size) { return this.canReplace(this.childCount, this.childCount, other.content) }
  else { return this.type.compatibleContent(other.type) }
};

// :: ()
// Check whether this node and its descendants conform to the
// schema, and raise error when they do not.
Node.prototype.check = function check () {
  if (!this.type.validContent(this.content))
    { throw new RangeError(("Invalid content for node " + (this.type.name) + ": " + (this.content.toString().slice(0, 50)))) }
  var copy = Mark.none;
  for (var i = 0; i < this.marks.length; i++) { copy = this.marks[i].addToSet(copy); }
  if (!Mark.sameSet(copy, this.marks))
    { throw new RangeError(("Invalid collection of marks for node " + (this.type.name) + ": " + (this.marks.map(function (m) { return m.type.name; })))) }
  this.content.forEach(function (node) { return node.check(); });
};

// :: () → Object
// Return a JSON-serializeable representation of this node.
Node.prototype.toJSON = function toJSON () {
  var obj = {type: this.type.name};
  for (var _ in this.attrs) {
    obj.attrs = this.attrs;
    break
  }
  if (this.content.size)
    { obj.content = this.content.toJSON(); }
  if (this.marks.length)
    { obj.marks = this.marks.map(function (n) { return n.toJSON(); }); }
  return obj
};

// :: (Schema, Object) → Node
// Deserialize a node from its JSON representation.
Node.fromJSON = function fromJSON (schema, json) {
  if (!json) { throw new RangeError("Invalid input for Node.fromJSON") }
  var marks = null;
  if (json.marks) {
    if (!Array.isArray(json.marks)) { throw new RangeError("Invalid mark data for Node.fromJSON") }
    marks = json.marks.map(schema.markFromJSON);
  }
  if (json.type == "text") {
    if (typeof json.text != "string") { throw new RangeError("Invalid text node in JSON") }
    return schema.text(json.text, marks)
  }
  var content = Fragment.fromJSON(schema, json.content);
  return schema.nodeType(json.type).create(json.attrs, content, marks)
};

Object.defineProperties( Node.prototype, prototypeAccessors$3 );

var TextNode = /*@__PURE__*/(function (Node) {
  function TextNode(type, attrs, content, marks) {
    Node.call(this, type, attrs, null, marks);

    if (!content) { throw new RangeError("Empty text nodes are not allowed") }

    this.text = content;
  }

  if ( Node ) TextNode.__proto__ = Node;
  TextNode.prototype = Object.create( Node && Node.prototype );
  TextNode.prototype.constructor = TextNode;

  var prototypeAccessors$1 = { textContent: { configurable: true },nodeSize: { configurable: true } };

  TextNode.prototype.toString = function toString () {
    if (this.type.spec.toDebugString) { return this.type.spec.toDebugString(this) }
    return wrapMarks(this.marks, JSON.stringify(this.text))
  };

  prototypeAccessors$1.textContent.get = function () { return this.text };

  TextNode.prototype.textBetween = function textBetween (from, to) { return this.text.slice(from, to) };

  prototypeAccessors$1.nodeSize.get = function () { return this.text.length };

  TextNode.prototype.mark = function mark (marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks)
  };

  TextNode.prototype.withText = function withText (text) {
    if (text == this.text) { return this }
    return new TextNode(this.type, this.attrs, text, this.marks)
  };

  TextNode.prototype.cut = function cut (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.text.length;

    if (from == 0 && to == this.text.length) { return this }
    return this.withText(this.text.slice(from, to))
  };

  TextNode.prototype.eq = function eq (other) {
    return this.sameMarkup(other) && this.text == other.text
  };

  TextNode.prototype.toJSON = function toJSON () {
    var base = Node.prototype.toJSON.call(this);
    base.text = this.text;
    return base
  };

  Object.defineProperties( TextNode.prototype, prototypeAccessors$1 );

  return TextNode;
}(Node));

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--)
    { str = marks[i].type.name + "(" + str + ")"; }
  return str
}

// ::- Instances of this class represent a match state of a node
// type's [content expression](#model.NodeSpec.content), and can be
// used to find out whether further content matches here, and whether
// a given position is a valid end of the node.
var ContentMatch = function ContentMatch(validEnd) {
  // :: bool
  // True when this match state represents a valid end of the node.
  this.validEnd = validEnd;
  this.next = [];
  this.wrapCache = [];
};

var prototypeAccessors$4 = { inlineContent: { configurable: true },defaultType: { configurable: true },edgeCount: { configurable: true } };

ContentMatch.parse = function parse (string, nodeTypes) {
  var stream = new TokenStream(string, nodeTypes);
  if (stream.next == null) { return ContentMatch.empty }
  var expr = parseExpr(stream);
  if (stream.next) { stream.err("Unexpected trailing text"); }
  var match = dfa(nfa(expr));
  checkForDeadEnds(match, stream);
  return match
};

// :: (NodeType) → ?ContentMatch
// Match a node type, returning a match after that node if
// successful.
ContentMatch.prototype.matchType = function matchType (type) {
  for (var i = 0; i < this.next.length; i += 2)
    { if (this.next[i] == type) { return this.next[i + 1] } }
  return null
};

// :: (Fragment, ?number, ?number) → ?ContentMatch
// Try to match a fragment. Returns the resulting match when
// successful.
ContentMatch.prototype.matchFragment = function matchFragment (frag, start, end) {
    if ( start === void 0 ) start = 0;
    if ( end === void 0 ) end = frag.childCount;

  var cur = this;
  for (var i = start; cur && i < end; i++)
    { cur = cur.matchType(frag.child(i).type); }
  return cur
};

prototypeAccessors$4.inlineContent.get = function () {
  var first = this.next[0];
  return first ? first.isInline : false
};

// :: ?NodeType
// Get the first matching node type at this match position that can
// be generated.
prototypeAccessors$4.defaultType.get = function () {
  for (var i = 0; i < this.next.length; i += 2) {
    var type = this.next[i];
    if (!(type.isText || type.hasRequiredAttrs())) { return type }
  }
};

ContentMatch.prototype.compatible = function compatible (other) {
  for (var i = 0; i < this.next.length; i += 2)
    { for (var j = 0; j < other.next.length; j += 2)
      { if (this.next[i] == other.next[j]) { return true } } }
  return false
};

// :: (Fragment, bool, ?number) → ?Fragment
// Try to match the given fragment, and if that fails, see if it can
// be made to match by inserting nodes in front of it. When
// successful, return a fragment of inserted nodes (which may be
// empty if nothing had to be inserted). When `toEnd` is true, only
// return a fragment if the resulting match goes to the end of the
// content expression.
ContentMatch.prototype.fillBefore = function fillBefore (after, toEnd, startIndex) {
    if ( toEnd === void 0 ) toEnd = false;
    if ( startIndex === void 0 ) startIndex = 0;

  var seen = [this];
  function search(match, types) {
    var finished = match.matchFragment(after, startIndex);
    if (finished && (!toEnd || finished.validEnd))
      { return Fragment.from(types.map(function (tp) { return tp.createAndFill(); })) }

    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i], next = match.next[i + 1];
      if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
        seen.push(next);
        var found = search(next, types.concat(type));
        if (found) { return found }
      }
    }
  }

  return search(this, [])
};

// :: (NodeType) → ?[NodeType]
// Find a set of wrapping node types that would allow a node of the
// given type to appear at this position. The result may be empty
// (when it fits directly) and will be null when no such wrapping
// exists.
ContentMatch.prototype.findWrapping = function findWrapping (target) {
  for (var i = 0; i < this.wrapCache.length; i += 2)
    { if (this.wrapCache[i] == target) { return this.wrapCache[i + 1] } }
  var computed = this.computeWrapping(target);
  this.wrapCache.push(target, computed);
  return computed
};

ContentMatch.prototype.computeWrapping = function computeWrapping (target) {
  var seen = Object.create(null), active = [{match: this, type: null, via: null}];
  while (active.length) {
    var current = active.shift(), match = current.match;
    if (match.matchType(target)) {
      var result = [];
      for (var obj = current; obj.type; obj = obj.via)
        { result.push(obj.type); }
      return result.reverse()
    }
    for (var i = 0; i < match.next.length; i += 2) {
      var type = match.next[i];
      if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || match.next[i + 1].validEnd)) {
        active.push({match: type.contentMatch, type: type, via: current});
        seen[type.name] = true;
      }
    }
  }
};

// :: number
// The number of outgoing edges this node has in the finite
// automaton that describes the content expression.
prototypeAccessors$4.edgeCount.get = function () {
  return this.next.length >> 1
};

// :: (number) → {type: NodeType, next: ContentMatch}
// Get the _n_​th outgoing edge from this node in the finite
// automaton that describes the content expression.
ContentMatch.prototype.edge = function edge (n) {
  var i = n << 1;
  if (i >= this.next.length) { throw new RangeError(("There's no " + n + "th edge in this content match")) }
  return {type: this.next[i], next: this.next[i + 1]}
};

ContentMatch.prototype.toString = function toString () {
  var seen = [];
  function scan(m) {
    seen.push(m);
    for (var i = 1; i < m.next.length; i += 2)
      { if (seen.indexOf(m.next[i]) == -1) { scan(m.next[i]); } }
  }
  scan(this);
  return seen.map(function (m, i) {
    var out = i + (m.validEnd ? "*" : " ") + " ";
    for (var i$1 = 0; i$1 < m.next.length; i$1 += 2)
      { out += (i$1 ? ", " : "") + m.next[i$1].name + "->" + seen.indexOf(m.next[i$1 + 1]); }
    return out
  }).join("\n")
};

Object.defineProperties( ContentMatch.prototype, prototypeAccessors$4 );

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function TokenStream(string, nodeTypes) {
  this.string = string;
  this.nodeTypes = nodeTypes;
  this.inline = null;
  this.pos = 0;
  this.tokens = string.split(/\s*(?=\b|\W|$)/);
  if (this.tokens[this.tokens.length - 1] == "") { this.tokens.pop(); }
  if (this.tokens[0] == "") { this.tokens.shift(); }
};

var prototypeAccessors$1$2 = { next: { configurable: true } };

prototypeAccessors$1$2.next.get = function () { return this.tokens[this.pos] };

TokenStream.prototype.eat = function eat (tok) { return this.next == tok && (this.pos++ || true) };

TokenStream.prototype.err = function err (str) { throw new SyntaxError(str + " (in content expression '" + this.string + "')") };

Object.defineProperties( TokenStream.prototype, prototypeAccessors$1$2 );

function parseExpr(stream) {
  var exprs = [];
  do { exprs.push(parseExprSeq(stream)); }
  while (stream.eat("|"))
  return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
}

function parseExprSeq(stream) {
  var exprs = [];
  do { exprs.push(parseExprSubscript(stream)); }
  while (stream.next && stream.next != ")" && stream.next != "|")
  return exprs.length == 1 ? exprs[0] : {type: "seq", exprs: exprs}
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);
  for (;;) {
    if (stream.eat("+"))
      { expr = {type: "plus", expr: expr}; }
    else if (stream.eat("*"))
      { expr = {type: "star", expr: expr}; }
    else if (stream.eat("?"))
      { expr = {type: "opt", expr: expr}; }
    else if (stream.eat("{"))
      { expr = parseExprRange(stream, expr); }
    else { break }
  }
  return expr
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) { stream.err("Expected number, got '" + stream.next + "'"); }
  var result = Number(stream.next);
  stream.pos++;
  return result
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream), max = min;
  if (stream.eat(",")) {
    if (stream.next != "}") { max = parseNum(stream); }
    else { max = -1; }
  }
  if (!stream.eat("}")) { stream.err("Unclosed braced range"); }
  return {type: "range", min: min, max: max, expr: expr}
}

function resolveName(stream, name) {
  var types = stream.nodeTypes, type = types[name];
  if (type) { return [type] }
  var result = [];
  for (var typeName in types) {
    var type$1 = types[typeName];
    if (type$1.groups.indexOf(name) > -1) { result.push(type$1); }
  }
  if (result.length == 0) { stream.err("No node type or group '" + name + "' found"); }
  return result
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) { stream.err("Missing closing paren"); }
    return expr
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) { stream.inline = type.isInline; }
      else if (stream.inline != type.isInline) { stream.err("Mixing inline and block content"); }
      return {type: "name", value: type}
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {type: "choice", exprs: exprs}
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

// The code below helps compile a regular-expression-like language
// into a deterministic finite automaton. For a good introduction to
// these concepts, see https://swtch.com/~rsc/regexp/regexp1.html

// : (Object) → [[{term: ?any, to: number}]]
// Construct an NFA from an expression as returned by the parser. The
// NFA is represented as an array of states, which are themselves
// arrays of edges, which are `{term, to}` objects. The first state is
// the entry state and the last node is the success state.
//
// Note that unlike typical NFAs, the edge ordering in this one is
// significant, in that it is used to contruct filler content when
// necessary.
function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa

  function node() { return nfa.push([]) - 1 }
  function edge(from, to, term) {
    var edge = {term: term, to: to};
    nfa[from].push(edge);
    return edge
  }
  function connect(edges, to) { edges.forEach(function (edge) { return edge.to = to; }); }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) { return out.concat(compile(expr, from)); }, [])
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) { return next }
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)]
    } else if (expr.type == "plus") {
      var loop$1 = node();
      connect(compile(expr.expr, from), loop$1);
      connect(compile(expr.expr, loop$1), loop$1);
      return [edge(loop$1)]
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from))
    } else if (expr.type == "range") {
      var cur = from;
      for (var i$1 = 0; i$1 < expr.min; i$1++) {
        var next$1 = node();
        connect(compile(expr.expr, cur), next$1);
        cur = next$1;
      }
      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var i$2 = expr.min; i$2 < expr.max; i$2++) {
          var next$2 = node();
          edge(cur, next$2);
          connect(compile(expr.expr, cur), next$2);
          cur = next$2;
        }
      }
      return [edge(cur)]
    } else if (expr.type == "name") {
      return [edge(from, null, expr.value)]
    }
  }
}

function cmp(a, b) { return b - a }

// Get the set of nodes reachable by null edges from `node`. Omit
// nodes with only a single null-out-edge, since they may lead to
// needless duplicated nodes.
function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp)

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) { return scan(edges[0].to) }
    result.push(node);
    for (var i = 0; i < edges.length; i++) {
      var ref = edges[i];
      var term = ref.term;
      var to = ref.to;
      if (!term && result.indexOf(to) == -1) { scan(to); }
    }
  }
}

// : ([[{term: ?any, to: number}]]) → ContentMatch
// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set
// of state objects (`ContentMatch` instances) with transitions
// between them.
function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0))

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (ref) {
        var term = ref.term;
        var to = ref.to;

        if (!term) { return }
        var known = out.indexOf(term), set = known > -1 && out[known + 1];
        nullFrom(nfa, to).forEach(function (node) {
          if (!set) { out.push(term, set = []); }
          if (set.indexOf(node) == -1) { set.push(node); }
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);
    for (var i = 0; i < out.length; i += 2) {
      var states$1 = out[i + 1].sort(cmp);
      state.next.push(out[i], labeled[states$1.join(",")] || explore(states$1));
    }
    return state
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i], dead = !state.validEnd, nodes = [];
    for (var j = 0; j < state.next.length; j += 2) {
      var node = state.next[j], next = state.next[j + 1];
      nodes.push(node.name);
      if (dead && !(node.isText || node.hasRequiredAttrs())) { dead = false; }
      if (work.indexOf(next) == -1) { work.push(next); }
    }
    if (dead) { stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"); }
  }
}

// For node types where all attrs have a default value (or which don't
// have any attributes), build up a single reusable default attribute
// object, and use it for all nodes that don't specify specific
// attributes.
function defaultAttrs(attrs) {
  var defaults = Object.create(null);
  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) { return null }
    defaults[attrName] = attr.default;
  }
  return defaults
}

function computeAttrs(attrs, value) {
  var built = Object.create(null);
  for (var name in attrs) {
    var given = value && value[name];
    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) { given = attr.default; }
      else { throw new RangeError("No value supplied for attribute " + name) }
    }
    built[name] = given;
  }
  return built
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) { for (var name in attrs) { result[name] = new Attribute(attrs[name]); } }
  return result
}

// ::- Node types are objects allocated once per `Schema` and used to
// [tag](#model.Node.type) `Node` instances. They contain information
// about the node type, such as its name and what kind of node it
// represents.
var NodeType = function NodeType(name, schema, spec) {
  // :: string
  // The name the node type has in this schema.
  this.name = name;

  // :: Schema
  // A link back to the `Schema` the node type belongs to.
  this.schema = schema;

  // :: NodeSpec
  // The spec that this type is based on
  this.spec = spec;

  this.groups = spec.group ? spec.group.split(" ") : [];
  this.attrs = initAttrs(spec.attrs);

  this.defaultAttrs = defaultAttrs(this.attrs);

  // :: ContentMatch
  // The starting match of the node type's content expression.
  this.contentMatch = null;

  // : ?[MarkType]
  // The set of marks allowed in this node. `null` means all marks
  // are allowed.
  this.markSet = null;

  // :: bool
  // True if this node type has inline content.
  this.inlineContent = null;

  // :: bool
  // True if this is a block type
  this.isBlock = !(spec.inline || name == "text");

  // :: bool
  // True if this is the text node type.
  this.isText = name == "text";
};

var prototypeAccessors$5 = { isInline: { configurable: true },isTextblock: { configurable: true },isLeaf: { configurable: true },isAtom: { configurable: true },whitespace: { configurable: true } };

// :: bool
// True if this is an inline type.
prototypeAccessors$5.isInline.get = function () { return !this.isBlock };

// :: bool
// True if this is a textblock type, a block that contains inline
// content.
prototypeAccessors$5.isTextblock.get = function () { return this.isBlock && this.inlineContent };

// :: bool
// True for node types that allow no content.
prototypeAccessors$5.isLeaf.get = function () { return this.contentMatch == ContentMatch.empty };

// :: bool
// True when this node is an atom, i.e. when it does not have
// directly editable content.
prototypeAccessors$5.isAtom.get = function () { return this.isLeaf || this.spec.atom };

// :: union<"pre", "normal">
// The node type's [whitespace](#view.NodeSpec.whitespace) option.
prototypeAccessors$5.whitespace.get = function () { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") };

// :: () → bool
// Tells you whether this node type has any required attributes.
NodeType.prototype.hasRequiredAttrs = function hasRequiredAttrs () {
  for (var n in this.attrs) { if (this.attrs[n].isRequired) { return true } }
  return false
};

NodeType.prototype.compatibleContent = function compatibleContent (other) {
  return this == other || this.contentMatch.compatible(other.contentMatch)
};

NodeType.prototype.computeAttrs = function computeAttrs$1 (attrs) {
  if (!attrs && this.defaultAttrs) { return this.defaultAttrs }
  else { return computeAttrs(this.attrs, attrs) }
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a `Node` of this type. The given attributes are
// checked and defaulted (you can pass `null` to use the type's
// defaults entirely, if no required attributes exist). `content`
// may be a `Fragment`, a node, an array of nodes, or
// `null`. Similarly `marks` may be `null` to default to the empty
// set of marks.
NodeType.prototype.create = function create (attrs, content, marks) {
  if (this.isText) { throw new Error("NodeType.create can't construct text nodes") }
  return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Like [`create`](#model.NodeType.create), but check the given content
// against the node type's content restrictions, and throw an error
// if it doesn't match.
NodeType.prototype.createChecked = function createChecked (attrs, content, marks) {
  content = Fragment.from(content);
  if (!this.validContent(content))
    { throw new RangeError("Invalid content for node " + this.name) }
  return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks))
};

// :: (?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → ?Node
// Like [`create`](#model.NodeType.create), but see if it is necessary to
// add nodes to the start or end of the given fragment to make it
// fit the node. If no fitting wrapping can be found, return null.
// Note that, due to the fact that required nodes can always be
// created, this will always succeed if you pass null or
// `Fragment.empty` as content.
NodeType.prototype.createAndFill = function createAndFill (attrs, content, marks) {
  attrs = this.computeAttrs(attrs);
  content = Fragment.from(content);
  if (content.size) {
    var before = this.contentMatch.fillBefore(content);
    if (!before) { return null }
    content = before.append(content);
  }
  var after = this.contentMatch.matchFragment(content).fillBefore(Fragment.empty, true);
  if (!after) { return null }
  return new Node(this, attrs, content.append(after), Mark.setFrom(marks))
};

// :: (Fragment) → bool
// Returns true if the given fragment is valid content for this node
// type with the given attributes.
NodeType.prototype.validContent = function validContent (content) {
  var result = this.contentMatch.matchFragment(content);
  if (!result || !result.validEnd) { return false }
  for (var i = 0; i < content.childCount; i++)
    { if (!this.allowsMarks(content.child(i).marks)) { return false } }
  return true
};

// :: (MarkType) → bool
// Check whether the given mark type is allowed in this node.
NodeType.prototype.allowsMarkType = function allowsMarkType (markType) {
  return this.markSet == null || this.markSet.indexOf(markType) > -1
};

// :: ([Mark]) → bool
// Test whether the given set of marks are allowed in this node.
NodeType.prototype.allowsMarks = function allowsMarks (marks) {
  if (this.markSet == null) { return true }
  for (var i = 0; i < marks.length; i++) { if (!this.allowsMarkType(marks[i].type)) { return false } }
  return true
};

// :: ([Mark]) → [Mark]
// Removes the marks that are not allowed in this node from the given set.
NodeType.prototype.allowedMarks = function allowedMarks (marks) {
  if (this.markSet == null) { return marks }
  var copy;
  for (var i = 0; i < marks.length; i++) {
    if (!this.allowsMarkType(marks[i].type)) {
      if (!copy) { copy = marks.slice(0, i); }
    } else if (copy) {
      copy.push(marks[i]);
    }
  }
  return !copy ? marks : copy.length ? copy : Mark.empty
};

NodeType.compile = function compile (nodes, schema) {
  var result = Object.create(null);
  nodes.forEach(function (name, spec) { return result[name] = new NodeType(name, schema, spec); });

  var topType = schema.spec.topNode || "doc";
  if (!result[topType]) { throw new RangeError("Schema is missing its top node type ('" + topType + "')") }
  if (!result.text) { throw new RangeError("Every schema needs a 'text' type") }
  for (var _ in result.text.attrs) { throw new RangeError("The text node type should not have attributes") }

  return result
};

Object.defineProperties( NodeType.prototype, prototypeAccessors$5 );

// Attribute descriptors

var Attribute = function Attribute(options) {
  this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
  this.default = options.default;
};

var prototypeAccessors$1$3 = { isRequired: { configurable: true } };

prototypeAccessors$1$3.isRequired.get = function () {
  return !this.hasDefault
};

Object.defineProperties( Attribute.prototype, prototypeAccessors$1$3 );

// Marks

// ::- Like nodes, marks (which are associated with nodes to signify
// things like emphasis or being part of a link) are
// [tagged](#model.Mark.type) with type objects, which are
// instantiated once per `Schema`.
var MarkType = function MarkType(name, rank, schema, spec) {
  // :: string
  // The name of the mark type.
  this.name = name;

  // :: Schema
  // The schema that this mark type instance is part of.
  this.schema = schema;

  // :: MarkSpec
  // The spec on which the type is based.
  this.spec = spec;

  this.attrs = initAttrs(spec.attrs);

  this.rank = rank;
  this.excluded = null;
  var defaults = defaultAttrs(this.attrs);
  this.instance = defaults && new Mark(this, defaults);
};

// :: (?Object) → Mark
// Create a mark of this type. `attrs` may be `null` or an object
// containing only some of the mark's attributes. The others, if
// they have defaults, will be added.
MarkType.prototype.create = function create (attrs) {
  if (!attrs && this.instance) { return this.instance }
  return new Mark(this, computeAttrs(this.attrs, attrs))
};

MarkType.compile = function compile (marks, schema) {
  var result = Object.create(null), rank = 0;
  marks.forEach(function (name, spec) { return result[name] = new MarkType(name, rank++, schema, spec); });
  return result
};

// :: ([Mark]) → [Mark]
// When there is a mark of this type in the given set, a new set
// without it is returned. Otherwise, the input set is returned.
MarkType.prototype.removeFromSet = function removeFromSet (set) {
  for (var i = 0; i < set.length; i++) { if (set[i].type == this) {
    set = set.slice(0, i).concat(set.slice(i + 1));
    i--;
  } }
  return set
};

// :: ([Mark]) → ?Mark
// Tests whether there is a mark of this type in the given set.
MarkType.prototype.isInSet = function isInSet (set) {
  for (var i = 0; i < set.length; i++)
    { if (set[i].type == this) { return set[i] } }
};

// :: (MarkType) → bool
// Queries whether a given mark type is
// [excluded](#model.MarkSpec.excludes) by this one.
MarkType.prototype.excludes = function excludes (other) {
  return this.excluded.indexOf(other) > -1
};

// SchemaSpec:: interface
// An object describing a schema, as passed to the [`Schema`](#model.Schema)
// constructor.
//
//   nodes:: union<Object<NodeSpec>, OrderedMap<NodeSpec>>
//   The node types in this schema. Maps names to
//   [`NodeSpec`](#model.NodeSpec) objects that describe the node type
//   associated with that name. Their order is significant—it
//   determines which [parse rules](#model.NodeSpec.parseDOM) take
//   precedence by default, and which nodes come first in a given
//   [group](#model.NodeSpec.group).
//
//   marks:: ?union<Object<MarkSpec>, OrderedMap<MarkSpec>>
//   The mark types that exist in this schema. The order in which they
//   are provided determines the order in which [mark
//   sets](#model.Mark.addToSet) are sorted and in which [parse
//   rules](#model.MarkSpec.parseDOM) are tried.
//
//   topNode:: ?string
//   The name of the default top-level node for the schema. Defaults
//   to `"doc"`.

// NodeSpec:: interface
//
//   content:: ?string
//   The content expression for this node, as described in the [schema
//   guide](/docs/guide/#schema.content_expressions). When not given,
//   the node does not allow any content.
//
//   marks:: ?string
//   The marks that are allowed inside of this node. May be a
//   space-separated string referring to mark names or groups, `"_"`
//   to explicitly allow all marks, or `""` to disallow marks. When
//   not given, nodes with inline content default to allowing all
//   marks, other nodes default to not allowing marks.
//
//   group:: ?string
//   The group or space-separated groups to which this node belongs,
//   which can be referred to in the content expressions for the
//   schema.
//
//   inline:: ?bool
//   Should be set to true for inline nodes. (Implied for text nodes.)
//
//   atom:: ?bool
//   Can be set to true to indicate that, though this isn't a [leaf
//   node](#model.NodeType.isLeaf), it doesn't have directly editable
//   content and should be treated as a single unit in the view.
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that nodes of this type get.
//
//   selectable:: ?bool
//   Controls whether nodes of this type can be selected as a [node
//   selection](#state.NodeSelection). Defaults to true for non-text
//   nodes.
//
//   draggable:: ?bool
//   Determines whether nodes of this type can be dragged without
//   being selected. Defaults to false.
//
//   code:: ?bool
//   Can be used to indicate that this node contains code, which
//   causes some commands to behave differently.
//
//   whitespace:: ?union<"pre", "normal">
//   Controls way whitespace in this a node is parsed. The default is
//   `"normal"`, which causes the [DOM parser](#model.DOMParser) to
//   collapse whitespace in normal mode, and normalize it (replacing
//   newlines and such with spaces) otherwise. `"pre"` causes the
//   parser to preserve spaces inside the node. When this option isn't
//   given, but [`code`](#model.NodeSpec.code) is true, `whitespace`
//   will default to `"pre"`. Note that this option doesn't influence
//   the way the node is rendered—that should be handled by `toDOM`
//   and/or styling.
//
//   defining:: ?bool
//   Determines whether this node is considered an important parent
//   node during replace operations (such as paste). Non-defining (the
//   default) nodes get dropped when their entire content is replaced,
//   whereas defining nodes persist and wrap the inserted content.
//   Likewise, in _inserted_ content the defining parents of the
//   content are preserved when possible. Typically,
//   non-default-paragraph textblock types, and possibly list items,
//   are marked as defining.
//
//   isolating:: ?bool
//   When enabled (default is false), the sides of nodes of this type
//   count as boundaries that regular editing operations, like
//   backspacing or lifting, won't cross. An example of a node that
//   should probably have this enabled is a table cell.
//
//   toDOM:: ?(node: Node) → DOMOutputSpec
//   Defines the default way a node of this type should be serialized
//   to DOM/HTML (as used by
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)).
//   Should return a DOM node or an [array
//   structure](#model.DOMOutputSpec) that describes one, with an
//   optional number zero (“hole”) in it to indicate where the node's
//   content should be inserted.
//
//   For text nodes, the default is to create a text DOM node. Though
//   it is possible to create a serializer where text is rendered
//   differently, this is not supported inside the editor, so you
//   shouldn't override that in your text node spec.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this node, which can be
//   used by [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) to
//   automatically derive a parser. The `node` field in the rules is
//   implied (the name of this node will be filled in automatically).
//   If you supply your own parser, you do not need to also specify
//   parsing rules in your schema.
//
//   toDebugString:: ?(node: Node) -> string
//   Defines the default way a node of this type should be serialized
//   to a string representation for debugging (e.g. in error messages).

// MarkSpec:: interface
//
//   attrs:: ?Object<AttributeSpec>
//   The attributes that marks of this type get.
//
//   inclusive:: ?bool
//   Whether this mark should be active when the cursor is positioned
//   at its end (or at its start when that is also the start of the
//   parent node). Defaults to true.
//
//   excludes:: ?string
//   Determines which other marks this mark can coexist with. Should
//   be a space-separated strings naming other marks or groups of marks.
//   When a mark is [added](#model.Mark.addToSet) to a set, all marks
//   that it excludes are removed in the process. If the set contains
//   any mark that excludes the new mark but is not, itself, excluded
//   by the new mark, the mark can not be added an the set. You can
//   use the value `"_"` to indicate that the mark excludes all
//   marks in the schema.
//
//   Defaults to only being exclusive with marks of the same type. You
//   can set it to an empty string (or any string not containing the
//   mark's own name) to allow multiple marks of a given type to
//   coexist (as long as they have different attributes).
//
//   group:: ?string
//   The group or space-separated groups to which this mark belongs.
//
//   spanning:: ?bool
//   Determines whether marks of this type can span multiple adjacent
//   nodes when serialized to DOM/HTML. Defaults to true.
//
//   toDOM:: ?(mark: Mark, inline: bool) → DOMOutputSpec
//   Defines the default way marks of this type should be serialized
//   to DOM/HTML. When the resulting spec contains a hole, that is
//   where the marked content is placed. Otherwise, it is appended to
//   the top node.
//
//   parseDOM:: ?[ParseRule]
//   Associates DOM parser information with this mark (see the
//   corresponding [node spec field](#model.NodeSpec.parseDOM)). The
//   `mark` field in the rules is implied.

// AttributeSpec:: interface
//
// Used to [define](#model.NodeSpec.attrs) attributes on nodes or
// marks.
//
//   default:: ?any
//   The default value for this attribute, to use when no explicit
//   value is provided. Attributes that have no default must be
//   provided whenever a node or mark of a type that has them is
//   created.

// ::- A document schema. Holds [node](#model.NodeType) and [mark
// type](#model.MarkType) objects for the nodes and marks that may
// occur in conforming documents, and provides functionality for
// creating and deserializing such documents.
var Schema = function Schema(spec) {
  // :: SchemaSpec
  // The [spec](#model.SchemaSpec) on which the schema is based,
  // with the added guarantee that its `nodes` and `marks`
  // properties are
  // [`OrderedMap`](https://github.com/marijnh/orderedmap) instances
  // (not raw objects).
  this.spec = {};
  for (var prop in spec) { this.spec[prop] = spec[prop]; }
  this.spec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.nodes);
  this.spec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__["default"].from(spec.marks);

  // :: Object<NodeType>
  // An object mapping the schema's node names to node type objects.
  this.nodes = NodeType.compile(this.spec.nodes, this);

  // :: Object<MarkType>
  // A map from mark names to mark type objects.
  this.marks = MarkType.compile(this.spec.marks, this);

  var contentExprCache = Object.create(null);
  for (var prop$1 in this.nodes) {
    if (prop$1 in this.marks)
      { throw new RangeError(prop$1 + " can not be both a node and a mark") }
    var type = this.nodes[prop$1], contentExpr = type.spec.content || "", markExpr = type.spec.marks;
    type.contentMatch = contentExprCache[contentExpr] ||
      (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
    type.inlineContent = type.contentMatch.inlineContent;
    type.markSet = markExpr == "_" ? null :
      markExpr ? gatherMarks(this, markExpr.split(" ")) :
      markExpr == "" || !type.inlineContent ? [] : null;
  }
  for (var prop$2 in this.marks) {
    var type$1 = this.marks[prop$2], excl = type$1.spec.excludes;
    type$1.excluded = excl == null ? [type$1] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
  }

  this.nodeFromJSON = this.nodeFromJSON.bind(this);
  this.markFromJSON = this.markFromJSON.bind(this);

  // :: NodeType
  // The type of the [default top node](#model.SchemaSpec.topNode)
  // for this schema.
  this.topNodeType = this.nodes[this.spec.topNode || "doc"];

  // :: Object
  // An object for storing whatever values modules may want to
  // compute and cache per schema. (If you want to store something
  // in it, try to use property names unlikely to clash.)
  this.cached = Object.create(null);
  this.cached.wrappings = Object.create(null);
};

// :: (union<string, NodeType>, ?Object, ?union<Fragment, Node, [Node]>, ?[Mark]) → Node
// Create a node in this schema. The `type` may be a string or a
// `NodeType` instance. Attributes will be extended
// with defaults, `content` may be a `Fragment`,
// `null`, a `Node`, or an array of nodes.
Schema.prototype.node = function node (type, attrs, content, marks) {
  if (typeof type == "string")
    { type = this.nodeType(type); }
  else if (!(type instanceof NodeType))
    { throw new RangeError("Invalid node type: " + type) }
  else if (type.schema != this)
    { throw new RangeError("Node type from different schema used (" + type.name + ")") }

  return type.createChecked(attrs, content, marks)
};

// :: (string, ?[Mark]) → Node
// Create a text node in the schema. Empty text nodes are not
// allowed.
Schema.prototype.text = function text (text$1, marks) {
  var type = this.nodes.text;
  return new TextNode(type, type.defaultAttrs, text$1, Mark.setFrom(marks))
};

// :: (union<string, MarkType>, ?Object) → Mark
// Create a mark with the given type and attributes.
Schema.prototype.mark = function mark (type, attrs) {
  if (typeof type == "string") { type = this.marks[type]; }
  return type.create(attrs)
};

// :: (Object) → Node
// Deserialize a node from its JSON representation. This method is
// bound.
Schema.prototype.nodeFromJSON = function nodeFromJSON (json) {
  return Node.fromJSON(this, json)
};

// :: (Object) → Mark
// Deserialize a mark from its JSON representation. This method is
// bound.
Schema.prototype.markFromJSON = function markFromJSON (json) {
  return Mark.fromJSON(this, json)
};

Schema.prototype.nodeType = function nodeType (name) {
  var found = this.nodes[name];
  if (!found) { throw new RangeError("Unknown node type: " + name) }
  return found
};

function gatherMarks(schema, marks) {
  var found = [];
  for (var i = 0; i < marks.length; i++) {
    var name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var mark$1 = schema.marks[prop];
        if (name == "_" || (mark$1.spec.group && mark$1.spec.group.split(" ").indexOf(name) > -1))
          { found.push(ok = mark$1); }
      }
    }
    if (!ok) { throw new SyntaxError("Unknown mark type: '" + marks[i] + "'") }
  }
  return found
}

// ParseOptions:: interface
// These are the options recognized by the
// [`parse`](#model.DOMParser.parse) and
// [`parseSlice`](#model.DOMParser.parseSlice) methods.
//
//   preserveWhitespace:: ?union<bool, "full">
//   By default, whitespace is collapsed as per HTML's rules. Pass
//   `true` to preserve whitespace, but normalize newlines to
//   spaces, and `"full"` to preserve whitespace entirely.
//
//   findPositions:: ?[{node: dom.Node, offset: number}]
//   When given, the parser will, beside parsing the content,
//   record the document positions of the given DOM positions. It
//   will do so by writing to the objects, adding a `pos` property
//   that holds the document position. DOM positions that are not
//   in the parsed content will not be written to.
//
//   from:: ?number
//   The child node index to start parsing from.
//
//   to:: ?number
//   The child node index to stop parsing at.
//
//   topNode:: ?Node
//   By default, the content is parsed into the schema's default
//   [top node type](#model.Schema.topNodeType). You can pass this
//   option to use the type and attributes from a different node
//   as the top container.
//
//   topMatch:: ?ContentMatch
//   Provide the starting content match that content parsed into the
//   top node is matched against.
//
//   context:: ?ResolvedPos
//   A set of additional nodes to count as
//   [context](#model.ParseRule.context) when parsing, above the
//   given [top node](#model.ParseOptions.topNode).

// ParseRule:: interface
// A value that describes how to parse a given DOM node or inline
// style as a ProseMirror node or mark.
//
//   tag:: ?string
//   A CSS selector describing the kind of DOM elements to match. A
//   single rule should have _either_ a `tag` or a `style` property.
//
//   namespace:: ?string
//   The namespace to match. This should be used with `tag`.
//   Nodes are only matched when the namespace matches or this property
//   is null.
//
//   style:: ?string
//   A CSS property name to match. When given, this rule matches
//   inline styles that list that property. May also have the form
//   `"property=value"`, in which case the rule only matches if the
//   property's value exactly matches the given value. (For more
//   complicated filters, use [`getAttrs`](#model.ParseRule.getAttrs)
//   and return false to indicate that the match failed.) Rules
//   matching styles may only produce [marks](#model.ParseRule.mark),
//   not nodes.
//
//   priority:: ?number
//   Can be used to change the order in which the parse rules in a
//   schema are tried. Those with higher priority come first. Rules
//   without a priority are counted as having priority 50. This
//   property is only meaningful in a schema—when directly
//   constructing a parser, the order of the rule array is used.
//
//   consuming:: ?boolean
//   By default, when a rule matches an element or style, no further
//   rules get a chance to match it. By setting this to `false`, you
//   indicate that even when this rule matches, other rules that come
//   after it should also run.
//
//   context:: ?string
//   When given, restricts this rule to only match when the current
//   context—the parent nodes into which the content is being
//   parsed—matches this expression. Should contain one or more node
//   names or node group names followed by single or double slashes.
//   For example `"paragraph/"` means the rule only matches when the
//   parent node is a paragraph, `"blockquote/paragraph/"` restricts
//   it to be in a paragraph that is inside a blockquote, and
//   `"section//"` matches any position inside a section—a double
//   slash matches any sequence of ancestor nodes. To allow multiple
//   different contexts, they can be separated by a pipe (`|`)
//   character, as in `"blockquote/|list_item/"`.
//
//   node:: ?string
//   The name of the node type to create when this rule matches. Only
//   valid for rules with a `tag` property, not for style rules. Each
//   rule should have one of a `node`, `mark`, or `ignore` property
//   (except when it appears in a [node](#model.NodeSpec.parseDOM) or
//   [mark spec](#model.MarkSpec.parseDOM), in which case the `node`
//   or `mark` property will be derived from its position).
//
//   mark:: ?string
//   The name of the mark type to wrap the matched content in.
//
//   ignore:: ?bool
//   When true, ignore content that matches this rule.
//
//   closeParent:: ?bool
//   When true, finding an element that matches this rule will close
//   the current node.
//
//   skip:: ?bool
//   When true, ignore the node that matches this rule, but do parse
//   its content.
//
//   attrs:: ?Object
//   Attributes for the node or mark created by this rule. When
//   `getAttrs` is provided, it takes precedence.
//
//   getAttrs:: ?(union<dom.Node, string>) → ?union<Object, false>
//   A function used to compute the attributes for the node or mark
//   created by this rule. Can also be used to describe further
//   conditions the DOM element or style must match. When it returns
//   `false`, the rule won't match. When it returns null or undefined,
//   that is interpreted as an empty/default set of attributes.
//
//   Called with a DOM Element for `tag` rules, and with a string (the
//   style's value) for `style` rules.
//
//   contentElement:: ?union<string, (dom.Node) → dom.Node>
//   For `tag` rules that produce non-leaf nodes or marks, by default
//   the content of the DOM element is parsed as content of the mark
//   or node. If the child nodes are in a descendent node, this may be
//   a CSS selector string that the parser must use to find the actual
//   content element, or a function that returns the actual content
//   element to the parser.
//
//   getContent:: ?(dom.Node, schema: Schema) → Fragment
//   Can be used to override the content of a matched node. When
//   present, instead of parsing the node's child nodes, the result of
//   this function is used.
//
//   preserveWhitespace:: ?union<bool, "full">
//   Controls whether whitespace should be preserved when parsing the
//   content inside the matched element. `false` means whitespace may
//   be collapsed, `true` means that whitespace should be preserved
//   but newlines normalized to spaces, and `"full"` means that
//   newlines should also be preserved.

// ::- A DOM parser represents a strategy for parsing DOM content into
// a ProseMirror document conforming to a given schema. Its behavior
// is defined by an array of [rules](#model.ParseRule).
var DOMParser = function DOMParser(schema, rules) {
  var this$1 = this;

  // :: Schema
  // The schema into which the parser parses.
  this.schema = schema;
  // :: [ParseRule]
  // The set of [parse rules](#model.ParseRule) that the parser
  // uses, in order of precedence.
  this.rules = rules;
  this.tags = [];
  this.styles = [];

  rules.forEach(function (rule) {
    if (rule.tag) { this$1.tags.push(rule); }
    else if (rule.style) { this$1.styles.push(rule); }
  });

  // Only normalize list elements when lists in the schema can't directly contain themselves
  this.normalizeLists = !this.tags.some(function (r) {
    if (!/^(ul|ol)\b/.test(r.tag) || !r.node) { return false }
    var node = schema.nodes[r.node];
    return node.contentMatch.matchType(node)
  });
};

// :: (dom.Node, ?ParseOptions) → Node
// Parse a document from the content of a DOM node.
DOMParser.prototype.parse = function parse (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, false);
  context.addAll(dom, null, options.from, options.to);
  return context.finish()
};

// :: (dom.Node, ?ParseOptions) → Slice
// Parses the content of the given DOM node, like
// [`parse`](#model.DOMParser.parse), and takes the same set of
// options. But unlike that method, which produces a whole node,
// this one returns a slice that is open at the sides, meaning that
// the schema constraints aren't applied to the start of nodes to
// the left of the input and the end of nodes at the end.
DOMParser.prototype.parseSlice = function parseSlice (dom, options) {
    if ( options === void 0 ) options = {};

  var context = new ParseContext(this, options, true);
  context.addAll(dom, null, options.from, options.to);
  return Slice.maxOpen(context.finish())
};

DOMParser.prototype.matchTag = function matchTag (dom, context, after) {
  for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
    var rule = this.tags[i];
    if (matches(dom, rule.tag) &&
        (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&
        (!rule.context || context.matchesContext(rule.context))) {
      if (rule.getAttrs) {
        var result = rule.getAttrs(dom);
        if (result === false) { continue }
        rule.attrs = result;
      }
      return rule
    }
  }
};

DOMParser.prototype.matchStyle = function matchStyle (prop, value, context, after) {
  for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
    var rule = this.styles[i];
    if (rule.style.indexOf(prop) != 0 ||
        rule.context && !context.matchesContext(rule.context) ||
        // Test that the style string either precisely matches the prop,
        // or has an '=' sign after the prop, followed by the given
        // value.
        rule.style.length > prop.length &&
        (rule.style.charCodeAt(prop.length) != 61 || rule.style.slice(prop.length + 1) != value))
      { continue }
    if (rule.getAttrs) {
      var result = rule.getAttrs(value);
      if (result === false) { continue }
      rule.attrs = result;
    }
    return rule
  }
};

// : (Schema) → [ParseRule]
DOMParser.schemaRules = function schemaRules (schema) {
  var result = [];
  function insert(rule) {
    var priority = rule.priority == null ? 50 : rule.priority, i = 0;
    for (; i < result.length; i++) {
      var next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
      if (nextPriority < priority) { break }
    }
    result.splice(i, 0, rule);
  }

  var loop = function ( name ) {
    var rules = schema.marks[name].spec.parseDOM;
    if (rules) { rules.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.mark = name;
    }); }
  };

    for (var name in schema.marks) loop( name );
  var loop$1 = function ( name ) {
    var rules$1 = schema.nodes[name$1].spec.parseDOM;
    if (rules$1) { rules$1.forEach(function (rule) {
      insert(rule = copy(rule));
      rule.node = name$1;
    }); }
  };

    for (var name$1 in schema.nodes) loop$1();
  return result
};

// :: (Schema) → DOMParser
// Construct a DOM parser using the parsing rules listed in a
// schema's [node specs](#model.NodeSpec.parseDOM), reordered by
// [priority](#model.ParseRule.priority).
DOMParser.fromSchema = function fromSchema (schema) {
  return schema.cached.domParser ||
    (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)))
};

// : Object<bool> The block-level tags in HTML5
var blockTags = {
  address: true, article: true, aside: true, blockquote: true, canvas: true,
  dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,
  footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,
  h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,
  output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true
};

// : Object<bool> The tags that we normally ignore.
var ignoreTags = {
  head: true, noscript: true, object: true, script: true, style: true, title: true
};

// : Object<bool> List tags.
var listTags = {ol: true, ul: true};

// Using a bitfield for node context options
var OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;

function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null) { return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |
    (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0) }
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT
}

var NodeContext = function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
  this.type = type;
  this.attrs = attrs;
  this.solid = solid;
  this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  this.options = options;
  this.content = [];
  // Marks applied to this node itself
  this.marks = marks;
  // Marks applied to its children
  this.activeMarks = Mark.none;
  // Marks that can't apply here, but will be used in children if possible
  this.pendingMarks = pendingMarks;
  // Nested Marks with same type
  this.stashMarks = [];
};

NodeContext.prototype.findWrapping = function findWrapping (node) {
  if (!this.match) {
    if (!this.type) { return [] }
    var fill = this.type.contentMatch.fillBefore(Fragment.from(node));
    if (fill) {
      this.match = this.type.contentMatch.matchFragment(fill);
    } else {
      var start = this.type.contentMatch, wrap;
      if (wrap = start.findWrapping(node.type)) {
        this.match = start;
        return wrap
      } else {
        return null
      }
    }
  }
  return this.match.findWrapping(node.type)
};

NodeContext.prototype.finish = function finish (openEnd) {
  if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace
    var last = this.content[this.content.length - 1], m;
    if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
      if (last.text.length == m[0].length) { this.content.pop(); }
      else { this.content[this.content.length - 1] = last.withText(last.text.slice(0, last.text.length - m[0].length)); }
    }
  }
  var content = Fragment.from(this.content);
  if (!openEnd && this.match)
    { content = content.append(this.match.fillBefore(Fragment.empty, true)); }
  return this.type ? this.type.create(this.attrs, content, this.marks) : content
};

NodeContext.prototype.popFromStashMark = function popFromStashMark (mark) {
  for (var i = this.stashMarks.length - 1; i >= 0; i--)
    { if (mark.eq(this.stashMarks[i])) { return this.stashMarks.splice(i, 1)[0] } }
};

NodeContext.prototype.applyPending = function applyPending (nextType) {
  for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
    var mark = pending[i];
    if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) &&
        !mark.isInSet(this.activeMarks)) {
      this.activeMarks = mark.addToSet(this.activeMarks);
      this.pendingMarks = mark.removeFromSet(this.pendingMarks);
    }
  }
};

NodeContext.prototype.inlineContext = function inlineContext (node) {
  if (this.type) { return this.type.inlineContent }
  if (this.content.length) { return this.content[0].isInline }
  return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase())
};

var ParseContext = function ParseContext(parser, options, open) {
  // : DOMParser The parser we are using.
  this.parser = parser;
  // : Object The options passed to this parse.
  this.options = options;
  this.isOpen = open;
  var topNode = options.topNode, topContext;
  var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (open ? OPT_OPEN_LEFT : 0);
  if (topNode)
    { topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true,
                                 options.topMatch || topNode.type.contentMatch, topOptions); }
  else if (open)
    { topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions); }
  else
    { topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions); }
  this.nodes = [topContext];
  // : [Mark] The current set of marks
  this.open = 0;
  this.find = options.findPositions;
  this.needsBlock = false;
};

var prototypeAccessors$6 = { top: { configurable: true },currentPos: { configurable: true } };

prototypeAccessors$6.top.get = function () {
  return this.nodes[this.open]
};

// : (dom.Node)
// Add a DOM node to the content. Text is inserted as text node,
// otherwise, the node is passed to `addElement` or, if it has a
// `style` attribute, `addElementWithStyles`.
ParseContext.prototype.addDOM = function addDOM (dom) {
  if (dom.nodeType == 3) {
    this.addTextNode(dom);
  } else if (dom.nodeType == 1) {
    var style = dom.getAttribute("style");
    var marks = style ? this.readStyles(parseStyles(style)) : null, top = this.top;
    if (marks != null) { for (var i = 0; i < marks.length; i++) { this.addPendingMark(marks[i]); } }
    this.addElement(dom);
    if (marks != null) { for (var i$1 = 0; i$1 < marks.length; i$1++) { this.removePendingMark(marks[i$1], top); } }
  }
};

ParseContext.prototype.addTextNode = function addTextNode (dom) {
  var value = dom.nodeValue;
  var top = this.top;
  if (top.options & OPT_PRESERVE_WS_FULL ||
      top.inlineContext(dom) ||
      /[^ \t\r\n\u000c]/.test(value)) {
    if (!(top.options & OPT_PRESERVE_WS)) {
      value = value.replace(/[ \t\r\n\u000c]+/g, " ");
      // If this starts with whitespace, and there is no node before it, or
      // a hard break, or a text node that ends with whitespace, strip the
      // leading space.
      if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
        var nodeBefore = top.content[top.content.length - 1];
        var domNodeBefore = dom.previousSibling;
        if (!nodeBefore ||
            (domNodeBefore && domNodeBefore.nodeName == 'BR') ||
            (nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)))
          { value = value.slice(1); }
      }
    } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
      value = value.replace(/\r?\n|\r/g, " ");
    } else {
      value = value.replace(/\r\n?/g, "\n");
    }
    if (value) { this.insertNode(this.parser.schema.text(value)); }
    this.findInText(dom);
  } else {
    this.findInside(dom);
  }
};

// : (dom.Element, ?ParseRule)
// Try to find a handler for the given tag and use that to parse. If
// none is found, the element's content nodes are added directly.
ParseContext.prototype.addElement = function addElement (dom, matchAfter) {
  var name = dom.nodeName.toLowerCase(), ruleID;
  if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) { normalizeList(dom); }
  var rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||
      (ruleID = this.parser.matchTag(dom, this, matchAfter));
  if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
    this.findInside(dom);
    this.ignoreFallback(dom);
  } else if (!rule || rule.skip || rule.closeParent) {
    if (rule && rule.closeParent) { this.open = Math.max(0, this.open - 1); }
    else if (rule && rule.skip.nodeType) { dom = rule.skip; }
    var sync, top = this.top, oldNeedsBlock = this.needsBlock;
    if (blockTags.hasOwnProperty(name)) {
      sync = true;
      if (!top.type) { this.needsBlock = true; }
    } else if (!dom.firstChild) {
      this.leafFallback(dom);
      return
    }
    this.addAll(dom);
    if (sync) { this.sync(top); }
    this.needsBlock = oldNeedsBlock;
  } else {
    this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : null);
  }
};

// Called for leaf DOM nodes that would otherwise be ignored
ParseContext.prototype.leafFallback = function leafFallback (dom) {
  if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
    { this.addTextNode(dom.ownerDocument.createTextNode("\n")); }
};

// Called for ignored nodes
ParseContext.prototype.ignoreFallback = function ignoreFallback (dom) {
  // Ignored BR nodes should at least create an inline context
  if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
    { this.findPlace(this.parser.schema.text("-")); }
};

// Run any style parser associated with the node's styles. Either
// return an array of marks, or null to indicate some of the styles
// had a rule with `ignore` set.
ParseContext.prototype.readStyles = function readStyles (styles) {
  var marks = Mark.none;
  style: for (var i = 0; i < styles.length; i += 2) {
    for (var after = null;;) {
      var rule = this.parser.matchStyle(styles[i], styles[i + 1], this, after);
      if (!rule) { continue style }
      if (rule.ignore) { return null }
      marks = this.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(marks);
      if (rule.consuming === false) { after = rule; }
      else { break }
    }
  }
  return marks
};

// : (dom.Element, ParseRule) → bool
// Look up a handler for the given node. If none are found, return
// false. Otherwise, apply it, use its return value to drive the way
// the node's content is wrapped, and return true.
ParseContext.prototype.addElementByRule = function addElementByRule (dom, rule, continueAfter) {
    var this$1 = this;

  var sync, nodeType, markType, mark;
  if (rule.node) {
    nodeType = this.parser.schema.nodes[rule.node];
    if (!nodeType.isLeaf) {
      sync = this.enter(nodeType, rule.attrs, rule.preserveWhitespace);
    } else if (!this.insertNode(nodeType.create(rule.attrs))) {
      this.leafFallback(dom);
    }
  } else {
    markType = this.parser.schema.marks[rule.mark];
    mark = markType.create(rule.attrs);
    this.addPendingMark(mark);
  }
  var startIn = this.top;

  if (nodeType && nodeType.isLeaf) {
    this.findInside(dom);
  } else if (continueAfter) {
    this.addElement(dom, continueAfter);
  } else if (rule.getContent) {
    this.findInside(dom);
    rule.getContent(dom, this.parser.schema).forEach(function (node) { return this$1.insertNode(node); });
  } else {
    var contentDOM = rule.contentElement;
    if (typeof contentDOM == "string") { contentDOM = dom.querySelector(contentDOM); }
    else if (typeof contentDOM == "function") { contentDOM = contentDOM(dom); }
    if (!contentDOM) { contentDOM = dom; }
    this.findAround(dom, contentDOM, true);
    this.addAll(contentDOM, sync);
  }
  if (sync) { this.sync(startIn); this.open--; }
  if (mark) { this.removePendingMark(mark, startIn); }
};

// : (dom.Node, ?NodeBuilder, ?number, ?number)
// Add all child nodes between `startIndex` and `endIndex` (or the
// whole node, if not given). If `sync` is passed, use it to
// synchronize after every block element.
ParseContext.prototype.addAll = function addAll (parent, sync, startIndex, endIndex) {
  var index = startIndex || 0;
  for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild,
           end = endIndex == null ? null : parent.childNodes[endIndex];
       dom != end; dom = dom.nextSibling, ++index) {
    this.findAtPoint(parent, index);
    this.addDOM(dom);
    if (sync && blockTags.hasOwnProperty(dom.nodeName.toLowerCase()))
      { this.sync(sync); }
  }
  this.findAtPoint(parent, index);
};

// Try to find a way to fit the given node type into the current
// context. May add intermediate wrappers and/or leave non-solid
// nodes that we're in.
ParseContext.prototype.findPlace = function findPlace (node) {
  var route, sync;
  for (var depth = this.open; depth >= 0; depth--) {
    var cx = this.nodes[depth];
    var found = cx.findWrapping(node);
    if (found && (!route || route.length > found.length)) {
      route = found;
      sync = cx;
      if (!found.length) { break }
    }
    if (cx.solid) { break }
  }
  if (!route) { return false }
  this.sync(sync);
  for (var i = 0; i < route.length; i++)
    { this.enterInner(route[i], null, false); }
  return true
};

// : (Node) → ?Node
// Try to insert the given node, adjusting the context when needed.
ParseContext.prototype.insertNode = function insertNode (node) {
  if (node.isInline && this.needsBlock && !this.top.type) {
    var block = this.textblockFromContext();
    if (block) { this.enterInner(block); }
  }
  if (this.findPlace(node)) {
    this.closeExtra();
    var top = this.top;
    top.applyPending(node.type);
    if (top.match) { top.match = top.match.matchType(node.type); }
    var marks = top.activeMarks;
    for (var i = 0; i < node.marks.length; i++)
      { if (!top.type || top.type.allowsMarkType(node.marks[i].type))
        { marks = node.marks[i].addToSet(marks); } }
    top.content.push(node.mark(marks));
    return true
  }
  return false
};

// : (NodeType, ?Object) → bool
// Try to start a node of the given type, adjusting the context when
// necessary.
ParseContext.prototype.enter = function enter (type, attrs, preserveWS) {
  var ok = this.findPlace(type.create(attrs));
  if (ok) { this.enterInner(type, attrs, true, preserveWS); }
  return ok
};

// Open a node of the given type
ParseContext.prototype.enterInner = function enterInner (type, attrs, solid, preserveWS) {
  this.closeExtra();
  var top = this.top;
  top.applyPending(type);
  top.match = top.match && top.match.matchType(type, attrs);
  var options = wsOptionsFor(type, preserveWS, top.options);
  if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0) { options |= OPT_OPEN_LEFT; }
  this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
  this.open++;
};

// Make sure all nodes above this.open are finished and added to
// their parents
ParseContext.prototype.closeExtra = function closeExtra (openEnd) {
  var i = this.nodes.length - 1;
  if (i > this.open) {
    for (; i > this.open; i--) { this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd)); }
    this.nodes.length = this.open + 1;
  }
};

ParseContext.prototype.finish = function finish () {
  this.open = 0;
  this.closeExtra(this.isOpen);
  return this.nodes[0].finish(this.isOpen || this.options.topOpen)
};

ParseContext.prototype.sync = function sync (to) {
  for (var i = this.open; i >= 0; i--) { if (this.nodes[i] == to) {
    this.open = i;
    return
  } }
};

prototypeAccessors$6.currentPos.get = function () {
  this.closeExtra();
  var pos = 0;
  for (var i = this.open; i >= 0; i--) {
    var content = this.nodes[i].content;
    for (var j = content.length - 1; j >= 0; j--)
      { pos += content[j].nodeSize; }
    if (i) { pos++; }
  }
  return pos
};

ParseContext.prototype.findAtPoint = function findAtPoint (parent, offset) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == parent && this.find[i].offset == offset)
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findInside = function findInside (parent) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
      { this.find[i].pos = this.currentPos; }
  } }
};

ParseContext.prototype.findAround = function findAround (parent, content, before) {
  if (parent != content && this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
      var pos = content.compareDocumentPosition(this.find[i].node);
      if (pos & (before ? 2 : 4))
        { this.find[i].pos = this.currentPos; }
    }
  } }
};

ParseContext.prototype.findInText = function findInText (textNode) {
  if (this.find) { for (var i = 0; i < this.find.length; i++) {
    if (this.find[i].node == textNode)
      { this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset); }
  } }
};

// : (string) → bool
// Determines whether the given [context
// string](#ParseRule.context) matches this context.
ParseContext.prototype.matchesContext = function matchesContext (context) {
    var this$1 = this;

  if (context.indexOf("|") > -1)
    { return context.split(/\s*\|\s*/).some(this.matchesContext, this) }

  var parts = context.split("/");
  var option = this.options.context;
  var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
  var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
  var match = function (i, depth) {
    for (; i >= 0; i--) {
      var part = parts[i];
      if (part == "") {
        if (i == parts.length - 1 || i == 0) { continue }
        for (; depth >= minDepth; depth--)
          { if (match(i - 1, depth)) { return true } }
        return false
      } else {
        var next = depth > 0 || (depth == 0 && useRoot) ? this$1.nodes[depth].type
            : option && depth >= minDepth ? option.node(depth - minDepth).type
            : null;
        if (!next || (next.name != part && next.groups.indexOf(part) == -1))
          { return false }
        depth--;
      }
    }
    return true
  };
  return match(parts.length - 1, this.open)
};

ParseContext.prototype.textblockFromContext = function textblockFromContext () {
  var $context = this.options.context;
  if ($context) { for (var d = $context.depth; d >= 0; d--) {
    var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
    if (deflt && deflt.isTextblock && deflt.defaultAttrs) { return deflt }
  } }
  for (var name in this.parser.schema.nodes) {
    var type = this.parser.schema.nodes[name];
    if (type.isTextblock && type.defaultAttrs) { return type }
  }
};

ParseContext.prototype.addPendingMark = function addPendingMark (mark) {
  var found = findSameMarkInSet(mark, this.top.pendingMarks);
  if (found) { this.top.stashMarks.push(found); }
  this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
};

ParseContext.prototype.removePendingMark = function removePendingMark (mark, upto) {
  for (var depth = this.open; depth >= 0; depth--) {
    var level = this.nodes[depth];
    var found = level.pendingMarks.lastIndexOf(mark);
    if (found > -1) {
      level.pendingMarks = mark.removeFromSet(level.pendingMarks);
    } else {
      level.activeMarks = mark.removeFromSet(level.activeMarks);
      var stashMark = level.popFromStashMark(mark);
      if (stashMark && level.type && level.type.allowsMarkType(stashMark.type))
        { level.activeMarks = stashMark.addToSet(level.activeMarks); }
    }
    if (level == upto) { break }
  }
};

Object.defineProperties( ParseContext.prototype, prototypeAccessors$6 );

// Kludge to work around directly nested list nodes produced by some
// tools and allowed by browsers to mean that the nested list is
// actually part of the list item above it.
function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

// Apply a CSS selector.
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector)
}

// : (string) → [string]
// Tokenize a style attribute into property/value pairs.
function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g, m, result = [];
  while (m = re.exec(style)) { result.push(m[1], m[2].trim()); }
  return result
}

function copy(obj) {
  var copy = {};
  for (var prop in obj) { copy[prop] = obj[prop]; }
  return copy
}

// Used when finding a mark at the top level of a fragment parse.
// Checks whether it would be reasonable to apply a given mark type to
// a given node, by looking at the way the mark occurs in the schema.
function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;
  var loop = function ( name ) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) { return }
    var seen = [], scan = function (match) {
      seen.push(match);
      for (var i = 0; i < match.edgeCount; i++) {
        var ref = match.edge(i);
        var type = ref.type;
        var next = ref.next;
        if (type == nodeType) { return true }
        if (seen.indexOf(next) < 0 && scan(next)) { return true }
      }
    };
    if (scan(parent.contentMatch)) { return { v: true } }
  };

  for (var name in nodes) {
    var returned = loop( name );

    if ( returned ) return returned.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) { return set[i] }
  }
}

// DOMOutputSpec:: interface
// A description of a DOM structure. Can be either a string, which is
// interpreted as a text node, a DOM node, which is interpreted as
// itself, a `{dom: Node, contentDOM: ?Node}` object, or an array.
//
// An array describes a DOM element. The first value in the array
// should be a string—the name of the DOM element, optionally prefixed
// by a namespace URL and a space. If the second element is plain
// object, it is interpreted as a set of attributes for the element.
// Any elements after that (including the 2nd if it's not an attribute
// object) are interpreted as children of the DOM elements, and must
// either be valid `DOMOutputSpec` values, or the number zero.
//
// The number zero (pronounced “hole”) is used to indicate the place
// where a node's child nodes should be inserted. If it occurs in an
// output spec, it should be the only child element in its parent
// node.

// ::- A DOM serializer knows how to convert ProseMirror nodes and
// marks of various types to DOM nodes.
var DOMSerializer = function DOMSerializer(nodes, marks) {
  // :: Object<(node: Node) → DOMOutputSpec>
  // The node serialization functions.
  this.nodes = nodes || {};
  // :: Object<?(mark: Mark, inline: bool) → DOMOutputSpec>
  // The mark serialization functions.
  this.marks = marks || {};
};

// :: (Fragment, ?Object) → dom.DocumentFragment
// Serialize the content of this fragment to a DOM fragment. When
// not in the browser, the `document` option, containing a DOM
// document, should be passed so that the serializer can create
// nodes.
DOMSerializer.prototype.serializeFragment = function serializeFragment (fragment, options, target) {
    var this$1 = this;
    if ( options === void 0 ) options = {};

  if (!target) { target = doc(options).createDocumentFragment(); }

  var top = target, active = null;
  fragment.forEach(function (node) {
    if (active || node.marks.length) {
      if (!active) { active = []; }
      var keep = 0, rendered = 0;
      while (keep < active.length && rendered < node.marks.length) {
        var next = node.marks[rendered];
        if (!this$1.marks[next.type.name]) { rendered++; continue }
        if (!next.eq(active[keep]) || next.type.spec.spanning === false) { break }
        keep += 2; rendered++;
      }
      while (keep < active.length) {
        top = active.pop();
        active.pop();
      }
      while (rendered < node.marks.length) {
        var add = node.marks[rendered++];
        var markDOM = this$1.serializeMark(add, node.isInline, options);
        if (markDOM) {
          active.push(add, top);
          top.appendChild(markDOM.dom);
          top = markDOM.contentDOM || markDOM.dom;
        }
      }
    }
    top.appendChild(this$1.serializeNodeInner(node, options));
  });

  return target
};

DOMSerializer.prototype.serializeNodeInner = function serializeNodeInner (node, options) {
    if ( options === void 0 ) options = {};

  var ref =
      DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node));
    var dom = ref.dom;
    var contentDOM = ref.contentDOM;
  if (contentDOM) {
    if (node.isLeaf)
      { throw new RangeError("Content hole not allowed in a leaf node spec") }
    if (options.onContent)
      { options.onContent(node, contentDOM, options); }
    else
      { this.serializeFragment(node.content, options, contentDOM); }
  }
  return dom
};

// :: (Node, ?Object) → dom.Node
// Serialize this node to a DOM node. This can be useful when you
// need to serialize a part of a document, as opposed to the whole
// document. To serialize a whole document, use
// [`serializeFragment`](#model.DOMSerializer.serializeFragment) on
// its [content](#model.Node.content).
DOMSerializer.prototype.serializeNode = function serializeNode (node, options) {
    if ( options === void 0 ) options = {};

  var dom = this.serializeNodeInner(node, options);
  for (var i = node.marks.length - 1; i >= 0; i--) {
    var wrap = this.serializeMark(node.marks[i], node.isInline, options);
    if (wrap) {
(wrap.contentDOM || wrap.dom).appendChild(dom);
      dom = wrap.dom;
    }
  }
  return dom
};

DOMSerializer.prototype.serializeMark = function serializeMark (mark, inline, options) {
    if ( options === void 0 ) options = {};

  var toDOM = this.marks[mark.type.name];
  return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline))
};

// :: (dom.Document, DOMOutputSpec) → {dom: dom.Node, contentDOM: ?dom.Node}
// Render an [output spec](#model.DOMOutputSpec) to a DOM node. If
// the spec has a hole (zero) in it, `contentDOM` will point at the
// node with the hole.
DOMSerializer.renderSpec = function renderSpec (doc, structure, xmlNS) {
    if ( xmlNS === void 0 ) xmlNS = null;

  if (typeof structure == "string")
    { return {dom: doc.createTextNode(structure)} }
  if (structure.nodeType != null)
    { return {dom: structure} }
  if (structure.dom && structure.dom.nodeType != null)
    { return structure }
  var tagName = structure[0], space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  var contentDOM = null, dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
  var attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (var name in attrs) { if (attrs[name] != null) {
      var space$1 = name.indexOf(" ");
      if (space$1 > 0) { dom.setAttributeNS(name.slice(0, space$1), name.slice(space$1 + 1), attrs[name]); }
      else { dom.setAttribute(name, attrs[name]); }
    } }
  }
  for (var i = start; i < structure.length; i++) {
    var child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        { throw new RangeError("Content hole must be the only child of its parent node") }
      return {dom: dom, contentDOM: dom}
    } else {
      var ref = DOMSerializer.renderSpec(doc, child, xmlNS);
        var inner = ref.dom;
        var innerContent = ref.contentDOM;
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM) { throw new RangeError("Multiple content holes") }
        contentDOM = innerContent;
      }
    }
  }
  return {dom: dom, contentDOM: contentDOM}
};

// :: (Schema) → DOMSerializer
// Build a serializer using the [`toDOM`](#model.NodeSpec.toDOM)
// properties in a schema's node and mark specs.
DOMSerializer.fromSchema = function fromSchema (schema) {
  return schema.cached.domSerializer ||
    (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)))
};

// : (Schema) → Object<(node: Node) → DOMOutputSpec>
// Gather the serializers in a schema's node specs into an object.
// This can be useful as a base to build a custom serializer from.
DOMSerializer.nodesFromSchema = function nodesFromSchema (schema) {
  var result = gatherToDOM(schema.nodes);
  if (!result.text) { result.text = function (node) { return node.text; }; }
  return result
};

// : (Schema) → Object<(mark: Mark) → DOMOutputSpec>
// Gather the serializers in a schema's mark specs into an object.
DOMSerializer.marksFromSchema = function marksFromSchema (schema) {
  return gatherToDOM(schema.marks)
};

function gatherToDOM(obj) {
  var result = {};
  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) { result[name] = toDOM; }
  }
  return result
}

function doc(options) {
  // declare global: window
  return options.document || window.document
}


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 42 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>) → OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (OrderedMap);


/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddMarkStep": () => (/* binding */ AddMarkStep),
/* harmony export */   "MapResult": () => (/* binding */ MapResult),
/* harmony export */   "Mapping": () => (/* binding */ Mapping),
/* harmony export */   "RemoveMarkStep": () => (/* binding */ RemoveMarkStep),
/* harmony export */   "ReplaceAroundStep": () => (/* binding */ ReplaceAroundStep),
/* harmony export */   "ReplaceStep": () => (/* binding */ ReplaceStep),
/* harmony export */   "Step": () => (/* binding */ Step),
/* harmony export */   "StepMap": () => (/* binding */ StepMap),
/* harmony export */   "StepResult": () => (/* binding */ StepResult),
/* harmony export */   "Transform": () => (/* binding */ Transform),
/* harmony export */   "TransformError": () => (/* binding */ TransformError),
/* harmony export */   "canJoin": () => (/* binding */ canJoin),
/* harmony export */   "canSplit": () => (/* binding */ canSplit),
/* harmony export */   "dropPoint": () => (/* binding */ dropPoint),
/* harmony export */   "findWrapping": () => (/* binding */ findWrapping),
/* harmony export */   "insertPoint": () => (/* binding */ insertPoint),
/* harmony export */   "joinPoint": () => (/* binding */ joinPoint),
/* harmony export */   "liftTarget": () => (/* binding */ liftTarget),
/* harmony export */   "replaceStep": () => (/* binding */ replaceStep)
/* harmony export */ });
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);


// Mappable:: interface
// There are several things that positions can be mapped through.
// Such objects conform to this interface.
//
//   map:: (pos: number, assoc: ?number) → number
//   Map a position through this object. When given, `assoc` (should
//   be -1 or 1, defaults to 1) determines with which side the
//   position is associated, which determines in which direction to
//   move when a chunk of content is inserted at the mapped position.
//
//   mapResult:: (pos: number, assoc: ?number) → MapResult
//   Map a position, and return an object containing additional
//   information about the mapping. The result's `deleted` field tells
//   you whether the position was deleted (completely enclosed in a
//   replaced range) during the mapping. When content on only one side
//   is deleted, the position itself is only considered deleted when
//   `assoc` points in the direction of the deleted content.

// Recovery values encode a range index and an offset. They are
// represented as numbers, because tons of them will be created when
// mapping, for example, a large number of decorations. The number's
// lower 16 bits provide the index, the remaining bits the offset.
//
// Note: We intentionally don't use bit shift operators to en- and
// decode these, since those clip to 32 bits, which we might in rare
// cases want to overflow. A 64-bit float can represent 48-bit
// integers precisely.

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) { return index + offset * factor16 }
function recoverIndex(value) { return value & lower16 }
function recoverOffset(value) { return (value - (value & lower16)) / factor16 }

// ::- An object representing a mapped position with extra
// information.
var MapResult = function MapResult(pos, deleted, recover) {
  if ( deleted === void 0 ) deleted = false;
  if ( recover === void 0 ) recover = null;

  // :: number The mapped version of the position.
  this.pos = pos;
  // :: bool Tells you whether the position was deleted, that is,
  // whether the step removed its surroundings from the document.
  this.deleted = deleted;
  this.recover = recover;
};

// :: class extends Mappable
// A map describing the deletions and insertions made by a step, which
// can be used to find the correspondence between positions in the
// pre-step version of a document and the same position in the
// post-step version.
var StepMap = function StepMap(ranges, inverted) {
  if ( inverted === void 0 ) inverted = false;

  if (!ranges.length && StepMap.empty) { return StepMap.empty }
  this.ranges = ranges;
  this.inverted = inverted;
};

StepMap.prototype.recover = function recover (value) {
  var diff = 0, index = recoverIndex(value);
  if (!this.inverted) { for (var i = 0; i < index; i++)
    { diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; } }
  return this.ranges[index * 3] + diff + recoverOffset(value)
};

// : (number, ?number) → MapResult
StepMap.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

// : (number, ?number) → number
StepMap.prototype.map = function map (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, true) };

StepMap.prototype._map = function _map (pos, assoc, simple) {
  var diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
    if (pos <= end) {
      var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
      var result = start + diff + (side < 0 ? 0 : newSize);
      if (simple) { return result }
      var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
      return new MapResult(result, assoc < 0 ? pos != start : pos != end, recover)
    }
    diff += newSize - oldSize;
  }
  return simple ? pos + diff : new MapResult(pos + diff)
};

StepMap.prototype.touches = function touches (pos, recover) {
  var diff = 0, index = recoverIndex(recover);
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i] - (this.inverted ? diff : 0);
    if (start > pos) { break }
    var oldSize = this.ranges[i + oldIndex], end = start + oldSize;
    if (pos <= end && i == index * 3) { return true }
    diff += this.ranges[i + newIndex] - oldSize;
  }
  return false
};

// :: ((oldStart: number, oldEnd: number, newStart: number, newEnd: number))
// Calls the given function on each of the changed ranges included in
// this map.
StepMap.prototype.forEach = function forEach (f) {
  var oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
  for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
    var start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
    var oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
    f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
    diff += newSize - oldSize;
  }
};

// :: () → StepMap
// Create an inverted version of this map. The result can be used to
// map positions in the post-step document to the pre-step document.
StepMap.prototype.invert = function invert () {
  return new StepMap(this.ranges, !this.inverted)
};

StepMap.prototype.toString = function toString () {
  return (this.inverted ? "-" : "") + JSON.stringify(this.ranges)
};

// :: (n: number) → StepMap
// Create a map that moves all positions by offset `n` (which may be
// negative). This can be useful when applying steps meant for a
// sub-document to a larger document, or vice-versa.
StepMap.offset = function offset (n) {
  return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n])
};

// :: StepMap
// A StepMap that contains no changed ranges.
StepMap.empty = new StepMap([]);

// :: class extends Mappable
// A mapping represents a pipeline of zero or more [step
// maps](#transform.StepMap). It has special provisions for losslessly
// handling mapping positions through a series of steps in which some
// steps are inverted versions of earlier steps. (This comes up when
// ‘[rebasing](/docs/guide/#transform.rebasing)’ steps for
// collaboration or history management.)
var Mapping = function Mapping(maps, mirror, from, to) {
  // :: [StepMap]
  // The step maps in this mapping.
  this.maps = maps || [];
  // :: number
  // The starting position in the `maps` array, used when `map` or
  // `mapResult` is called.
  this.from = from || 0;
  // :: number
  // The end position in the `maps` array.
  this.to = to == null ? this.maps.length : to;
  this.mirror = mirror;
};

// :: (?number, ?number) → Mapping
// Create a mapping that maps only through a part of this one.
Mapping.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.maps.length;

  return new Mapping(this.maps, this.mirror, from, to)
};

Mapping.prototype.copy = function copy () {
  return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to)
};

// :: (StepMap, ?number)
// Add a step map to the end of this mapping. If `mirrors` is
// given, it should be the index of the step map that is the mirror
// image of this one.
Mapping.prototype.appendMap = function appendMap (map, mirrors) {
  this.to = this.maps.push(map);
  if (mirrors != null) { this.setMirror(this.maps.length - 1, mirrors); }
};

// :: (Mapping)
// Add all the step maps in a given mapping to this one (preserving
// mirroring information).
Mapping.prototype.appendMapping = function appendMapping (mapping) {
  for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : null);
  }
};

// :: (number) → ?number
// Finds the offset of the step map that mirrors the map at the
// given offset, in this mapping (as per the second argument to
// `appendMap`).
Mapping.prototype.getMirror = function getMirror (n) {
  if (this.mirror) { for (var i = 0; i < this.mirror.length; i++)
    { if (this.mirror[i] == n) { return this.mirror[i + (i % 2 ? -1 : 1)] } } }
};

Mapping.prototype.setMirror = function setMirror (n, m) {
  if (!this.mirror) { this.mirror = []; }
  this.mirror.push(n, m);
};

// :: (Mapping)
// Append the inverse of the given mapping to this one.
Mapping.prototype.appendMappingInverted = function appendMappingInverted (mapping) {
  for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
    var mirr = mapping.getMirror(i);
    this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : null);
  }
};

// :: () → Mapping
// Create an inverted version of this mapping.
Mapping.prototype.invert = function invert () {
  var inverse = new Mapping;
  inverse.appendMappingInverted(this);
  return inverse
};

// : (number, ?number) → number
// Map a position through this mapping.
Mapping.prototype.map = function map (pos, assoc) {
    if ( assoc === void 0 ) assoc = 1;

  if (this.mirror) { return this._map(pos, assoc, true) }
  for (var i = this.from; i < this.to; i++)
    { pos = this.maps[i].map(pos, assoc); }
  return pos
};

// : (number, ?number) → MapResult
// Map a position through this mapping, returning a mapping
// result.
Mapping.prototype.mapResult = function mapResult (pos, assoc) {
  if ( assoc === void 0 ) assoc = 1;
 return this._map(pos, assoc, false) };

Mapping.prototype._map = function _map (pos, assoc, simple) {
  var deleted = false;

  for (var i = this.from; i < this.to; i++) {
    var map = this.maps[i], result = map.mapResult(pos, assoc);
    if (result.recover != null) {
      var corr = this.getMirror(i);
      if (corr != null && corr > i && corr < this.to) {
        i = corr;
        pos = this.maps[corr].recover(result.recover);
        continue
      }
    }

    if (result.deleted) { deleted = true; }
    pos = result.pos;
  }

  return simple ? pos : new MapResult(pos, deleted)
};

function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err
}

TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";

// ::- Abstraction to build up and track an array of
// [steps](#transform.Step) representing a document transformation.
//
// Most transforming methods return the `Transform` object itself, so
// that they can be chained.
var Transform = function Transform(doc) {
  // :: Node
  // The current document (the result of applying the steps in the
  // transform).
  this.doc = doc;
  // :: [Step]
  // The steps in this transform.
  this.steps = [];
  // :: [Node]
  // The documents before each of the steps.
  this.docs = [];
  // :: Mapping
  // A mapping with the maps for each of the steps in this transform.
  this.mapping = new Mapping;
};

var prototypeAccessors = { before: { configurable: true },docChanged: { configurable: true } };

// :: Node The starting document.
prototypeAccessors.before.get = function () { return this.docs.length ? this.docs[0] : this.doc };

// :: (step: Step) → this
// Apply a new step in this transform, saving the result. Throws an
// error when the step fails.
Transform.prototype.step = function step (object) {
  var result = this.maybeStep(object);
  if (result.failed) { throw new TransformError(result.failed) }
  return this
};

// :: (Step) → StepResult
// Try to apply a step in this transformation, ignoring it if it
// fails. Returns the step result.
Transform.prototype.maybeStep = function maybeStep (step) {
  var result = step.apply(this.doc);
  if (!result.failed) { this.addStep(step, result.doc); }
  return result
};

// :: bool
// True when the document has been changed (when there are any
// steps).
prototypeAccessors.docChanged.get = function () {
  return this.steps.length > 0
};

Transform.prototype.addStep = function addStep (step, doc) {
  this.docs.push(this.doc);
  this.steps.push(step);
  this.mapping.appendMap(step.getMap());
  this.doc = doc;
};

Object.defineProperties( Transform.prototype, prototypeAccessors );

function mustOverride() { throw new Error("Override me") }

var stepsByID = Object.create(null);

// ::- A step object represents an atomic change. It generally applies
// only to the document it was created for, since the positions
// stored in it will only make sense for that document.
//
// New steps are defined by creating classes that extend `Step`,
// overriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`
// methods, and registering your class with a unique
// JSON-serialization identifier using
// [`Step.jsonID`](#transform.Step^jsonID).
var Step = function Step () {};

Step.prototype.apply = function apply (_doc) { return mustOverride() };

// :: () → StepMap
// Get the step map that represents the changes made by this step,
// and which can be used to transform between positions in the old
// and the new document.
Step.prototype.getMap = function getMap () { return StepMap.empty };

// :: (doc: Node) → Step
// Create an inverted version of this step. Needs the document as it
// was before the step as argument.
Step.prototype.invert = function invert (_doc) { return mustOverride() };

// :: (mapping: Mappable) → ?Step
// Map this step through a mappable thing, returning either a
// version of that step with its positions adjusted, or `null` if
// the step was entirely deleted by the mapping.
Step.prototype.map = function map (_mapping) { return mustOverride() };

// :: (other: Step) → ?Step
// Try to merge this step with another one, to be applied directly
// after it. Returns the merged step when possible, null if the
// steps can't be merged.
Step.prototype.merge = function merge (_other) { return null };

// :: () → Object
// Create a JSON-serializeable representation of this step. When
// defining this for a custom subclass, make sure the result object
// includes the step type's [JSON id](#transform.Step^jsonID) under
// the `stepType` property.
Step.prototype.toJSON = function toJSON () { return mustOverride() };

// :: (Schema, Object) → Step
// Deserialize a step from its JSON representation. Will call
// through to the step class' own implementation of this method.
Step.fromJSON = function fromJSON (schema, json) {
  if (!json || !json.stepType) { throw new RangeError("Invalid input for Step.fromJSON") }
  var type = stepsByID[json.stepType];
  if (!type) { throw new RangeError(("No step type " + (json.stepType) + " defined")) }
  return type.fromJSON(schema, json)
};

// :: (string, constructor<Step>)
// To be able to serialize steps to JSON, each step needs a string
// ID to attach to its JSON representation. Use this method to
// register an ID for your step classes. Try to pick something
// that's unlikely to clash with steps from other modules.
Step.jsonID = function jsonID (id, stepClass) {
  if (id in stepsByID) { throw new RangeError("Duplicate use of step JSON ID " + id) }
  stepsByID[id] = stepClass;
  stepClass.prototype.jsonID = id;
  return stepClass
};

// ::- The result of [applying](#transform.Step.apply) a step. Contains either a
// new document or a failure value.
var StepResult = function StepResult(doc, failed) {
  // :: ?Node The transformed document.
  this.doc = doc;
  // :: ?string Text providing information about a failed step.
  this.failed = failed;
};

// :: (Node) → StepResult
// Create a successful step result.
StepResult.ok = function ok (doc) { return new StepResult(doc, null) };

// :: (string) → StepResult
// Create a failed step result.
StepResult.fail = function fail (message) { return new StepResult(null, message) };

// :: (Node, number, number, Slice) → StepResult
// Call [`Node.replace`](#model.Node.replace) with the given
// arguments. Create a successful result if it succeeds, and a
// failed one if it throws a `ReplaceError`.
StepResult.fromReplace = function fromReplace (doc, from, to, slice) {
  try {
    return StepResult.ok(doc.replace(from, to, slice))
  } catch (e) {
    if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) { return StepResult.fail(e.message) }
    throw e
  }
};

// ::- Replace a part of the document with a slice of new content.
var ReplaceStep = /*@__PURE__*/(function (Step) {
  function ReplaceStep(from, to, slice, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceStep.__proto__ = Step;
  ReplaceStep.prototype = Object.create( Step && Step.prototype );
  ReplaceStep.prototype.constructor = ReplaceStep;

  ReplaceStep.prototype.apply = function apply (doc) {
    if (this.structure && contentBetween(doc, this.from, this.to))
      { return StepResult.fail("Structure replace would overwrite content") }
    return StepResult.fromReplace(doc, this.from, this.to, this.slice)
  };

  ReplaceStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.to - this.from, this.slice.size])
  };

  ReplaceStep.prototype.invert = function invert (doc) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to))
  };

  ReplaceStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted) { return null }
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice)
  };

  ReplaceStep.prototype.merge = function merge (other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure) { return null }

    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      var slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure)
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      var slice$1 = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
          : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice$1, this.structure)
    } else {
      return null
    }
  };

  ReplaceStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replace", from: this.from, to: this.to};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for ReplaceStep.fromJSON") }
    return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure)
  };

  return ReplaceStep;
}(Step));

Step.jsonID("replace", ReplaceStep);

// ::- Replace a part of the document with a slice of content, but
// preserve a range of the replaced content by moving it into the
// slice.
var ReplaceAroundStep = /*@__PURE__*/(function (Step) {
  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert, structure) {
    Step.call(this);
    // :: number
    // The start position of the replaced range.
    this.from = from;
    // :: number
    // The end position of the replaced range.
    this.to = to;
    // :: number
    // The start of preserved range.
    this.gapFrom = gapFrom;
    // :: number
    // The end of preserved range.
    this.gapTo = gapTo;
    // :: Slice
    // The slice to insert.
    this.slice = slice;
    // :: number
    // The position in the slice where the preserved range should be
    // inserted.
    this.insert = insert;
    this.structure = !!structure;
  }

  if ( Step ) ReplaceAroundStep.__proto__ = Step;
  ReplaceAroundStep.prototype = Object.create( Step && Step.prototype );
  ReplaceAroundStep.prototype.constructor = ReplaceAroundStep;

  ReplaceAroundStep.prototype.apply = function apply (doc) {
    if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||
                           contentBetween(doc, this.gapTo, this.to)))
      { return StepResult.fail("Structure gap-replace would overwrite content") }

    var gap = doc.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      { return StepResult.fail("Gap is not a flat range") }
    var inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted) { return StepResult.fail("Content does not fit in gap") }
    return StepResult.fromReplace(doc, this.from, this.to, inserted)
  };

  ReplaceAroundStep.prototype.getMap = function getMap () {
    return new StepMap([this.from, this.gapFrom - this.from, this.insert,
                        this.gapTo, this.to - this.gapTo, this.slice.size - this.insert])
  };

  ReplaceAroundStep.prototype.invert = function invert (doc) {
    var gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap,
                                 this.from + this.insert, this.from + this.insert + gap,
                                 doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
                                 this.gapFrom - this.from, this.structure)
  };

  ReplaceAroundStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    var gapFrom = mapping.map(this.gapFrom, -1), gapTo = mapping.map(this.gapTo, 1);
    if ((from.deleted && to.deleted) || gapFrom < from.pos || gapTo > to.pos) { return null }
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure)
  };

  ReplaceAroundStep.prototype.toJSON = function toJSON () {
    var json = {stepType: "replaceAround", from: this.from, to: this.to,
                gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert};
    if (this.slice.size) { json.slice = this.slice.toJSON(); }
    if (this.structure) { json.structure = true; }
    return json
  };

  ReplaceAroundStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" ||
        typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      { throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON") }
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo,
                                 prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure)
  };

  return ReplaceAroundStep;
}(Step));

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from), dist = to - from, depth = $from.depth;
  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }
  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist > 0) {
      if (!next || next.isLeaf) { return true }
      next = next.firstChild;
      dist--;
    }
  }
  return false
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) &&
    (end == node.childCount || node.canReplace(0, end))
}

// :: (NodeRange) → ?number
// Try to find a target depth to which the content in the given range
// can be lifted. Will not go across
// [isolating](#model.NodeSpec.isolating) parent nodes.
function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);
  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content))
      { return depth }
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) { break }
  }
}

// :: (NodeRange, number) → this
// Split the content in the given range off from its parent, if there
// is sibling content before or after it, and move it up the tree to
// the depth specified by `target`. You'll probably want to use
// [`liftTarget`](#transform.liftTarget) to compute `target`, to make
// sure the lift is valid.
Transform.prototype.lift = function(range, target) {
  var $from = range.$from;
  var $to = range.$to;
  var depth = range.depth;

  var gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  var start = gapStart, end = gapEnd;

  var before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;
  for (var d = depth, splitting = false; d > target; d--)
    { if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    } }
  var after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;
  for (var d$1 = depth, splitting$1 = false; d$1 > target; d$1--)
    { if (splitting$1 || $to.after(d$1 + 1) < $to.end(d$1)) {
      splitting$1 = true;
      after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d$1).copy(after));
      openEnd++;
    } else {
      end++;
    } }

  return this.step(new ReplaceAroundStep(start, end, gapStart, gapEnd,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd),
                                         before.size - openStart, true))
};

// :: (NodeRange, NodeType, ?Object, ?NodeRange) → ?[{type: NodeType, attrs: ?Object}]
// Try to find a valid way to wrap the content in the given range in a
// node of the given type. May introduce extra nodes around and inside
// the wrapper node, if necessary. Returns null if no valid wrapping
// could be found. When `innerRange` is given, that range's content is
// used as the content to fit into the wrapping, instead of the
// content of `range`.
function findWrapping(range, nodeType, attrs, innerRange) {
  if ( innerRange === void 0 ) innerRange = range;

  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) { return null }
  return around.map(withAttrs).concat({type: nodeType, attrs: attrs}).concat(inner.map(withAttrs))
}

function withAttrs(type) { return {type: type, attrs: null} }

function findWrappingOutside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) { return null }
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null
}

function findWrappingInside(range, type) {
  var parent = range.parent;
  var startIndex = range.startIndex;
  var endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) { return null }
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;
  for (var i = startIndex; innerMatch && i < endIndex; i++)
    { innerMatch = innerMatch.matchType(parent.child(i).type); }
  if (!innerMatch || !innerMatch.validEnd) { return null }
  return inside
}

// :: (NodeRange, [{type: NodeType, attrs: ?Object}]) → this
// Wrap the given [range](#model.NodeRange) in the given set of wrappers.
// The wrappers are assumed to be valid in this position, and should
// probably be computed with [`findWrapping`](#transform.findWrapping).
Transform.prototype.wrap = function(range, wrappers) {
  var content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      var match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        { throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") }
    }
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  var start = range.start, end = range.end;
  return this.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true))
};

// :: (number, ?number, NodeType, ?Object) → this
// Set the type of all textblocks (partly) between `from` and `to` to
// the given node type with the given attributes.
Transform.prototype.setBlockType = function(from, to, type, attrs) {
  var this$1 = this;
  if ( to === void 0 ) to = from;

  if (!type.isTextblock) { throw new RangeError("Type given to setBlockType should be a textblock") }
  var mapFrom = this.steps.length;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(this$1.doc, this$1.mapping.slice(mapFrom).map(pos), type)) {
      // Ensure all markup that isn't allowed in the new node type is cleared
      this$1.clearIncompatible(this$1.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = this$1.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      this$1.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1,
                                      new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false
    }
  });
  return this
};

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type)
}

// :: (number, ?NodeType, ?Object, ?[Mark]) → this
// Change the type, attributes, and/or marks of the node at `pos`.
// When `type` isn't given, the existing node type is preserved,
Transform.prototype.setNodeMarkup = function(pos, type, attrs, marks) {
  var node = this.doc.nodeAt(pos);
  if (!node) { throw new RangeError("No node at given position") }
  if (!type) { type = node.type; }
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    { return this.replaceWith(pos, pos + node.nodeSize, newNode) }

  if (!type.validContent(node.content))
    { throw new RangeError("Invalid content for node type " + type.name) }

  return this.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1,
                                         new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true))
};

// :: (Node, number, number, ?[?{type: NodeType, attrs: ?Object}]) → bool
// Check whether splitting at the given position is allowed.
function canSplit(doc, pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = doc.resolve(pos), base = $pos.depth - depth;
  var innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating ||
      !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||
      !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    { return false }
  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d), index$1 = $pos.index(d);
    if (node.type.spec.isolating) { return false }
    var rest = node.content.cutByIndex(index$1, node.childCount);
    var after = (typesAfter && typesAfter[i]) || node;
    if (after != node) { rest = rest.replaceChild(0, after.type.create(after.attrs)); }
    if (!node.canReplace(index$1 + 1, node.childCount) || !after.type.validContent(rest))
      { return false }
  }
  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type)
}

// :: (number, ?number, ?[?{type: NodeType, attrs: ?Object}]) → this
// Split the node at the given position, and optionally, if `depth` is
// greater than one, any number of nodes above that. By default, the
// parts split off will inherit the node type of the original node.
// This can be changed by passing an array of types and attributes to
// use after the split.
Transform.prototype.split = function(pos, depth, typesAfter) {
  if ( depth === void 0 ) depth = 1;

  var $pos = this.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }
  return this.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true))
};

// :: (Node, number) → bool
// Test whether the blocks before and after a given position can be
// joined.
function canJoin(doc, pos) {
  var $pos = doc.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) &&
    $pos.parent.canReplace(index, index + 1)
}

function joinable(a, b) {
  return a && b && !a.isLeaf && a.canAppend(b)
}

// :: (Node, number, ?number) → ?number
// Find an ancestor of the given position that can be joined to the
// block before (or after if `dir` is positive). Returns the joinable
// point, if any.
function joinPoint(doc, pos, dir) {
  if ( dir === void 0 ) dir = -1;

  var $pos = doc.resolve(pos);
  for (var d = $pos.depth;; d--) {
    var before = (void 0), after = (void 0), index = $pos.index(d);
    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) &&
        $pos.node(d).canReplace(index, index + 1)) { return pos }
    if (d == 0) { break }
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

// :: (number, ?number) → this
// Join the blocks around the given position. If depth is 2, their
// last and first siblings are also joined, and so on.
Transform.prototype.join = function(pos, depth) {
  if ( depth === void 0 ) depth = 1;

  var step = new ReplaceStep(pos - depth, pos + depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true);
  return this.step(step)
};

// :: (Node, number, NodeType) → ?number
// Try to find a point where a node of the given type can be inserted
// near `pos`, by searching up the node hierarchy when `pos` itself
// isn't a valid place but is at the start or end of a node. Return
// null if no position was found.
function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) { return pos }

  if ($pos.parentOffset == 0)
    { for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);
      if ($pos.node(d).canReplaceWith(index, index, nodeType)) { return $pos.before(d + 1) }
      if (index > 0) { return null }
    } }
  if ($pos.parentOffset == $pos.parent.content.size)
    { for (var d$1 = $pos.depth - 1; d$1 >= 0; d$1--) {
      var index$1 = $pos.indexAfter(d$1);
      if ($pos.node(d$1).canReplaceWith(index$1, index$1, nodeType)) { return $pos.after(d$1 + 1) }
      if (index$1 < $pos.node(d$1).childCount) { return null }
    } }
}

// :: (Node, number, Slice) → ?number
// Finds a position at or around the given position where the given
// slice can be inserted. Will look at parent nodes' nearest boundary
// and try there, even if the original position wasn't directly at the
// start or end of that node. Returns null when no position was found.
function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) { return pos }
  var content = slice.content;
  for (var i = 0; i < slice.openStart; i++) { content = content.firstChild.content; }
  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        { return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1) }
    }
  }
  return null
}

function mapFragment(fragment, f, parent) {
  var mapped = [];
  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) { child = child.copy(mapFragment(child.content, f, child)); }
    if (child.isInline) { child = f(child, parent, i); }
    mapped.push(child);
  }
  return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped)
}

// ::- Add a mark to all inline content between two positions.
var AddMarkStep = /*@__PURE__*/(function (Step) {
  function AddMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the marked range.
    this.from = from;
    // :: number
    // The end of the marked range.
    this.to = to;
    // :: Mark
    // The mark to add.
    this.mark = mark;
  }

  if ( Step ) AddMarkStep.__proto__ = Step;
  AddMarkStep.prototype = Object.create( Step && Step.prototype );
  AddMarkStep.prototype.constructor = AddMarkStep;

  AddMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);
    var parent = $from.node($from.sharedDepth(this.to));
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node, parent) {
      if (!node.isAtom || !parent.type.allowsMarkType(this$1.mark.type)) { return node }
      return node.mark(this$1.mark.addToSet(node.marks))
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  AddMarkStep.prototype.invert = function invert () {
    return new RemoveMarkStep(this.from, this.to, this.mark)
  };

  AddMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new AddMarkStep(from.pos, to.pos, this.mark)
  };

  AddMarkStep.prototype.merge = function merge (other) {
    if (other instanceof AddMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new AddMarkStep(Math.min(this.from, other.from),
                             Math.max(this.to, other.to), this.mark) }
  };

  AddMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "addMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  AddMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for AddMarkStep.fromJSON") }
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return AddMarkStep;
}(Step));

Step.jsonID("addMark", AddMarkStep);

// ::- Remove a mark from all inline content between two positions.
var RemoveMarkStep = /*@__PURE__*/(function (Step) {
  function RemoveMarkStep(from, to, mark) {
    Step.call(this);
    // :: number
    // The start of the unmarked range.
    this.from = from;
    // :: number
    // The end of the unmarked range.
    this.to = to;
    // :: Mark
    // The mark to remove.
    this.mark = mark;
  }

  if ( Step ) RemoveMarkStep.__proto__ = Step;
  RemoveMarkStep.prototype = Object.create( Step && Step.prototype );
  RemoveMarkStep.prototype.constructor = RemoveMarkStep;

  RemoveMarkStep.prototype.apply = function apply (doc) {
    var this$1 = this;

    var oldSlice = doc.slice(this.from, this.to);
    var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, function (node) {
      return node.mark(this$1.mark.removeFromSet(node.marks))
    }), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc, this.from, this.to, slice)
  };

  RemoveMarkStep.prototype.invert = function invert () {
    return new AddMarkStep(this.from, this.to, this.mark)
  };

  RemoveMarkStep.prototype.map = function map (mapping) {
    var from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos) { return null }
    return new RemoveMarkStep(from.pos, to.pos, this.mark)
  };

  RemoveMarkStep.prototype.merge = function merge (other) {
    if (other instanceof RemoveMarkStep &&
        other.mark.eq(this.mark) &&
        this.from <= other.to && this.to >= other.from)
      { return new RemoveMarkStep(Math.min(this.from, other.from),
                                Math.max(this.to, other.to), this.mark) }
  };

  RemoveMarkStep.prototype.toJSON = function toJSON () {
    return {stepType: "removeMark", mark: this.mark.toJSON(),
            from: this.from, to: this.to}
  };

  RemoveMarkStep.fromJSON = function fromJSON (schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      { throw new RangeError("Invalid input for RemoveMarkStep.fromJSON") }
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark))
  };

  return RemoveMarkStep;
}(Step));

Step.jsonID("removeMark", RemoveMarkStep);

// :: (number, number, Mark) → this
// Add the given mark to the inline content between `from` and `to`.
Transform.prototype.addMark = function(from, to, mark) {
  var this$1 = this;

  var removed = [], added = [], removing = null, adding = null;
  this.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) { return }
    var marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            { removing.to = end; }
          else
            { removed.push(removing = new RemoveMarkStep(start, end, marks[i])); }
        }
      }

      if (adding && adding.to == start)
        { adding.to = end; }
      else
        { added.push(adding = new AddMarkStep(start, end, mark)); }
    }
  });

  removed.forEach(function (s) { return this$1.step(s); });
  added.forEach(function (s) { return this$1.step(s); });
  return this
};

// :: (number, number, ?union<Mark, MarkType>) → this
// Remove marks from inline nodes between `from` and `to`. When `mark`
// is a single mark, remove precisely that mark. When it is a mark type,
// remove all marks of that type. When it is null, remove all marks of
// any type.
Transform.prototype.removeMark = function(from, to, mark) {
  var this$1 = this;
  if ( mark === void 0 ) mark = null;

  var matched = [], step = 0;
  this.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) { return }
    step++;
    var toRemove = null;
    if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {
      var set = node.marks, found;
      while (found = mark.isInSet(set)) {
(toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) { toRemove = [mark]; }
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);
      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i], found$1 = (void 0);
        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) { found$1 = m; }
        }
        if (found$1) {
          found$1.to = end;
          found$1.step = step;
        } else {
          matched.push({style: style, from: Math.max(pos, from), to: end, step: step});
        }
      }
    }
  });
  matched.forEach(function (m) { return this$1.step(new RemoveMarkStep(m.from, m.to, m.style)); });
  return this
};

// :: (number, NodeType, ?ContentMatch) → this
// Removes all marks and nodes from the content of the node at `pos`
// that don't match the given new parent node type. Accepts an
// optional starting [content match](#model.ContentMatch) as third
// argument.
Transform.prototype.clearIncompatible = function(pos, parentType, match) {
  if ( match === void 0 ) match = parentType.contentMatch;

  var node = this.doc.nodeAt(pos);
  var delSteps = [], cur = pos + 1;
  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i), end = cur + child.nodeSize;
    var allowed = match.matchType(child.type, child.attrs);
    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));
    } else {
      match = allowed;
      for (var j = 0; j < child.marks.length; j++) { if (!parentType.allowsMarkType(child.marks[j].type))
        { this.step(new RemoveMarkStep(cur, end, child.marks[j])); } }
    }
    cur = end;
  }
  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
    this.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));
  }
  for (var i$1 = delSteps.length - 1; i$1 >= 0; i$1--) { this.step(delSteps[i$1]); }
  return this
};

// :: (Node, number, ?number, ?Slice) → ?Step
// ‘Fit’ a slice into a given position in the document, producing a
// [step](#transform.Step) that inserts it. Will return null if
// there's no meaningful way to insert the slice here, or inserting it
// would be a no-op (an empty slice over an empty range).
function replaceStep(doc, from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  if (from == to && !slice.size) { return null }

  var $from = doc.resolve(from), $to = doc.resolve(to);
  // Optimization -- avoid work if it's obvious that it's not needed.
  if (fitsTrivially($from, $to, slice)) { return new ReplaceStep(from, to, slice) }
  return new Fitter($from, $to, slice).fit()
}

// :: (number, ?number, ?Slice) → this
// Replace the part of the document between `from` and `to` with the
// given `slice`.
Transform.prototype.replace = function(from, to, slice) {
  if ( to === void 0 ) to = from;
  if ( slice === void 0 ) slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty;

  var step = replaceStep(this.doc, from, to, slice);
  if (step) { this.step(step); }
  return this
};

// :: (number, number, union<Fragment, Node, [Node]>) → this
// Replace the given range with the given content, which may be a
// fragment, node, or array of nodes.
Transform.prototype.replaceWith = function(from, to, content) {
  return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0))
};

// :: (number, number) → this
// Delete the content between the given positions.
Transform.prototype.delete = function(from, to) {
  return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)
};

// :: (number, union<Fragment, Node, [Node]>) → this
// Insert the given content at the given position.
Transform.prototype.insert = function(pos, content) {
  return this.replaceWith(pos, pos, content)
};

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&
    $from.parent.canReplace($from.index(), $to.index(), slice.content)
}

// Algorithm for 'placing' the elements of a slice into a gap:
//
// We consider the content of each node that is open to the left to be
// independently placeable. I.e. in <p("foo"), p("bar")>, when the
// paragraph on the left is open, "foo" can be placed (somewhere on
// the left side of the replacement gap) independently from p("bar").
//
// This class tracks the state of the placement progress in the
// following properties:
//
//  - `frontier` holds a stack of `{type, match}` objects that
//    represent the open side of the replacement. It starts at
//    `$from`, then moves forward as content is placed, and is finally
//    reconciled with `$to`.
//
//  - `unplaced` is a slice that represents the content that hasn't
//    been placed yet.
//
//  - `placed` is a fragment of placed content. Its open-start value
//    is implicit in `$from`, and its open-end value in `frontier`.
var Fitter = function Fitter($from, $to, slice) {
  this.$to = $to;
  this.$from = $from;
  this.unplaced = slice;

  this.frontier = [];
  for (var i = 0; i <= $from.depth; i++) {
    var node = $from.node(i);
    this.frontier.push({
      type: node.type,
      match: node.contentMatchAt($from.indexAfter(i))
    });
  }

  this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;
  for (var i$1 = $from.depth; i$1 > 0; i$1--)
    { this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i$1).copy(this.placed)); }
};

var prototypeAccessors$1 = { depth: { configurable: true } };

prototypeAccessors$1.depth.get = function () { return this.frontier.length - 1 };

Fitter.prototype.fit = function fit () {
  // As long as there's unplaced content, try to place some of it.
  // If that fails, either increase the open score of the unplaced
  // slice, or drop nodes from it, and then try again.
  while (this.unplaced.size) {
    var fit = this.findFittable();
    if (fit) { this.placeNodes(fit); }
    else { this.openMore() || this.dropNode(); }
  }
  // When there's inline content directly after the frontier _and_
  // directly after `this.$to`, we must generate a `ReplaceAround`
  // step that pulls that content into the node after the frontier.
  // That means the fitting must be done to the end of the textblock
  // node after `this.$to`, not `this.$to` itself.
  var moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
  var $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
  if (!$to) { return null }

  // If closing to `$to` succeeded, create a step
  var content = this.placed, openStart = $from.depth, openEnd = $to.depth;
  while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes
    content = content.firstChild.content;
    openStart--; openEnd--;
  }
  var slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);
  if (moveInline > -1)
    { return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize) }
  if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps
    { return new ReplaceStep($from.pos, $to.pos, slice) }
};

// Find a position on the start spine of `this.unplaced` that has
// content that can be moved somewhere on the frontier. Returns two
// depths, one for the slice and one for the frontier.
Fitter.prototype.findFittable = function findFittable () {
  // Only try wrapping nodes (pass 2) after finding a place without
  // wrapping failed.
  for (var pass = 1; pass <= 2; pass++) {
    for (var sliceDepth = this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
      var fragment = (void 0), parent = (void 0);
      if (sliceDepth) {
        parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
        fragment = parent.content;
      } else {
        fragment = this.unplaced.content;
      }
      var first = fragment.firstChild;
      for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
        var ref = this.frontier[frontierDepth];
          var type = ref.type;
          var match = ref.match;
          var wrap = (void 0), inject = (void 0);
        // In pass 1, if the next node matches, or there is no next
        // node but the parents look compatible, we've found a
        // place.
        if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))
                          : type.compatibleContent(parent.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, inject: inject} }
        // In pass 2, look for a set of wrapping nodes that make
        // `first` fit here.
        else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))
          { return {sliceDepth: sliceDepth, frontierDepth: frontierDepth, parent: parent, wrap: wrap} }
        // Don't continue looking further up if the parent node
        // would fit here.
        if (parent && match.matchType(parent.type)) { break }
      }
    }
  }
};

Fitter.prototype.openMore = function openMore () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (!inner.childCount || inner.firstChild.isLeaf) { return false }
  this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1,
                            Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
  return true
};

Fitter.prototype.dropNode = function dropNode () {
  var ref = this.unplaced;
    var content = ref.content;
    var openStart = ref.openStart;
    var openEnd = ref.openEnd;
  var inner = contentAt(content, openStart);
  if (inner.childCount <= 1 && openStart > 0) {
    var openAtEnd = content.size - openStart <= openStart + inner.size;
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1,
                              openAtEnd ? openStart - 1 : openEnd);
  } else {
    this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
  }
};

// : ({sliceDepth: number, frontierDepth: number, parent: ?Node, wrap: ?[NodeType], inject: ?Fragment})
// Move content from the unplaced slice at `sliceDepth` to the
// frontier node at `frontierDepth`. Close that frontier node when
// applicable.
Fitter.prototype.placeNodes = function placeNodes (ref) {
    var sliceDepth = ref.sliceDepth;
    var frontierDepth = ref.frontierDepth;
    var parent = ref.parent;
    var inject = ref.inject;
    var wrap = ref.wrap;

  while (this.depth > frontierDepth) { this.closeFrontierNode(); }
  if (wrap) { for (var i = 0; i < wrap.length; i++) { this.openFrontierNode(wrap[i]); } }

  var slice = this.unplaced, fragment = parent ? parent.content : slice.content;
  var openStart = slice.openStart - sliceDepth;
  var taken = 0, add = [];
  var ref$1 = this.frontier[frontierDepth];
    var match = ref$1.match;
    var type = ref$1.type;
  if (inject) {
    for (var i$1 = 0; i$1 < inject.childCount; i$1++) { add.push(inject.child(i$1)); }
    match = match.matchFragment(inject);
  }
  // Computes the amount of (end) open nodes at the end of the
  // fragment. When 0, the parent is open, but no more. When
  // negative, nothing is open.
  var openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);
  // Scan over the fragment, fitting as many child nodes as
  // possible.
  while (taken < fragment.childCount) {
    var next = fragment.child(taken), matches = match.matchType(next.type);
    if (!matches) { break }
    taken++;
    if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes
      match = matches;
      add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0,
                              taken == fragment.childCount ? openEndCount : -1));
    }
  }
  var toEnd = taken == fragment.childCount;
  if (!toEnd) { openEndCount = -1; }

  this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));
  this.frontier[frontierDepth].match = match;

  // If the parent types match, and the entire node was moved, and
  // it's not open, close this frontier node right away.
  if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
    { this.closeFrontierNode(); }

  // Add new frontier nodes for any open nodes at the end.
  for (var i$2 = 0, cur = fragment; i$2 < openEndCount; i$2++) {
    var node = cur.lastChild;
    this.frontier.push({type: node.type, match: node.contentMatchAt(node.childCount)});
    cur = node.content;
  }

  // Update `this.unplaced`. Drop the entire node from which we
  // placed it we got to its end, otherwise just drop the placed
  // nodes.
  this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)
    : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty
    : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1),
                sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
};

Fitter.prototype.mustMoveInline = function mustMoveInline () {
  if (!this.$to.parent.isTextblock) { return -1 }
  var top = this.frontier[this.depth], level;
  if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||
      (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)) { return -1 }

  var ref = this.$to;
    var depth = ref.depth;
    var after = this.$to.after(depth);
  while (depth > 1 && after == this.$to.end(--depth)) { ++after; }
  return after
};

Fitter.prototype.findCloseLevel = function findCloseLevel ($to) {
  scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
    var ref = this.frontier[i];
      var match = ref.match;
      var type = ref.type;
    var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
    var fit = contentAfterFits($to, i, type, match, dropInner);
    if (!fit) { continue }
    for (var d = i - 1; d >= 0; d--) {
      var ref$1 = this.frontier[d];
        var match$1 = ref$1.match;
        var type$1 = ref$1.type;
      var matches = contentAfterFits($to, d, type$1, match$1, true);
      if (!matches || matches.childCount) { continue scan }
    }
    return {depth: i, fit: fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to}
  }
};

Fitter.prototype.close = function close ($to) {
  var close = this.findCloseLevel($to);
  if (!close) { return null }

  while (this.depth > close.depth) { this.closeFrontierNode(); }
  if (close.fit.childCount) { this.placed = addToFragment(this.placed, close.depth, close.fit); }
  $to = close.move;
  for (var d = close.depth + 1; d <= $to.depth; d++) {
    var node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
    this.openFrontierNode(node.type, node.attrs, add);
  }
  return $to
};

Fitter.prototype.openFrontierNode = function openFrontierNode (type, attrs, content) {
  var top = this.frontier[this.depth];
  top.match = top.match.matchType(type);
  this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));
  this.frontier.push({type: type, match: type.contentMatch});
};

Fitter.prototype.closeFrontierNode = function closeFrontierNode () {
  var open = this.frontier.pop();
  var add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);
  if (add.childCount) { this.placed = addToFragment(this.placed, this.frontier.length, add); }
};

Object.defineProperties( Fitter.prototype, prototypeAccessors$1 );

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) { return fragment.cutByIndex(count) }
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)))
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) { return fragment.append(content) }
  return fragment.replaceChild(fragment.childCount - 1,
                               fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)))
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) { fragment = fragment.firstChild.content; }
  return fragment
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) { return node }
  var frag = node.content;
  if (openStart > 1)
    { frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0)); }
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) { frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true)); }
  }
  return node.copy(frag)
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) { return null }
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++)
    { if (!type.allowsMarks(fragment.child(i).marks)) { return true } }
  return false
}

function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent
}

// :: (number, number, Slice) → this
// Replace a range of the document with a given slice, using `from`,
// `to`, and the slice's [`openStart`](#model.Slice.openStart) property
// as hints, rather than fixed start and end points. This method may
// grow the replaced area or close open nodes in the slice in order to
// get a fit that is more in line with WYSIWYG expectations, by
// dropping fully covered parent nodes of the replaced region when
// they are marked [non-defining as context](#model.NodeSpec.definingAsContext), or
// including an open parent node from the slice that _is_ marked as
// [defining its content](#model.NodeSpec.definingForContent).
//
// This is the method, for example, to handle paste. The similar
// [`replace`](#transform.Transform.replace) method is a more
// primitive tool which will _not_ move the start and end of its given
// range, and is useful in situations where you need more precise
// control over what happens.
Transform.prototype.replaceRange = function(from, to, slice) {
  if (!slice.size) { return this.deleteRange(from, to) }

  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    { return this.step(new ReplaceStep(from, to, slice)) }

  var targetDepths = coveredDepths($from, this.doc.resolve(to));
  // Can't replace the whole document, so remove 0 if it's present
  if (targetDepths[targetDepths.length - 1] == 0) { targetDepths.pop(); }
  // Negative numbers represent not expansion over the whole node at
  // that depth, but replacing from $from.before(-D) to $to.pos.
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  // This loop picks a preferred target depth, if one of the covering
  // depths is not outside of a defining node, and adds negative
  // depths for any depth that has $from at its start and does not
  // cross a defining node.
  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) { break }
    if (targetDepths.indexOf(d) > -1) { preferredTarget = d; }
    else if ($from.before(d) == pos) { targetDepths.splice(1, 0, -d); }
  }
  // Try to fit each possible depth of the slice into each possible
  // target depth, starting with the preferred depths.
  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);

  var leftNodes = [], preferredDepth = slice.openStart;
  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) { break }
    content = node.content;
  }

  // Back up preferredDepth to cover defining textblocks directly
  // above it, possibly skipping a non-defining textblock.
  for (var d$1 = preferredDepth - 1; d$1 >= 0; d$1--) {
    var type = leftNodes[d$1].type, def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type) { preferredDepth = d$1; }
    else if (def || !type.isTextblock) { break }
  }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) { continue }
    for (var i$1 = 0; i$1 < targetDepths.length; i$1++) {
      // Loop over possible expansion levels, starting with the
      // preferred one
      var targetDepth = targetDepths[(i$1 + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) { expand = false; targetDepth = -targetDepth; }
      var parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        { return this.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to,
                            new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth),
                                      openDepth, slice.openEnd)) }
    }
  }

  var startSteps = this.steps.length;
  for (var i$2 = targetDepths.length - 1; i$2 >= 0; i$2--) {
    this.replace(from, to, slice);
    if (this.steps.length > startSteps) { break }
    var depth = targetDepths[i$2];
    if (depth < 0) { continue }
    from = $from.before(depth); to = $to.after(depth);
  }
  return this
};

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));
  }
  return fragment
}

// :: (number, number, Node) → this
// Replace the given range with a node, but use `from` and `to` as
// hints, rather than precise positions. When from and to are the same
// and are at the start or end of a parent node in which the given
// node doesn't fit, this method may _move_ them out towards a parent
// that does allow the given node to be placed. When the given range
// completely covers a parent node, this method may completely replace
// that parent node.
Transform.prototype.replaceRangeWith = function(from, to, node) {
  if (!node.isInline && from == to && this.doc.resolve(from).parent.content.size) {
    var point = insertPoint(this.doc, from, node.type);
    if (point != null) { from = to = point; }
  }
  return this.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0))
};

// :: (number, number) → this
// Delete the given range, expanding it to cover fully covered
// parent nodes until a valid replace is found.
Transform.prototype.deleteRange = function(from, to) {
  var $from = this.doc.resolve(from), $to = this.doc.resolve(to);
  var covered = coveredDepths($from, $to);
  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i], last = i == covered.length - 1;
    if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)
      { return this.delete($from.start(depth), $to.end(depth)) }
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      { return this.delete($from.before(depth), $to.after(depth)) }
  }
  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)
      { return this.delete($from.before(d), to) }
  }
  return this.delete(from, to)
};

// : (ResolvedPos, ResolvedPos) → [number]
// Returns an array of all depths for which $from - $to spans the
// whole content of the nodes at that depth.
function coveredDepths($from, $to) {
  var result = [], minDepth = Math.min($from.depth, $to.depth);
  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) ||
        $to.end(d) > $to.pos + ($to.depth - d) ||
        $from.node(d).type.spec.isolating ||
        $to.node(d).type.spec.isolating) { break }
    if (start == $to.start(d) ||
        (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&
         d && $to.start(d - 1) == start - 1))
      { result.push(d); }
  }
  return result
}


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorState = __webpack_require__(40);



Object.keys(prosemirrorState).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorState[k]; }
	});
});


/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(46);
} else {
  module.exports = __webpack_require__(47);
}


/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorTransform = __webpack_require__(43);



Object.keys(prosemirrorTransform).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorTransform[k]; }
	});
});


/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorTransform = __webpack_require__(43);



Object.keys(prosemirrorTransform).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorTransform[k]; }
	});
});


/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var objectWithoutPropertiesLoose = __webpack_require__(49);

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 49 */
/***/ ((module) => {

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assignStyle": () => (/* reexport safe */ _assignStyle__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   "camelCaseProperty": () => (/* reexport safe */ _camelCaseProperty__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   "cssifyDeclaration": () => (/* reexport safe */ _cssifyDeclaration__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   "cssifyObject": () => (/* reexport safe */ _cssifyObject__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   "hyphenateProperty": () => (/* reexport safe */ _hyphenateProperty__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   "isPrefixedProperty": () => (/* reexport safe */ _isPrefixedProperty__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   "isPrefixedValue": () => (/* reexport safe */ _isPrefixedValue__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   "isUnitlessProperty": () => (/* reexport safe */ _isUnitlessProperty__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   "normalizeProperty": () => (/* reexport safe */ _normalizeProperty__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   "resolveArrayValue": () => (/* reexport safe */ _resolveArrayValue__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   "unprefixProperty": () => (/* reexport safe */ _unprefixProperty__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   "unprefixValue": () => (/* reexport safe */ _unprefixValue__WEBPACK_IMPORTED_MODULE_11__["default"])
/* harmony export */ });
/* harmony import */ var _assignStyle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51);
/* harmony import */ var _camelCaseProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _cssifyDeclaration__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(53);
/* harmony import */ var _cssifyObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(56);
/* harmony import */ var _hyphenateProperty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(54);
/* harmony import */ var _isPrefixedProperty__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(57);
/* harmony import */ var _isPrefixedValue__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(58);
/* harmony import */ var _isUnitlessProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(59);
/* harmony import */ var _normalizeProperty__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60);
/* harmony import */ var _resolveArrayValue__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(62);
/* harmony import */ var _unprefixProperty__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(61);
/* harmony import */ var _unprefixValue__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(63);














/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ assignStyle)
/* harmony export */ });
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(n); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function filterUniqueArray(arr) {
  return arr.filter(function (val, index) {
    return arr.lastIndexOf(val) === index;
  });
}

function assignStyle(base) {
  for (var i = 0, len = arguments.length <= 1 ? 0 : arguments.length - 1; i < len; ++i) {
    var style = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];

    for (var property in style) {
      var value = style[property];
      var baseValue = base[property];

      if (baseValue && value) {
        if (Array.isArray(baseValue)) {
          base[property] = filterUniqueArray(baseValue.concat(value));
          continue;
        }

        if (Array.isArray(value)) {
          base[property] = filterUniqueArray([baseValue].concat(_toConsumableArray(value)));
          continue;
        }

        if (_typeof(value) === 'object') {
          base[property] = assignStyle({}, baseValue, value);
          continue;
        }
      }

      base[property] = value;
    }
  }

  return base;
}

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ camelCaseProperty)
/* harmony export */ });
var DASH = /-([a-z])/g;
var MS = /^Ms/g;
var cache = {};

function toUpper(match) {
  return match[1].toUpperCase();
}

function camelCaseProperty(property) {
  if (cache.hasOwnProperty(property)) {
    return cache[property];
  }

  var camelProp = property.replace(DASH, toUpper).replace(MS, 'ms');
  cache[property] = camelProp;
  return camelProp;
}

/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cssifyDeclaration)
/* harmony export */ });
/* harmony import */ var _hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);

function cssifyDeclaration(property, value) {
  return (0,_hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(property) + ':' + value;
}

/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ hyphenateProperty)
/* harmony export */ });
/* harmony import */ var hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55);

function hyphenateProperty(property) {
  return (0,hyphenate_style_name__WEBPACK_IMPORTED_MODULE_0__["default"])(property);
}

/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g
var msPattern = /^ms-/
var cache = {}

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower)
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (hyphenateStyleName);


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ cssifyObject)
/* harmony export */ });
/* harmony import */ var _cssifyDeclaration__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(53);

function cssifyObject(style) {
  var css = '';

  for (var property in style) {
    var value = style[property];

    if (typeof value !== 'string' && typeof value !== 'number') {
      continue;
    } // prevents the semicolon after
    // the last rule declaration


    if (css) {
      css += ';';
    }

    css += (0,_cssifyDeclaration__WEBPACK_IMPORTED_MODULE_0__["default"])(property, value);
  }

  return css;
}

/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPrefixedProperty)
/* harmony export */ });
var RE = /^(Webkit|Moz|O|ms)/;
function isPrefixedProperty(property) {
  return RE.test(property);
}

/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isPrefixedValue)
/* harmony export */ });
var RE = /-webkit-|-moz-|-ms-/;
function isPrefixedValue(value) {
  return typeof value === 'string' && RE.test(value);
}

/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isUnitlessProperty)
/* harmony export */ });
/* harmony import */ var _hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);

var unitlessProperties = {
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  fontWeight: true,
  lineHeight: true,
  opacity: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};
var prefixedUnitlessProperties = ['animationIterationCount', 'boxFlex', 'boxFlexGroup', 'boxOrdinalGroup', 'columnCount', 'flex', 'flexGrow', 'flexPositive', 'flexShrink', 'flexNegative', 'flexOrder', 'gridColumn', 'gridColumnEnd', 'gridColumnStart', 'gridRow', 'gridRowEnd', 'gridRowStart', 'lineClamp', 'order'];
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

function getPrefixedProperty(prefix, property) {
  return prefix + property.charAt(0).toUpperCase() + property.slice(1);
} // add all prefixed properties to the unitless properties


for (var i = 0, len = prefixedUnitlessProperties.length; i < len; ++i) {
  var property = prefixedUnitlessProperties[i];
  unitlessProperties[property] = true;

  for (var j = 0, jLen = prefixes.length; j < jLen; ++j) {
    unitlessProperties[getPrefixedProperty(prefixes[j], property)] = true;
  }
} // add all hypenated properties as well


for (var _property in unitlessProperties) {
  unitlessProperties[(0,_hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(_property)] = true;
}

function isUnitlessProperty(property) {
  return unitlessProperties.hasOwnProperty(property);
}

/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ normalizeProperty)
/* harmony export */ });
/* harmony import */ var _camelCaseProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52);
/* harmony import */ var _unprefixProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(61);


function normalizeProperty(property) {
  return (0,_unprefixProperty__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_camelCaseProperty__WEBPACK_IMPORTED_MODULE_1__["default"])(property));
}

/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unprefixProperty)
/* harmony export */ });
var RE = /^(ms|Webkit|Moz|O)/;
function unprefixProperty(property) {
  var propertyWithoutPrefix = property.replace(RE, '');
  return propertyWithoutPrefix.charAt(0).toLowerCase() + propertyWithoutPrefix.slice(1);
}

/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ resolveArrayValue)
/* harmony export */ });
/* harmony import */ var _hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);

function resolveArrayValue(property, value) {
  return value.join(';' + (0,_hyphenateProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(property) + ':');
}

/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ unprefixValue)
/* harmony export */ });
var RE = /(-ms-|-webkit-|-moz-|-o-)/g;
function unprefixValue(value) {
  if (typeof value === 'string') {
    return value.replace(RE, '');
  }

  return value;
}

/***/ }),
/* 64 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(65);
} else {
  module.exports = __webpack_require__(66);
}


/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorModel = __webpack_require__(41);



Object.keys(prosemirrorModel).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorModel[k]; }
	});
});


/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorModel = __webpack_require__(41);



Object.keys(prosemirrorModel).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorModel[k]; }
	});
});


/***/ }),
/* 67 */
/***/ ((module) => {

"use strict";


/**
 * @module parenthesis
 */

function parse (str, opts) {
	// pretend non-string parsed per-se
	if (typeof str !== 'string') return [str]

	var res = [str]

	if (typeof opts === 'string' || Array.isArray(opts)) {
		opts = {brackets: opts}
	}
	else if (!opts) opts = {}

	var brackets = opts.brackets ? (Array.isArray(opts.brackets) ? opts.brackets : [opts.brackets]) : ['{}', '[]', '()']

	var escape = opts.escape || '___'

	var flat = !!opts.flat

	brackets.forEach(function (bracket) {
		// create parenthesis regex
		var pRE = new RegExp(['\\', bracket[0], '[^\\', bracket[0], '\\', bracket[1], ']*\\', bracket[1]].join(''))

		var ids = []

		function replaceToken(token, idx, str){
			// save token to res
			var refId = res.push(token.slice(bracket[0].length, -bracket[1].length)) - 1

			ids.push(refId)

			return escape + refId + escape
		}

		res.forEach(function (str, i) {
			var prevStr

			// replace paren tokens till there’s none
			var a = 0
			while (str != prevStr) {
				prevStr = str
				str = str.replace(pRE, replaceToken)
				if (a++ > 10e3) throw Error('References have circular dependency. Please, check them.')
			}

			res[i] = str
		})

		// wrap found refs to brackets
		ids = ids.reverse()
		res = res.map(function (str) {
			ids.forEach(function (id) {
				str = str.replace(new RegExp('(\\' + escape + id + '\\' + escape + ')', 'g'), bracket[0] + '$1' + bracket[1])
			})
			return str
		})
	})

	var re = new RegExp('\\' + escape + '([0-9]+)' + '\\' + escape)

	// transform references to tree
	function nest (str, refs, escape) {
		var res = [], match

		var a = 0
		while (match = re.exec(str)) {
			if (a++ > 10e3) throw Error('Circular references in parenthesis')

			res.push(str.slice(0, match.index))

			res.push(nest(refs[match[1]], refs))

			str = str.slice(match.index + match[0].length)
		}

		res.push(str)

		return res
	}

	return flat ? res : nest(res[0], res)
}

function stringify (arg, opts) {
	if (opts && opts.flat) {
		var escape = opts && opts.escape || '___'

		var str = arg[0], prevStr

		// pretend bad string stringified with no parentheses
		if (!str) return ''


		var re = new RegExp('\\' + escape + '([0-9]+)' + '\\' + escape)

		var a = 0
		while (str != prevStr) {
			if (a++ > 10e3) throw Error('Circular references in ' + arg)
			prevStr = str
			str = str.replace(re, replaceRef)
		}

		return str
	}

	return arg.reduce(function f (prev, curr) {
		if (Array.isArray(curr)) {
			curr = curr.reduce(f, '')
		}
		return prev + curr
	}, '')

	function replaceRef(match, idx){
		if (arg[idx] == null) throw Error('Reference ' + idx + 'is undefined')
		return arg[idx]
	}
}

function parenthesis (arg, opts) {
	if (Array.isArray(arg)) {
		return stringify(arg, opts)
	}
	else {
		return parse(arg, opts)
	}
}

parenthesis.parse = parse
parenthesis.stringify = stringify

module.exports = parenthesis


/***/ }),
/* 68 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(69);
} else {
  module.exports = __webpack_require__(82);
}


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(70);

var COPY_LABEL =
/*i18n*/
{
  id: 'extension.command.copy.label',
  comment: 'Label for copy command.',
  message: 'Copy'
};
var COPY_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.copy.description',
  comment: 'Description for copy command.',
  message: 'Copy the selected text'
};
var CUT_LABEL =
/*i18n*/
{
  id: 'extension.command.cut.label',
  comment: 'Label for cut command.',
  message: 'Cut'
};
var CUT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.cut.description',
  comment: 'Description for cut command.',
  message: 'Cut the selected text'
};
var PASTE_LABEL =
/*i18n*/
{
  id: 'extension.command.paste.label',
  comment: 'Label for paste command.',
  message: 'Paste'
};
var PASTE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.paste.description',
  comment: 'Description for paste command.',
  message: 'Paste content into the editor'
};
var SELECT_ALL_LABEL =
/*i18n*/
{
  id: 'extension.command.select-all.label',
  comment: 'Label for select all command.',
  message: 'Select all'
};
var SELECT_ALL_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.select-all.description',
  comment: 'Description for select all command.',
  message: 'Select all content within the editor'
};

var coreMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  COPY_LABEL: COPY_LABEL,
  COPY_DESCRIPTION: COPY_DESCRIPTION,
  CUT_LABEL: CUT_LABEL,
  CUT_DESCRIPTION: CUT_DESCRIPTION,
  PASTE_LABEL: PASTE_LABEL,
  PASTE_DESCRIPTION: PASTE_DESCRIPTION,
  SELECT_ALL_LABEL: SELECT_ALL_LABEL,
  SELECT_ALL_DESCRIPTION: SELECT_ALL_DESCRIPTION
});

var ESCAPE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.escape',
  comment: 'Label for escape key in shortcuts.',
  message: 'Enter'
};
var COMMAND_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.command',
  comment: 'Label for command key in shortcuts.',
  message: 'Command'
};
var CONTROL_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.control',
  comment: 'Label for control key in shortcuts.',
  message: 'Control'
};
var ENTER_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.enter',
  comment: 'Label for enter key in shortcuts.',
  message: 'Enter'
};
var SHIFT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.shift',
  comment: 'Label for shift key in shortcuts.',
  message: 'Shift'
};
var ALT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.alt',
  comment: 'Label for alt key in shortcuts.',
  message: 'Alt'
};
var CAPS_LOCK_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.capsLock',
  comment: 'Label for caps lock key in shortcuts.',
  message: 'Caps Lock'
};
var BACKSPACE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.backspace',
  comment: 'Label for backspace key in shortcuts.',
  message: 'Backspace'
};
var TAB_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.tab',
  comment: 'Label for tab key in shortcuts.',
  message: 'Tab'
};
var SPACE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.space',
  comment: 'Label for space key in shortcuts.',
  message: 'Space'
};
var DELETE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.delete',
  comment: 'Label for delete key in shortcuts.',
  message: 'Delete'
};
var PAGE_UP_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.pageUp',
  comment: 'Label for page up key in shortcuts.',
  message: 'Page Up'
};
var PAGE_DOWN_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.pageDown',
  comment: 'Label for page down key in shortcuts.',
  message: 'Page Down'
};
var HOME_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.home',
  comment: 'Label for home key in shortcuts.',
  message: 'Home'
};
var END_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.end',
  comment: 'Label for end key in shortcuts.',
  message: 'End'
};
var ARROW_LEFT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowLeft',
  comment: 'Label for arrow left key in shortcuts.',
  message: 'Arrow Left'
};
var ARROW_RIGHT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowRight',
  comment: 'Label for arrow right key in shortcuts.',
  message: 'Arrow Right'
};
var ARROW_UP_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowUp',
  comment: 'Label for arrow up key in shortcuts.',
  message: 'Arrow Up'
};
var ARROW_DOWN_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowDown',
  comment: 'Label for arrowDown key in shortcuts.',
  message: 'Arrow Down'
};

var coreUtilsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ESCAPE_KEY: ESCAPE_KEY,
  COMMAND_KEY: COMMAND_KEY,
  CONTROL_KEY: CONTROL_KEY,
  ENTER_KEY: ENTER_KEY,
  SHIFT_KEY: SHIFT_KEY,
  ALT_KEY: ALT_KEY,
  CAPS_LOCK_KEY: CAPS_LOCK_KEY,
  BACKSPACE_KEY: BACKSPACE_KEY,
  TAB_KEY: TAB_KEY,
  SPACE_KEY: SPACE_KEY,
  DELETE_KEY: DELETE_KEY,
  PAGE_UP_KEY: PAGE_UP_KEY,
  PAGE_DOWN_KEY: PAGE_DOWN_KEY,
  HOME_KEY: HOME_KEY,
  END_KEY: END_KEY,
  ARROW_LEFT_KEY: ARROW_LEFT_KEY,
  ARROW_RIGHT_KEY: ARROW_RIGHT_KEY,
  ARROW_UP_KEY: ARROW_UP_KEY,
  ARROW_DOWN_KEY: ARROW_DOWN_KEY
});

var ADD_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.add-annotation.label',
  comment: 'Label for adding an annotation.',
  message: 'Add annotation'
};
var UPDATE_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.update-annotation.label',
  comment: 'Label for updating an annotation.',
  message: 'Update annotation'
};
var REMOVE_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.remove-annotation.label',
  comment: 'Label for removing an annotation.',
  message: 'Remove annotation'
};

var extensionAnnotationMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ADD_ANNOTATION: ADD_ANNOTATION,
  UPDATE_ANNOTATION: UPDATE_ANNOTATION,
  REMOVE_ANNOTATION: REMOVE_ANNOTATION
});

var LABEL$e =
/*i18n*/
{
  id: 'extension.command.set-text-direction.label',
  comment: 'Label for setting the text direction.',
  message: "{dir, select, ltr {Left-To-Right}\nrtl {Right-To-Left}\nother {Reset Direction}}"
};
var DESCRIPTION$b =
/*i18n*/
{
  id: 'extension.command.set-text-direction.description',
  comment: 'Description for setting the text direction.',
  message: "{dir, select, ltr {Set the text direction from left to right}\nrtl {Set the text direction from right to left}\nother {Reset text direction}}"
};

var extensionBidiMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$e,
  DESCRIPTION: DESCRIPTION$b
});

var LABEL$d =
/*i18n*/
{
  id: 'extension.command.toggle-blockquote.label',
  comment: 'Label for blockquote formatting command.',
  message: 'Blockquote'
};
var DESCRIPTION$a =
/*i18n*/
{
  id: 'extension.command.toggle-blockquote.description',
  comment: 'Description for blockquote formatting command.',
  message: 'Add blockquote formatting to the selected text'
};

var extensionBlockquoteMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$d,
  DESCRIPTION: DESCRIPTION$a
});

var LABEL$c =
/*i18n*/
{
  id: 'extension.command.toggle-bold.label',
  comment: 'Label for bold formatting command.',
  message: 'Bold'
};
var DESCRIPTION$9 =
/*i18n*/
{
  id: 'extension.command.toggle-bold.description',
  comment: 'Description for bold formatting command.',
  message: 'Add bold formatting to the selected text'
};

var extensionBoldMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$c,
  DESCRIPTION: DESCRIPTION$9
});

var LABEL$b =
/*i18n*/
{
  id: 'extension.command.toggle-callout.label',
  comment: 'Label for callout command with support for callout types.',
  message: "{type, select, info {Information Callout}\nwarning {Warning Callout}\nerror {Error Callout}\nsuccess {Success Callout}\nother {Callout}}"
};
var DESCRIPTION$8 =
/*i18n*/
{
  id: 'extension.command.toggle-callout.description',
  comment: 'Description of the callout command with support for callout types.',
  message: "{type, select, info {Create an information callout block}\nwarning {Create a warning callout block}\nerror {Create an error callout block}\nsuccess {Create a success callout block}\nother {Create a callout block}}"
};

var extensionCalloutMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$b,
  DESCRIPTION: DESCRIPTION$8
});

var LABEL$a =
/*i18n*/
{
  id: 'extension.command.toggle-code-block.label',
  comment: 'Label for the code block command.',
  message: 'Codeblock'
};
var DESCRIPTION$7 =
/*i18n*/
{
  id: 'extension.command.toggle-code-block.description',
  comment: 'Description for the code block command.',
  message: 'Add a code block'
};

var extensionCodeBlockMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$a,
  DESCRIPTION: DESCRIPTION$7
});

var LABEL$9 =
/*i18n*/
{
  id: 'extension.command.toggle-code.label',
  comment: 'Label for the inline code formatting.',
  message: 'Code'
};
var DESCRIPTION$6 =
/*i18n*/
{
  id: 'extension.command.toggle-code.description',
  comment: 'Description for the inline code formatting command.',
  message: 'Add inline code formatting to the selected text'
};

var extensionCodeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$9,
  DESCRIPTION: DESCRIPTION$6
});

var LABEL$8 =
/*i18n*/
{
  id: 'extension.command.toggle-columns.label',
  comment: 'Label for columns command with support for number of columns counts.',
  message: "{count, select, 2 {Two Column Block}\n3 {Three Column Block}\n4 {Four Column Block}\nother {Multi Column Block}}"
};
var DESCRIPTION$5 =
/*i18n*/
{
  id: 'extension.command.toggle-columns.description',
  comment: 'Description of the columns command with support for number of columns counts.',
  message: "{count, select, 2 {Split the block into two columns}\n3 {Split the current block into three columns}\n4 {Split the current block into four columns}\nother {Split the current block into multiple columns}}"
};

var extensionColumnsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$8,
  DESCRIPTION: DESCRIPTION$5
});

var INSERT_EMOJI_LABEL =
/*i18n*/
{
  id: 'extension.command.insert-emoji.label',
  comment: 'Label for inserting an emoji.',
  message: 'Insert Emoji'
};

var extensionEmojiMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INSERT_EMOJI_LABEL: INSERT_EMOJI_LABEL
});

var SET_LABEL$1 =
/*i18n*/
{
  id: 'extension.command.set-font-size.label',
  comment: 'Label for adding a font size.',
  message: 'Font size'
};
var SET_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.set-font-size.description',
  comment: 'Description for adding a font size.',
  message: 'Set the font size for the selected text.'
};
var INCREASE_LABEL =
/*i18n*/
{
  id: 'extension.command.increase-font-size.label',
  comment: 'Label for increasing the font size.',
  message: 'Increase'
};
var INCREASE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.increase-font-size.description',
  comment: 'Description for increasing the font size.',
  message: 'Increase the font size'
};
var DECREASE_LABEL =
/*i18n*/
{
  id: 'extension.command.decrease-font-size.label',
  comment: 'Label for decreasing the font size.',
  message: 'Decrease'
};
var DECREASE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.decrease-font-size.description',
  comment: 'Description for decreasing the font size.',
  message: 'Decrease the font size.'
};

var extensionFontSizeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SET_LABEL: SET_LABEL$1,
  SET_DESCRIPTION: SET_DESCRIPTION,
  INCREASE_LABEL: INCREASE_LABEL,
  INCREASE_DESCRIPTION: INCREASE_DESCRIPTION,
  DECREASE_LABEL: DECREASE_LABEL,
  DECREASE_DESCRIPTION: DECREASE_DESCRIPTION
});

var LABEL$7 =
/*i18n*/
{
  id: 'extension.command.toggle-heading.label',
  comment: 'Label for heading command with support for levels.',
  message: "{level, select, 1 {Heading 1}\n2 {Heading 2}\n3 {Heading 3}\n4 {Heading 4}\n5 {Heading 5}\n6 {Heading 6}\nother {Heading}}"
};

var extensionHeadingMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$7
});

var UNDO_LABEL =
/*i18n*/
{
  id: 'extension.command.undo.label',
  comment: 'Label for undo.',
  message: 'Undo'
};
var UNDO_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.undo.description',
  comment: 'Description for undo.',
  message: 'Undo the most recent action'
};
var REDO_LABEL =
/*i18n*/
{
  id: 'extension.command.redo.label',
  comment: 'Label for redo.',
  message: 'Redo'
};
var REDO_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.redo.description',
  comment: 'Description for redo.',
  message: 'Redo the most recent action'
};

var extensionHistoryMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  UNDO_LABEL: UNDO_LABEL,
  UNDO_DESCRIPTION: UNDO_DESCRIPTION,
  REDO_LABEL: REDO_LABEL,
  REDO_DESCRIPTION: REDO_DESCRIPTION
});

var LABEL$6 =
/*i18n*/
{
  id: 'extension.command.toggle-italic.label',
  comment: 'Label for italic formatting command.',
  message: 'Italic'
};
var DESCRIPTION$4 =
/*i18n*/
{
  id: 'extension.command.toggle-italic.description',
  comment: 'Description for italic formatting command.',
  message: 'Italicize the selected text'
};

var extensionItalicMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$6,
  DESCRIPTION: DESCRIPTION$4
});

var ORDERED_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-ordered-list.label',
  comment: 'Label for inserting an ordered list into the editor.',
  message: 'Ordered list'
};
var BULLET_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-bullet-list.description',
  comment: 'Description for inserting a bullet list into the editor.',
  message: 'Bulleted list'
};
var TASK_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-task-list.description',
  comment: 'Description for inserting a task list into the editor.',
  message: 'Tasked list'
};

var extensionListMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ORDERED_LIST_LABEL: ORDERED_LIST_LABEL,
  BULLET_LIST_LABEL: BULLET_LIST_LABEL,
  TASK_LIST_LABEL: TASK_LIST_LABEL
});

var INCREASE_INDENT_LABEL =
/*i18n*/
{
  id: 'extension.command.increase-indent.label',
  comment: 'Label for increasing the indentation level.',
  message: 'Increase indentation'
};
var DECREASE_INDENT_LABEL =
/*i18n*/
{
  id: 'extension.command.decrease-indent.label',
  comment: 'Label for decreasing the indentation level of the current node block.',
  message: 'Decrease indentation'
};
var CENTER_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.center-align.label',
  comment: 'Center align the text in the current node.',
  message: 'Center align'
};
var JUSTIFY_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.justify-align.label',
  comment: 'Justify the alignment of the selected nodes.',
  message: 'Justify'
};
var RIGHT_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.right-align.label',
  comment: 'Right align the selected nodes.',
  message: 'Right align'
};
var LEFT_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.left-align.label',
  comment: 'Left align the selected nodes.',
  message: 'Left align'
};

var extensionNodeFormattingMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INCREASE_INDENT_LABEL: INCREASE_INDENT_LABEL,
  DECREASE_INDENT_LABEL: DECREASE_INDENT_LABEL,
  CENTER_ALIGN_LABEL: CENTER_ALIGN_LABEL,
  JUSTIFY_ALIGN_LABEL: JUSTIFY_ALIGN_LABEL,
  RIGHT_ALIGN_LABEL: RIGHT_ALIGN_LABEL,
  LEFT_ALIGN_LABEL: LEFT_ALIGN_LABEL
});

var INSERT_LABEL =
/*i18n*/
{
  id: 'extension.command.insert-paragraph.label',
  comment: 'Label for inserting a paragraph.',
  message: 'Insert Paragraph'
};
var INSERT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.insert-paragraph.description',
  comment: 'Description for inserting a paragraph.',
  message: 'Insert a new paragraph'
};
var CONVERT_LABEL =
/*i18n*/
{
  id: 'extension.command.convert-paragraph.label',
  comment: 'Label for converting the current node into a paragraph.',
  message: 'Convert Paragraph'
};
var CONVERT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.convert-paragraph.description',
  comment: 'Description for converting a paragraph.',
  message: 'Convert current block into a paragraph block.'
};

var extensionParagraphMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INSERT_LABEL: INSERT_LABEL,
  INSERT_DESCRIPTION: INSERT_DESCRIPTION,
  CONVERT_LABEL: CONVERT_LABEL,
  CONVERT_DESCRIPTION: CONVERT_DESCRIPTION
});

var LABEL$5 =
/*i18n*/
{
  id: 'extension.command.toggle-strike.label',
  comment: 'Label for strike formatting command.',
  message: 'Strikethrough'
};
var DESCRIPTION$3 =
/*i18n*/
{
  id: 'extension.command.toggle-strike.description',
  comment: 'Description for strike formatting command.',
  message: 'Strikethrough the selected text'
};

var extensionStrikeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$5,
  DESCRIPTION: DESCRIPTION$3
});

var LABEL$4 =
/*i18n*/
{
  id: 'extension.command.toggle-subscript.label',
  comment: 'Label for toggling a subscript.',
  message: 'Subscript'
};

var extensionSubMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$4
});

var LABEL$3 =
/*i18n*/
{
  id: 'extension.command.toggle-superscript.label',
  comment: 'Label for toggling a superscript.',
  message: 'Superscript'
};

var extensionSupMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$3
});

var CREATE_COMMAND_LABEL =
/*i18n*/
{
  id: 'extension.command.create-table.label',
  comment: 'Label for creating a table',
  message: 'Create table'
};
var CREATE_COMMAND_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.create-table.description',
  comment: 'Description for creating a table',
  message: 'Create a table with set number of rows and columns.'
};
/**
 * Takes a `{ count: number }` value to denote the number of columns.
 */

var COLUMN_COUNT =
/*i18n*/
{
  id: 'extension.table.column_count',
  comment: 'The number of columns',
  message: '{count, plural, one {# column} other {# columns}}'
};
/**
 * Takes a `{ count: number }` value to denote the number of rows.
 */

var ROW_COUNT =
/*i18n*/
{
  id: 'extension.table.row_count',
  comment: 'The number of rows',
  message: '{count, plural, one {# row} other {# rows}}'
};

var extensionTablesMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CREATE_COMMAND_LABEL: CREATE_COMMAND_LABEL,
  CREATE_COMMAND_DESCRIPTION: CREATE_COMMAND_DESCRIPTION,
  COLUMN_COUNT: COLUMN_COUNT,
  ROW_COUNT: ROW_COUNT
});

var TOGGLE_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-upper-case.label',
  comment: 'Label for toggling between upper and lower case.',
  message: "{case, select, upper {Uppercase}\nlower {Lowercase}\ncapitalize {Sentence case}\nsmallCaps {Small caps}\nother {Text case}}"
};
var SET_LABEL =
/*i18n*/
{
  id: 'extension.command.set-casing.label',
  comment: 'Label for setting the case.',
  message: 'Set text case'
};

var extensionTextCaseMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TOGGLE_LABEL: TOGGLE_LABEL,
  SET_LABEL: SET_LABEL
});

var SET_COLOR_LABEL =
/*i18n*/
{
  id: 'extension.command.set-text-color.label',
  comment: 'Label for color formatting command.',
  message: 'Text color'
};
var SET_COLOR_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.set-text-color.description',
  comment: 'Description for color formatting command.',
  message: 'Set the text color for the selected text.'
};
var TRANSPARENT =
/*i18n*/
{
  id: 'ui.text-color.transparent',
  comment: 'Transparent color label.',
  message: 'Transparent'
};
var WHITE =
/*i18n*/
{
  id: 'ui.text-color.white',
  comment: 'White color.',
  message: 'White'
};
var BLACK =
/*i18n*/
{
  id: 'ui.text-color.black',
  comment: 'Black color.',
  message: 'Black'
};
var GRAY =
/*i18n*/
{
  id: 'ui.text-color.gray',
  comment: 'Gray color.',
  message: "Gray"
};
var GRAY_HUE =
/*i18n*/
{
  id: 'ui.text-color.gray.hue',
  comment: 'Gray color hues.',
  message: "Gray {hue}"
};
var RED =
/*i18n*/
{
  id: 'ui.text-color.red',
  comment: 'Red color.',
  message: "Red"
};
var RED_HUE =
/*i18n*/
{
  id: 'ui.text-color.red.hue',
  comment: 'Red color hues.',
  message: "Red {hue}"
};
var PINK =
/*i18n*/
{
  id: 'ui.text-color.pink',
  comment: 'Pink color.',
  message: "Pink"
};
var PINK_HUE =
/*i18n*/
{
  id: 'ui.text-color.pink.hue',
  comment: 'Pink color hues.',
  message: "Pink {hue}"
};
var GRAPE =
/*i18n*/
{
  id: 'ui.text-color.grape',
  comment: 'Grape color.',
  message: "Grape"
};
var GRAPE_HUE =
/*i18n*/
{
  id: 'ui.text-color.grape.hue',
  comment: 'Grape color hues.',
  message: "Grape {hue}"
};
var VIOLET =
/*i18n*/
{
  id: 'ui.text-color.violet',
  comment: 'Violet color.',
  message: "Violet"
};
var VIOLET_HUE =
/*i18n*/
{
  id: 'ui.text-color.violet.hue',
  comment: 'Violet color hues.',
  message: "Violet {hue}"
};
var INDIGO =
/*i18n*/
{
  id: 'ui.text-color.indigo',
  comment: 'Indigo color.',
  message: "Indigo"
};
var INDIGO_HUE =
/*i18n*/
{
  id: 'ui.text-color.indigo.hue',
  comment: 'Indigo color hues.',
  message: "Indigo {hue}"
};
var BLUE =
/*i18n*/
{
  id: 'ui.text-color.blue',
  comment: 'Blue color.',
  message: "Blue"
};
var BLUE_HUE =
/*i18n*/
{
  id: 'ui.text-color.blue.hue',
  comment: 'Blue color hues.',
  message: "Blue {hue}"
};
var CYAN =
/*i18n*/
{
  id: 'ui.text-color.cyan',
  comment: 'Cyan color.',
  message: "Cyan"
};
var CYAN_HUE =
/*i18n*/
{
  id: 'ui.text-color.cyan.hue',
  comment: 'Cyan color hues.',
  message: "Cyan {hue}"
};
var TEAL =
/*i18n*/
{
  id: 'ui.text-color.teal',
  comment: 'Teal color.',
  message: "Teal"
};
var TEAL_HUE =
/*i18n*/
{
  id: 'ui.text-color.teal.hue',
  comment: 'Teal color hues.',
  message: "Teal {hue}"
};
var GREEN =
/*i18n*/
{
  id: 'ui.text-color.green',
  comment: 'Green color.',
  message: "Green"
};
var GREEN_HUE =
/*i18n*/
{
  id: 'ui.text-color.green.hue',
  comment: 'Green color hues.',
  message: "Green {hue}"
};
var LIME =
/*i18n*/
{
  id: 'ui.text-color.lime',
  comment: 'Lime color.',
  message: "Lime"
};
var LIME_HUE =
/*i18n*/
{
  id: 'ui.text-color.lime.hue',
  comment: 'Lime color hues.',
  message: "Lime {hue}"
};
var YELLOW =
/*i18n*/
{
  id: 'ui.text-color.yellow',
  comment: 'Yellow color.',
  message: "Yellow"
};
var YELLOW_HUE =
/*i18n*/
{
  id: 'ui.text-color.yellow.hue',
  comment: 'Yellow color hues.',
  message: "Yellow {hue}"
};
var ORANGE =
/*i18n*/
{
  id: 'ui.text-color.orange',
  comment: 'Orange color.',
  message: "Orange"
};
var ORANGE_HUE =
/*i18n*/
{
  id: 'ui.text-color.orange.hue',
  comment: 'Orange color hues.',
  message: "Orange {hue}"
};

var extensionTextColorMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SET_COLOR_LABEL: SET_COLOR_LABEL,
  SET_COLOR_DESCRIPTION: SET_COLOR_DESCRIPTION,
  TRANSPARENT: TRANSPARENT,
  WHITE: WHITE,
  BLACK: BLACK,
  GRAY: GRAY,
  GRAY_HUE: GRAY_HUE,
  RED: RED,
  RED_HUE: RED_HUE,
  PINK: PINK,
  PINK_HUE: PINK_HUE,
  GRAPE: GRAPE,
  GRAPE_HUE: GRAPE_HUE,
  VIOLET: VIOLET,
  VIOLET_HUE: VIOLET_HUE,
  INDIGO: INDIGO,
  INDIGO_HUE: INDIGO_HUE,
  BLUE: BLUE,
  BLUE_HUE: BLUE_HUE,
  CYAN: CYAN,
  CYAN_HUE: CYAN_HUE,
  TEAL: TEAL,
  TEAL_HUE: TEAL_HUE,
  GREEN: GREEN,
  GREEN_HUE: GREEN_HUE,
  LIME: LIME,
  LIME_HUE: LIME_HUE,
  YELLOW: YELLOW,
  YELLOW_HUE: YELLOW_HUE,
  ORANGE: ORANGE,
  ORANGE_HUE: ORANGE_HUE
});

var LABEL$2 =
/*i18n*/
{
  id: 'extension.command.set-text-highlight.label',
  comment: 'Label for adding a text highlight.',
  message: 'Text highlight'
};
var DESCRIPTION$2 =
/*i18n*/
{
  id: 'extension.command.set-text-highlight.description',
  comment: 'Description for adding a text highlight.',
  message: 'Set the text highlight color for the selected text.'
};

var extensionTextHighlightMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$2,
  DESCRIPTION: DESCRIPTION$2
});

var LABEL$1 =
/*i18n*/
{
  id: 'extension.command.toggle-underline.label',
  comment: 'Label for underline formatting command.',
  message: 'Underline'
};
var DESCRIPTION$1 =
/*i18n*/
{
  id: 'extension.command.toggle-underline.description',
  comment: 'Description for underline formatting command.',
  message: 'Underline the selected text'
};

var extensionUnderlineMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$1,
  DESCRIPTION: DESCRIPTION$1
});

var LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-whitespace.label',
  comment: 'Label for displaying whitespace characters.',
  message: 'Toggle Whitespace'
};
var DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.toggle-whitespace.description',
  comment: 'Description for displaying whitespace characters.',
  message: 'Show hidden whitespace characters in your editor.'
};

var extensionWhitespaceMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL,
  DESCRIPTION: DESCRIPTION
});

var NO_ITEMS_AVAILABLE =
/*i18n*/
{
  id: 'react-components.mention-atom-component.zero-items',
  comment: 'Shown when no popup items are available',
  message: 'No items available'
};

var reactComponentsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NO_ITEMS_AVAILABLE: NO_ITEMS_AVAILABLE
});

exports.CoreMessages = coreMessages;
exports.CoreUtilsMessages = coreUtilsMessages;
exports.ExtensionAnnotationMessages = extensionAnnotationMessages;
exports.ExtensionBidiMessages = extensionBidiMessages;
exports.ExtensionBlockquoteMessages = extensionBlockquoteMessages;
exports.ExtensionBoldMessages = extensionBoldMessages;
exports.ExtensionCalloutMessages = extensionCalloutMessages;
exports.ExtensionCodeBlockMessages = extensionCodeBlockMessages;
exports.ExtensionCodeMessages = extensionCodeMessages;
exports.ExtensionColumnsMessages = extensionColumnsMessages;
exports.ExtensionEmojiMessages = extensionEmojiMessages;
exports.ExtensionFontSizeMessages = extensionFontSizeMessages;
exports.ExtensionHeadingMessages = extensionHeadingMessages;
exports.ExtensionHistoryMessages = extensionHistoryMessages;
exports.ExtensionItalicMessages = extensionItalicMessages;
exports.ExtensionListMessages = extensionListMessages;
exports.ExtensionNodeFormattingMessages = extensionNodeFormattingMessages;
exports.ExtensionParagraphMessages = extensionParagraphMessages;
exports.ExtensionStrikeMessages = extensionStrikeMessages;
exports.ExtensionSubMessages = extensionSubMessages;
exports.ExtensionSupMessages = extensionSupMessages;
exports.ExtensionTablesMessages = extensionTablesMessages;
exports.ExtensionTextCaseMessages = extensionTextCaseMessages;
exports.ExtensionTextColorMessages = extensionTextColorMessages;
exports.ExtensionTextHighlightMessages = extensionTextHighlightMessages;
exports.ExtensionUnderlineMessages = extensionUnderlineMessages;
exports.ExtensionWhitespaceMessages = extensionWhitespaceMessages;
exports.ReactComponentMessages = reactComponentsMessages;


/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(71)
} else {
  module.exports = __webpack_require__(80)
}


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
Object.defineProperty(exports, "__esModule", ({value:!0}));var e=__webpack_require__(72),t=__webpack_require__(73),r=__webpack_require__(74),n=__webpack_require__(76),a=__webpack_require__(79),l=__webpack_require__(8),o=__webpack_require__(48);function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var s=i(e),u=i(t),c=i(r),f=i(n),h=i(a),v=i(l),d=i(o),m=function(e){return"string"==typeof e},_=function(e){return"function"==typeof e},g=new Map,y=new Map;function p(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return function(n){if(m(n)&&(n=new Date(n)),r){var a=D(e,t),l=y.get(a);if(l)return l.format(n);var o=new Intl.DateTimeFormat(e,t);return y.set(a,o),o.format(n)}var i=new Intl.DateTimeFormat(e,t);return i.format(n)}}function b(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return function(n){if(r){var a=D(e,t),l=g.get(a);if(l)return l.format(n);var o=new Intl.NumberFormat(e,t);return g.set(a,o),o.format(n)}var i=new Intl.NumberFormat(e,t);return i.format(n)}}function D(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=Array.isArray(e)?e.sort().join("-"):e;return"".concat(r,"-").concat(JSON.stringify(t))}var k=Object.freeze({__proto__:null,date:p,number:b}),A=/\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;function O(e){var t=e.locale,r=e.locales,n=e.values,a=e.formats,l=e.localeData,o=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{plurals:void 0},n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t=t||e;var a=r.plurals,l=function(e){return m(e)?n[e]||{style:e}:e},o=function(e,r){return function(n){var a=_(r)?r(n):r,l=Array.isArray(a)?a:[a],o=b(t)(e);return l.map((function(e){return m(e)?e.replace("#",o):e}))}};return a||console.error("Plurals for locale ".concat(e," aren't loaded. Use i18n.loadLocaleData method to load plurals for specific locale. Using other plural rule as a fallback.")),{plural:function(e,t){var r=t.offset,n=void 0===r?0:r,l=d.default(t,["offset"]),i=l[e]||l[null==a?void 0:a(e-n)]||l.other;return o(e-n,i)},selectordinal:function(e,t){var r=t.offset,n=void 0===r?0:r,l=d.default(t,["offset"]),i=l[e]||l[null==a?void 0:a(e-n,!0)]||l.other;return o(e-n,i)},select:function(e,t){return t[e]||t.other},number:function(e,r){return b(t,l(r))(e)},date:function(e,r){return p(t,l(r))(e)},undefined:function(e){return e}}}(t,r,l,a);return function e(t,r,a){var l=n[t],i=o[r](l,a),s=_(i)?i(e):i;return Array.isArray(s)?s.join(""):s}}function j(e,t,r,n){return function(a){var l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=O({locale:t,locales:r,localeData:n,formats:l,values:a}),i=function e(t){return Array.isArray(t)?t.reduce((function(t,r){if(m(r))return t+r;var n=v.default(r,3),a=n[0],l=n[1],i=n[2],s={};null==i||m(i)?s=i:Object.keys(i).forEach((function(t){s[t]=e(i[t])}));var u=o(a,l,s);return null==u?t:t+u}),""):t},s=i(e);return m(s)&&A.test(s)?JSON.parse('"'.concat(s.trim(),'"')):m(s)?s.trim():s}}var x=function(){function e(){s.default(this,e),this._events={}}return u.default(e,[{key:"on",value:function(e,t){var r=this;return this._hasEvent(e)||(this._events[e]=[]),this._events[e].push(t),function(){return r.removeListener(e,t)}}},{key:"removeListener",value:function(e,t){if(this._hasEvent(e)){var r=this._events[e].indexOf(t);~r&&this._events[e].splice(r,1)}}},{key:"emit",value:function(e){for(var t=this,r=arguments.length,n=new Array(r>1?r-1:0),a=1;a<r;a++)n[a-1]=arguments[a];this._hasEvent(e)&&this._events[e].map((function(e){return e.apply(t,n)}))}},{key:"_hasEvent",value:function(e){return Array.isArray(this._events[e])}}]),e}();function w(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var r,n=h.default(e);if(t){var a=h.default(this).constructor;r=Reflect.construct(n,arguments,a)}else r=n.apply(this,arguments);return f.default(this,r)}}var L=function(e){c.default(r,e);var t=w(r);function r(e){var n;return s.default(this,r),n=t.call(this),n._messages={},n._localeData={},null!=e.missing&&(n._missing=e.missing),null!=e.messages&&n.load(e.messages),null!=e.localeData&&n.loadLocaleData(e.localeData),null==e.locale&&null==e.locales||n.activate(e.locale,e.locales),n}return u.default(r,[{key:"_loadLocaleData",value:function(e,t){null==this._localeData[e]?this._localeData[e]=t:Object.assign(this._localeData[e],t)}},{key:"loadLocaleData",value:function(e,t){var r=this;null!=t?this._loadLocaleData(e,t):Object.keys(e).forEach((function(t){return r._loadLocaleData(t,e[t])})),this.emit("change")}},{key:"_load",value:function(e,t){null==this._messages[e]?this._messages[e]=t:Object.assign(this._messages[e],t)}},{key:"load",value:function(e,t){var r=this;null!=t?this._load(e,t):Object.keys(e).forEach((function(t){return r._load(t,e[t])})),this.emit("change")}},{key:"activate",value:function(e,t){this._locale=e,this._locales=t,this.emit("change")}},{key:"_",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=r.message,a=r.formats,l=r.context;m(e)||(t=e.values||t,n=e.message,l=e.context,e=e.id);var o,i=!l&&!this.messages[e],s=l&&!this.messages[l][e],u=s||i,c=this._missing;return c&&u?_(c)?c(this._locale,e,l):c:(u&&this.emit("missing",{id:e,context:l,locale:this._locale}),o=l&&!s?this.messages[l][e]||n||e:this.messages[e]||n||e,m(o)&&A.test(o)?JSON.parse('"'.concat(o,'"')):m(o)?o:j(o,this._locale,this._locales,this.localeData)(t,a))}},{key:"date",value:function(e,t){return p(this._locales||this._locale,t)(e)}},{key:"number",value:function(e,t){return b(this._locales||this._locale,t)(e)}},{key:"locale",get:function(){return this._locale}},{key:"locales",get:function(){return this._locales}},{key:"messages",get:function(){var e;return null!==(e=this._messages[this._locale])&&void 0!==e?e:{}}},{key:"localeData",get:function(){var e;return null!==(e=this._localeData[this._locale])&&void 0!==e?e:{}}}]),r}(x);function q(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return new L(e)}var E=q();exports.I18n=L,exports.formats=k,exports.i18n=E,exports.setupI18n=q;
//# sourceMappingURL=core.production.min.js.map


/***/ }),
/* 72 */
/***/ ((module) => {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 73 */
/***/ ((module) => {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var setPrototypeOf = __webpack_require__(75);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 75 */
/***/ ((module) => {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 76 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = (__webpack_require__(77)["default"]);

var assertThisInitialized = __webpack_require__(78);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 77 */
/***/ ((module) => {

function _typeof(obj) {
  "@babel/helpers - typeof";

  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
}

module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 78 */
/***/ ((module) => {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 79 */
/***/ ((module) => {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  }, module.exports.__esModule = true, module.exports["default"] = module.exports;
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _classCallCheck = __webpack_require__(72);
var _createClass = __webpack_require__(73);
var _inherits = __webpack_require__(74);
var _possibleConstructorReturn = __webpack_require__(76);
var _getPrototypeOf = __webpack_require__(79);
var _slicedToArray = __webpack_require__(8);
var _objectWithoutProperties = __webpack_require__(48);
var _defineProperty = __webpack_require__(15);
var messageformatParser = __webpack_require__(81);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _classCallCheck__default = /*#__PURE__*/_interopDefaultLegacy(_classCallCheck);
var _createClass__default = /*#__PURE__*/_interopDefaultLegacy(_createClass);
var _inherits__default = /*#__PURE__*/_interopDefaultLegacy(_inherits);
var _possibleConstructorReturn__default = /*#__PURE__*/_interopDefaultLegacy(_possibleConstructorReturn);
var _getPrototypeOf__default = /*#__PURE__*/_interopDefaultLegacy(_getPrototypeOf);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);
var _objectWithoutProperties__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutProperties);
var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

var isString = function isString(s) {
  return typeof s === "string";
};
var isFunction = function isFunction(f) {
  return typeof f === "function";
};

/** Memoized cache */

var numberFormats = new Map();
var dateFormats = new Map();
function date(locales) {
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var memoize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (value) {
    if (isString(value)) value = new Date(value);

    if (memoize) {
      var key = cacheKey(locales, format);
      var cachedFormatter = dateFormats.get(key);

      if (cachedFormatter) {
        return cachedFormatter.format(value);
      }

      var _formatter = new Intl.DateTimeFormat(locales, format);

      dateFormats.set(key, _formatter);
      return _formatter.format(value);
    }

    var formatter = new Intl.DateTimeFormat(locales, format);
    return formatter.format(value);
  };
}
function number(locales) {
  var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var memoize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  return function (value) {
    if (memoize) {
      var key = cacheKey(locales, format);
      var cachedFormatter = numberFormats.get(key);

      if (cachedFormatter) {
        return cachedFormatter.format(value);
      }

      var _formatter2 = new Intl.NumberFormat(locales, format);

      numberFormats.set(key, _formatter2);
      return _formatter2.format(value);
    }

    var formatter = new Intl.NumberFormat(locales, format);
    return formatter.format(value);
  };
}
/** Memoize helpers */

function cacheKey(locales) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var localeKey = Array.isArray(locales) ? locales.sort().join('-') : locales;
  return "".concat(localeKey, "-").concat(JSON.stringify(options));
}

var formats = /*#__PURE__*/Object.freeze({
  __proto__: null,
  date: date,
  number: number
});

var UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/g;

var defaultFormats = function defaultFormats(locale, locales) {
  var localeData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    plurals: undefined
  };
  var formats = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  locales = locales || locale;
  var plurals = localeData.plurals;

  var style = function style(format) {
    return isString(format) ? formats[format] || {
      style: format
    } : format;
  };

  var replaceOctothorpe = function replaceOctothorpe(value, message) {
    return function (ctx) {
      var msg = isFunction(message) ? message(ctx) : message;
      var norm = Array.isArray(msg) ? msg : [msg];

      var valueStr = number(locales)(value);

      return norm.map(function (m) {
        return isString(m) ? m.replace("#", valueStr) : m;
      });
    };
  };

  if (!plurals) {
    console.error("Plurals for locale ".concat(locale, " aren't loaded. Use i18n.loadLocaleData method to load plurals for specific locale. Using other plural rule as a fallback."));
  }

  return {
    plural: function plural(value, _ref) {
      var _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          rules = _objectWithoutProperties__default['default'](_ref, ["offset"]);

      var message = rules[value] || rules[plurals === null || plurals === void 0 ? void 0 : plurals(value - offset)] || rules.other;
      return replaceOctothorpe(value - offset, message);
    },
    selectordinal: function selectordinal(value, _ref2) {
      var _ref2$offset = _ref2.offset,
          offset = _ref2$offset === void 0 ? 0 : _ref2$offset,
          rules = _objectWithoutProperties__default['default'](_ref2, ["offset"]);

      var message = rules[value] || rules[plurals === null || plurals === void 0 ? void 0 : plurals(value - offset, true)] || rules.other;
      return replaceOctothorpe(value - offset, message);
    },
    select: function select(value, rules) {
      return rules[value] || rules.other;
    },
    number: function number$1(value, format) {
      return number(locales, style(format))(value);
    },
    date: function date$1(value, format) {
      return date(locales, style(format))(value);
    },
    undefined: function undefined$1(value) {
      return value;
    }
  };
}; // Params -> CTX

/**
 * Creates a context object, which formats ICU MessageFormat arguments based on
 * argument type.
 *
 * @param locale     - Locale of message
 * @param locales      - Locales to be used when formatting the numbers or dates
 * @param values       - Parameters for variable interpolation
 * @param localeData - Locale data (e.g: plurals)
 * @param formats - Custom format styles
 * @returns {function(string, string, any)}
 */


function context(_ref3) {
  var locale = _ref3.locale,
      locales = _ref3.locales,
      values = _ref3.values,
      formats = _ref3.formats,
      localeData = _ref3.localeData;
  var formatters = defaultFormats(locale, locales, localeData, formats);

  var ctx = function ctx(name, type, format) {
    var value = values[name];
    var formatted = formatters[type](value, format);
    var message = isFunction(formatted) ? formatted(ctx) : formatted;
    return Array.isArray(message) ? message.join("") : message;
  };

  return ctx;
}

function interpolate(translation, locale, locales, localeData) {
  return function (values) {
    var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var ctx = context({
      locale: locale,
      locales: locales,
      localeData: localeData,
      formats: formats,
      values: values
    });

    var formatMessage = function formatMessage(message) {
      if (!Array.isArray(message)) return message;
      return message.reduce(function (message, token) {
        if (isString(token)) return message + token;

        var _token = _slicedToArray__default['default'](token, 3),
            name = _token[0],
            type = _token[1],
            format = _token[2];

        var interpolatedFormat = {};

        if (format != null && !isString(format)) {
          Object.keys(format).forEach(function (key) {
            interpolatedFormat[key] = formatMessage(format[key]);
          });
        } else {
          interpolatedFormat = format;
        }

        var value = ctx(name, type, interpolatedFormat);
        if (value == null) return message;
        return message + value;
      }, "");
    };

    var result = formatMessage(translation);
    if (isString(result) && UNICODE_REGEX.test(result)) return JSON.parse("\"".concat(result.trim(), "\""));
    if (isString(result)) return result.trim();
    return result;
  };
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty__default['default'](target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function processTokens(tokens) {
  if (!tokens.filter(function (token) {
    return !isString(token);
  }).length) {
    return tokens.join("");
  }

  return tokens.map(function (token) {
    if (isString(token)) {
      return token; // # in plural case
    } else if (token.type === "octothorpe") {
      return "#"; // simple argument
    } else if (token.type === "argument") {
      return [token.arg]; // argument with custom format (date, number)
    } else if (token.type === "function") {
      var _param = token.param && token.param.tokens[0];

      var param = typeof _param === "string" ? _param.trim() : _param;
      return [token.arg, token.key, param].filter(Boolean);
    }

    var offset = token.offset ? parseInt(token.offset) : undefined; // complex argument with cases

    var formatProps = {};
    token.cases.forEach(function (item) {
      formatProps[item.key] = processTokens(item.tokens);
    });
    return [token.arg, token.type, _objectSpread({
      offset: offset
    }, formatProps)];
  });
} // Message -> (Params -> String)


function compile(message) {
  try {
    return processTokens(messageformatParser.parse(message));
  } catch (e) {
    console.error("Message cannot be parsed due to syntax errors: ".concat(message));
    return message;
  }
}

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck__default['default'](this, EventEmitter);

    this._events = {};
  }

  _createClass__default['default'](EventEmitter, [{
    key: "on",
    value: function on(event, listener) {
      var _this = this;

      if (!this._hasEvent(event)) this._events[event] = [];

      this._events[event].push(listener);

      return function () {
        return _this.removeListener(event, listener);
      };
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      if (!this._hasEvent(event)) return;

      var index = this._events[event].indexOf(listener);

      if (~index) this._events[event].splice(index, 1);
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var _this2 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (!this._hasEvent(event)) return;

      this._events[event].map(function (listener) {
        return listener.apply(_this2, args);
      });
    }
  }, {
    key: "_hasEvent",
    value: function _hasEvent(event) {
      return Array.isArray(this._events[event]);
    }
  }]);

  return EventEmitter;
}();

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf__default['default'](Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf__default['default'](this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn__default['default'](this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
var I18n = /*#__PURE__*/function (_EventEmitter) {
  _inherits__default['default'](I18n, _EventEmitter);

  var _super = _createSuper(I18n);

  function I18n(params) {
    var _this;

    _classCallCheck__default['default'](this, I18n);

    _this = _super.call(this);
    _this._messages = {};
    _this._localeData = {};
    if (params.missing != null) _this._missing = params.missing;
    if (params.messages != null) _this.load(params.messages);
    if (params.localeData != null) _this.loadLocaleData(params.localeData);

    if (params.locale != null || params.locales != null) {
      _this.activate(params.locale, params.locales);
    }

    return _this;
  }

  _createClass__default['default'](I18n, [{
    key: "_loadLocaleData",
    value: function _loadLocaleData(locale, localeData) {
      if (this._localeData[locale] == null) {
        this._localeData[locale] = localeData;
      } else {
        Object.assign(this._localeData[locale], localeData);
      }
    }
  }, {
    key: "loadLocaleData",
    value: function loadLocaleData(localeOrAllData, localeData) {
      var _this2 = this;

      if (localeData != null) {
        // loadLocaleData('en', enLocaleData)
        // Loading locale data for a single locale.
        this._loadLocaleData(localeOrAllData, localeData);
      } else {
        // loadLocaleData(allLocaleData)
        // Loading all locale data at once.
        Object.keys(localeOrAllData).forEach(function (locale) {
          return _this2._loadLocaleData(locale, localeOrAllData[locale]);
        });
      }

      this.emit("change");
    }
  }, {
    key: "_load",
    value: function _load(locale, messages) {
      if (this._messages[locale] == null) {
        this._messages[locale] = messages;
      } else {
        Object.assign(this._messages[locale], messages);
      }
    }
  }, {
    key: "load",
    value: function load(localeOrMessages, messages) {
      var _this3 = this;

      if (messages != null) {
        // load('en', catalog)
        // Loading a catalog for a single locale.
        this._load(localeOrMessages, messages);
      } else {
        // load(catalogs)
        // Loading several locales at once.
        Object.keys(localeOrMessages).forEach(function (locale) {
          return _this3._load(locale, localeOrMessages[locale]);
        });
      }

      this.emit("change");
    }
  }, {
    key: "activate",
    value: function activate(locale, locales) {
      {
        if (!this._messages[locale]) {
          console.warn("Messages for locale \"".concat(locale, "\" not loaded."));
        }

        if (!this._localeData[locale]) {
          console.warn("Locale data for locale \"".concat(locale, "\" not loaded. Plurals won't work correctly."));
        }
      }

      this._locale = locale;
      this._locales = locales;
      this.emit("change");
    } // method for translation and formatting

  }, {
    key: "_",
    value: function _(id) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          message = _ref.message,
          formats = _ref.formats,
          context = _ref.context;

      if (!isString(id)) {
        values = id.values || values;
        message = id.message;
        context = id.context;
        id = id.id;
      }

      var messageMissing = !context && !this.messages[id];
      var contextualMessageMissing = context && !this.messages[context][id];
      var messageUnreachable = contextualMessageMissing || messageMissing; // replace missing messages with custom message for debugging

      var missing = this._missing;

      if (missing && messageUnreachable) {
        return isFunction(missing) ? missing(this._locale, id, context) : missing;
      }

      if (messageUnreachable) {
        this.emit("missing", {
          id: id,
          context: context,
          locale: this._locale
        });
      }

      var translation;

      if (context && !contextualMessageMissing) {
        // context is like a subdirectory of other keys
        translation = this.messages[context][id] || message || id;
      } else {
        translation = this.messages[id] || message || id;
      }

      {
        translation = isString(translation) ? compile(translation) : translation;
      } // hack for parsing unicode values inside a string to get parsed in react native environments


      if (isString(translation) && UNICODE_REGEX.test(translation)) return JSON.parse("\"".concat(translation, "\""));
      if (isString(translation)) return translation;
      return interpolate(translation, this._locale, this._locales, this.localeData)(values, formats);
    }
  }, {
    key: "date",
    value: function date$1(value, format) {
      return date(this._locales || this._locale, format)(value);
    }
  }, {
    key: "number",
    value: function number$1(value, format) {
      return number(this._locales || this._locale, format)(value);
    }
  }, {
    key: "locale",
    get: function get() {
      return this._locale;
    }
  }, {
    key: "locales",
    get: function get() {
      return this._locales;
    }
  }, {
    key: "messages",
    get: function get() {
      var _this$_messages$this$;

      return (_this$_messages$this$ = this._messages[this._locale]) !== null && _this$_messages$this$ !== void 0 ? _this$_messages$this$ : {};
    }
  }, {
    key: "localeData",
    get: function get() {
      var _this$_localeData$thi;

      return (_this$_localeData$thi = this._localeData[this._locale]) !== null && _this$_localeData$thi !== void 0 ? _this$_localeData$thi : {};
    }
  }]);

  return I18n;
}(EventEmitter);

function setupI18n() {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return new I18n(params);
}

var i18n = setupI18n();

exports.I18n = I18n;
exports.formats = formats;
exports.i18n = i18n;
exports.setupI18n = setupI18n;
//# sourceMappingURL=core.development.js.map


/***/ }),
/* 81 */
/***/ ((module) => {

"use strict";
/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */



function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = "#",
      peg$c1 = peg$literalExpectation("#", false),
      peg$c2 = function() { return inPlural[0]; },
      peg$c3 = function() { return { type: 'octothorpe' }; },
      peg$c4 = function(str) { return str.join(''); },
      peg$c5 = "{",
      peg$c6 = peg$literalExpectation("{", false),
      peg$c7 = "}",
      peg$c8 = peg$literalExpectation("}", false),
      peg$c9 = function(arg) {
          return {
            type: 'argument',
            arg: arg
          };
        },
      peg$c10 = ",",
      peg$c11 = peg$literalExpectation(",", false),
      peg$c12 = "select",
      peg$c13 = peg$literalExpectation("select", false),
      peg$c14 = function(arg, m) { if (options.strict) { inPlural.unshift(false); } return m; },
      peg$c15 = function(arg, cases) {
          if (options.strict) inPlural.shift()
          return {
            type: 'select',
            arg: arg,
            cases: cases
          };
        },
      peg$c16 = "plural",
      peg$c17 = peg$literalExpectation("plural", false),
      peg$c18 = "selectordinal",
      peg$c19 = peg$literalExpectation("selectordinal", false),
      peg$c20 = function(arg, m) { inPlural.unshift(true); return m; },
      peg$c21 = function(arg, type, offset, cases) {
          var ls = ((type === 'selectordinal') ? options.ordinal : options.cardinal)
                   || ['zero', 'one', 'two', 'few', 'many', 'other'];
          if (ls && ls.length) cases.forEach(function(c) {
            if (isNaN(c.key) && ls.indexOf(c.key) < 0) throw new Error(
              'Invalid key `' + c.key + '` for argument `' + arg + '`.' +
              ' Valid ' + type + ' keys for this locale are `' + ls.join('`, `') +
              '`, and explicit keys like `=0`.');
          });
          inPlural.shift()
          return {
            type: type,
            arg: arg,
            offset: offset || 0,
            cases: cases
          };
        },
      peg$c22 = function(arg, key, param) {
          return {
            type: 'function',
            arg: arg,
            key: key,
            param: param
          };
        },
      peg$c23 = peg$otherExpectation("identifier"),
      peg$c24 = /^[^\t-\r \x85\u200E\u200F\u2028\u2029!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/,
      peg$c25 = peg$classExpectation([["\t", "\r"], " ", "\x85", "\u200E", "\u200F", "\u2028", "\u2029", ["!", "/"], [":", "@"], ["[", "^"], "`", ["{", "~"], ["\xA1", "\xA7"], "\xA9", "\xAB", "\xAC", "\xAE", "\xB0", "\xB1", "\xB6", "\xBB", "\xBF", "\xD7", "\xF7", ["\u2010", "\u2027"], ["\u2030", "\u203E"], ["\u2041", "\u2053"], ["\u2055", "\u205E"], ["\u2190", "\u245F"], ["\u2500", "\u2775"], ["\u2794", "\u2BFF"], ["\u2E00", "\u2E7F"], ["\u3001", "\u3003"], ["\u3008", "\u3020"], "\u3030", "\uFD3E", "\uFD3F", "\uFE45", "\uFE46"], true, false),
      peg$c26 = function(key, tokens) { return { key: key, tokens: tokens }; },
      peg$c27 = function(tokens) { return tokens; },
      peg$c28 = peg$otherExpectation("plural offset"),
      peg$c29 = "offset",
      peg$c30 = peg$literalExpectation("offset", false),
      peg$c31 = ":",
      peg$c32 = peg$literalExpectation(":", false),
      peg$c33 = function(d) { return d; },
      peg$c34 = "=",
      peg$c35 = peg$literalExpectation("=", false),
      peg$c36 = "number",
      peg$c37 = peg$literalExpectation("number", false),
      peg$c38 = "date",
      peg$c39 = peg$literalExpectation("date", false),
      peg$c40 = "time",
      peg$c41 = peg$literalExpectation("time", false),
      peg$c42 = "spellout",
      peg$c43 = peg$literalExpectation("spellout", false),
      peg$c44 = "ordinal",
      peg$c45 = peg$literalExpectation("ordinal", false),
      peg$c46 = "duration",
      peg$c47 = peg$literalExpectation("duration", false),
      peg$c48 = function(key) {
            if (options.strict || /^\d/.test(key)) return false
            switch (key.toLowerCase()) {
              case 'select':
              case 'plural':
              case 'selectordinal':
                return false
              default:
                return true
            }
          },
      peg$c49 = function(key) { return key },
      peg$c50 = function(tokens) { return !options.strict },
      peg$c51 = function(tokens) { return { tokens: tokens } },
      peg$c52 = function(parts) { return { tokens: [parts.join('')] } },
      peg$c53 = peg$otherExpectation("a valid (strict) function parameter"),
      peg$c54 = /^[^'{}]/,
      peg$c55 = peg$classExpectation(["'", "{", "}"], true, false),
      peg$c56 = function(p) { return p.join('') },
      peg$c57 = "'",
      peg$c58 = peg$literalExpectation("'", false),
      peg$c59 = function(quoted) { return quoted },
      peg$c60 = function(p) { return '{' + p.join('') + '}' },
      peg$c61 = peg$otherExpectation("doubled apostrophe"),
      peg$c62 = "''",
      peg$c63 = peg$literalExpectation("''", false),
      peg$c64 = function() { return "'"; },
      peg$c65 = /^[^']/,
      peg$c66 = peg$classExpectation(["'"], true, false),
      peg$c67 = "'{",
      peg$c68 = peg$literalExpectation("'{", false),
      peg$c69 = function(str) { return '\u007B'+str.join(''); },
      peg$c70 = "'}",
      peg$c71 = peg$literalExpectation("'}", false),
      peg$c72 = function(str) { return '\u007D'+str.join(''); },
      peg$c73 = peg$otherExpectation("escaped string"),
      peg$c74 = "'#",
      peg$c75 = peg$literalExpectation("'#", false),
      peg$c76 = function(str) { return "#"+str.join(''); },
      peg$c77 = function(quotedOcto) { return quotedOcto[0]; },
      peg$c78 = peg$otherExpectation("plain char"),
      peg$c79 = /^[^{}#\0-\x08\x0E-\x1F\x7F]/,
      peg$c80 = peg$classExpectation(["{", "}", "#", ["\0", "\b"], ["\x0E", "\x1F"], "\x7F"], true, false),
      peg$c81 = function(octo) { return !inPlural[0]; },
      peg$c82 = function(octo) { return octo; },
      peg$c83 = peg$otherExpectation("integer"),
      peg$c84 = /^[0-9]/,
      peg$c85 = peg$classExpectation([["0", "9"]], false, false),
      peg$c86 = peg$otherExpectation("white space"),
      peg$c87 = /^[\t-\r \x85\u200E\u200F\u2028\u2029]/,
      peg$c88 = peg$classExpectation([["\t", "\r"], " ", "\x85", "\u200E", "\u200F", "\u2028", "\u2029"], false, false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1;

    s0 = [];
    s1 = peg$parsetoken();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsetoken();
    }

    return s0;
  }

  function peg$parsetoken() {
    var s0, s1, s2;

    s0 = peg$parseargument();
    if (s0 === peg$FAILED) {
      s0 = peg$parseselect();
      if (s0 === peg$FAILED) {
        s0 = peg$parseplural();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefunction();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c0;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c1); }
            }
            if (s1 !== peg$FAILED) {
              peg$savedPos = peg$currPos;
              s2 = peg$c2();
              if (s2) {
                s2 = void 0;
              } else {
                s2 = peg$FAILED;
              }
              if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c3();
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parsechar();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parsechar();
                }
              } else {
                s1 = peg$FAILED;
              }
              if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c4(s1);
              }
              s0 = s1;
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parseargument() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c7;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c9(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseselect() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c11); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c12) {
                  s8 = peg$c12;
                  peg$currPos += 6;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c13); }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s8 = peg$c14(s3, s8);
                }
                s7 = s8;
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c10;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c11); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = [];
                        s12 = peg$parseselectCase();
                        if (s12 !== peg$FAILED) {
                          while (s12 !== peg$FAILED) {
                            s11.push(s12);
                            s12 = peg$parseselectCase();
                          }
                        } else {
                          s11 = peg$FAILED;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                              s13 = peg$c7;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c8); }
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c15(s3, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseplural() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c11); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$currPos;
                if (input.substr(peg$currPos, 6) === peg$c16) {
                  s8 = peg$c16;
                  peg$currPos += 6;
                } else {
                  s8 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c17); }
                }
                if (s8 === peg$FAILED) {
                  if (input.substr(peg$currPos, 13) === peg$c18) {
                    s8 = peg$c18;
                    peg$currPos += 13;
                  } else {
                    s8 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c19); }
                  }
                }
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s7;
                  s8 = peg$c20(s3, s8);
                }
                s7 = s8;
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c10;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c11); }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$parseoffset();
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = [];
                          s13 = peg$parsepluralCase();
                          if (s13 !== peg$FAILED) {
                            while (s13 !== peg$FAILED) {
                              s12.push(s13);
                              s13 = peg$parsepluralCase();
                            }
                          } else {
                            s12 = peg$FAILED;
                          }
                          if (s12 !== peg$FAILED) {
                            s13 = peg$parse_();
                            if (s13 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 125) {
                                s14 = peg$c7;
                                peg$currPos++;
                              } else {
                                s14 = peg$FAILED;
                                if (peg$silentFails === 0) { peg$fail(peg$c8); }
                              }
                              if (s14 !== peg$FAILED) {
                                peg$savedPos = s0;
                                s1 = peg$c21(s3, s7, s11, s12);
                                s0 = s1;
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsefunction() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseid();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c10;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c11); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                s7 = peg$parsefunctionKey();
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$parsefunctionParam();
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 125) {
                        s10 = peg$c7;
                        peg$currPos++;
                      } else {
                        s10 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c8); }
                      }
                      if (s10 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s1 = peg$c22(s3, s7, s9);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseid() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c24.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c25); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c24.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c25); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c23); }
    }

    return s0;
  }

  function peg$parseselectCase() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseid();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsecaseTokens();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsepluralCase() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepluralKey();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          s4 = peg$parsecaseTokens();
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c26(s2, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsecaseTokens() {
    var s0, s1, s2, s3, s4, s5;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c5;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c6); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$currPos;
      s3 = peg$parse_();
      if (s3 !== peg$FAILED) {
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.charCodeAt(peg$currPos) === 123) {
          s5 = peg$c5;
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c6); }
        }
        peg$silentFails--;
        if (s5 !== peg$FAILED) {
          peg$currPos = s4;
          s4 = void 0;
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsetoken();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsetoken();
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c7;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c8); }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c27(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseoffset() {
    var s0, s1, s2, s3, s4, s5, s6, s7;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.substr(peg$currPos, 6) === peg$c29) {
        s2 = peg$c29;
        peg$currPos += 6;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c31;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c32); }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parse_();
            if (s5 !== peg$FAILED) {
              s6 = peg$parsedigits();
              if (s6 !== peg$FAILED) {
                s7 = peg$parse_();
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c33(s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c28); }
    }

    return s0;
  }

  function peg$parsepluralKey() {
    var s0, s1, s2;

    s0 = peg$parseid();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c34;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsedigits();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c33(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsefunctionKey() {
    var s0, s1, s2, s3, s4, s5;

    if (input.substr(peg$currPos, 6) === peg$c36) {
      s0 = peg$c36;
      peg$currPos += 6;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c37); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 4) === peg$c38) {
        s0 = peg$c38;
        peg$currPos += 4;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c39); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c40) {
          s0 = peg$c40;
          peg$currPos += 4;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 8) === peg$c42) {
            s0 = peg$c42;
            peg$currPos += 8;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c43); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 7) === peg$c44) {
              s0 = peg$c44;
              peg$currPos += 7;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c45); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 8) === peg$c46) {
                s0 = peg$c46;
                peg$currPos += 8;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c47); }
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 6) === peg$c12) {
                  s2 = peg$c12;
                  peg$currPos += 6;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c13); }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = void 0;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$currPos;
                  peg$silentFails++;
                  if (input.substr(peg$currPos, 6) === peg$c16) {
                    s3 = peg$c16;
                    peg$currPos += 6;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c17); }
                  }
                  peg$silentFails--;
                  if (s3 === peg$FAILED) {
                    s2 = void 0;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$FAILED;
                  }
                  if (s2 !== peg$FAILED) {
                    s3 = peg$currPos;
                    peg$silentFails++;
                    if (input.substr(peg$currPos, 13) === peg$c18) {
                      s4 = peg$c18;
                      peg$currPos += 13;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c19); }
                    }
                    peg$silentFails--;
                    if (s4 === peg$FAILED) {
                      s3 = void 0;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parseid();
                      if (s4 !== peg$FAILED) {
                        peg$savedPos = peg$currPos;
                        s5 = peg$c48(s4);
                        if (s5) {
                          s5 = void 0;
                        } else {
                          s5 = peg$FAILED;
                        }
                        if (s5 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c49(s4);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsefunctionParam() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 44) {
        s2 = peg$c10;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c11); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsetoken();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsetoken();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s4 = peg$c50(s3);
          if (s4) {
            s4 = void 0;
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c51(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c10;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsestrictFunctionParamPart();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsestrictFunctionParamPart();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c52(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsestrictFunctionParamPart() {
    var s0, s1, s2, s3;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c54.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c55); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c54.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c55); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c56(s1);
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$parsedoubleapos();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 39) {
          s1 = peg$c57;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parseinapos();
          if (s2 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 39) {
              s3 = peg$c57;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c58); }
            }
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c59(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 123) {
            s1 = peg$c5;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c6); }
          }
          if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsestrictFunctionParamPart();
            while (s3 !== peg$FAILED) {
              s2.push(s3);
              s3 = peg$parsestrictFunctionParamPart();
            }
            if (s2 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 125) {
                s3 = peg$c7;
                peg$currPos++;
              } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c8); }
              }
              if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c60(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c53); }
    }

    return s0;
  }

  function peg$parsedoubleapos() {
    var s0, s1;

    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c62) {
      s1 = peg$c62;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c63); }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c64();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c61); }
    }

    return s0;
  }

  function peg$parseinapos() {
    var s0, s1, s2;

    s0 = peg$parsedoubleapos();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = [];
      if (peg$c65.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c66); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c65.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c66); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c4(s1);
      }
      s0 = s1;
    }

    return s0;
  }

  function peg$parsequotedCurly() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c67) {
      s1 = peg$c67;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c68); }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parseinapos();
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parseinapos();
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c57;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c69(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c70) {
        s1 = peg$c70;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c71); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseinapos();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parseinapos();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c57;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c58); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c72(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }

    return s0;
  }

  function peg$parsequoted() {
    var s0, s1, s2, s3, s4, s5;

    peg$silentFails++;
    s0 = peg$parsequotedCurly();
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c74) {
        s3 = peg$c74;
        peg$currPos += 2;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c75); }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseinapos();
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseinapos();
        }
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s5 = peg$c57;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c58); }
          }
          if (s5 !== peg$FAILED) {
            peg$savedPos = s2;
            s3 = peg$c76(s4);
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = peg$currPos;
        s3 = peg$c2();
        if (s3) {
          s3 = void 0;
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c77(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s0 = peg$c57;
          peg$currPos++;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c58); }
        }
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c73); }
    }

    return s0;
  }

  function peg$parseplainChar() {
    var s0, s1;

    peg$silentFails++;
    if (peg$c79.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c80); }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c78); }
    }

    return s0;
  }

  function peg$parsechar() {
    var s0, s1, s2;

    s0 = peg$parsedoubleapos();
    if (s0 === peg$FAILED) {
      s0 = peg$parsequoted();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 35) {
          s1 = peg$c0;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s1 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s2 = peg$c81(s1);
          if (s2) {
            s2 = void 0;
          } else {
            s2 = peg$FAILED;
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c82(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$parseplainChar();
        }
      }
    }

    return s0;
  }

  function peg$parsedigits() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c84.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c85); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c84.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c85); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c83); }
    }

    return s0;
  }

  function peg$parse_() {
    var s0, s1, s2;

    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    if (peg$c87.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c88); }
    }
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      if (peg$c87.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c86); }
    }

    return s0;
  }


    var inPlural = [false];


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

__webpack_require__(70);

var COPY_LABEL =
/*i18n*/
{
  id: 'extension.command.copy.label',
  comment: 'Label for copy command.',
  message: 'Copy'
};
var COPY_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.copy.description',
  comment: 'Description for copy command.',
  message: 'Copy the selected text'
};
var CUT_LABEL =
/*i18n*/
{
  id: 'extension.command.cut.label',
  comment: 'Label for cut command.',
  message: 'Cut'
};
var CUT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.cut.description',
  comment: 'Description for cut command.',
  message: 'Cut the selected text'
};
var PASTE_LABEL =
/*i18n*/
{
  id: 'extension.command.paste.label',
  comment: 'Label for paste command.',
  message: 'Paste'
};
var PASTE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.paste.description',
  comment: 'Description for paste command.',
  message: 'Paste content into the editor'
};
var SELECT_ALL_LABEL =
/*i18n*/
{
  id: 'extension.command.select-all.label',
  comment: 'Label for select all command.',
  message: 'Select all'
};
var SELECT_ALL_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.select-all.description',
  comment: 'Description for select all command.',
  message: 'Select all content within the editor'
};

var coreMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  COPY_LABEL: COPY_LABEL,
  COPY_DESCRIPTION: COPY_DESCRIPTION,
  CUT_LABEL: CUT_LABEL,
  CUT_DESCRIPTION: CUT_DESCRIPTION,
  PASTE_LABEL: PASTE_LABEL,
  PASTE_DESCRIPTION: PASTE_DESCRIPTION,
  SELECT_ALL_LABEL: SELECT_ALL_LABEL,
  SELECT_ALL_DESCRIPTION: SELECT_ALL_DESCRIPTION
});

var ESCAPE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.escape',
  comment: 'Label for escape key in shortcuts.',
  message: 'Enter'
};
var COMMAND_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.command',
  comment: 'Label for command key in shortcuts.',
  message: 'Command'
};
var CONTROL_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.control',
  comment: 'Label for control key in shortcuts.',
  message: 'Control'
};
var ENTER_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.enter',
  comment: 'Label for enter key in shortcuts.',
  message: 'Enter'
};
var SHIFT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.shift',
  comment: 'Label for shift key in shortcuts.',
  message: 'Shift'
};
var ALT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.alt',
  comment: 'Label for alt key in shortcuts.',
  message: 'Alt'
};
var CAPS_LOCK_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.capsLock',
  comment: 'Label for caps lock key in shortcuts.',
  message: 'Caps Lock'
};
var BACKSPACE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.backspace',
  comment: 'Label for backspace key in shortcuts.',
  message: 'Backspace'
};
var TAB_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.tab',
  comment: 'Label for tab key in shortcuts.',
  message: 'Tab'
};
var SPACE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.space',
  comment: 'Label for space key in shortcuts.',
  message: 'Space'
};
var DELETE_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.delete',
  comment: 'Label for delete key in shortcuts.',
  message: 'Delete'
};
var PAGE_UP_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.pageUp',
  comment: 'Label for page up key in shortcuts.',
  message: 'Page Up'
};
var PAGE_DOWN_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.pageDown',
  comment: 'Label for page down key in shortcuts.',
  message: 'Page Down'
};
var HOME_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.home',
  comment: 'Label for home key in shortcuts.',
  message: 'Home'
};
var END_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.end',
  comment: 'Label for end key in shortcuts.',
  message: 'End'
};
var ARROW_LEFT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowLeft',
  comment: 'Label for arrow left key in shortcuts.',
  message: 'Arrow Left'
};
var ARROW_RIGHT_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowRight',
  comment: 'Label for arrow right key in shortcuts.',
  message: 'Arrow Right'
};
var ARROW_UP_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowUp',
  comment: 'Label for arrow up key in shortcuts.',
  message: 'Arrow Up'
};
var ARROW_DOWN_KEY =
/*i18n*/
{
  id: 'keyboard.shortcut.arrowDown',
  comment: 'Label for arrowDown key in shortcuts.',
  message: 'Arrow Down'
};

var coreUtilsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ESCAPE_KEY: ESCAPE_KEY,
  COMMAND_KEY: COMMAND_KEY,
  CONTROL_KEY: CONTROL_KEY,
  ENTER_KEY: ENTER_KEY,
  SHIFT_KEY: SHIFT_KEY,
  ALT_KEY: ALT_KEY,
  CAPS_LOCK_KEY: CAPS_LOCK_KEY,
  BACKSPACE_KEY: BACKSPACE_KEY,
  TAB_KEY: TAB_KEY,
  SPACE_KEY: SPACE_KEY,
  DELETE_KEY: DELETE_KEY,
  PAGE_UP_KEY: PAGE_UP_KEY,
  PAGE_DOWN_KEY: PAGE_DOWN_KEY,
  HOME_KEY: HOME_KEY,
  END_KEY: END_KEY,
  ARROW_LEFT_KEY: ARROW_LEFT_KEY,
  ARROW_RIGHT_KEY: ARROW_RIGHT_KEY,
  ARROW_UP_KEY: ARROW_UP_KEY,
  ARROW_DOWN_KEY: ARROW_DOWN_KEY
});

var ADD_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.add-annotation.label',
  comment: 'Label for adding an annotation.',
  message: 'Add annotation'
};
var UPDATE_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.update-annotation.label',
  comment: 'Label for updating an annotation.',
  message: 'Update annotation'
};
var REMOVE_ANNOTATION =
/*i18n*/
{
  id: 'extension.command.remove-annotation.label',
  comment: 'Label for removing an annotation.',
  message: 'Remove annotation'
};

var extensionAnnotationMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ADD_ANNOTATION: ADD_ANNOTATION,
  UPDATE_ANNOTATION: UPDATE_ANNOTATION,
  REMOVE_ANNOTATION: REMOVE_ANNOTATION
});

var LABEL$e =
/*i18n*/
{
  id: 'extension.command.set-text-direction.label',
  comment: 'Label for setting the text direction.',
  message: "{dir, select, ltr {Left-To-Right}\nrtl {Right-To-Left}\nother {Reset Direction}}"
};
var DESCRIPTION$b =
/*i18n*/
{
  id: 'extension.command.set-text-direction.description',
  comment: 'Description for setting the text direction.',
  message: "{dir, select, ltr {Set the text direction from left to right}\nrtl {Set the text direction from right to left}\nother {Reset text direction}}"
};

var extensionBidiMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$e,
  DESCRIPTION: DESCRIPTION$b
});

var LABEL$d =
/*i18n*/
{
  id: 'extension.command.toggle-blockquote.label',
  comment: 'Label for blockquote formatting command.',
  message: 'Blockquote'
};
var DESCRIPTION$a =
/*i18n*/
{
  id: 'extension.command.toggle-blockquote.description',
  comment: 'Description for blockquote formatting command.',
  message: 'Add blockquote formatting to the selected text'
};

var extensionBlockquoteMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$d,
  DESCRIPTION: DESCRIPTION$a
});

var LABEL$c =
/*i18n*/
{
  id: 'extension.command.toggle-bold.label',
  comment: 'Label for bold formatting command.',
  message: 'Bold'
};
var DESCRIPTION$9 =
/*i18n*/
{
  id: 'extension.command.toggle-bold.description',
  comment: 'Description for bold formatting command.',
  message: 'Add bold formatting to the selected text'
};

var extensionBoldMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$c,
  DESCRIPTION: DESCRIPTION$9
});

var LABEL$b =
/*i18n*/
{
  id: 'extension.command.toggle-callout.label',
  comment: 'Label for callout command with support for callout types.',
  message: "{type, select, info {Information Callout}\nwarning {Warning Callout}\nerror {Error Callout}\nsuccess {Success Callout}\nother {Callout}}"
};
var DESCRIPTION$8 =
/*i18n*/
{
  id: 'extension.command.toggle-callout.description',
  comment: 'Description of the callout command with support for callout types.',
  message: "{type, select, info {Create an information callout block}\nwarning {Create a warning callout block}\nerror {Create an error callout block}\nsuccess {Create a success callout block}\nother {Create a callout block}}"
};

var extensionCalloutMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$b,
  DESCRIPTION: DESCRIPTION$8
});

var LABEL$a =
/*i18n*/
{
  id: 'extension.command.toggle-code-block.label',
  comment: 'Label for the code block command.',
  message: 'Codeblock'
};
var DESCRIPTION$7 =
/*i18n*/
{
  id: 'extension.command.toggle-code-block.description',
  comment: 'Description for the code block command.',
  message: 'Add a code block'
};

var extensionCodeBlockMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$a,
  DESCRIPTION: DESCRIPTION$7
});

var LABEL$9 =
/*i18n*/
{
  id: 'extension.command.toggle-code.label',
  comment: 'Label for the inline code formatting.',
  message: 'Code'
};
var DESCRIPTION$6 =
/*i18n*/
{
  id: 'extension.command.toggle-code.description',
  comment: 'Description for the inline code formatting command.',
  message: 'Add inline code formatting to the selected text'
};

var extensionCodeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$9,
  DESCRIPTION: DESCRIPTION$6
});

var LABEL$8 =
/*i18n*/
{
  id: 'extension.command.toggle-columns.label',
  comment: 'Label for columns command with support for number of columns counts.',
  message: "{count, select, 2 {Two Column Block}\n3 {Three Column Block}\n4 {Four Column Block}\nother {Multi Column Block}}"
};
var DESCRIPTION$5 =
/*i18n*/
{
  id: 'extension.command.toggle-columns.description',
  comment: 'Description of the columns command with support for number of columns counts.',
  message: "{count, select, 2 {Split the block into two columns}\n3 {Split the current block into three columns}\n4 {Split the current block into four columns}\nother {Split the current block into multiple columns}}"
};

var extensionColumnsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$8,
  DESCRIPTION: DESCRIPTION$5
});

var INSERT_EMOJI_LABEL =
/*i18n*/
{
  id: 'extension.command.insert-emoji.label',
  comment: 'Label for inserting an emoji.',
  message: 'Insert Emoji'
};

var extensionEmojiMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INSERT_EMOJI_LABEL: INSERT_EMOJI_LABEL
});

var SET_LABEL$1 =
/*i18n*/
{
  id: 'extension.command.set-font-size.label',
  comment: 'Label for adding a font size.',
  message: 'Font size'
};
var SET_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.set-font-size.description',
  comment: 'Description for adding a font size.',
  message: 'Set the font size for the selected text.'
};
var INCREASE_LABEL =
/*i18n*/
{
  id: 'extension.command.increase-font-size.label',
  comment: 'Label for increasing the font size.',
  message: 'Increase'
};
var INCREASE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.increase-font-size.description',
  comment: 'Description for increasing the font size.',
  message: 'Increase the font size'
};
var DECREASE_LABEL =
/*i18n*/
{
  id: 'extension.command.decrease-font-size.label',
  comment: 'Label for decreasing the font size.',
  message: 'Decrease'
};
var DECREASE_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.decrease-font-size.description',
  comment: 'Description for decreasing the font size.',
  message: 'Decrease the font size.'
};

var extensionFontSizeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SET_LABEL: SET_LABEL$1,
  SET_DESCRIPTION: SET_DESCRIPTION,
  INCREASE_LABEL: INCREASE_LABEL,
  INCREASE_DESCRIPTION: INCREASE_DESCRIPTION,
  DECREASE_LABEL: DECREASE_LABEL,
  DECREASE_DESCRIPTION: DECREASE_DESCRIPTION
});

var LABEL$7 =
/*i18n*/
{
  id: 'extension.command.toggle-heading.label',
  comment: 'Label for heading command with support for levels.',
  message: "{level, select, 1 {Heading 1}\n2 {Heading 2}\n3 {Heading 3}\n4 {Heading 4}\n5 {Heading 5}\n6 {Heading 6}\nother {Heading}}"
};

var extensionHeadingMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$7
});

var UNDO_LABEL =
/*i18n*/
{
  id: 'extension.command.undo.label',
  comment: 'Label for undo.',
  message: 'Undo'
};
var UNDO_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.undo.description',
  comment: 'Description for undo.',
  message: 'Undo the most recent action'
};
var REDO_LABEL =
/*i18n*/
{
  id: 'extension.command.redo.label',
  comment: 'Label for redo.',
  message: 'Redo'
};
var REDO_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.redo.description',
  comment: 'Description for redo.',
  message: 'Redo the most recent action'
};

var extensionHistoryMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  UNDO_LABEL: UNDO_LABEL,
  UNDO_DESCRIPTION: UNDO_DESCRIPTION,
  REDO_LABEL: REDO_LABEL,
  REDO_DESCRIPTION: REDO_DESCRIPTION
});

var LABEL$6 =
/*i18n*/
{
  id: 'extension.command.toggle-italic.label',
  comment: 'Label for italic formatting command.',
  message: 'Italic'
};
var DESCRIPTION$4 =
/*i18n*/
{
  id: 'extension.command.toggle-italic.description',
  comment: 'Description for italic formatting command.',
  message: 'Italicize the selected text'
};

var extensionItalicMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$6,
  DESCRIPTION: DESCRIPTION$4
});

var ORDERED_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-ordered-list.label',
  comment: 'Label for inserting an ordered list into the editor.',
  message: 'Ordered list'
};
var BULLET_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-bullet-list.description',
  comment: 'Description for inserting a bullet list into the editor.',
  message: 'Bulleted list'
};
var TASK_LIST_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-task-list.description',
  comment: 'Description for inserting a task list into the editor.',
  message: 'Tasked list'
};

var extensionListMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ORDERED_LIST_LABEL: ORDERED_LIST_LABEL,
  BULLET_LIST_LABEL: BULLET_LIST_LABEL,
  TASK_LIST_LABEL: TASK_LIST_LABEL
});

var INCREASE_INDENT_LABEL =
/*i18n*/
{
  id: 'extension.command.increase-indent.label',
  comment: 'Label for increasing the indentation level.',
  message: 'Increase indentation'
};
var DECREASE_INDENT_LABEL =
/*i18n*/
{
  id: 'extension.command.decrease-indent.label',
  comment: 'Label for decreasing the indentation level of the current node block.',
  message: 'Decrease indentation'
};
var CENTER_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.center-align.label',
  comment: 'Center align the text in the current node.',
  message: 'Center align'
};
var JUSTIFY_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.justify-align.label',
  comment: 'Justify the alignment of the selected nodes.',
  message: 'Justify'
};
var RIGHT_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.right-align.label',
  comment: 'Right align the selected nodes.',
  message: 'Right align'
};
var LEFT_ALIGN_LABEL =
/*i18n*/
{
  id: 'extension.command.left-align.label',
  comment: 'Left align the selected nodes.',
  message: 'Left align'
};

var extensionNodeFormattingMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INCREASE_INDENT_LABEL: INCREASE_INDENT_LABEL,
  DECREASE_INDENT_LABEL: DECREASE_INDENT_LABEL,
  CENTER_ALIGN_LABEL: CENTER_ALIGN_LABEL,
  JUSTIFY_ALIGN_LABEL: JUSTIFY_ALIGN_LABEL,
  RIGHT_ALIGN_LABEL: RIGHT_ALIGN_LABEL,
  LEFT_ALIGN_LABEL: LEFT_ALIGN_LABEL
});

var INSERT_LABEL =
/*i18n*/
{
  id: 'extension.command.insert-paragraph.label',
  comment: 'Label for inserting a paragraph.',
  message: 'Insert Paragraph'
};
var INSERT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.insert-paragraph.description',
  comment: 'Description for inserting a paragraph.',
  message: 'Insert a new paragraph'
};
var CONVERT_LABEL =
/*i18n*/
{
  id: 'extension.command.convert-paragraph.label',
  comment: 'Label for converting the current node into a paragraph.',
  message: 'Convert Paragraph'
};
var CONVERT_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.convert-paragraph.description',
  comment: 'Description for converting a paragraph.',
  message: 'Convert current block into a paragraph block.'
};

var extensionParagraphMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  INSERT_LABEL: INSERT_LABEL,
  INSERT_DESCRIPTION: INSERT_DESCRIPTION,
  CONVERT_LABEL: CONVERT_LABEL,
  CONVERT_DESCRIPTION: CONVERT_DESCRIPTION
});

var LABEL$5 =
/*i18n*/
{
  id: 'extension.command.toggle-strike.label',
  comment: 'Label for strike formatting command.',
  message: 'Strikethrough'
};
var DESCRIPTION$3 =
/*i18n*/
{
  id: 'extension.command.toggle-strike.description',
  comment: 'Description for strike formatting command.',
  message: 'Strikethrough the selected text'
};

var extensionStrikeMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$5,
  DESCRIPTION: DESCRIPTION$3
});

var LABEL$4 =
/*i18n*/
{
  id: 'extension.command.toggle-subscript.label',
  comment: 'Label for toggling a subscript.',
  message: 'Subscript'
};

var extensionSubMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$4
});

var LABEL$3 =
/*i18n*/
{
  id: 'extension.command.toggle-superscript.label',
  comment: 'Label for toggling a superscript.',
  message: 'Superscript'
};

var extensionSupMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$3
});

var CREATE_COMMAND_LABEL =
/*i18n*/
{
  id: 'extension.command.create-table.label',
  comment: 'Label for creating a table',
  message: 'Create table'
};
var CREATE_COMMAND_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.create-table.description',
  comment: 'Description for creating a table',
  message: 'Create a table with set number of rows and columns.'
};
/**
 * Takes a `{ count: number }` value to denote the number of columns.
 */

var COLUMN_COUNT =
/*i18n*/
{
  id: 'extension.table.column_count',
  comment: 'The number of columns',
  message: '{count, plural, one {# column} other {# columns}}'
};
/**
 * Takes a `{ count: number }` value to denote the number of rows.
 */

var ROW_COUNT =
/*i18n*/
{
  id: 'extension.table.row_count',
  comment: 'The number of rows',
  message: '{count, plural, one {# row} other {# rows}}'
};

var extensionTablesMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  CREATE_COMMAND_LABEL: CREATE_COMMAND_LABEL,
  CREATE_COMMAND_DESCRIPTION: CREATE_COMMAND_DESCRIPTION,
  COLUMN_COUNT: COLUMN_COUNT,
  ROW_COUNT: ROW_COUNT
});

var TOGGLE_LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-upper-case.label',
  comment: 'Label for toggling between upper and lower case.',
  message: "{case, select, upper {Uppercase}\nlower {Lowercase}\ncapitalize {Sentence case}\nsmallCaps {Small caps}\nother {Text case}}"
};
var SET_LABEL =
/*i18n*/
{
  id: 'extension.command.set-casing.label',
  comment: 'Label for setting the case.',
  message: 'Set text case'
};

var extensionTextCaseMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  TOGGLE_LABEL: TOGGLE_LABEL,
  SET_LABEL: SET_LABEL
});

var SET_COLOR_LABEL =
/*i18n*/
{
  id: 'extension.command.set-text-color.label',
  comment: 'Label for color formatting command.',
  message: 'Text color'
};
var SET_COLOR_DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.set-text-color.description',
  comment: 'Description for color formatting command.',
  message: 'Set the text color for the selected text.'
};
var TRANSPARENT =
/*i18n*/
{
  id: 'ui.text-color.transparent',
  comment: 'Transparent color label.',
  message: 'Transparent'
};
var WHITE =
/*i18n*/
{
  id: 'ui.text-color.white',
  comment: 'White color.',
  message: 'White'
};
var BLACK =
/*i18n*/
{
  id: 'ui.text-color.black',
  comment: 'Black color.',
  message: 'Black'
};
var GRAY =
/*i18n*/
{
  id: 'ui.text-color.gray',
  comment: 'Gray color.',
  message: "Gray"
};
var GRAY_HUE =
/*i18n*/
{
  id: 'ui.text-color.gray.hue',
  comment: 'Gray color hues.',
  message: "Gray {hue}"
};
var RED =
/*i18n*/
{
  id: 'ui.text-color.red',
  comment: 'Red color.',
  message: "Red"
};
var RED_HUE =
/*i18n*/
{
  id: 'ui.text-color.red.hue',
  comment: 'Red color hues.',
  message: "Red {hue}"
};
var PINK =
/*i18n*/
{
  id: 'ui.text-color.pink',
  comment: 'Pink color.',
  message: "Pink"
};
var PINK_HUE =
/*i18n*/
{
  id: 'ui.text-color.pink.hue',
  comment: 'Pink color hues.',
  message: "Pink {hue}"
};
var GRAPE =
/*i18n*/
{
  id: 'ui.text-color.grape',
  comment: 'Grape color.',
  message: "Grape"
};
var GRAPE_HUE =
/*i18n*/
{
  id: 'ui.text-color.grape.hue',
  comment: 'Grape color hues.',
  message: "Grape {hue}"
};
var VIOLET =
/*i18n*/
{
  id: 'ui.text-color.violet',
  comment: 'Violet color.',
  message: "Violet"
};
var VIOLET_HUE =
/*i18n*/
{
  id: 'ui.text-color.violet.hue',
  comment: 'Violet color hues.',
  message: "Violet {hue}"
};
var INDIGO =
/*i18n*/
{
  id: 'ui.text-color.indigo',
  comment: 'Indigo color.',
  message: "Indigo"
};
var INDIGO_HUE =
/*i18n*/
{
  id: 'ui.text-color.indigo.hue',
  comment: 'Indigo color hues.',
  message: "Indigo {hue}"
};
var BLUE =
/*i18n*/
{
  id: 'ui.text-color.blue',
  comment: 'Blue color.',
  message: "Blue"
};
var BLUE_HUE =
/*i18n*/
{
  id: 'ui.text-color.blue.hue',
  comment: 'Blue color hues.',
  message: "Blue {hue}"
};
var CYAN =
/*i18n*/
{
  id: 'ui.text-color.cyan',
  comment: 'Cyan color.',
  message: "Cyan"
};
var CYAN_HUE =
/*i18n*/
{
  id: 'ui.text-color.cyan.hue',
  comment: 'Cyan color hues.',
  message: "Cyan {hue}"
};
var TEAL =
/*i18n*/
{
  id: 'ui.text-color.teal',
  comment: 'Teal color.',
  message: "Teal"
};
var TEAL_HUE =
/*i18n*/
{
  id: 'ui.text-color.teal.hue',
  comment: 'Teal color hues.',
  message: "Teal {hue}"
};
var GREEN =
/*i18n*/
{
  id: 'ui.text-color.green',
  comment: 'Green color.',
  message: "Green"
};
var GREEN_HUE =
/*i18n*/
{
  id: 'ui.text-color.green.hue',
  comment: 'Green color hues.',
  message: "Green {hue}"
};
var LIME =
/*i18n*/
{
  id: 'ui.text-color.lime',
  comment: 'Lime color.',
  message: "Lime"
};
var LIME_HUE =
/*i18n*/
{
  id: 'ui.text-color.lime.hue',
  comment: 'Lime color hues.',
  message: "Lime {hue}"
};
var YELLOW =
/*i18n*/
{
  id: 'ui.text-color.yellow',
  comment: 'Yellow color.',
  message: "Yellow"
};
var YELLOW_HUE =
/*i18n*/
{
  id: 'ui.text-color.yellow.hue',
  comment: 'Yellow color hues.',
  message: "Yellow {hue}"
};
var ORANGE =
/*i18n*/
{
  id: 'ui.text-color.orange',
  comment: 'Orange color.',
  message: "Orange"
};
var ORANGE_HUE =
/*i18n*/
{
  id: 'ui.text-color.orange.hue',
  comment: 'Orange color hues.',
  message: "Orange {hue}"
};

var extensionTextColorMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  SET_COLOR_LABEL: SET_COLOR_LABEL,
  SET_COLOR_DESCRIPTION: SET_COLOR_DESCRIPTION,
  TRANSPARENT: TRANSPARENT,
  WHITE: WHITE,
  BLACK: BLACK,
  GRAY: GRAY,
  GRAY_HUE: GRAY_HUE,
  RED: RED,
  RED_HUE: RED_HUE,
  PINK: PINK,
  PINK_HUE: PINK_HUE,
  GRAPE: GRAPE,
  GRAPE_HUE: GRAPE_HUE,
  VIOLET: VIOLET,
  VIOLET_HUE: VIOLET_HUE,
  INDIGO: INDIGO,
  INDIGO_HUE: INDIGO_HUE,
  BLUE: BLUE,
  BLUE_HUE: BLUE_HUE,
  CYAN: CYAN,
  CYAN_HUE: CYAN_HUE,
  TEAL: TEAL,
  TEAL_HUE: TEAL_HUE,
  GREEN: GREEN,
  GREEN_HUE: GREEN_HUE,
  LIME: LIME,
  LIME_HUE: LIME_HUE,
  YELLOW: YELLOW,
  YELLOW_HUE: YELLOW_HUE,
  ORANGE: ORANGE,
  ORANGE_HUE: ORANGE_HUE
});

var LABEL$2 =
/*i18n*/
{
  id: 'extension.command.set-text-highlight.label',
  comment: 'Label for adding a text highlight.',
  message: 'Text highlight'
};
var DESCRIPTION$2 =
/*i18n*/
{
  id: 'extension.command.set-text-highlight.description',
  comment: 'Description for adding a text highlight.',
  message: 'Set the text highlight color for the selected text.'
};

var extensionTextHighlightMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$2,
  DESCRIPTION: DESCRIPTION$2
});

var LABEL$1 =
/*i18n*/
{
  id: 'extension.command.toggle-underline.label',
  comment: 'Label for underline formatting command.',
  message: 'Underline'
};
var DESCRIPTION$1 =
/*i18n*/
{
  id: 'extension.command.toggle-underline.description',
  comment: 'Description for underline formatting command.',
  message: 'Underline the selected text'
};

var extensionUnderlineMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL$1,
  DESCRIPTION: DESCRIPTION$1
});

var LABEL =
/*i18n*/
{
  id: 'extension.command.toggle-whitespace.label',
  comment: 'Label for displaying whitespace characters.',
  message: 'Toggle Whitespace'
};
var DESCRIPTION =
/*i18n*/
{
  id: 'extension.command.toggle-whitespace.description',
  comment: 'Description for displaying whitespace characters.',
  message: 'Show hidden whitespace characters in your editor.'
};

var extensionWhitespaceMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  LABEL: LABEL,
  DESCRIPTION: DESCRIPTION
});

var NO_ITEMS_AVAILABLE =
/*i18n*/
{
  id: 'react-components.mention-atom-component.zero-items',
  comment: 'Shown when no popup items are available',
  message: 'No items available'
};

var reactComponentsMessages = /*#__PURE__*/Object.freeze({
  __proto__: null,
  NO_ITEMS_AVAILABLE: NO_ITEMS_AVAILABLE
});

exports.CoreMessages = coreMessages;
exports.CoreUtilsMessages = coreUtilsMessages;
exports.ExtensionAnnotationMessages = extensionAnnotationMessages;
exports.ExtensionBidiMessages = extensionBidiMessages;
exports.ExtensionBlockquoteMessages = extensionBlockquoteMessages;
exports.ExtensionBoldMessages = extensionBoldMessages;
exports.ExtensionCalloutMessages = extensionCalloutMessages;
exports.ExtensionCodeBlockMessages = extensionCodeBlockMessages;
exports.ExtensionCodeMessages = extensionCodeMessages;
exports.ExtensionColumnsMessages = extensionColumnsMessages;
exports.ExtensionEmojiMessages = extensionEmojiMessages;
exports.ExtensionFontSizeMessages = extensionFontSizeMessages;
exports.ExtensionHeadingMessages = extensionHeadingMessages;
exports.ExtensionHistoryMessages = extensionHistoryMessages;
exports.ExtensionItalicMessages = extensionItalicMessages;
exports.ExtensionListMessages = extensionListMessages;
exports.ExtensionNodeFormattingMessages = extensionNodeFormattingMessages;
exports.ExtensionParagraphMessages = extensionParagraphMessages;
exports.ExtensionStrikeMessages = extensionStrikeMessages;
exports.ExtensionSubMessages = extensionSubMessages;
exports.ExtensionSupMessages = extensionSupMessages;
exports.ExtensionTablesMessages = extensionTablesMessages;
exports.ExtensionTextCaseMessages = extensionTextCaseMessages;
exports.ExtensionTextColorMessages = extensionTextColorMessages;
exports.ExtensionTextHighlightMessages = extensionTextHighlightMessages;
exports.ExtensionUnderlineMessages = extensionUnderlineMessages;
exports.ExtensionWhitespaceMessages = extensionWhitespaceMessages;
exports.ReactComponentMessages = reactComponentsMessages;


/***/ }),
/* 83 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(84);
} else {
  module.exports = __webpack_require__(86);
}


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorInputrules = __webpack_require__(85);



Object.keys(prosemirrorInputrules).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorInputrules[k]; }
	});
});


/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InputRule": () => (/* binding */ InputRule),
/* harmony export */   "closeDoubleQuote": () => (/* binding */ closeDoubleQuote),
/* harmony export */   "closeSingleQuote": () => (/* binding */ closeSingleQuote),
/* harmony export */   "ellipsis": () => (/* binding */ ellipsis),
/* harmony export */   "emDash": () => (/* binding */ emDash),
/* harmony export */   "inputRules": () => (/* binding */ inputRules),
/* harmony export */   "openDoubleQuote": () => (/* binding */ openDoubleQuote),
/* harmony export */   "openSingleQuote": () => (/* binding */ openSingleQuote),
/* harmony export */   "smartQuotes": () => (/* binding */ smartQuotes),
/* harmony export */   "textblockTypeInputRule": () => (/* binding */ textblockTypeInputRule),
/* harmony export */   "undoInputRule": () => (/* binding */ undoInputRule),
/* harmony export */   "wrappingInputRule": () => (/* binding */ wrappingInputRule)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(43);



// ::- Input rules are regular expressions describing a piece of text
// that, when typed, causes something to happen. This might be
// changing two dashes into an emdash, wrapping a paragraph starting
// with `"> "` into a blockquote, or something entirely different.
var InputRule = function InputRule(match, handler) {
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
};

function stringHandler(string) {
  return function(state, match, start, end) {
    var insert = string;
    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;
      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }
    return state.tr.insertText(insert, start, end)
  }
}

var MAX_MATCH = 500;

// :: (config: {rules: [InputRule]}) → Plugin
// Create an input rules plugin. When enabled, it will cause text
// input that matches any of the given rules to trigger the rule's
// action.
function inputRules(ref) {
  var rules = ref.rules;

  var plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({
    state: {
      init: function init() { return null },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) { return stored }
        return tr.selectionSet || tr.docChanged ? null : prev
      }
    },

    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin)
      },
      handleDOMEvents: {
        compositionend: function (view) {
          setTimeout(function () {
            var ref = view.state.selection;
            var $cursor = ref.$cursor;
            if ($cursor) { run(view, $cursor.pos, $cursor.pos, "", rules, plugin); }
          });
        }
      }
    },

    isInputRules: true
  });
  return plugin
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) { return false }
  var state = view.state, $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) { return false }
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,
                                            null, "\ufffc") + text;
  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) { continue }
    view.dispatch(tr.setMeta(plugin, {transform: tr, from: from, to: to, text: text}));
    return true
  }
  return false
}

// :: (EditorState, ?(Transaction)) → bool
// This is a command that will undo an input rule, if applying such a
// rule was the last thing that the user did.
function undoInputRule(state, dispatch) {
  var plugins = state.plugins;
  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i], undoable = (void 0);
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr, toUndo = undoable.transform;
        for (var j = toUndo.steps.length - 1; j >= 0; j--)
          { tr.step(toUndo.steps[j].invert(toUndo.docs[j])); }
        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
        dispatch(tr);
      }
      return true
    }
  }
  return false
}

// :: InputRule Converts double dashes to an emdash.
var emDash = new InputRule(/--$/, "—");
// :: InputRule Converts three dots to an ellipsis character.
var ellipsis = new InputRule(/\.\.\.$/, "…");
// :: InputRule “Smart” opening double quotes.
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“");
// :: InputRule “Smart” closing double quotes.
var closeDoubleQuote = new InputRule(/"$/, "”");
// :: InputRule “Smart” opening single quotes.
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘");
// :: InputRule “Smart” closing single quotes.
var closeSingleQuote = new InputRule(/'$/, "’");

// :: [InputRule] Smart-quote related input rules.
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>, ?([string], Node) → bool) → InputRule
// Build an input rule for automatically wrapping a textblock when a
// given string is typed. The `regexp` argument is
// directly passed through to the `InputRule` constructor. You'll
// probably want the regexp to start with `^`, so that the pattern can
// only occur at the start of a textblock.
//
// `nodeType` is the type of node to wrap in. If it needs attributes,
// you can either pass them directly, or pass a function that will
// compute them from the regular expression match.
//
// By default, if there's a node with the same type above the newly
// wrapped node, the rule will try to [join](#transform.Transform.join) those
// two nodes. You can pass a join predicate, which takes a regular
// expression match and the node before the wrapped node, and can
// return a boolean to indicate whether a join should happen.
function wrappingInputRule(regexp, nodeType, getAttrs, joinPredicate) {
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr.delete(start, end);
    var $start = tr.doc.resolve(start), range = $start.blockRange(), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return null }
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, start - 1) &&
        (!joinPredicate || joinPredicate(match, before)))
      { tr.join(start - 1); }
    return tr
  })
}

// :: (RegExp, NodeType, ?union<Object, ([string]) → ?Object>) → InputRule
// Build an input rule that changes the type of a textblock when the
// matched text is typed into it. You'll usually want to start your
// regexp with `^` to that it is only matched at the start of a
// textblock. The optional `getAttrs` parameter can be used to compute
// the new node's attributes, and works the same as in the
// `wrappingInputRule` function.
function textblockTypeInputRule(regexp, nodeType, getAttrs) {
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) { return null }
    return state.tr
      .delete(start, end)
      .setBlockType(start, start, nodeType, attrs)
  })
}


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorInputrules = __webpack_require__(85);



Object.keys(prosemirrorInputrules).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorInputrules[k]; }
	});
});


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(88);
} else {
  module.exports = __webpack_require__(99);
}


/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorSuggest = __webpack_require__(89);



Object.keys(prosemirrorSuggest).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorSuggest[k]; }
	});
});


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(90);
} else {
  module.exports = __webpack_require__(98);
}


/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorState = __webpack_require__(40);
var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var _defineProperty = __webpack_require__(15);
var _classPrivateFieldSet = __webpack_require__(91);
var _classPrivateFieldGet = __webpack_require__(94);
var prosemirrorView = __webpack_require__(96);
var coreHelpers = __webpack_require__(20);
var escapeStringRegex = __webpack_require__(97);
var coreConstants = __webpack_require__(17);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var escapeStringRegex__default = /*#__PURE__*/_interopDefault(escapeStringRegex);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

/**
 * This [[`Suggester`]] interface defines all the options required to create a
 * suggestion within your editor.
 *
 * @remarks
 *
 * The options are passed to the [[`suggest`]] method which uses them.
 */

/**
 * A function for checking whether the next selection is valid.
 *
 * It is called for all registered suggesters before any of the onChange
 * handlers are fired.
 *
 * @param $pos - the next valid position that supports text selections.
 * @param tr - the transaction that can be mutated when `appendTransaction` is
 * set to true.
 * @param matches - the possibly undefined exit and change matcher names. These
 * can be used to check if the name matches the current suggester.
 */

/**
 * A function that can be used to determine whether the decoration should be set
 * or not.
 *
 * @param match - the current active match
 * @param resolvedRange - the range of the match with each position resolved.
 */

/**
 * The potential reasons for an exit of a mention.
 */
exports.ExitReason = void 0;
/**
 * The potential reason for changes
 */

(function (ExitReason) {
  ExitReason["End"] = "exit-end";
  ExitReason["Removed"] = "delete";
  ExitReason["Split"] = "exit-split";
  ExitReason["InvalidSplit"] = "invalid-exit-split";
  ExitReason["MoveEnd"] = "move-end";
  ExitReason["MoveStart"] = "move-start";
  ExitReason["JumpForward"] = "jump-forward-exit";
  ExitReason["JumpBackward"] = "jump-backward-exit";
  ExitReason["SelectionOutside"] = "selection-outside";
})(exports.ExitReason || (exports.ExitReason = {}));

exports.ChangeReason = void 0;
/**
 * The parameters needed for the [[`SuggestIgnoreProps.addIgnored`]] action
 * method available to the suggest plugin handlers.
 *
 * @remarks
 *
 * See:
 * - [[`RemoveIgnoredProps`]]
 */

(function (ChangeReason) {
  ChangeReason["Start"] = "start";
  ChangeReason["Text"] = "change-character";
  ChangeReason["SelectionInside"] = "selection-inside";
  ChangeReason["Move"] = "move";
  ChangeReason["JumpBackward"] = "jump-backward-change";
  ChangeReason["JumpForward"] = "jump-forward-change";
})(exports.ChangeReason || (exports.ChangeReason = {}));

/**
 * Is this a change in the current suggestion (added or deleted characters)?
 */

function isChange(compare) {
  return !!(compare.prev && compare.next && compare.prev.text.full !== compare.next.text.full);
}
/**
 * Has the cursor moved within the current suggestion (added or deleted
 * characters)?
 */

function isMove(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.cursor !== compare.next.range.cursor);
}
/**
 * Are we entering a new suggestion?
 */

function isEntry(compare) {
  return !!(!compare.prev && compare.next);
}
/**
 * Are we exiting a suggestion?
 */

function isExit(compare) {
  return !!(compare.prev && !compare.next);
}
/**
 * Is this a jump from one suggestion to another?
 */

function isJump(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.from !== compare.next.range.from);
}
/**
 * Check that the passed in value is an [[`ExitReason`]].
 */

function isExitReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ExitReason).includes(value);
}
/**
 * Check that that the passed in value is a [[`ChangeReason`]].
 */

function isChangeReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ChangeReason).includes(value);
}
var selectionExitReasons = [exports.ExitReason.MoveEnd, exports.ExitReason.MoveStart, exports.ExitReason.SelectionOutside, exports.ExitReason.JumpForward, exports.ExitReason.JumpBackward];
/**
 * An exit which is caused by a change in the selection and no other change in
 * the document.
 */

function isSelectionExitReason(value) {
  return coreHelpers.includes(selectionExitReasons, value);
}
var selectionChangeReasons = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward, exports.ChangeReason.Move, exports.ChangeReason.SelectionInside];
function isSelectionChangeReason(value) {
  return coreHelpers.includes(selectionChangeReasons, value);
}
/**
 * Checks that the reason passed is a split reason. This typically means that we
 * should default to a partial update / creation of the mention.
 */

function isSplitReason(value) {
  return value === exports.ExitReason.Split;
}
/**
 * Checks that the reason was caused by a split at a point where there is no
 * query.
 */

function isInvalidSplitReason(value) {
  return value === exports.ExitReason.InvalidSplit;
}
/**
 * Checks that the reason was caused by a deletion.
 */

function isRemovedReason(value) {
  return value === exports.ExitReason.Removed;
} // Constants for the jump reasons

var exitJump = [exports.ExitReason.JumpBackward, exports.ExitReason.JumpForward];
var changeJump = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward];
/**
 * Checks to see if this is a jump reason.
 */

function isJumpReason(map) {
  var _map$exit, _map$change;

  return coreHelpers.includes(exitJump, (_map$exit = map.exit) === null || _map$exit === void 0 ? void 0 : _map$exit.exitReason) || coreHelpers.includes(changeJump, (_map$change = map.change) === null || _map$change === void 0 ? void 0 : _map$change.changeReason);
}
/**
 * True when the match is currently active (i.e. it's query has a value)
 */

function isValidMatch(match) {
  return !!(match && match.query.full.length >= match.suggester.matchOffset);
}
/**
 * True when the current selection is outside the match.
 */

function selectionOutsideMatch(props) {
  var match = props.match,
      selection = props.selection;
  return !!match && (selection.from < match.range.from || selection.from > match.range.to);
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof prosemirrorState.TextSelection;
}

/**
 * Small utility method for creating a match with the reason property available.
 */
function createMatchWithReason(props) {
  var match = props.match,
      changeReason = props.changeReason,
      exitReason = props.exitReason;
  return _objectSpread(_objectSpread({}, match), {}, {
    changeReason,
    exitReason
  });
}

/**
 * Checks to see if the text before the matching character is a valid prefix.
 *
 * @param prefix - the prefix to test
 * @param options - see [[`IsPrefixValidOptions`]]
 */
function isPrefixValid(prefix, options) {
  var invalidPrefixCharacters = options.invalidPrefixCharacters,
      validPrefixCharacters = options.validPrefixCharacters; // Will ignore the empty string intentionally.

  if (invalidPrefixCharacters) {
    var regex = new RegExp(regexToString(invalidPrefixCharacters));
    return !regex.test(prefix);
  }

  {
    var _regex = new RegExp(regexToString(validPrefixCharacters));

    return _regex.test(prefix);
  }
}
/**
 * Find the position of a mention for a given selection and character
 *
 * @param props - see [[`FindPositionProps`]]
 */


function findPosition(props) {
  var text = props.text,
      regexp = props.regexp,
      $pos = props.$pos,
      suggester = props.suggester; // The starting position for matches

  var start = $pos.start();
  var position;
  coreHelpers.findMatches(text, regexp).forEach(match => {
    // Check the character before the current match to ensure it is not one of
    // the supported characters
    var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);

    if (isPrefixValid(matchPrefix, suggester)) {
      // The absolute position of the matching parent node
      var from = match.index + start; // The full match of the created regex.

      var fullMatch = match[0]; // The matching text for the `char` regex or string is always captured as
      // the first matching group.

      var charMatch = match[1];

      if (!coreHelpers.isString(fullMatch) || !coreHelpers.isString(charMatch)) {
        return;
      } // The position where the match ends


      var to = from + fullMatch.length; // The cursor position (or end position whichever is greater)

      var cursor = Math.min(to, $pos.pos); // The length of the current match

      var matchLength = cursor - from; // If the $position is located within the matched substring, return that
      // range.

      if (from < $pos.pos && to >= $pos.pos) {
        position = {
          range: {
            from,
            to,
            cursor
          },
          match,
          query: {
            partial: fullMatch.slice(charMatch.length, matchLength),
            full: fullMatch.slice(charMatch.length)
          },
          text: {
            partial: fullMatch.slice(0, matchLength),
            full: fullMatch
          },
          textAfter: $pos.doc.textBetween(to, $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          textBefore: $pos.doc.textBetween(start, from, coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          suggester
        };
      }
    }
  });
  return position;
}

/**
 * Checks if any matches exist at the current selection so that the suggesters
 * can be activated or deactivated.
 */
function findMatch(props) {
  var $pos = props.$pos,
      suggester = props.suggester;
  var char = suggester.char,
      name = suggester.name,
      startOfLine = suggester.startOfLine,
      supportedCharacters = suggester.supportedCharacters,
      matchOffset = suggester.matchOffset,
      multiline = suggester.multiline,
      caseInsensitive = suggester.caseInsensitive,
      unicode = suggester.unicode; // Create the regular expression to match the text against

  var regexp = createRegexFromSuggester({
    char,
    matchOffset,
    startOfLine,
    supportedCharacters,
    multiline,
    caseInsensitive,
    unicode
  }); // All the text in the current node

  var text = $pos.doc.textBetween($pos.before(), $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER); // Find the position and return it

  return findPosition({
    suggester,
    text,
    regexp,
    $pos,
    char,
    name
  });
}

/**
 * Checks the provided match and generates a new match. This is useful for
 * determining the kind of change that has happened.
 *
 * If the match still exists and it is different then it's likely a split has
 * occurred.
 */
function recheckMatch(props) {
  var state = props.state,
      match = props.match;

  try {
    // Wrapped in try/catch because it's possible for everything to be deleted
    // and the doc.resolve will fail.
    return findMatch({
      $pos: state.doc.resolve(match.range.cursor),
      suggester: match.suggester
    });
  } catch (_unused) {
    return;
  }
}

/**
 * Check whether the insert action occurred at the end, in the middle or caused
 * the suggestion to be invalid.
 *
 * Prev refers to the original previous and next refers to the updated version
 * after the split
 */
function createInsertReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state; // Has the text been removed? TODO how to tests for deletions mid document?

  if (!next && prev.range.from >= state.doc.nodeSize) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.Removed
      })
    };
  } // Are we within an invalid split?


  if (!next || !prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.InvalidSplit
      })
    };
  } // Are we at the end position?


  if (prev.range.to === next.range.cursor) {
    // It seems that this never gets called. Revisit the logic and check whether
    // it's even necessary.
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.End
      })
    };
  } // Are we in the middle of the mention


  if (prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.Split
      })
    };
  }

  return {};
}

/**
 * Find the reason for the Jump between two suggesters.
 */
function findJumpReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state;
  var value = coreHelpers.object();
  var updatedPrevious = recheckMatch({
    state,
    match: prev
  });

  var _ref = updatedPrevious && updatedPrevious.query.full !== prev.query.full // has query changed
  ? createInsertReason({
    prev,
    next: updatedPrevious,
    state
  }) : value,
      exit = _ref.exit;

  var isJumpForward = prev.range.from < next.range.from;

  if (isJumpForward) {
    return {
      exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.JumpForward
      }),
      change: createMatchWithReason({
        match: next,
        changeReason: exports.ChangeReason.JumpForward
      })
    };
  }

  return {
    exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
      match: prev,
      exitReason: exports.ExitReason.JumpBackward
    }),
    change: createMatchWithReason({
      match: next,
      changeReason: exports.ChangeReason.JumpBackward
    })
  };
}

/**
 * Find the reason for the exit.
 *
 * This provides some context and helps sets up a helper command with sane
 * defaults.
 */
function findExitReason(props) {
  var match = props.match,
      state = props.state,
      $pos = props.$pos;
  var selection = state.selection;
  var updatedPrevious = recheckMatch({
    match,
    state
  }); // Exit created a split

  if (!updatedPrevious || updatedPrevious.text.full !== match.text.full) {
    return createInsertReason({
      prev: match,
      next: updatedPrevious,
      state
    });
  } // Exit caused by a selection


  if (!selection.empty && (selection.from <= match.range.from || selection.to >= match.range.to)) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.SelectionOutside
      })
    };
  } // Exit happened at the end of previous suggestion


  if ($pos.pos > match.range.to) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveEnd
      })
    };
  } // Exit happened at the start of previous suggestion


  if ($pos.pos <= match.range.from) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveStart
      })
    };
  }

  return {};
}

/**
 * Creates an array of the actions taken based on the current prev and next
 * state field
 */
function findReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state,
      $pos = props.$pos;
  var value = coreHelpers.object();

  if (!prev && !next) {
    return value;
  }

  var compare = {
    prev,
    next
  }; // Check for a Jump

  if (isJump(compare)) {
    return findJumpReason({
      prev: compare.prev,
      next: compare.next,
      state
    });
  } // Entered into a new suggestion


  if (isEntry(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Start
      })
    };
  } // Exited a suggestion


  if (isExit(compare)) {
    return findExitReason({
      $pos,
      match: compare.prev,
      state
    });
  }

  if (isChange(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Text
      })
    };
  }

  if (isMove(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: state.selection.empty ? exports.ChangeReason.Move : exports.ChangeReason.SelectionInside
      })
    };
  }

  return value;
}
/**
 * Check to see if the current $pos has a parent node matching the type.
 */

function hasParentNode($pos, types) {
  for (var depth = $pos.depth; depth > 0; depth--) {
    var node = $pos.node(depth);

    if (types.includes(node.type.name)) {
      return true;
    }
  }

  return false;
}
/**
 * Check whether the mark is active anywhere between `$from` and `$end`.
 *
 * Currently this is not doing exactly what it should. I've decided to be lazy
 * and only check the following.
 *
 * - Do any of the requested marks span the entire range using `rangeHasMarks`?
 * - Does the starting position have a mark?
 * - Does the cursor have a mark?
 * - Does the end position have a mark?
 *
 * In reality I should also check for each position within the range to see if a
 * target mark is active but I won't for now.
 */


function markActiveInRange(resolvedRange, marks) {
  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Check if there is a mark spanning the range of marks.

  if (rangeHasMarks(resolvedRange, marks)) {
    return true;
  } // Check if any of the positions in the available range have the active mark
  // associated with


  return coreHelpers.range($from.pos, $to.pos).some(value => positionHasMarks($from.doc.resolve(value), marks));
}
/**
 * Check if the entire matching range `from` the start point all the way through
 * `to` the end point, has any of the provided marks that span it.
 */

function rangeHasMarks(resolvedRange, marks) {
  var _$from$marksAcross;

  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Get the set of marks which span across the whole range.

  var setOfMarks = new Set(((_$from$marksAcross = $from.marksAcross($to)) !== null && _$from$marksAcross !== void 0 ? _$from$marksAcross : []).map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Check if the provided position has the given marks.
 */

function positionHasMarks($pos, marks) {
  // Get the set of marks for the current `$pos` which is used to check firstly
  // whether the set of marks is valid, and secondly whether the set of marks
  // includes any invalid marks.
  var setOfMarks = new Set($pos.marks().map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Checks if the suggester is in an invalid position.
 */

function isPositionValidForSuggester(suggester, resolvedRange) {
  var $cursor = resolvedRange.$cursor;
  var validMarks = suggester.validMarks,
      validNodes = suggester.validNodes,
      invalidMarks = suggester.invalidMarks,
      invalidNodes = suggester.invalidNodes; // Break early in the default case.

  if (!validMarks && !validNodes && coreHelpers.isEmptyArray(invalidMarks) && coreHelpers.isEmptyArray(invalidNodes)) {
    return true;
  }

  if (validMarks && !rangeHasMarks(resolvedRange, validMarks)) {
    return false;
  }

  if (validNodes && !hasParentNode($cursor, validNodes)) {
    return false;
  }

  if (!validMarks && markActiveInRange(resolvedRange, invalidMarks)) {
    return false;
  }

  if (!validNodes && hasParentNode($cursor, invalidNodes)) {
    return false;
  }

  return true;
}
/**
 * Find a match for the provided matchers.
 */


function findFromSuggesters(props) {
  var suggesters = props.suggesters,
      $pos = props.$pos,
      selectionEmpty = props.selectionEmpty; // Find the first match and break when done

  var _iterator = _createForOfIteratorHelper(suggesters),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var suggester = _step.value;

      // Make sure the selection is valid for this `suggester`.
      if (suggester.emptySelectionsOnly && !selectionEmpty) {
        continue;
      }

      try {
        var match = findMatch({
          suggester,
          $pos
        });

        if (!match) {
          continue;
        } // The resolved positions where `to` represents the cursor position.


        var resolvedRange = {
          $from: $pos.doc.resolve(match.range.from),
          $to: $pos.doc.resolve(match.range.to),
          $cursor: $pos
        };

        if (isPositionValidForSuggester(suggester, resolvedRange) && suggester.isValidPosition(resolvedRange, match)) {
          return match;
        } // Break early and return the match which was found.

      } catch (_unused2) {// Captures any errors which can pop up when all the content in the editor
        // is deleted or an invalid position was provided.
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return;
}
/**
 * Convert a RegExp into a string
 *
 * @param regexOrString
 */

function regexToString(regexOrString) {
  return coreHelpers.isRegExp(regexOrString) ? regexOrString.source : regexOrString;
}
/**
 * Find regex prefix when depending on whether the mention only supports the
 * start of a line or not
 *
 * @param onlyStartOfLine
 */


function getRegexPrefix(onlyStartOfLine) {
  return onlyStartOfLine ? '^' : '';
}
/**
 * Get the supported characters regex string.
 */


function getRegexSupportedCharacters(supportedCharacters, matchOffset) {
  return "(?:".concat(regexToString(supportedCharacters), "){").concat(matchOffset, ",}");
}
/**
 * Get the `char` from the `suggester` as regex.
 */


function getCharAsRegex(char) {
  return coreHelpers.isString(char) ? new RegExp(escapeStringRegex__default["default"](char)) : char;
}

/**
 * Create a regex expression which evaluate matches directly from the suggester
 * properties.
 */
function createRegexFromSuggester(props) {
  var char = props.char,
      matchOffset = props.matchOffset,
      startOfLine = props.startOfLine,
      supportedCharacters = props.supportedCharacters,
      _props$captureChar = props.captureChar,
      captureChar = _props$captureChar === void 0 ? true : _props$captureChar,
      _props$caseInsensitiv = props.caseInsensitive,
      caseInsensitive = _props$caseInsensitiv === void 0 ? false : _props$caseInsensitiv,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$unicode = props.unicode,
      unicode = _props$unicode === void 0 ? false : _props$unicode;
  var flags = "g".concat(multiline ? 'm' : '').concat(caseInsensitive ? 'i' : '').concat(unicode ? 'u' : '');
  var charRegex = getCharAsRegex(char).source;

  if (captureChar) {
    charRegex = "(".concat(charRegex, ")");
  }

  return new RegExp("".concat(getRegexPrefix(startOfLine)).concat(charRegex).concat(getRegexSupportedCharacters(supportedCharacters, matchOffset)), flags);
}
/**
 * The default value for the suggester.
 */

var DEFAULT_SUGGESTER = {
  appendTransaction: false,
  priority: 50,
  ignoredTag: 'span',
  matchOffset: 0,
  disableDecorations: false,
  startOfLine: false,
  suggestClassName: 'suggest',
  suggestTag: 'span',
  supportedCharacters: /\w+/,
  validPrefixCharacters: /^[\s\0]?$/,
  invalidPrefixCharacters: null,
  ignoredClassName: null,
  invalidMarks: [],
  invalidNodes: [],
  validMarks: null,
  validNodes: null,
  isValidPosition: () => true,
  checkNextValidSelection: null,
  emptySelectionsOnly: false,
  caseInsensitive: false,
  multiline: false,
  unicode: false,
  captureChar: true
};
/**
 * This can be added to the meta data of an update to let the suggestion plugin
 * know that it should ignore the update.
 */

var IGNORE_SUGGEST_META_KEY = '__ignore_prosemirror_suggest_update__';
/**
 * Takes the passed through `suggester` and adds all the missing default values.
 */

function getSuggesterWithDefaults(suggester) {
  return _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);
}

/**
 * The `prosemirror-suggest` state which manages the list of suggesters.
 */

var _docChanged = /*#__PURE__*/new WeakMap();

var _ignoreNextExit = /*#__PURE__*/new WeakMap();

var _suggesters = /*#__PURE__*/new WeakMap();

var _next = /*#__PURE__*/new WeakMap();

var _prev = /*#__PURE__*/new WeakMap();

var _handlerMatches = /*#__PURE__*/new WeakMap();

var _ignored = /*#__PURE__*/new WeakMap();

var _removed = /*#__PURE__*/new WeakMap();

var _lastChangeFromAppend = /*#__PURE__*/new WeakMap();

class SuggestState {
  /**
   * Create an instance of the SuggestState class.
   */
  static create(suggesters) {
    return new SuggestState(suggesters);
  }
  /**
   * True when the doc changed in the most recently applied transaction.
   */


  /**
   * The set of all decorations.
   */
  get decorationSet() {
    return _classPrivateFieldGet(this, _ignored);
  }
  /**
   * True when the most recent change was to remove a mention.
   *
   * @remarks
   *
   * This is needed because sometimes removing a prosemirror `Mark` has no
   * effect. Hence we need to keep track of whether it's removed and then later
   * in the apply step check that a removal has happened and reset the
   * `handlerMatches` to prevent an infinite loop.
   */


  get removed() {
    return _classPrivateFieldGet(this, _removed);
  }
  /**
   * Returns the current active suggester state field if one exists
   */


  get match() {
    return _classPrivateFieldGet(this, _next) ? _classPrivateFieldGet(this, _next) : _classPrivateFieldGet(this, _prev) && _classPrivateFieldGet(this, _handlerMatches).exit ? _classPrivateFieldGet(this, _prev) : undefined;
  }
  /**
   * Create the state for the `prosemirror-suggest` plugin.
   *
   * @remarks
   *
   * Each suggester must provide a name value which is globally unique since it
   * acts as the identifier.
   *
   * It is possible to register multiple suggesters with identical `char`
   * properties. The matched suggester is based on the specificity of the
   * `regex` and the order in which they are passed in. Earlier suggesters are
   * prioritized.
   */


  constructor(_suggesters2) {
    _classPrivateFieldInitSpec(this, _docChanged, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _ignoreNextExit, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _suggesters, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _next, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _prev, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _handlerMatches, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _ignored, {
      writable: true,
      value: prosemirrorView.DecorationSet.empty
    });

    _classPrivateFieldInitSpec(this, _removed, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _lastChangeFromAppend, {
      writable: true,
      value: false
    });

    _defineProperty(this, "setMarkRemoved", () => {
      _classPrivateFieldSet(this, _removed, true);
    });

    _defineProperty(this, "findNextTextSelection", selection => {
      var doc = selection.$from.doc; // Make sure the position doesn't exceed the bounds of the document.

      var pos = Math.min(doc.nodeSize - 2, selection.to + 1);
      var $pos = doc.resolve(pos); // Get the position furthest along in the editor to pass back to suggesters
      // which have the handler.

      var nextSelection = prosemirrorState.Selection.findFrom($pos, 1, true); // Ignore non-text selections and null / undefined values. This is needed
      // for TS mainly, since the `true` in the `Selection.findFrom` method means
      // only `TextSelection` instances will be returned.

      if (!isTextSelection(nextSelection)) {
        return;
      }

      return nextSelection;
    });

    _defineProperty(this, "ignoreNextExit", () => {
      _classPrivateFieldSet(this, _ignoreNextExit, true);
    });

    _defineProperty(this, "addIgnored", _ref => {
      var from = _ref.from,
          name = _ref.name,
          _ref$specific = _ref.specific,
          specific = _ref$specific === void 0 ? false : _ref$specific;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;
      var to = from + offset;
      var attributes = suggester.ignoredClassName ? {
        class: suggester.ignoredClassName
      } : {};
      var decoration = prosemirrorView.Decoration.inline(from, to, _objectSpread({
        nodeName: suggester.ignoredTag
      }, attributes), {
        name,
        specific,
        char: suggester.char
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).add(this.view.state.doc, [decoration]));
    });

    _defineProperty(this, "removeIgnored", _ref2 => {
      var from = _ref2.from,
          name = _ref2.name;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;

      var decoration = _classPrivateFieldGet(this, _ignored).find(from, from + offset)[0];

      if (!decoration || decoration.spec.name !== name) {
        return;
      }

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove([decoration]));
    });

    _defineProperty(this, "clearIgnored", name => {
      if (!name) {
        _classPrivateFieldSet(this, _ignored, prosemirrorView.DecorationSet.empty);

        return;
      }

      var decorations = _classPrivateFieldGet(this, _ignored).find();

      var decorationsToClear = decorations.filter(_ref3 => {
        var spec = _ref3.spec;
        return spec.name === name;
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove(decorationsToClear));
    });

    _defineProperty(this, "findMatchAtPosition", ($pos, name) => {
      var suggesters = name ? _classPrivateFieldGet(this, _suggesters).filter(suggester => suggester.name === name) : _classPrivateFieldGet(this, _suggesters);
      return findFromSuggesters({
        suggesters,
        $pos,
        docChanged: false,
        selectionEmpty: true
      });
    });

    _defineProperty(this, "setLastChangeFromAppend", () => {
      _classPrivateFieldSet(this, _lastChangeFromAppend, true);
    });

    var mapper = createSuggesterMapper();

    _classPrivateFieldSet(this, _suggesters, _suggesters2.map(mapper));

    _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(_classPrivateFieldGet(this, _suggesters), (a, b) => b.priority - a.priority));
  }
  /**
   * Initialize the SuggestState with a view which is stored for use later.
   */


  init(view) {
    this.view = view;
    return this;
  }
  /**
   * Sets the removed property to be true.
   *
   * This is useful when working with marks.
   */


  /**
   * Create the props which should be passed into each action handler
   */
  createProps(match) {
    var _match$suggester = match.suggester,
        name = _match$suggester.name,
        char = _match$suggester.char;
    return _objectSpread({
      view: this.view,
      addIgnored: this.addIgnored,
      clearIgnored: this.clearIgnored,
      ignoreNextExit: this.ignoreNextExit,
      setMarkRemoved: this.setMarkRemoved,
      name,
      char
    }, match);
  }
  /**
   * Check whether the exit callback is valid at this time.
   */


  shouldRunExit() {
    if (_classPrivateFieldGet(this, _ignoreNextExit)) {
      _classPrivateFieldSet(this, _ignoreNextExit, false);

      return false;
    }

    return true;
  }
  /**
   * Find the next text selection from the current selection.
   */


  /**
   * Update all the suggesters with the next valid selection. This is called
   * within the `appendTransaction` ProseMirror method before any of the change
   * handlers are called.
   *
   * @internal
   */
  updateWithNextSelection(tr) {
    // Get the position furthest along in the editor to pass back to suggesters
    // which have the handler.
    var nextSelection = this.findNextTextSelection(tr.selection);

    if (!nextSelection) {
      return;
    } // Update every suggester with a method attached.


    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _suggesters)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _classPrivateFieldGet2, _classPrivateFieldGet3, _suggester$checkNextV;

        var suggester = _step.value;
        var change = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _handlerMatches).change) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.suggester.name;
        var exit = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _handlerMatches).exit) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.suggester.name;
        (_suggester$checkNextV = suggester.checkNextValidSelection) === null || _suggester$checkNextV === void 0 ? void 0 : _suggester$checkNextV.call(suggester, nextSelection.$from, tr, {
          change,
          exit
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Call the `onChange` handlers.
   *
   * @internal
   */


  changeHandler(tr, appendTransaction) {
    var _classPrivateFieldGet4 = _classPrivateFieldGet(this, _handlerMatches),
        change = _classPrivateFieldGet4.change,
        exit = _classPrivateFieldGet4.exit;

    var match = this.match; // Cancel update when a suggester isn't active

    if (!change && !exit || !isValidMatch(match)) {
      return;
    }

    var shouldRunExit = appendTransaction === (exit === null || exit === void 0 ? void 0 : exit.suggester.appendTransaction) && this.shouldRunExit();
    var shouldRunChange = appendTransaction === (change === null || change === void 0 ? void 0 : change.suggester.appendTransaction);

    if (!shouldRunExit && !shouldRunChange) {
      return;
    } // When a jump happens run the action that involves the position that occurs
    // later in the document. This is so that changes don't affect previous
    // positions.


    if (change && exit && isJumpReason({
      change,
      exit
    })) {
      var exitDetails = this.createProps(exit);
      var changeDetails = this.createProps(change); // Whether the jump was forwards or backwards. A forwards jump means that
      // the user was within a suggester nearer the beginning of the document,
      // before jumping forward to a point later on in the document.

      var movedForwards = exit.range.from < change.range.from;

      if (movedForwards) {
        // Subtle change to call exit first. Conceptually it happens before the
        // change so call the handler before the change handler.
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      } else {
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      }

      if (shouldRunExit) {
        _classPrivateFieldSet(this, _removed, false);
      }

      return;
    }

    if (change && shouldRunChange) {
      change.suggester.onChange(this.createProps(change), tr);
    }

    if (exit && shouldRunExit) {
      exit.suggester.onChange(this.createProps(exit), tr);

      _classPrivateFieldSet(this, _removed, false);

      if (isInvalidSplitReason(exit.exitReason)) {
        // When the split has made the match invalid, remove the matches before
        // the next input.
        _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());
      }
    }

    return;
  }
  /**
   * Update the current ignored decorations based on the latest changes to the
   * prosemirror document.
   */


  mapIgnoredDecorations(tr) {
    // Map over and update the ignored decorations.
    var ignored = _classPrivateFieldGet(this, _ignored).map(tr.mapping, tr.doc);

    var decorations = ignored.find(); // For suggesters with multiple characters it is possible for a `paste` or
    // any edit action within the decoration to expand the ignored section. We
    // check for that here and if the section size has changed it should be
    // marked as invalid and removed from the ignored `DecorationSet`.

    var invalid = decorations.filter(_ref4 => {
      var from = _ref4.from,
          to = _ref4.to,
          spec = _ref4.spec;
      var charLength = coreHelpers.isString(spec.char) ? spec.char.length : 1;

      if (to - from !== charLength) {
        return true;
      }

      return false;
    });

    _classPrivateFieldSet(this, _ignored, ignored.remove(invalid));
  }
  /**
   * This sets the next exit to not trigger the exit reason inside the
   * `onChange` callback.
   *
   * This can be useful when you trigger a command, that exists the suggestion
   * match and want to prevent further onChanges from occurring for the
   * currently active suggester.
   */


  /**
   * Checks whether a match should be ignored.
   *
   * TODO add logic here to decide whether to ignore a match based on the active
   * node, or mark.
   */
  shouldIgnoreMatch(_ref5) {
    var range = _ref5.range,
        name = _ref5.suggester.name;

    var decorations = _classPrivateFieldGet(this, _ignored).find();

    var shouldIgnore = decorations.some(_ref6 => {
      var spec = _ref6.spec,
          from = _ref6.from;

      if (from !== range.from) {
        return false;
      }

      return spec.specific ? spec.name === name : true;
    });
    return shouldIgnore;
  }
  /**
   * Reset the state.
   */


  resetState() {
    _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());

    _classPrivateFieldSet(this, _next, undefined);

    _classPrivateFieldSet(this, _removed, false);

    _classPrivateFieldSet(this, _lastChangeFromAppend, false);
  }
  /**
   * Update the next state value.
   */


  updateReasons(props) {
    var $pos = props.$pos,
        state = props.state;

    var docChanged = _classPrivateFieldGet(this, _docChanged);

    var suggesters = _classPrivateFieldGet(this, _suggesters);

    var selectionEmpty = state.selection.empty;
    var match = isTextSelection(state.selection) ? findFromSuggesters({
      suggesters,
      $pos,
      docChanged,
      selectionEmpty
    }) : undefined; // Track the next match if not being ignored.

    _classPrivateFieldSet(this, _next, match && this.shouldIgnoreMatch(match) ? undefined : match); // Store the matches with reasons


    _classPrivateFieldSet(this, _handlerMatches, findReason({
      next: _classPrivateFieldGet(this, _next),
      prev: _classPrivateFieldGet(this, _prev),
      state,
      $pos
    }));
  }
  /**
   * A helper method to check is a match exists for the provided suggester name
   * at the provided position.
   */


  /**
   * Add a new suggest or replace it if it already exists.
   */
  addSuggester(suggester) {
    var previous = _classPrivateFieldGet(this, _suggesters).find(item => item.name === suggester.name);

    var mapper = createSuggesterMapper();

    if (previous) {
      _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).map(item => item === previous ? mapper(suggester) : item));
    } else {
      var suggesters = [..._classPrivateFieldGet(this, _suggesters), mapper(suggester)];

      _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(suggesters, (a, b) => b.priority - a.priority));
    }

    return () => this.removeSuggester(suggester.name);
  }
  /**
   * Remove a suggester if it exists.
   */


  removeSuggester(suggester) {
    var name = coreHelpers.isString(suggester) ? suggester : suggester.name;

    _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).filter(item => item.name !== name)); // When removing a suggester make sure to clear the ignored sections.


    this.clearIgnored(name);
  }

  toJSON() {
    return this.match;
  }
  /**
   * Applies updates to the state to be used within the plugins apply method.
   *
   * @param - params
   */


  apply(props) {
    var _classPrivateFieldGet5 = _classPrivateFieldGet(this, _handlerMatches),
        exit = _classPrivateFieldGet5.exit,
        change = _classPrivateFieldGet5.change;

    if (_classPrivateFieldGet(this, _lastChangeFromAppend)) {
      _classPrivateFieldSet(this, _lastChangeFromAppend, false);

      if (!(exit !== null && exit !== void 0 && exit.suggester.appendTransaction) && !(change !== null && change !== void 0 && change.suggester.appendTransaction)) {
        return this;
      }
    }

    var tr = props.tr,
        state = props.state;
    var transactionHasChanged = tr.docChanged || tr.selectionSet;
    var shouldIgnoreUpdate = tr.getMeta(IGNORE_SUGGEST_META_KEY);

    if (shouldIgnoreUpdate || !transactionHasChanged && !_classPrivateFieldGet(this, _removed)) {
      return this;
    }

    _classPrivateFieldSet(this, _docChanged, tr.docChanged);

    this.mapIgnoredDecorations(tr); // If the previous run was an exit, reset the suggester matches.

    if (exit) {
      this.resetState();
    } // Track the previous match.


    _classPrivateFieldSet(this, _prev, _classPrivateFieldGet(this, _next)); // Match against the current selection position


    this.updateReasons({
      $pos: tr.selection.$from,
      state
    });
    return this;
  }
  /**
   * Handle the decorations which wrap the mention while it is active and not
   * yet complete.
   */


  createDecorations(state) {
    var match = this.match;

    if (!isValidMatch(match)) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var disableDecorations = match.suggester.disableDecorations;
    var shouldSkip = coreHelpers.isFunction(disableDecorations) ? disableDecorations(state, match) : disableDecorations;

    if (shouldSkip) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var range = match.range,
        suggester = match.suggester;
    var name = suggester.name,
        suggestTag = suggester.suggestTag,
        suggestClassName = suggester.suggestClassName;
    var from = range.from,
        to = range.to;
    return this.shouldIgnoreMatch(match) ? _classPrivateFieldGet(this, _ignored) : _classPrivateFieldGet(this, _ignored).add(state.doc, [prosemirrorView.Decoration.inline(from, to, {
      nodeName: suggestTag,
      class: name ? "".concat(suggestClassName, " suggest-").concat(name) : suggestClassName
    }, {
      name
    })]);
  }
  /**
   * Set that the last change was caused by an appended transaction.
   *
   * @internal
   */


}

/**
 * Map over the suggesters provided and make sure they have all the required
 * properties.
 */
function createSuggesterMapper() {
  var names = new Set();
  return suggester => {
    if (names.has(suggester.name)) {
      throw new Error("A suggester already exists with the name '".concat(suggester.name, "'. The name provided must be unique."));
    } // Attach the defaults to the passed in suggester.


    var suggesterWithDefaults = _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);

    names.add(suggester.name);
    return suggesterWithDefaults;
  };
}
/**
 * This key is stored to provide access to the plugin state.
 */


var suggestPluginKey = new prosemirrorState.PluginKey('suggest');

/**
 * Get the state of the suggest plugin.
 *
 * @param state - the editor state.
 */

function getSuggestPluginState(state) {
  return suggestPluginKey.getState(state);
}
/**
 * Add a new suggester or replace it if the name already exists in the existing
 * configuration.
 *
 * Will return a function for disposing of the added suggester.
 */

function addSuggester(state, suggester) {
  return getSuggestPluginState(state).addSuggester(suggester);
}
/**
 * Call this method with a transaction to skip the suggest plugin checks for the
 * next update.
 *
 * This can be used for updates that don't need to trigger a recheck of the
 * suggest state.
 */

function ignoreUpdateForSuggest(tr) {
  tr.setMeta(IGNORE_SUGGEST_META_KEY, true);
}
/**
 * Remove a suggester if it exists. Pass in the name or the full suggester
 * object.
 */

function removeSuggester(state, suggester) {
  return getSuggestPluginState(state).removeSuggester(suggester);
}
/**
 * This creates a suggest plugin with all the suggesters that you provide.
 *
 * The priority of the suggesters is the order in which they are passed into
 * this function.
 *
 * - `const plugin = suggest(two, one, three)` - Here `two` will be checked
 *   first, then `one` and then `three`.
 *
 * Only one suggester can match at any given time. The order and specificity of
 * the regex parameters help determines which suggester will be active.
 *
 * @param suggesters - a list of suggesters in the order they should be
 * evaluated.
 */

function suggest() {
  for (var _len = arguments.length, suggesters = new Array(_len), _key = 0; _key < _len; _key++) {
    suggesters[_key] = arguments[_key];
  }

  // Create the initial plugin state for the suggesters.
  var pluginState = SuggestState.create(suggesters);
  return new prosemirrorState.Plugin({
    key: suggestPluginKey,
    // Handle the plugin view
    view: _view => {
      // Initialize the state with the required view before it is used.
      pluginState.init(_view);
      return {
        update: view => {
          return pluginState.changeHandler(view.state.tr, false);
        }
      };
    },
    state: {
      // Initialize the state
      init: () => {
        return pluginState;
      },
      // Apply changes to the state
      apply: (tr, _pluginState, _oldState, state) => {
        return pluginState.apply({
          tr,
          state
        });
      }
    },

    /** Append a transaction via the onChange handlers */
    appendTransaction: (_, __, state) => {
      var tr = state.tr; // Run the transaction updater for the next selection.

      pluginState.updateWithNextSelection(tr); // Run the change handler.

      pluginState.changeHandler(tr, true); // Check if the transaction has been amended in any way.

      if (tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet) {
        pluginState.setLastChangeFromAppend();
        return tr;
      }

      return null;
    },
    props: {
      // Sets up a decoration (styling options) on the currently active
      // decoration
      decorations: state => {
        return pluginState.createDecorations(state);
      }
    }
  });
}

exports.DEFAULT_SUGGESTER = DEFAULT_SUGGESTER;
exports.IGNORE_SUGGEST_META_KEY = IGNORE_SUGGEST_META_KEY;
exports.addSuggester = addSuggester;
exports.createRegexFromSuggester = createRegexFromSuggester;
exports.findFromSuggesters = findFromSuggesters;
exports.getSuggestPluginState = getSuggestPluginState;
exports.getSuggesterWithDefaults = getSuggesterWithDefaults;
exports.ignoreUpdateForSuggest = ignoreUpdateForSuggest;
exports.isChangeReason = isChangeReason;
exports.isExitReason = isExitReason;
exports.isInvalidSplitReason = isInvalidSplitReason;
exports.isJumpReason = isJumpReason;
exports.isRemovedReason = isRemovedReason;
exports.isSelectionChangeReason = isSelectionChangeReason;
exports.isSelectionExitReason = isSelectionExitReason;
exports.isSplitReason = isSplitReason;
exports.isValidMatch = isValidMatch;
exports.markActiveInRange = markActiveInRange;
exports.positionHasMarks = positionHasMarks;
exports.rangeHasMarks = rangeHasMarks;
exports.removeSuggester = removeSuggester;
exports.selectionOutsideMatch = selectionOutsideMatch;
exports.suggest = suggest;


/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorSet = __webpack_require__(92);

var classExtractFieldDescriptor = __webpack_require__(93);

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "set");
  classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}

module.exports = _classPrivateFieldSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 92 */
/***/ ((module) => {

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }

    descriptor.value = value;
  }
}

module.exports = _classApplyDescriptorSet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 93 */
/***/ ((module) => {

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }

  return privateMap.get(receiver);
}

module.exports = _classExtractFieldDescriptor, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 94 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var classApplyDescriptorGet = __webpack_require__(95);

var classExtractFieldDescriptor = __webpack_require__(93);

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = classExtractFieldDescriptor(receiver, privateMap, "get");
  return classApplyDescriptorGet(receiver, descriptor);
}

module.exports = _classPrivateFieldGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 95 */
/***/ ((module) => {

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }

  return descriptor.value;
}

module.exports = _classApplyDescriptorGet, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Decoration": () => (/* binding */ Decoration),
/* harmony export */   "DecorationSet": () => (/* binding */ DecorationSet),
/* harmony export */   "EditorView": () => (/* binding */ EditorView),
/* harmony export */   "__endComposition": () => (/* binding */ endComposition),
/* harmony export */   "__parseFromClipboard": () => (/* binding */ parseFromClipboard),
/* harmony export */   "__serializeForClipboard": () => (/* binding */ serializeForClipboard)
/* harmony export */ });
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(40);
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(43);




var result = {};

if (typeof navigator != "undefined" && typeof document != "undefined") {
  var ie_edge = /Edge\/(\d+)/.exec(navigator.userAgent);
  var ie_upto10 = /MSIE \d/.test(navigator.userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

  var ie = result.ie = !!(ie_upto10 || ie_11up || ie_edge);
  result.ie_version = ie_upto10 ? document.documentMode || 6 : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : null;
  result.gecko = !ie && /gecko\/(\d+)/i.test(navigator.userAgent);
  result.gecko_version = result.gecko && +(/Firefox\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
  var chrome = !ie && /Chrome\/(\d+)/.exec(navigator.userAgent);
  result.chrome = !!chrome;
  result.chrome_version = chrome && +chrome[1];
  // Is true for both iOS and iPadOS for convenience
  result.safari = !ie && /Apple Computer/.test(navigator.vendor);
  result.ios = result.safari && (/Mobile\/\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);
  result.mac = result.ios || /Mac/.test(navigator.platform);
  result.android = /Android \d/.test(navigator.userAgent);
  result.webkit = "webkitFontSmoothing" in document.documentElement.style;
  result.webkit_version = result.webkit && +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1];
}

var domIndex = function(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) { return index }
  }
};

var parentNode = function(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent
};

var reusedRange = null;

// Note that this will always return the same range, because DOM range
// objects are every expensive, and keep slowing down subsequent DOM
// updates, for some reason.
var textRange = function(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range
};

// Scans forward and backward through DOM positions equivalent to the
// given one to see if the two are in the same place (i.e. after a
// text node vs at the end of that text node)
var isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||
                        scanFor(node, off, targetNode, targetOff, 1))
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) { return true }
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||
          node.contentEditable == "false")
        { return false }
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") { return false }
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) { return true }
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) { return false }
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;
  for (var cur = dom; cur; cur = cur.parentNode) { if (desc = cur.pmViewDesc) { break } }
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom)
}

// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523
// (isCollapsed inappropriately returns true in shadow dom)
var selectionCollapsed = function(domSel) {
  var collapsed = domSel.isCollapsed;
  if (collapsed && result.chrome && domSel.rangeCount && !domSel.getRangeAt(0).collapsed)
    { collapsed = false; }
  return collapsed
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event
}

function windowRect(doc) {
  return {left: 0, right: doc.documentElement.clientWidth,
          top: 0, bottom: doc.documentElement.clientHeight}
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side]
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  // Adjust for elements with style "transform: scale()"
  var scaleX = (rect.width / node.offsetWidth) || 1;
  var scaleY = (rect.height / node.offsetHeight) || 1;
  // Make sure scrollbar width isn't included in the rectangle
  return {left: rect.left, right: rect.left + node.clientWidth * scaleX,
          top: rect.top, bottom: rect.top + node.clientHeight * scaleY}
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;
  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) { break }
    if (parent.nodeType != 1) { continue }
    var atTop = parent == doc.body || parent.nodeType != 1;
    var bounding = atTop ? windowRect(doc) : clientRect(parent);
    var moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      { moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top")); }
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      { moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom"); }
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      { moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left")); }
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      { moveX = rect.right - bounding.right + getSide(scrollMargin, "right"); }
    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = parent.scrollLeft, startY = parent.scrollTop;
        if (moveY) { parent.scrollTop += moveY; }
        if (moveX) { parent.scrollLeft += moveX; }
        var dX = parent.scrollLeft - startX, dY = parent.scrollTop - startY;
        rect = {left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY};
      }
    }
    if (atTop) { break }
  }
}

// Store the scroll position of the editor's parent nodes, along with
// the top position of an element near the top of the editor, which
// will be used to make sure the visible viewport remains stable even
// when the size of the content above changes.
function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  var refDOM, refTop;
  for (var x = (rect.left + rect.right) / 2, y = startY + 1;
       y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (dom == view.dom || !view.dom.contains(dom)) { continue }
    var localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break
    }
  }
  return {refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom)}
}

function scrollStack(dom) {
  var stack = [], doc = dom.ownerDocument;
  for (; dom; dom = parentNode(dom)) {
    stack.push({dom: dom, top: dom.scrollTop, left: dom.scrollLeft});
    if (dom == doc) { break }
  }
  return stack
}

// Reset the scroll position of the editor's parent nodes to that what
// it was before, when storeScrollPos was called.
function resetScrollPos(ref) {
  var refDOM = ref.refDOM;
  var refTop = ref.refTop;
  var stack = ref.stack;

  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var ref = stack[i];
    var dom = ref.dom;
    var top = ref.top;
    var left = ref.left;
    if (dom.scrollTop != top + dTop) { dom.scrollTop = top + dTop; }
    if (dom.scrollLeft != left) { dom.scrollLeft = left; }
  }
}

var preventScrollSupported = null;
// Feature-detects support for .focus({preventScroll: true}), and uses
// a fallback kludge when not supported.
function focusPreventScroll(dom) {
  if (dom.setActive) { return dom.setActive() } // in IE
  if (preventScrollSupported) { return dom.focus(preventScrollSupported) }

  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {preventScroll: true};
      return true
    }
  } : undefined);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest, dxClosest = 2e8, coordsClosest, offset = 0;
  var rowBot = coords.top, rowTop = coords.top;
  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = (void 0);
    if (child.nodeType == 1) { rects = child.getClientRects(); }
    else if (child.nodeType == 3) { rects = textRange(child).getClientRects(); }
    else { continue }

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left
            : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {left: rect.right < coords.left ? rect.right : rect.left, top: coords.top} : coords;
          if (child.nodeType == 1 && dx)
            { offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0); }
          continue
        }
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||
                       coords.left >= rect.left && coords.top >= rect.bottom))
        { offset = childIndex + 1; }
    }
  }
  if (closest && closest.nodeType == 3) { return findOffsetInText(closest, coordsClosest) }
  if (!closest || (dxClosest && closest.nodeType == 1)) { return {node: node, offset: offset} }
  return findOffsetInNode(closest, coordsClosest)
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();
  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) { continue }
    if (inRect(coords, rect))
      { return {node: node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)} }
  }
  return {node: node, offset: 0}
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1&&
    coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    { return parent }
  return dom
}

function posFromElement(view, elt, coords) {
  var ref = findOffsetInNode(elt, coords);
  var node = ref.node;
  var offset = ref.offset;
  var bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset, bias)
}

function posFromCaret(view, node, offset, coords) {
  // Browser (in caretPosition/RangeFromPoint) will agressively
  // normalize towards nearby inline nodes. Since we are interested in
  // positions between block nodes too, we first walk up the hierarchy
  // of nodes to see if there are block nodes that the coordinates
  // fall outside of. If so, we take the position before/after that
  // block. If not, we call `posFromDOM` on the raw node/offset.
  var outside = -1;
  for (var cur = node;;) {
    if (cur == view.dom) { break }
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) { return null }
    if (desc.node.isBlock && desc.parent) {
      var rect = desc.dom.getBoundingClientRect();
      if (rect.left > coords.left || rect.top > coords.top) { outside = desc.posBefore; }
      else if (rect.right < coords.left || rect.bottom < coords.top) { outside = desc.posAfter; }
      else { break }
    }
    cur = desc.dom.parentNode;
  }
  return outside > -1 ? outside : view.docView.posFromDOM(node, offset)
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];
      if (child.nodeType == 1) {
        var rects = child.getClientRects();
        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) { return elementFromPoint(child, coords, rect) }
        }
      }
      if ((i = (i + 1) % len) == startI) { break }
    }
  }
  return element
}

// Given an x,y position on the editor, get the position in the document.
function posAtCoords(view, coords) {
  var assign, assign$1;

  var doc = view.dom.ownerDocument, node, offset;
  if (doc.caretPositionFromPoint) {
    try { // Firefox throws for this call in hard-to-predict circumstances (#994)
      var pos$1 = doc.caretPositionFromPoint(coords.left, coords.top);
      if (pos$1) { ((assign = pos$1, node = assign.offsetNode, offset = assign.offset)); }
    } catch (_) {}
  }
  if (!node && doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(coords.left, coords.top);
    if (range) { ((assign$1 = range, node = assign$1.startContainer, offset = assign$1.startOffset)); }
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top + 1), pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) { return null }
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) { return null }
  }
  // Safari's caretRangeFromPoint returns nonsense when on a draggable element
  if (result.safari) {
    for (var p = elt; node && p; p = parentNode(p))
      { if (p.draggable) { node = offset = null; } }
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (result.gecko && node.nodeType == 1) {
      // Firefox will sometimes return offsets into <input> nodes, which
      // have no actual children, from caretPositionFromPoint (#953)
      offset = Math.min(offset, node.childNodes.length);
      // It'll also move the returned position before image nodes,
      // even if those are behind it.
      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset], box$1;
        if (next.nodeName == "IMG" && (box$1 = next.getBoundingClientRect()).right <= coords.left &&
            box$1.bottom > coords.top)
          { offset++; }
      }
    }
    // Suspiciously specific kludge to work around caret*FromPoint
    // never returning a position at the end of the document
    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&
        coords.top > node.lastChild.getBoundingClientRect().bottom)
      { pos = view.state.doc.content.size; }
    // Ignore positions directly after a BR, since caret*FromPoint
    // 'round up' positions that would be more accurately placed
    // before the BR node.
    else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR")
      { pos = posFromCaret(view, node, offset, coords); }
  }
  if (pos == null) { pos = posFromElement(view, elt, coords); }

  var desc = view.docView.nearestDesc(elt, true);
  return {pos: pos, inside: desc ? desc.posAtStart - desc.border : -1}
}

function singleRect(object, bias) {
  var rects = object.getClientRects();
  return !rects.length ? object.getBoundingClientRect() : rects[bias < 0 ? 0 : rects.length - 1]
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

// : (EditorView, number, number) → {left: number, top: number, right: number, bottom: number}
// Given a position in the document model, get a bounding box of the
// character at that position, relative to the window.
function coordsAtPos(view, pos, side) {
  var ref = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  var node = ref.node;
  var offset = ref.offset;

  var supportEmptyRange = result.webkit || result.gecko;
  if (node.nodeType == 3) {
    // These browsers support querying empty text ranges. Prefer that in
    // bidi context or when at the end of a node.
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);
      // Firefox returns bad results (the position before the space)
      // when querying a position directly after line-broken
      // whitespace. Detect this situation and and kludge around it
      if (result.gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);
        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top)
            { return flattenV(rectAfter, rectAfter.left < rectBefore.left) }
        }
      }
      return rect
    } else {
      var from = offset, to = offset, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset) { to++; takeSide = -1; }
      else if (side >= 0 && offset == node.nodeValue.length) { from--; takeSide = 1; }
      else if (side < 0) { from--; }
      else { to ++; }
      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0)
    }
  }

  // Return a horizontal line in block context
  if (!view.state.doc.resolve(pos).parent.inlineContent) {
    if (offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) { return flattenH(before.getBoundingClientRect(), false) }
    }
    if (offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) { return flattenH(after.getBoundingClientRect(), true) }
    }
    return flattenH(node.getBoundingClientRect(), side >= 0)
  }

  // Inline, not in text node (this is not Bidi-safe)
  if (offset && (side < 0 || offset == nodeSize(node))) {
    var before$1 = node.childNodes[offset - 1];
    var target = before$1.nodeType == 3 ? textRange(before$1, nodeSize(before$1) - (supportEmptyRange ? 0 : 1))
        // BR nodes tend to only return the rectangle before them.
        // Only use them if they are the last element in their parent
        : before$1.nodeType == 1 && (before$1.nodeName != "BR" || !before$1.nextSibling) ? before$1 : null;
    if (target) { return flattenV(singleRect(target, 1), false) }
  }
  if (offset < nodeSize(node)) {
    var after$1 = node.childNodes[offset];
    while (after$1.pmViewDesc && after$1.pmViewDesc.ignoreForCoords) { after$1 = after$1.nextSibling; }
    var target$1 = !after$1 ? null : after$1.nodeType == 3 ? textRange(after$1, 0, (supportEmptyRange ? 0 : 1))
        : after$1.nodeType == 1 ? after$1 : null;
    if (target$1) { return flattenV(singleRect(target$1, -1), true) }
  }
  // All else failed, just try to get a rectangle for the target node
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0)
}

function flattenV(rect, left) {
  if (rect.width == 0) { return rect }
  var x = left ? rect.left : rect.right;
  return {top: rect.top, bottom: rect.bottom, left: x, right: x}
}

function flattenH(rect, top) {
  if (rect.height == 0) { return rect }
  var y = top ? rect.top : rect.bottom;
  return {top: y, bottom: y, left: rect.left, right: rect.right}
}

function withFlushedState(view, state, f) {
  var viewState = view.state, active = view.root.activeElement;
  if (viewState != state) { view.updateState(state); }
  if (active != view.dom) { view.focus(); }
  try {
    return f()
  } finally {
    if (viewState != state) { view.updateState(viewState); }
    if (active != view.dom && active) { active.focus(); }
  }
}

// : (EditorView, number, number)
// Whether vertical position motion in a given direction
// from a position would leave a text block.
function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var ref = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    var dom = ref.node;
    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) { break }
      if (nearest.node.isBlock) { dom = nearest.dom; break }
      dom = nearest.dom.parentNode;
    }
    var coords = coordsAtPos(view, $pos.pos, 1);
    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = (void 0);
      if (child.nodeType == 1) { boxes = child.getClientRects(); }
      else if (child.nodeType == 3) { boxes = textRange(child, 0, child.nodeValue.length).getClientRects(); }
      else { continue }
      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 &&
            (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2
             : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          { return false }
      }
    }
    return true
  })
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var ref = state.selection;
  var $head = ref.$head;
  if (!$head.parent.isTextblock) { return false }
  var offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;
  var sel = view.root.getSelection();
  // If the textblock is all LTR, or the browser doesn't support
  // Selection.modify (Edge), fall back to a primitive approach
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    { return dir == "left" || dir == "backward" ? atStart : atEnd }

  return withFlushedState(view, state, function () {
    // This is a huge hack, but appears to be the best we can
    // currently do: use `Selection.modify` to move the selection by
    // one character, and see if that moves the cursor out of the
    // textblock (or doesn't move it at all, when at the start/end of
    // the document).
    var oldRange = sel.getRangeAt(0), oldNode = sel.focusNode, oldOff = sel.focusOffset;
    var oldBidiLevel = sel.caretBidiLevel; // Only for Firefox
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    var result = !parentDOM.contains(sel.focusNode.nodeType == 1 ? sel.focusNode : sel.focusNode.parentNode) ||
        (oldNode == sel.focusNode && oldOff == sel.focusOffset);
    // Restore the previous selection
    sel.removeAllRanges();
    sel.addRange(oldRange);
    if (oldBidiLevel != null) { sel.caretBidiLevel = oldBidiLevel; }
    return result
  })
}

var cachedState = null, cachedDir = null, cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) { return cachedResult }
  cachedState = state; cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down"
    ? endOfTextblockVertical(view, state, dir)
    : endOfTextblockHorizontal(view, state, dir)
}

// NodeView:: interface
//
// By default, document nodes are rendered using the result of the
// [`toDOM`](#model.NodeSpec.toDOM) method of their spec, and managed
// entirely by the editor. For some use cases, such as embedded
// node-specific editing interfaces, you want more control over
// the behavior of a node's in-editor representation, and need to
// [define](#view.EditorProps.nodeViews) a custom node view.
//
// Mark views only support `dom` and `contentDOM`, and don't support
// any of the node view methods.
//
// Objects returned as node views must conform to this interface.
//
//   dom:: ?dom.Node
//   The outer DOM node that represents the document node. When not
//   given, the default strategy is used to create a DOM node.
//
//   contentDOM:: ?dom.Node
//   The DOM node that should hold the node's content. Only meaningful
//   if the node view also defines a `dom` property and if its node
//   type is not a leaf node type. When this is present, ProseMirror
//   will take care of rendering the node's children into it. When it
//   is not present, the node view itself is responsible for rendering
//   (or deciding not to render) its child nodes.
//
//   update:: ?(node: Node, decorations: [Decoration], innerDecorations: DecorationSource) → bool
//   When given, this will be called when the view is updating itself.
//   It will be given a node (possibly of a different type), an array
//   of active decorations around the node (which are automatically
//   drawn, and the node view may ignore if it isn't interested in
//   them), and a [decoration source](#view.DecorationSource) that
//   represents any decorations that apply to the content of the node
//   (which again may be ignored). It should return true if it was
//   able to update to that node, and false otherwise. If the node
//   view has a `contentDOM` property (or no `dom` property), updating
//   its child nodes will be handled by ProseMirror.
//
//   selectNode:: ?()
//   Can be used to override the way the node's selected status (as a
//   node selection) is displayed.
//
//   deselectNode:: ?()
//   When defining a `selectNode` method, you should also provide a
//   `deselectNode` method to remove the effect again.
//
//   setSelection:: ?(anchor: number, head: number, root: dom.Document)
//   This will be called to handle setting the selection inside the
//   node. The `anchor` and `head` positions are relative to the start
//   of the node. By default, a DOM selection will be created between
//   the DOM positions corresponding to those positions, but if you
//   override it you can do something else.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to prevent the editor view from trying to handle some
//   or all DOM events that bubble up from the node view. Events for
//   which this returns true are not handled by the editor.
//
//   ignoreMutation:: ?(dom.MutationRecord) → bool
//   Called when a DOM
//   [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver)
//   or a selection change happens within the view. When the change is
//   a selection change, the record will have a `type` property of
//   `"selection"` (which doesn't occur for native mutation records).
//   Return false if the editor should re-read the selection or
//   re-parse the range around the mutation, true if it can safely be
//   ignored.
//
//   destroy:: ?()
//   Called when the node view is removed from the editor or the whole
//   editor is destroyed. (Not available for marks.)

// View descriptions are data structures that describe the DOM that is
// used to represent the editor's content. They are used for:
//
// - Incremental redrawing when the document changes
//
// - Figuring out what part of the document a given DOM position
//   corresponds to
//
// - Wiring in custom implementations of the editing interface for a
//   given node
//
// They form a doubly-linked mutable tree, starting at `view.docView`.

var NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;

// Superclass for the various kinds of descriptions. Defines their
// basic structure and shared methods.
var ViewDesc = function ViewDesc(parent, children, dom, contentDOM) {
  this.parent = parent;
  this.children = children;
  this.dom = dom;
  // An expando property on the DOM node provides a link back to its
  // description.
  dom.pmViewDesc = this;
  // This is the node that holds the child views. It may be null for
  // descs that don't have children.
  this.contentDOM = contentDOM;
  this.dirty = NOT_DIRTY;
};

var prototypeAccessors = { size: { configurable: true },border: { configurable: true },posBefore: { configurable: true },posAtStart: { configurable: true },posAfter: { configurable: true },posAtEnd: { configurable: true },contentLost: { configurable: true },domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

// Used to check whether a given description corresponds to a
// widget/mark/node.
ViewDesc.prototype.matchesWidget = function matchesWidget () { return false };
ViewDesc.prototype.matchesMark = function matchesMark () { return false };
ViewDesc.prototype.matchesNode = function matchesNode () { return false };
ViewDesc.prototype.matchesHack = function matchesHack (_nodeName) { return false };

// : () → ?ParseRule
// When parsing in-editor content (in domchange.js), we allow
// descriptions to determine the parse rules that should be used to
// parse them.
ViewDesc.prototype.parseRule = function parseRule () { return null };

// : (dom.Event) → bool
// Used by the editor's event handler to ignore events that come
// from certain descs.
ViewDesc.prototype.stopEvent = function stopEvent () { return false };

// The size of the content represented by this desc.
prototypeAccessors.size.get = function () {
  var size = 0;
  for (var i = 0; i < this.children.length; i++) { size += this.children[i].size; }
  return size
};

// For block nodes, this represents the space taken up by their
// start/end tokens.
prototypeAccessors.border.get = function () { return 0 };

ViewDesc.prototype.destroy = function destroy () {
  this.parent = null;
  if (this.dom.pmViewDesc == this) { this.dom.pmViewDesc = null; }
  for (var i = 0; i < this.children.length; i++)
    { this.children[i].destroy(); }
};

ViewDesc.prototype.posBeforeChild = function posBeforeChild (child) {
  for (var i = 0, pos = this.posAtStart; i < this.children.length; i++) {
    var cur = this.children[i];
    if (cur == child) { return pos }
    pos += cur.size;
  }
};

prototypeAccessors.posBefore.get = function () {
  return this.parent.posBeforeChild(this)
};

prototypeAccessors.posAtStart.get = function () {
  return this.parent ? this.parent.posBeforeChild(this) + this.border : 0
};

prototypeAccessors.posAfter.get = function () {
  return this.posBefore + this.size
};

prototypeAccessors.posAtEnd.get = function () {
  return this.posAtStart + this.size - 2 * this.border
};

// : (dom.Node, number, ?number) → number
ViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
  // If the DOM position is in the content, use the child desc after
  // it to figure out a position.
  if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
    if (bias < 0) {
      var domBefore, desc;
      if (dom == this.contentDOM) {
        domBefore = dom.childNodes[offset - 1];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domBefore = dom.previousSibling;
      }
      while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) { domBefore = domBefore.previousSibling; }
      return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart
    } else {
      var domAfter, desc$1;
      if (dom == this.contentDOM) {
        domAfter = dom.childNodes[offset];
      } else {
        while (dom.parentNode != this.contentDOM) { dom = dom.parentNode; }
        domAfter = dom.nextSibling;
      }
      while (domAfter && !((desc$1 = domAfter.pmViewDesc) && desc$1.parent == this)) { domAfter = domAfter.nextSibling; }
      return domAfter ? this.posBeforeChild(desc$1) : this.posAtEnd
    }
  }
  // Otherwise, use various heuristics, falling back on the bias
  // parameter, to determine whether to return the position at the
  // start or at the end of this view desc.
  var atEnd;
  if (dom == this.dom && this.contentDOM) {
    atEnd = offset > domIndex(this.contentDOM);
  } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
    atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
  } else if (this.dom.firstChild) {
    if (offset == 0) { for (var search = dom;; search = search.parentNode) {
      if (search == this.dom) { atEnd = false; break }
      if (search.parentNode.firstChild != search) { break }
    } }
    if (atEnd == null && offset == dom.childNodes.length) { for (var search$1 = dom;; search$1 = search$1.parentNode) {
      if (search$1 == this.dom) { atEnd = true; break }
      if (search$1.parentNode.lastChild != search$1) { break }
    } }
  }
  return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart
};

// Scan up the dom finding the first desc that is a descendant of
// this one.
ViewDesc.prototype.nearestDesc = function nearestDesc (dom, onlyNodes) {
  for (var first = true, cur = dom; cur; cur = cur.parentNode) {
    var desc = this.getDesc(cur);
    if (desc && (!onlyNodes || desc.node)) {
      // If dom is outside of this desc's nodeDOM, don't count it.
      if (first && desc.nodeDOM &&
          !(desc.nodeDOM.nodeType == 1 ? desc.nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : desc.nodeDOM == dom))
        { first = false; }
      else
        { return desc }
    }
  }
};

ViewDesc.prototype.getDesc = function getDesc (dom) {
  var desc = dom.pmViewDesc;
  for (var cur = desc; cur; cur = cur.parent) { if (cur == this) { return desc } }
};

ViewDesc.prototype.posFromDOM = function posFromDOM (dom, offset, bias) {
  for (var scan = dom; scan; scan = scan.parentNode) {
    var desc = this.getDesc(scan);
    if (desc) { return desc.localPosFromDOM(dom, offset, bias) }
  }
  return -1
};

// : (number) → ?NodeViewDesc
// Find the desc for the node after the given pos, if any. (When a
// parent node overrode rendering, there might not be one.)
ViewDesc.prototype.descAt = function descAt (pos) {
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == pos && end != offset) {
      while (!child.border && child.children.length) { child = child.children[0]; }
      return child
    }
    if (pos < end) { return child.descAt(pos - offset - child.border) }
    offset = end;
  }
};

// : (number, number) → {node: dom.Node, offset: number}
ViewDesc.prototype.domFromPos = function domFromPos (pos, side) {
  if (!this.contentDOM) { return {node: this.dom, offset: 0} }
  // First find the position in the child array
  var i = 0, offset = 0;
  for (var curPos = 0; i < this.children.length; i++) {
    var child = this.children[i], end = curPos + child.size;
    if (end > pos || child instanceof TrailingHackViewDesc) { offset = pos - curPos; break }
    curPos = end;
  }
  // If this points into the middle of a child, call through
  if (offset) { return this.children[i].domFromPos(offset - this.children[i].border, side) }
  // Go back if there were any zero-length widgets with side >= 0 before this point
  for (var prev = (void 0); i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.widget.type.side >= 0; i--) {}
  // Scan towards the first useable node
  if (side <= 0) {
    var prev$1, enter = true;
    for (;; i--, enter = false) {
      prev$1 = i ? this.children[i - 1] : null;
      if (!prev$1 || prev$1.dom.parentNode == this.contentDOM) { break }
    }
    if (prev$1 && side && enter && !prev$1.border && !prev$1.domAtom) { return prev$1.domFromPos(prev$1.size, side) }
    return {node: this.contentDOM, offset: prev$1 ? domIndex(prev$1.dom) + 1 : 0}
  } else {
    var next, enter$1 = true;
    for (;; i++, enter$1 = false) {
      next = i < this.children.length ? this.children[i] : null;
      if (!next || next.dom.parentNode == this.contentDOM) { break }
    }
    if (next && enter$1 && !next.border && !next.domAtom) { return next.domFromPos(0, side) }
    return {node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length}
  }
};

// Used to find a DOM range in a single parent for a given changed
// range.
ViewDesc.prototype.parseRange = function parseRange (from, to, base) {
    if ( base === void 0 ) base = 0;

  if (this.children.length == 0)
    { return {node: this.contentDOM, from: from, to: to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length} }

  var fromOffset = -1, toOffset = -1;
  for (var offset = base, i = 0;; i++) {
    var child = this.children[i], end = offset + child.size;
    if (fromOffset == -1 && from <= end) {
      var childBase = offset + child.border;
      // FIXME maybe descend mark views to parse a narrower range?
      if (from >= childBase && to <= end - child.border && child.node &&
          child.contentDOM && this.contentDOM.contains(child.contentDOM))
        { return child.parseRange(from, to, childBase) }

      from = offset;
      for (var j = i; j > 0; j--) {
        var prev = this.children[j - 1];
        if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
          fromOffset = domIndex(prev.dom) + 1;
          break
        }
        from -= prev.size;
      }
      if (fromOffset == -1) { fromOffset = 0; }
    }
    if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
      to = end;
      for (var j$1 = i + 1; j$1 < this.children.length; j$1++) {
        var next = this.children[j$1];
        if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
          toOffset = domIndex(next.dom);
          break
        }
        to += next.size;
      }
      if (toOffset == -1) { toOffset = this.contentDOM.childNodes.length; }
      break
    }
    offset = end;
  }
  return {node: this.contentDOM, from: from, to: to, fromOffset: fromOffset, toOffset: toOffset}
};

ViewDesc.prototype.emptyChildAt = function emptyChildAt (side) {
  if (this.border || !this.contentDOM || !this.children.length) { return false }
  var child = this.children[side < 0 ? 0 : this.children.length - 1];
  return child.size == 0 || child.emptyChildAt(side)
};

// : (number) → dom.Node
ViewDesc.prototype.domAfterPos = function domAfterPos (pos) {
  var ref = this.domFromPos(pos, 0);
    var node = ref.node;
    var offset = ref.offset;
  if (node.nodeType != 1 || offset == node.childNodes.length)
    { throw new RangeError("No node after pos " + pos) }
  return node.childNodes[offset]
};

// : (number, number, dom.Document)
// View descs are responsible for setting any selection that falls
// entirely inside of them, so that custom implementations can do
// custom things with the selection. Note that this falls apart when
// a selection starts in such a node and ends in another, in which
// case we just use whatever domFromPos produces as a best effort.
ViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
  // If the selection falls entirely in a child, give it to that child
  var from = Math.min(anchor, head), to = Math.max(anchor, head);
  for (var i = 0, offset = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (from > offset && to < end)
      { return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force) }
    offset = end;
  }

  var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
  var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
  var domSel = root.getSelection();

  var brKludge = false;
  // On Firefox, using Selection.collapse to put the cursor after a
  // BR node for some reason doesn't always work (#1073). On Safari,
  // the cursor sometimes inexplicable visually lags behind its
  // reported position in such situations (#1092).
  if ((result.gecko || result.safari) && anchor == head) {
    var node = anchorDOM.node;
      var offset$1 = anchorDOM.offset;
    if (node.nodeType == 3) {
      brKludge = offset$1 && node.nodeValue[offset$1 - 1] == "\n";
      // Issue #1128
      if (brKludge && offset$1 == node.nodeValue.length) {
        for (var scan = node, after = (void 0); scan; scan = scan.parentNode) {
          if (after = scan.nextSibling) {
            if (after.nodeName == "BR")
              { anchorDOM = headDOM = {node: after.parentNode, offset: domIndex(after) + 1}; }
            break
          }
          var desc = scan.pmViewDesc;
          if (desc && desc.node && desc.node.isBlock) { break }
        }
      }
    } else {
      var prev = node.childNodes[offset$1 - 1];
      brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
    }
  }
  // Firefox can act strangely when the selection is in front of an
  // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536
  if (result.gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
    var after$1 = domSel.focusNode.childNodes[domSel.focusOffset];
    if (after$1 && after$1.contentEditable == "false") { force = true; }
  }

  if (!(force || brKludge && result.safari) &&
      isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) &&
      isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset))
    { return }

  // Selection.extend can be used to create an 'inverted' selection
  // (one where the focus is before the anchor), but not all
  // browsers support it yet.
  var domSelExtended = false;
  if ((domSel.extend || anchor == head) && !brKludge) {
    domSel.collapse(anchorDOM.node, anchorDOM.offset);
    try {
      if (anchor != head) { domSel.extend(headDOM.node, headDOM.offset); }
      domSelExtended = true;
    } catch (err) {
      // In some cases with Chrome the selection is empty after calling
      // collapse, even when it should be valid. This appears to be a bug, but
      // it is difficult to isolate. If this happens fallback to the old path
      // without using extend.
      if (!(err instanceof DOMException)) { throw err }
      // declare global: DOMException
    }
  }
  if (!domSelExtended) {
    if (anchor > head) { var tmp = anchorDOM; anchorDOM = headDOM; headDOM = tmp; }
    var range = document.createRange();
    range.setEnd(headDOM.node, headDOM.offset);
    range.setStart(anchorDOM.node, anchorDOM.offset);
    domSel.removeAllRanges();
    domSel.addRange(range);
  }
};

// : (dom.MutationRecord) → bool
ViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
  return !this.contentDOM && mutation.type != "selection"
};

prototypeAccessors.contentLost.get = function () {
  return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM)
};

// Remove a subtree of the element tree that has been touched
// by a DOM change, so that the next update will redraw it.
ViewDesc.prototype.markDirty = function markDirty (from, to) {
  for (var offset = 0, i = 0; i < this.children.length; i++) {
    var child = this.children[i], end = offset + child.size;
    if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
      var startInside = offset + child.border, endInside = end - child.border;
      if (from >= startInside && to <= endInside) {
        this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
        if (from == startInside && to == endInside &&
            (child.contentLost || child.dom.parentNode != this.contentDOM)) { child.dirty = NODE_DIRTY; }
        else { child.markDirty(from - startInside, to - startInside); }
        return
      } else {
        child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length
          ? CONTENT_DIRTY : NODE_DIRTY;
      }
    }
    offset = end;
  }
  this.dirty = CONTENT_DIRTY;
};

ViewDesc.prototype.markParentsDirty = function markParentsDirty () {
  var level = 1;
  for (var node = this.parent; node; node = node.parent, level++) {
    var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
    if (node.dirty < dirty) { node.dirty = dirty; }
  }
};

prototypeAccessors.domAtom.get = function () { return false };

prototypeAccessors.ignoreForCoords.get = function () { return false };

Object.defineProperties( ViewDesc.prototype, prototypeAccessors );

// Reused array to avoid allocating fresh arrays for things that will
// stay empty anyway.
var nothing = [];

// A widget desc represents a widget decoration, which is a DOM node
// drawn between the document nodes.
var WidgetViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function WidgetViewDesc(parent, widget, view, pos) {
    var self, dom = widget.type.toDOM;
    if (typeof dom == "function") { dom = dom(view, function () {
      if (!self) { return pos }
      if (self.parent) { return self.parent.posBeforeChild(self) }
    }); }
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = false;
      dom.classList.add("ProseMirror-widget");
    }
    ViewDesc.call(this, parent, nothing, dom, null);
    this.widget = widget;
    self = this;
  }

  if ( ViewDesc ) WidgetViewDesc.__proto__ = ViewDesc;
  WidgetViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  WidgetViewDesc.prototype.constructor = WidgetViewDesc;

  var prototypeAccessors$1 = { domAtom: { configurable: true } };

  WidgetViewDesc.prototype.matchesWidget = function matchesWidget (widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type)
  };

  WidgetViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };

  WidgetViewDesc.prototype.stopEvent = function stopEvent (event) {
    var stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false
  };

  WidgetViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection
  };

  WidgetViewDesc.prototype.destroy = function destroy () {
    this.widget.type.destroy(this.dom);
    ViewDesc.prototype.destroy.call(this);
  };

  prototypeAccessors$1.domAtom.get = function () { return true };

  Object.defineProperties( WidgetViewDesc.prototype, prototypeAccessors$1 );

  return WidgetViewDesc;
}(ViewDesc));

var CompositionViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function CompositionViewDesc(parent, dom, textDOM, text) {
    ViewDesc.call(this, parent, nothing, dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }

  if ( ViewDesc ) CompositionViewDesc.__proto__ = ViewDesc;
  CompositionViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  CompositionViewDesc.prototype.constructor = CompositionViewDesc;

  var prototypeAccessors$2 = { size: { configurable: true } };

  prototypeAccessors$2.size.get = function () { return this.text.length };

  CompositionViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset) {
    if (dom != this.textDOM) { return this.posAtStart + (offset ? this.size : 0) }
    return this.posAtStart + offset
  };

  CompositionViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.textDOM, offset: pos}
  };

  CompositionViewDesc.prototype.ignoreMutation = function ignoreMutation (mut) {
    return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue
   };

  Object.defineProperties( CompositionViewDesc.prototype, prototypeAccessors$2 );

  return CompositionViewDesc;
}(ViewDesc));

// A mark desc represents a mark. May have multiple children,
// depending on how the mark is split. Note that marks are drawn using
// a fixed nesting order, for simplicity and predictability, so in
// some cases they will be split more often than would appear
// necessary.
var MarkViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function MarkViewDesc(parent, mark, dom, contentDOM) {
    ViewDesc.call(this, parent, [], dom, contentDOM);
    this.mark = mark;
  }

  if ( ViewDesc ) MarkViewDesc.__proto__ = ViewDesc;
  MarkViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  MarkViewDesc.prototype.constructor = MarkViewDesc;

  MarkViewDesc.create = function create (parent, mark, inline, view) {
    var custom = view.nodeViews[mark.type.name];
    var spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      { spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline)); }
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom)
  };

  MarkViewDesc.prototype.parseRule = function parseRule () {
    if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView) { return null }
    return {mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM}
  };

  MarkViewDesc.prototype.matchesMark = function matchesMark (mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark) };

  MarkViewDesc.prototype.markDirty = function markDirty (from, to) {
    ViewDesc.prototype.markDirty.call(this, from, to);
    // Move dirty info to nearest node view
    if (this.dirty != NOT_DIRTY) {
      var parent = this.parent;
      while (!parent.node) { parent = parent.parent; }
      if (parent.dirty < this.dirty) { parent.dirty = this.dirty; }
      this.dirty = NOT_DIRTY;
    }
  };

  MarkViewDesc.prototype.slice = function slice (from, to, view) {
    var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    var nodes = this.children, size = this.size;
    if (to < size) { nodes = replaceNodes(nodes, to, size, view); }
    if (from > 0) { nodes = replaceNodes(nodes, 0, from, view); }
    for (var i = 0; i < nodes.length; i++) { nodes[i].parent = copy; }
    copy.children = nodes;
    return copy
  };

  return MarkViewDesc;
}(ViewDesc));

// Node view descs are the main, most common type of view desc, and
// correspond to an actual node in the document. Unlike mark descs,
// they populate their child array themselves.
var NodeViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    ViewDesc.call(this, parent, node.isLeaf ? nothing : [], dom, contentDOM);
    this.nodeDOM = nodeDOM;
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    if (contentDOM) { this.updateChildren(view, pos); }
  }

  if ( ViewDesc ) NodeViewDesc.__proto__ = ViewDesc;
  NodeViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  NodeViewDesc.prototype.constructor = NodeViewDesc;

  var prototypeAccessors$3 = { size: { configurable: true },border: { configurable: true },domAtom: { configurable: true } };

  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  NodeViewDesc.create = function create (parent, node, outerDeco, innerDeco, view, pos) {
    var assign;

    var custom = view.nodeViews[node.type.name], descObj;
    var spec = custom && custom(node, view, function () {
      // (This is a function that allows the custom view to find its
      // own position)
      if (!descObj) { return pos }
      if (descObj.parent) { return descObj.parent.posBeforeChild(descObj) }
    }, outerDeco, innerDeco);

    var dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom) { dom = document.createTextNode(node.text); }
      else if (dom.nodeType != 3) { throw new RangeError("Text must be rendered as a DOM text node") }
    } else if (!dom) {
((assign = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node)), dom = assign.dom, contentDOM = assign.contentDOM));
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") { // Chrome gets confused by <br contenteditable=false>
      if (!dom.hasAttribute("contenteditable")) { dom.contentEditable = false; }
      if (node.type.spec.draggable) { dom.draggable = true; }
    }

    var nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);

    if (spec)
      { return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM,
                                              spec, view, pos + 1) }
    else if (node.isText)
      { return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) }
    else
      { return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos + 1) }
  };

  NodeViewDesc.prototype.parseRule = function parseRule () {
    var this$1 = this;

    // Experimental kludge to allow opt-in re-parsing of nodes
    if (this.node.type.spec.reparseInView) { return null }
    // FIXME the assumption that this can always return the current
    // attrs means that if the user somehow manages to change the
    // attrs in the dom, that won't be picked up. Not entirely sure
    // whether this is a problem
    var rule = {node: this.node.type.name, attrs: this.node.attrs};
    if (this.node.type.whitespace == "pre") { rule.preserveWhitespace = "full"; }
    if (!this.contentDOM) {
      rule.getContent = function () { return this$1.node.content; };
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      // Chrome likes to randomly recreate parent nodes when
      // backspacing things. When that happens, this tries to find the
      // new parent.
      for (var i = this.children.length - 1; i >= 0; i--) {
        var child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break
        }
      }
      if (!rule.contentElement) { rule.getContent = function () { return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty; }; }
    }
    return rule
  };

  NodeViewDesc.prototype.matchesNode = function matchesNode (node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) &&
      sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco)
  };

  prototypeAccessors$3.size.get = function () { return this.node.nodeSize };

  prototypeAccessors$3.border.get = function () { return this.node.isLeaf ? 0 : 1 };

  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  NodeViewDesc.prototype.updateChildren = function updateChildren (view, pos) {
    var this$1 = this;

    var inline = this.node.inlineContent, off = pos;
    var composition = view.composing && this.localCompositionInfo(view, pos);
    var localComposition = composition && composition.pos > -1 ? composition : null;
    var compositionInChild = composition && composition.pos < 0;
    var updater = new ViewTreeUpdater(this, localComposition && localComposition.node);
    iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
      if (widget.spec.marks)
        { updater.syncToMarks(widget.spec.marks, inline, view); }
      else if (widget.type.side >= 0 && !insideNode)
        { updater.syncToMarks(i == this$1.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Mark.none : this$1.node.child(i).marks, inline, view); }
      // If the next node is a desc matching this widget, reuse it,
      // otherwise insert the widget as a new view desc.
      updater.placeWidget(widget, view, off);
    }, function (child, outerDeco, innerDeco, i) {
      // Make sure the wrapping mark descs match the node's marks.
      updater.syncToMarks(child.marks, inline, view);
      // Try several strategies for drawing this node
      var compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ; else if (compositionInChild && view.state.selection.from > off &&
                 view.state.selection.to < off + child.nodeSize &&
                 (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&
                 updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ; else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i)) ; else {
        // Add it as a new view
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    // Drop all remaining descs after the current position.
    updater.syncToMarks(nothing, inline, view);
    if (this.node.isTextblock) { updater.addTextblockHacks(); }
    updater.destroyRest();

    // Sync the DOM if anything changed
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      // May have to protect focused DOM from being changed if a composition is active
      if (localComposition) { this.protectLocalComposition(view, localComposition); }
      renderDescs(this.contentDOM, this.children, view);
      if (result.ios) { iosHacks(this.dom); }
    }
  };

  NodeViewDesc.prototype.localCompositionInfo = function localCompositionInfo (view, pos) {
    // Only do something if both the selection and a focused text node
    // are inside of this node
    var ref = view.state.selection;
    var from = ref.from;
    var to = ref.to;
    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || from < pos || to > pos + this.node.content.size) { return }
    var sel = view.root.getSelection();
    var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
    if (!textNode || !this.dom.contains(textNode.parentNode)) { return }

    if (this.node.inlineContent) {
      // Find the text in the focused node in the node, stop if it's not
      // there (may have been modified through other means, in which
      // case it should overwritten)
      var text = textNode.nodeValue;
      var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
      return textPos < 0 ? null : {node: textNode, pos: textPos, text: text}
    } else {
      return {node: textNode, pos: -1}
    }
  };

  NodeViewDesc.prototype.protectLocalComposition = function protectLocalComposition (view, ref) {
    var node = ref.node;
    var pos = ref.pos;
    var text = ref.text;

    // The node is already part of a local view desc, leave it there
    if (this.getDesc(node)) { return }

    // Create a composition view for the orphaned nodes
    var topNode = node;
    for (;; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM) { break }
      while (topNode.previousSibling) { topNode.parentNode.removeChild(topNode.previousSibling); }
      while (topNode.nextSibling) { topNode.parentNode.removeChild(topNode.nextSibling); }
      if (topNode.pmViewDesc) { topNode.pmViewDesc = null; }
    }
    var desc = new CompositionViewDesc(this, topNode, node, text);
    view.compositionNodes.push(desc);

    // Patch up this.children to contain the composition view
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  };

  // : (Node, [Decoration], DecorationSource, EditorView) → bool
  // If this desc be updated to match the given node decoration,
  // do so and return true.
  NodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY ||
        !node.sameMarkup(this.node)) { return false }
    this.updateInner(node, outerDeco, innerDeco, view);
    return true
  };

  NodeViewDesc.prototype.updateInner = function updateInner (node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM) { this.updateChildren(view, this.posAtStart); }
    this.dirty = NOT_DIRTY;
  };

  NodeViewDesc.prototype.updateOuterDeco = function updateOuterDeco (outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco)) { return }
    var needsWrap = this.nodeDOM.nodeType != 1;
    var oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM,
                              computeOuterDeco(this.outerDeco, this.node, needsWrap),
                              computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = null;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  };

  // Mark this node as being the selected node.
  NodeViewDesc.prototype.selectNode = function selectNode () {
    this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.draggable = true; }
  };

  // Remove selected node marking from this node.
  NodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.nodeDOM.classList.remove("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable) { this.dom.removeAttribute("draggable"); }
  };

  prototypeAccessors$3.domAtom.get = function () { return this.node.isAtom };

  Object.defineProperties( NodeViewDesc.prototype, prototypeAccessors$3 );

  return NodeViewDesc;
}(ViewDesc));

// Create a view desc for the top-level document node, to be exported
// and used by the view class.
function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  return new NodeViewDesc(null, doc, outerDeco, innerDeco, dom, dom, dom, view, 0)
}

var TextViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view);
  }

  if ( NodeViewDesc ) TextViewDesc.__proto__ = NodeViewDesc;
  TextViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  TextViewDesc.prototype.constructor = TextViewDesc;

  var prototypeAccessors$4 = { domAtom: { configurable: true } };

  TextViewDesc.prototype.parseRule = function parseRule () {
    var skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco) { skip = skip.parentNode; }
    return {skip: skip || true}
  };

  TextViewDesc.prototype.update = function update (node, outerDeco, _, view) {
    if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||
        !node.sameMarkup(this.node)) { return false }
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM) { view.trackWrites = null; }
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true
  };

  TextViewDesc.prototype.inParent = function inParent () {
    var parentDOM = this.parent.contentDOM;
    for (var n = this.nodeDOM; n; n = n.parentNode) { if (n == parentDOM) { return true } }
    return false
  };

  TextViewDesc.prototype.domFromPos = function domFromPos (pos) {
    return {node: this.nodeDOM, offset: pos}
  };

  TextViewDesc.prototype.localPosFromDOM = function localPosFromDOM (dom, offset, bias) {
    if (dom == this.nodeDOM) { return this.posAtStart + Math.min(offset, this.node.text.length) }
    return NodeViewDesc.prototype.localPosFromDOM.call(this, dom, offset, bias)
  };

  TextViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return mutation.type != "characterData" && mutation.type != "selection"
  };

  TextViewDesc.prototype.slice = function slice (from, to, view) {
    var node = this.node.cut(from, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view)
  };

  TextViewDesc.prototype.markDirty = function markDirty (from, to) {
    NodeViewDesc.prototype.markDirty.call(this, from, to);
    if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))
      { this.dirty = NODE_DIRTY; }
  };

  prototypeAccessors$4.domAtom.get = function () { return false };

  Object.defineProperties( TextViewDesc.prototype, prototypeAccessors$4 );

  return TextViewDesc;
}(NodeViewDesc));

// A dummy desc used to tag trailing BR or IMG nodes created to work
// around contentEditable terribleness.
var TrailingHackViewDesc = /*@__PURE__*/(function (ViewDesc) {
  function TrailingHackViewDesc () {
    ViewDesc.apply(this, arguments);
  }

  if ( ViewDesc ) TrailingHackViewDesc.__proto__ = ViewDesc;
  TrailingHackViewDesc.prototype = Object.create( ViewDesc && ViewDesc.prototype );
  TrailingHackViewDesc.prototype.constructor = TrailingHackViewDesc;

  var prototypeAccessors$5 = { domAtom: { configurable: true },ignoreForCoords: { configurable: true } };

  TrailingHackViewDesc.prototype.parseRule = function parseRule () { return {ignore: true} };
  TrailingHackViewDesc.prototype.matchesHack = function matchesHack (nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName };
  prototypeAccessors$5.domAtom.get = function () { return true };
  prototypeAccessors$5.ignoreForCoords.get = function () { return this.dom.nodeName == "IMG" };

  Object.defineProperties( TrailingHackViewDesc.prototype, prototypeAccessors$5 );

  return TrailingHackViewDesc;
}(ViewDesc));

// A separate subclass is used for customized node views, so that the
// extra checks only have to be made for nodes that are actually
// customized.
var CustomNodeViewDesc = /*@__PURE__*/(function (NodeViewDesc) {
  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    NodeViewDesc.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }

  if ( NodeViewDesc ) CustomNodeViewDesc.__proto__ = NodeViewDesc;
  CustomNodeViewDesc.prototype = Object.create( NodeViewDesc && NodeViewDesc.prototype );
  CustomNodeViewDesc.prototype.constructor = CustomNodeViewDesc;

  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  CustomNodeViewDesc.prototype.update = function update (node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY) { return false }
    if (this.spec.update) {
      var result = this.spec.update(node, outerDeco, innerDeco);
      if (result) { this.updateInner(node, outerDeco, innerDeco, view); }
      return result
    } else if (!this.contentDOM && !node.isLeaf) {
      return false
    } else {
      return NodeViewDesc.prototype.update.call(this, node, outerDeco, innerDeco, view)
    }
  };

  CustomNodeViewDesc.prototype.selectNode = function selectNode () {
    this.spec.selectNode ? this.spec.selectNode() : NodeViewDesc.prototype.selectNode.call(this);
  };

  CustomNodeViewDesc.prototype.deselectNode = function deselectNode () {
    this.spec.deselectNode ? this.spec.deselectNode() : NodeViewDesc.prototype.deselectNode.call(this);
  };

  CustomNodeViewDesc.prototype.setSelection = function setSelection (anchor, head, root, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, root)
      : NodeViewDesc.prototype.setSelection.call(this, anchor, head, root, force);
  };

  CustomNodeViewDesc.prototype.destroy = function destroy () {
    if (this.spec.destroy) { this.spec.destroy(); }
    NodeViewDesc.prototype.destroy.call(this);
  };

  CustomNodeViewDesc.prototype.stopEvent = function stopEvent (event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false
  };

  CustomNodeViewDesc.prototype.ignoreMutation = function ignoreMutation (mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : NodeViewDesc.prototype.ignoreMutation.call(this, mutation)
  };

  return CustomNodeViewDesc;
}(NodeViewDesc));

// : (dom.Node, [ViewDesc])
// Sync the content of the given DOM node with the nodes associated
// with the given array of view descs, recursing into mark descs
// because this should sync the subtree for a whole node at a time.
function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild, written = false;
  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) { dom = rm(dom); written = true; }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) { dom = rm(dom); written = true; }
  if (written && view.trackWrites == parentDOM) { view.trackWrites = null; }
}

function OuterDecoLevel(nodeName) {
  if (nodeName) { this.nodeName = nodeName; }
}
OuterDecoLevel.prototype = Object.create(null);

var noDeco = [new OuterDecoLevel];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) { return noDeco }

  var top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) { continue }
    if (attrs.nodeName)
      { result.push(top = new OuterDecoLevel(attrs.nodeName)); }

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) { continue }
      if (needsWrap && result.length == 1)
        { result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div")); }
      if (name == "class") { top.class = (top.class ? top.class + " " : "") + val; }
      else if (name == "style") { top.style = (top.style ? top.style + ";" : "") + val; }
      else if (name != "nodeName") { top[name] = val; }
    }
  }

  return result
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  // Shortcut for trivial case
  if (prevComputed == noDeco && curComputed == noDeco) { return nodeDOM }

  var curDOM = nodeDOM;
  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      var parent = (void 0);
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&
          (parent = curDOM.parentNode) && parent.tagName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev)
    { if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      { dom.removeAttribute(name); } }
  for (var name$1 in cur)
    { if (name$1 != "class" && name$1 != "style" && name$1 != "nodeName" && cur[name$1] != prev[name$1])
      { dom.setAttribute(name$1, cur[name$1]); } }
  if (prev.class != cur.class) {
    var prevList = prev.class ? prev.class.split(" ").filter(Boolean) : nothing;
    var curList = cur.class ? cur.class.split(" ").filter(Boolean) : nothing;
    for (var i = 0; i < prevList.length; i++) { if (curList.indexOf(prevList[i]) == -1)
      { dom.classList.remove(prevList[i]); } }
    for (var i$1 = 0; i$1 < curList.length; i$1++) { if (prevList.indexOf(curList[i$1]) == -1)
      { dom.classList.add(curList[i$1]); } }
    if (dom.classList.length == 0)
      { dom.removeAttribute("class"); }
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        { dom.style.removeProperty(m[1]); }
    }
    if (cur.style)
      { dom.style.cssText += cur.style; }
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1))
}

// : ([Decoration], [Decoration]) → bool
function sameOuterDeco(a, b) {
  if (a.length != b.length) { return false }
  for (var i = 0; i < a.length; i++) { if (!a[i].type.eq(b[i].type)) { return false } }
  return true
}

// Remove a DOM node and return its next sibling.
function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next
}

// Helper class for incrementally updating a tree of mark descs and
// the widget and node descs inside of them.
var ViewTreeUpdater = function ViewTreeUpdater(top, lockedNode) {
  this.top = top;
  this.lock = lockedNode;
  // Index into `this.top`'s child array, represents the current
  // update position.
  this.index = 0;
  // When entering a mark, the current top and index are pushed
  // onto this.
  this.stack = [];
  // Tracks whether anything was changed
  this.changed = false;

  this.preMatch = preMatch(top.node.content, top);
};

// Destroy and remove the children between the given indices in
// `this.top`.
ViewTreeUpdater.prototype.destroyBetween = function destroyBetween (start, end) {
  if (start == end) { return }
  for (var i = start; i < end; i++) { this.top.children[i].destroy(); }
  this.top.children.splice(start, end - start);
  this.changed = true;
};

// Destroy all remaining children in `this.top`.
ViewTreeUpdater.prototype.destroyRest = function destroyRest () {
  this.destroyBetween(this.index, this.top.children.length);
};

// : ([Mark], EditorView)
// Sync the current stack of mark descs with the given array of
// marks, reusing existing mark descs when possible.
ViewTreeUpdater.prototype.syncToMarks = function syncToMarks (marks, inline, view) {
  var keep = 0, depth = this.stack.length >> 1;
  var maxKeep = Math.min(depth, marks.length);
  while (keep < maxKeep &&
         (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
    { keep++; }

  while (keep < depth) {
    this.destroyRest();
    this.top.dirty = NOT_DIRTY;
    this.index = this.stack.pop();
    this.top = this.stack.pop();
    depth--;
  }
  while (depth < marks.length) {
    this.stack.push(this.top, this.index + 1);
    var found = -1;
    for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
      if (this.top.children[i].matchesMark(marks[depth])) { found = i; break }
    }
    if (found > -1) {
      if (found > this.index) {
        this.changed = true;
        this.destroyBetween(this.index, found);
      }
      this.top = this.top.children[this.index];
    } else {
      var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
      this.top.children.splice(this.index, 0, markDesc);
      this.top = markDesc;
      this.changed = true;
    }
    this.index = 0;
    depth++;
  }
};

// : (Node, [Decoration], DecorationSource) → bool
// Try to find a node desc matching the given data. Skip over it and
// return true when successful.
ViewTreeUpdater.prototype.findNodeMatch = function findNodeMatch (node, outerDeco, innerDeco, index) {
  var found = -1, targetDesc;
  if (index >= this.preMatch.index &&
      (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&
      targetDesc.matchesNode(node, outerDeco, innerDeco)) {
    found = this.top.children.indexOf(targetDesc, this.index);
  } else {
    for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
      var child = this.top.children[i];
      if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
        found = i;
        break
      }
    }
  }
  if (found < 0) { return false }
  this.destroyBetween(this.index, found);
  this.index++;
  return true
};

ViewTreeUpdater.prototype.updateNodeAt = function updateNodeAt (node, outerDeco, innerDeco, index, view) {
  var child = this.top.children[index];
  if (!child.update(node, outerDeco, innerDeco, view)) { return false }
  this.destroyBetween(this.index, index);
  this.index = index + 1;
  return true
};

ViewTreeUpdater.prototype.findIndexWithChild = function findIndexWithChild (domNode) {
  for (;;) {
    var parent = domNode.parentNode;
    if (!parent) { return -1 }
    if (parent == this.top.contentDOM) {
      var desc = domNode.pmViewDesc;
      if (desc) { for (var i = this.index; i < this.top.children.length; i++) {
        if (this.top.children[i] == desc) { return i }
      } }
      return -1
    }
    domNode = parent;
  }
};

// : (Node, [Decoration], DecorationSource, EditorView, Fragment, number) → bool
// Try to update the next node, if any, to the given data. Checks
// pre-matches to avoid overwriting nodes that could still be used.
ViewTreeUpdater.prototype.updateNextNode = function updateNextNode (node, outerDeco, innerDeco, view, index) {
  for (var i = this.index; i < this.top.children.length; i++) {
    var next = this.top.children[i];
    if (next instanceof NodeViewDesc) {
      var preMatch = this.preMatch.matched.get(next);
      if (preMatch != null && preMatch != index) { return false }
      var nextDOM = next.dom;

      // Can't update if nextDOM is or contains this.lock, except if
      // it's a text node whose content already matches the new text
      // and whose decorations match the new ones.
      var locked = this.lock && (nextDOM == this.lock || nextDOM.nodeType == 1 && nextDOM.contains(this.lock.parentNode)) &&
          !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&
            next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
      if (!locked && next.update(node, outerDeco, innerDeco, view)) {
        this.destroyBetween(this.index, i);
        if (next.dom != nextDOM) { this.changed = true; }
        this.index++;
        return true
      }
      break
    }
  }
  return false
};

// : (Node, [Decoration], DecorationSource, EditorView)
// Insert the node as a newly created node desc.
ViewTreeUpdater.prototype.addNode = function addNode (node, outerDeco, innerDeco, view, pos) {
  this.top.children.splice(this.index++, 0, NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos));
  this.changed = true;
};

ViewTreeUpdater.prototype.placeWidget = function placeWidget (widget, view, pos) {
  var next = this.index < this.top.children.length ? this.top.children[this.index] : null;
  if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
    this.index++;
  } else {
    var desc = new WidgetViewDesc(this.top, widget, view, pos);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
};

// Make sure a textblock looks and behaves correctly in
// contentEditable.
ViewTreeUpdater.prototype.addTextblockHacks = function addTextblockHacks () {
  var lastChild = this.top.children[this.index - 1], parent = this.top;
  while (lastChild instanceof MarkViewDesc) {
    parent = lastChild;
    lastChild = parent.children[parent.children.length - 1];
  }

  if (!lastChild || // Empty textblock
      !(lastChild instanceof TextViewDesc) ||
      /\n$/.test(lastChild.node.text)) {
    // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)
    if ((result.safari || result.chrome) && lastChild && lastChild.dom.contentEditable == "false")
      { this.addHackNode("IMG", parent); }
    this.addHackNode("BR", this.top);
  }
};

ViewTreeUpdater.prototype.addHackNode = function addHackNode (nodeName, parent) {
  if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
    this.index++;
  } else {
    var dom = document.createElement(nodeName);
    if (nodeName == "IMG") {
      dom.className = "ProseMirror-separator";
      dom.alt = "";
    }
    if (nodeName == "BR") { dom.className = "ProseMirror-trailingBreak"; }
    var hack = new TrailingHackViewDesc(this.top, nothing, dom, null);
    if (parent != this.top) { parent.children.push(hack); }
    else { parent.children.splice(this.index++, 0, hack); }
    this.changed = true;
  }
};

// : (Fragment, [ViewDesc]) → {index: number, matched: Map<ViewDesc, number>, matches: ViewDesc[]}
// Iterate from the end of the fragment and array of descs to find
// directly matching ones, in order to avoid overeagerly reusing those
// for other nodes. Returns the fragment index of the first node that
// is part of the sequence of matched nodes at the end of the
// fragment.
function preMatch(frag, parentDesc) {
  var curDesc = parentDesc, descI = curDesc.children.length;
  var fI = frag.childCount, matched = new Map, matches = [];
  outer: while (fI > 0) {
    var desc = (void 0);
    for (;;) {
      if (descI) {
        var next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break
        }
      } else if (curDesc == parentDesc) {
        break outer
      } else {
        // FIXME
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    var node = desc.node;
    if (!node) { continue }
    if (node != frag.child(fI - 1)) { break }
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }
  return {index: fI, matched: matched, matches: matches.reverse()}
}

function compareSide(a, b) { return a.type.side - b.type.side }

// : (ViewDesc, DecorationSource, (Decoration, number), (Node, [Decoration], DecorationSource, number))
// This function abstracts iterating over the nodes and decorations in
// a fragment. Calls `onNode` for each node, with its local and child
// decorations. Splits text nodes when there is a decoration starting
// or ending inside of them. Calls `onWidget` for each widget.
function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent), offset = 0;
  // Simple, cheap variant for when there are no local decorations
  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }
    return
  }

  var decoIndex = 0, active = [], restNode = null;
  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++], widgets = (void 0);
      while (decoIndex < locals.length && locals[decoIndex].to == offset)
        { (widgets || (widgets = [widget])).push(locals[decoIndex++]); }
      if (widgets) {
        widgets.sort(compareSide);
        for (var i$1 = 0; i$1 < widgets.length; i$1++) { onWidget(widgets[i$1], parentIndex, !!restNode); }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var child$1 = (void 0), index = (void 0);
    if (restNode) {
      index = -1;
      child$1 = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      child$1 = parent.child(parentIndex++);
    } else {
      break
    }

    for (var i$2 = 0; i$2 < active.length; i$2++) { if (active[i$2].to <= offset) { active.splice(i$2--, 1); } }
    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)
      { active.push(locals[decoIndex++]); }

    var end = offset + child$1.nodeSize;
    if (child$1.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) { cutAt = locals[decoIndex].from; }
      for (var i$3 = 0; i$3 < active.length; i$3++) { if (active[i$3].to < cutAt) { cutAt = active[i$3].to; } }
      if (cutAt < end) {
        restNode = child$1.cut(cutAt - offset);
        child$1 = child$1.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = !active.length ? nothing
        : child$1.isInline && !child$1.isLeaf ? active.filter(function (d) { return !d.inline; })
        : active.slice();
    onNode(child$1, outerDeco, deco.forChild(offset, child$1), index);
    offset = end;
  }
}

// List markers in Mobile Safari will mysteriously disappear
// sometimes. This works around that.
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) { return node }
    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3)
        { return node.childNodes[offset] }
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null
    }
  }
}

// Find a piece of text in an inline fragment, overlapping from-to
function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) { continue }
    var str = child.text;
    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) { break }
      str += next.text;
    }
    if (pos >= from) {
      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from)
        { return childStart + found }
      if (from == to && str.length >= (to + text.length) - childStart &&
          str.slice(to - childStart, to - childStart + text.length) == text)
        { return to }
    }
  }
  return -1
}

// Replace range from-to in an array of view descs with replacement
// (may be null to just delete). This goes very much against the grain
// of the rest of this code, which tends to create nodes with the
// right shape in one go, rather than messing with them after
// creation, but is necessary in the composition hack.
function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];
  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i], start = off, end = off += child.size;
    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) { result.push(child.slice(0, from - start, view)); }
      if (replacement) {
        result.push(replacement);
        replacement = null;
      }
      if (end > to) { result.push(child.slice(to - start, child.size, view)); }
    }
  }
  return result
}

function selectionFromDOM(view, origin) {
  var domSel = view.root.getSelection(), doc = view.state.doc;
  if (!domSel.focusNode) { return null }
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset);
  if (head < 0) { return null }
  var $head = doc.resolve(head), $anchor, selection;
  if (selectionCollapsed(domSel)) {
    $anchor = $head;
    while (nearestDesc && !nearestDesc.node) { nearestDesc = nearestDesc.parent; }
    if (nearestDesc && nearestDesc.node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(nearestDesc.node) && nearestDesc.parent
        && !(nearestDesc.node.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset);
    if (anchor < 0) { return null }
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() :
    hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom)
}

function selectionToDOM(view, force) {
  var sel = view.state.selection;
  syncNodeSelection(view, sel);

  if (!editorOwnsSelection(view)) { return }

  // The delayed drag selection causes issues with Cell Selections
  // in Safari. And the drag selection delay is to workarond issues
  // which only present in Chrome.
  if (!force && view.mouseDown && view.mouseDown.allowDefault && result.chrome) {
    var domSel = view.root.getSelection(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset,
                                                  curSel.anchorNode, curSel.anchorOffset)) {
      view.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return
    }
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor;
    var head = sel.head;
    var resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        { resetEditableFrom = temporarilyEditableNear(view, sel.from); }
      if (!sel.empty && !sel.$from.parent.inlineContent)
        { resetEditableTo = temporarilyEditableNear(view, sel.to); }
    }
    view.docView.setSelection(anchor, head, view.root, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) { resetEditable(resetEditableFrom); }
      if (resetEditableTo) { resetEditable(resetEditableTo); }
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) { removeClassOnSelectionChange(view); }
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

// Kludge to work around Webkit not allowing a selection to start/end
// between non-editable block nodes. We briefly make something
// editable, set the selection, then set it uneditable again.

var brokenSelectBetweenUneditable = result.safari || result.chrome && result.chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var ref = view.docView.domFromPos(pos, 0);
  var node = ref.node;
  var offset = ref.offset;
  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (result.safari && after && after.contentEditable == "false") { return setEditable(after) }
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) { return setEditable(after) }
    else if (before) { return setEditable(before) }
  }
}

function setEditable(element) {
  element.contentEditable = "true";
  if (result.safari && element.draggable) { element.draggable = false; element.wasDraggable = true; }
  return element
}

function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) { element.draggable = true; element.wasDraggable = null; }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.hideSelectionGuard);
  var domSel = view.root.getSelection();
  var node = domSel.anchorNode, offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          { view.dom.classList.remove("ProseMirror-hideselection"); }
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.root.getSelection(), range = document.createRange();
  var node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img) { range.setEnd(node.parentNode, domIndex(node) + 1); }
  else { range.setEnd(node, 0); }
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);
  // Kludge to kill 'control selection' in IE11 when selecting an
  // invisible cursor wrapper, since that would result in those weird
  // resize handles and a selection that considers the absolutely
  // positioned wrapper, rather than the root editable node, the
  // focused element.
  if (!img && !view.state.selection.visible && result.ie && result.ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {
    var desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) { desc.selectNode(); }
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

// Clear all DOM statefulness of the last node selection.
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      { view.lastSelectedViewDesc.deselectNode(); }
    view.lastSelectedViewDesc = null;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) { return f(view, $anchor, $head); })
    || prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.between($anchor, $head, bias)
}

function hasFocusAndSelection(view) {
  if (view.editable && view.root.activeElement != view.dom) { return false }
  return hasSelection(view)
}

function hasSelection(view) {
  var sel = view.root.getSelection();
  if (!sel.anchorNode) { return false }
  try {
    // Firefox will raise 'permission denied' errors when accessing
    // properties of `sel.anchorNode` when it's in a generated CSS
    // element.
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&
      (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode))
  } catch(_) {
    return false
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.root.getSelection();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset)
}

function moveSelectionBlock(state, dir) {
  var ref = state.selection;
  var $anchor = ref.$anchor;
  var $head = ref.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom($start, dir)
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false
    } else if (view.endOfTextblock(dir > 0 ? "right" : "left")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)) { return apply(view, next) }
      return false
    } else if (!(result.mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText) { return false }
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) { return false }
      if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head))
      } else if (result.webkit) {
        // Chrome and Safari will introduce extra pointless cursor
        // positions around inline uneditable nodes, so we have to
        // take over and move the cursor past them (#937)
        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)))
      } else {
        return false
      }
    }
  } else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(dir > 0 ? sel.$to : sel.$from))
  } else {
    var next$1 = moveSelectionBlock(view.state, dir);
    if (next$1) { return apply(view, next$1) }
    return false
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR")
}

// Make sure the cursor isn't directly after one or more ignored
// nodes, which will confuse the browser's cursor motion logic.
function skipIgnoredNodesLeft(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var moveNode, moveOffset, force = false;
  // Gecko will do odd things when the selection is directly in front
  // of a non-editable node, so in that case, move it into the next
  // node if possible. Issue prosemirror/prosemirror#832.
  if (result.gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) { force = true; }
  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break
      } else {
        var before = node.childNodes[offset - 1];
        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else { break }
      }
    } else if (isBlockNode(node)) {
      break
    } else {
      var prev = node.previousSibling;
      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }
  if (force) { setSelFocus(view, sel, node, offset); }
  else if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

// Make sure the cursor isn't directly before one or more ignored
// nodes.
function skipIgnoredNodesRight(view) {
  var sel = view.root.getSelection();
  var node = sel.focusNode, offset = sel.focusOffset;
  if (!node) { return }
  var len = nodeLen(node);
  var moveNode, moveOffset;
  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) { break }
      var after = node.childNodes[offset];
      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      }
      else { break }
    } else if (isBlockNode(node)) {
      break
    } else {
      var next = node.nextSibling;
      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom) { break }
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode) { setSelFocus(view, sel, moveNode, moveOffset); }
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock
}

function setSelFocus(view, sel, node, offset) {
  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }
  view.domObserver.setCurSelection();
  var state = view.state;
  // If no state update ends up happening, reset the selection.
  setTimeout(function () {
    if (view.state == state) { selectionToDOM(view); }
  }, 50);
}

// : (EditorState, number)
// Check whether vertical selection motion would involve node
// selections. If so, apply it (if not, the result is left to the
// browser)
function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty || mods.indexOf("s") > -1) { return false }
  if (result.mac && mods.indexOf("m") > -1) { return false }
  var $from = sel.$from;
  var $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection))
      { return apply(view, next) }
  }
  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false
  }
  return false
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection)) { return true }
  var ref = view.state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  var empty = ref.empty;
  if (!$head.sameParent($anchor)) { return true }
  if (!empty) { return false }
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) { return true }
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) { tr.delete($head.pos - nextNode.nodeSize, $head.pos); }
    else { tr.delete($head.pos, $head.pos + nextNode.nodeSize); }
    view.dispatch(tr);
    return true
  }
  return false
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821
// In which Safari (and at some point in the past, Chrome) does really
// wrong things when the down arrow is pressed when the cursor is
// directly at the start of a textblock and has an uneditable node
// after it
function safariDownArrowBug(view) {
  if (!result.safari || view.state.selection.$head.parentOffset > 0) { return }
  var ref = view.root.getSelection();
  var focusNode = ref.focusNode;
  var focusOffset = ref.focusOffset;
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&
      focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, true);
    setTimeout(function () { return switchEditable(view, child, false); }, 20);
  }
}

// A backdrop key mapping used to make sure we always suppress keys
// that have a dangerous default effect, even if the commands they are
// bound to return false, and to make sure that cursor-motion keys
// find a cursor (as opposed to a node selection) when pressed. For
// cursor-motion keys, the code in the handlers also takes care of
// block selections.

function getMods(event) {
  var result = "";
  if (event.ctrlKey) { result += "c"; }
  if (event.metaKey) { result += "m"; }
  if (event.altKey) { result += "a"; }
  if (event.shiftKey) { result += "s"; }
  return result
}

function captureKeyDown(view, event) {
  var code = event.keyCode, mods = getMods(event);
  if (code == 8 || (result.mac && code == 72 && mods == "c")) { // Backspace, Ctrl-h on Mac
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodesLeft(view)
  } else if (code == 46 || (result.mac && code == 68 && mods == "c")) { // Delete, Ctrl-d on Mac
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodesRight(view)
  } else if (code == 13 || code == 27) { // Enter, Esc
    return true
  } else if (code == 37) { // Left arrow
    return selectHorizontally(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 39) { // Right arrow
    return selectHorizontally(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (code == 38) { // Up arrow
    return selectVertically(view, -1, mods) || skipIgnoredNodesLeft(view)
  } else if (code == 40) { // Down arrow
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesRight(view)
  } else if (mods == (result.mac ? "m" : "c") &&
             (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]
    return true
  }
  return false
}

// Note that all referencing and parsing is done with the
// start-of-operation selection and document, since that's the one
// that the DOM represents. If any changes came in in the meantime,
// the modification is mapped over those before it is applied, in
// readDOMChange.

function parseBetween(view, from_, to_) {
  var ref = view.docView.parseRange(from_, to_);
  var parent = ref.node;
  var fromOffset = ref.fromOffset;
  var toOffset = ref.toOffset;
  var from = ref.from;
  var to = ref.to;

  var domSel = view.root.getSelection(), find = null, anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{node: anchor, offset: domSel.anchorOffset}];
    if (!selectionCollapsed(domSel))
      { find.push({node: domSel.focusNode, offset: domSel.focusOffset}); }
  }
  // Work around issue in Chrome where backspacing sometimes replaces
  // the deleted content with a random BR node (issues #799, #831)
  if (result.chrome && view.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) { toOffset = off; break }
      if (!desc || desc.size) { break }
    }
  }
  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);

  var sel = null, doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    editableContent: true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    var anchor$1 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null) { head = anchor$1; }
    sel = {anchor: anchor$1 + from, head: head + from};
  }
  return {doc: doc, sel: sel, from: from, to: to}
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule()
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    // Safari replaces the list item or table cell with a BR
    // directly in the list node (?!) if you delete the last
    // character in a list item or table cell (#708, #862)
    if (result.safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {skip: skip}
    } else if (dom.parentNode.lastChild == dom || result.safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {ignore: true}
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {ignore: true}
  }
}

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.lastSelectionTime > Date.now() - 50 ? view.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      var tr$1 = view.state.tr.setSelection(newSel);
      if (origin == "pointer") { tr$1.setMeta("pointer", true); }
      else if (origin == "key") { tr$1.scrollIntoView(); }
      view.dispatch(tr$1);
    }
    return
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);

  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);

  // Chrome sometimes leaves the cursor before the inserted text when
  // composing after a cursor wrapper. This moves it forward.
  if (result.chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from) {
    var text = view.cursorWrapper.deco.type.toDOM.nextSibling;
    var size = text && text.nodeValue ? text.nodeValue.length : 1;
    parse.sel = {anchor: parse.sel.anchor + size, head: parse.sel.anchor + size};
  }

  var doc = view.state.doc, compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;
  // Prefer anchoring to end when Backspace is pressed
  if (view.lastKeyCode === 8 && Date.now() - 100 < view.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.lastKeyCode = null;

  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if ((result.ios && view.lastIOSEnter > Date.now() - 225 || result.android) &&
      addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }) &&
      (!change || change.endA >= change.endB) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
    view.lastIOSEnter = 0;
    return
  }
  if (!change) {
    if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&
        !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {start: sel.from, endA: sel.to, endB: sel.to};
    } else {
      if (parse.sel) {
        var sel$1 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel$1 && !sel$1.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel$1)); }
      }
      return
    }
  }
  view.domChangeCount++;
  // Handle the case where overwriting a selection by typing matches
  // the start or end of the selected content, creating a change
  // that's smaller than what was actually overwritten.
  if (view.state.selection.from < view.state.selection.to &&
      change.start == change.endB &&
      view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&
        view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&
               view.state.selection.to <= parse.to) {
      change.endB += (view.state.selection.to - change.endA);
      change.endA = view.state.selection.to;
    }
  }

  // IE11 will insert a non-breaking space _ahead_ of the space after
  // the cursor space when adding a space before another space. When
  // that happened, adjust the change to cover the space instead.
  if (result.ie && result.ie_version <= 11 && change.endB == change.start + 1 &&
      change.endA == change.start && change.start > parse.from &&
      parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \u00a0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent;
  var nextSel;
  // If this looks like the effect of pressing Enter (or was recorded
  // as being an iOS enter press), just dispatch an Enter key instead.
  if (((result.ios && view.lastIOSEnter > Date.now() - 225 &&
        (!inlineChange || addedNodes.some(function (n) { return n.nodeName == "DIV" || n.nodeName == "P"; }))) ||
       (!inlineChange && $from.pos < parse.doc.content.size &&
        (nextSel = prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) &&
        nextSel.head == $to.pos)) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); })) {
    view.lastIOSEnter = 0;
    return
  }
  // Same for backspace
  if (view.state.selection.anchor > change.start &&
      looksLikeJoin(doc, change.start, change.endA, $from, $to) &&
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) {
    if (result.android && result.chrome) { view.domObserver.suppressSelectionUpdates(); } // #820
    return
  }

  // Chrome Android will occasionally, during composition, delete the
  // entire composition and then immediately insert it again. This is
  // used to detect that situation.
  if (result.chrome && result.android && change.toB == change.from)
    { view.lastAndroidDelete = Date.now(); }

  // This tries to detect Android virtual keyboard
  // enter-and-pick-suggestion action. That sometimes (see issue
  // #1059) first fires a DOM mutation, before moving the selection to
  // the newly created block. And then, because ProseMirror cleans up
  // the DOM selection, it gives up moving the selection entirely,
  // leaving the cursor in the wrong place. When that happens, we drop
  // the new paragraph from the initial change, and fire a simulated
  // enter key afterwards.
  if (result.android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&
      parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
    }, 20);
  }

  var chFrom = change.start, chTo = change.endA;

  var tr, storedMarks, markChange, $from1;
  if (inlineChange) {
    if ($from.pos == $to.pos) { // Deletion
      // IE11 sometimes weirdly moves the DOM selection around after
      // backspacing out the first element in a textblock
      if (result.ie && result.ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () { return selectionToDOM(view); }, 20);
      }
      tr = view.state.tr.delete(chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if ( // Adding or removing a mark
      change.endA == change.endB && ($from1 = doc.resolve(change.start)) &&
      (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset),
                                 $from1.parent.content.cut($from1.parentOffset, change.endA - $from1.start())))
    ) {
      tr = view.state.tr;
      if (markChange.type == "add") { tr.addMark(chFrom, chTo, markChange.mark); }
      else { tr.removeMark(chFrom, chTo, markChange.mark); }
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      // Both positions in the same text node -- simply insert text
      var text$1 = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function (f) { return f(view, chFrom, chTo, text$1); })) { return }
      tr = view.state.tr.insertText(text$1, chFrom, chTo);
    }
  }

  if (!tr)
    { tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from)); }
  if (parse.sel) {
    var sel$2 = resolveSelection(view, tr.doc, parse.sel);
    // Chrome Android will sometimes, during composition, report the
    // selection in the wrong place. If it looks like that is
    // happening, don't update the selection.
    // Edge just doesn't move the cursor forward when you start typing
    // in an empty block or between br nodes.
    if (sel$2 && !(result.chrome && result.android && view.composing && sel$2.empty &&
                 (change.start != change.endB || view.lastAndroidDelete < Date.now() - 100) &&
                 (sel$2.head == chFrom || sel$2.head == tr.mapping.map(chTo) - 1) ||
                 result.ie && sel$2.empty && sel$2.head == chFrom))
      { tr.setSelection(sel$2); }
  }
  if (storedMarks) { tr.ensureMarks(storedMarks); }
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) { return null }
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head))
}

// : (Fragment, Fragment) → ?{mark: Mark, type: string}
// Given two same-length, non-empty fragments of inline content,
// determine whether the first could be created from the second by
// removing or adding a single mark type.
function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  var added = curMarks, removed = prevMarks, type, mark, update;
  for (var i = 0; i < prevMarks.length; i++) { added = prevMarks[i].removeFromSet(added); }
  for (var i$1 = 0; i$1 < curMarks.length; i$1++) { removed = curMarks[i$1].removeFromSet(removed); }
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = function (node) { return node.mark(mark.addToSet(node.marks)); };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = function (node) { return node.mark(mark.removeFromSet(node.marks)); };
  } else {
    return null
  }
  var updated = [];
  for (var i$2 = 0; i$2 < prev.childCount; i$2++) { updated.push(update(prev.child(i$2))); }
  if (prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(updated).eq(cur)) { return {mark: mark, type: type} }
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock ||
      // The content must have shrunk
      end - start <= $newEnd.pos - $newStart.pos ||
      // newEnd must point directly at or after the end of the block that newStart points into
      skipClosingAndOpening($newStart, true, false) < $newEnd.pos)
    { return false }

  var $start = old.resolve(start);
  // Start must be at the end of a block
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    { return false }
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  // The next textblock must start before end and end near it
  if (!$next.parent.isTextblock || $next.pos > end ||
      skipClosingAndOpening($next, true, false) < end)
    { return false }

  // The fragments after the join point must match
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content)
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }
  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }
  return end
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) { return null }
  var ref = a.findDiffEnd(b, pos + a.size, pos + b.size);
  var endA = ref.a;
  var endB = ref.b;
  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }
  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var move$1 = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;
    start -= move$1;
    endA = start + (endA - endB);
    endB = start;
  }
  return {start: start, endA: endA, endB: endB}
}

function serializeForClipboard(view, slice) {
  var context = [];
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(), wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {document: doc}));

  var firstChild = wrap.firstChild, needsWrap;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);
      while (wrap.firstChild) { wrapper.appendChild(wrap.firstChild); }
      wrap.appendChild(wrapper);
      if (needsWrap[i] != "tbody") {
        openStart++;
        openEnd++;
      }
    }
    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1)
    { firstChild.setAttribute("data-pm-slice", (openStart + " " + openEnd + " " + (JSON.stringify(context)))); }

  var text = view.someProp("clipboardTextSerializer", function (f) { return f(slice); }) ||
      slice.content.textBetween(0, slice.content.size, "\n\n");

  return {dom: wrap, text: text}
}

// : (EditorView, string, string, ?bool, ResolvedPos) → ?Slice
// Read a slice of content from the clipboard (or drop data).
function parseFromClipboard(view, text, html, plainText, $context) {
  var dom, inCode = $context.parent.type.spec.code, slice;
  if (!html && !text) { return null }
  var asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", function (f) { text = f(text, inCode || plainText); });
    if (inCode) { return text ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty }
    var parsed = view.someProp("clipboardTextParser", function (f) { return f(text, $context, plainText); });
    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var ref = view.state;
      var schema = ref.schema;
      var serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) { p.appendChild(serializer.serializeNode(schema.text(block, marks))); }
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) { html = f(html); });
    dom = readHTML(html);
    if (result.webkit) { restoreReplacedSpaces(dom); }
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+) (.*)/.exec(contextNode.getAttribute("data-pm-slice"));
  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode(dom) {
        if (dom.nodeName == "BR" && !dom.nextSibling &&
            dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) { return {ignore: true} }
      }
    });
  }
  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[3]);
  } else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent
    slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);
    if (slice.openStart || slice.openEnd) {
      var openStart = 0, openEnd = 0;
      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating;
           openStart++, node = node.firstChild) {}
      for (var node$1 = slice.content.lastChild; openEnd < slice.openEnd && !node$1.type.spec.isolating;
           openEnd++, node$1 = node$1.lastChild) {}
      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) { slice = f(slice); });
  return slice
}

var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;

// Takes a slice parsed with parseSlice, which means there hasn't been
// any content-expression checking done on the top nodes, tries to
// find a parent node in the current context that might fit the nodes,
// and if successful, rebuilds the slice so that it fits into that parent.
//
// This addresses the problem that Transform.replace expects a
// coherent slice, and will fail to place a set of siblings that don't
// fit anywhere in the schema.
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) { return fragment }
  var loop = function ( d ) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = (void 0), result = [];
    fragment.forEach(function (node) {
      if (!result) { return }
      var wrap = match.findWrapping(node.type), inLast;
      if (!wrap) { return result = null }
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) { result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length); }
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type, wrapped.attrs);
        lastWrap = wrap;
      }
    });
    if (result) { return { v: prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(result) } }
  };

  for (var d = $context.depth; d >= 0; d--) {
    var returned = loop( d );

    if ( returned ) return returned.v;
  }
  return fragment
}

function withWrappers(node, wrap, from) {
  if ( from === void 0 ) from = 0;

  for (var i = wrap.length - 1; i >= from; i--)
    { node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(node)); }
  return node
}

// Used to group adjacent nodes wrapped in similar parents by
// normalizeSiblings into the same parent node
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) { return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner)) }
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      { return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(withWrappers(node, wrap, depth + 1)))) }
  }
}

function closeRight(node, depth) {
  if (depth == 0) { return node }
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true);
  return node.copy(fragment.append(fill))
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (depth < to - 1) { inner = closeRange(inner, side, from, to, depth + 1, openEnd); }
  if (depth >= from)
    { inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, fragment.childCount > 1 || openEnd <= depth).append(inner)
      : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty, true)); }
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner))
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd); }
  if (openEnd < slice.openEnd)
    { slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd); }
  return slice
}

// Trick from jQuery -- some elements must be wrapped in other
// elements for innerHTML to work. I.e. if you do `div.innerHTML =
// "<td>..</td>"` the table cells are ignored.
var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};

var _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"))
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) { html = html.slice(metas[0].length); }
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    { html = wrap.map(function (n) { return "<" + n + ">"; }).join("") + html + wrap.map(function (n) { return "</" + n + ">"; }).reverse().join(""); }
  elt.innerHTML = html;
  if (wrap) { for (var i = 0; i < wrap.length; i++) { elt = elt.querySelector(wrap[i]) || elt; } }
  return elt
}

// Webkit browsers do some hard-to-predict replacement of regular
// spaces with non-breaking spaces when putting content on the
// clipboard. This tries to convert such non-breaking spaces (which
// will be wrapped in a plain span on Chrome, a span with class
// Apple-converted-space on Safari) back to regular spaces.
function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(result.chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\u00a0" && node.parentNode)
      { node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node); }
  }
}

function addContext(slice, context) {
  if (!slice.size) { return slice }
  var schema = slice.content.firstChild.type.schema, array;
  try { array = JSON.parse(context); }
  catch(e) { return slice }
  var content = slice.content;
  var openStart = slice.openStart;
  var openEnd = slice.openEnd;
  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) { break }
    content = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(type.create(array[i + 1], content));
    openStart++; openEnd++;
  }
  return new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(content, openStart, openEnd)
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified
var useCharData = result.ie && result.ie_version <= 11;

var SelectionState = function SelectionState() {
  this.anchorNode = this.anchorOffset = this.focusNode = this.focusOffset = null;
};

SelectionState.prototype.set = function set (sel) {
  this.anchorNode = sel.anchorNode; this.anchorOffset = sel.anchorOffset;
  this.focusNode = sel.focusNode; this.focusOffset = sel.focusOffset;
};

SelectionState.prototype.eq = function eq (sel) {
  return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&
    sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset
};

var DOMObserver = function DOMObserver(view, handleDOMChange) {
  var this$1 = this;

  this.view = view;
  this.handleDOMChange = handleDOMChange;
  this.queue = [];
  this.flushingSoon = -1;
  this.observer = window.MutationObserver &&
    new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) { this$1.queue.push(mutations[i]); }
      // IE11 will sometimes (on backspacing out a single character
      // text node after a BR node) call the observer callback
      // before actually updating the DOM, which will cause
      // ProseMirror to miss the change (see #930)
      if (result.ie && result.ie_version <= 11 && mutations.some(
        function (m) { return m.type == "childList" && m.removedNodes.length ||
             m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length; }))
        { this$1.flushSoon(); }
      else
        { this$1.flush(); }
    });
  this.currentSelection = new SelectionState;
  if (useCharData) {
    this.onCharData = function (e) {
      this$1.queue.push({target: e.target, type: "characterData", oldValue: e.prevValue});
      this$1.flushSoon();
    };
  }
  this.onSelectionChange = this.onSelectionChange.bind(this);
  this.suppressingSelectionUpdates = false;
};

DOMObserver.prototype.flushSoon = function flushSoon () {
    var this$1 = this;

  if (this.flushingSoon < 0)
    { this.flushingSoon = window.setTimeout(function () { this$1.flushingSoon = -1; this$1.flush(); }, 20); }
};

DOMObserver.prototype.forceFlush = function forceFlush () {
  if (this.flushingSoon > -1) {
    window.clearTimeout(this.flushingSoon);
    this.flushingSoon = -1;
    this.flush();
  }
};

DOMObserver.prototype.start = function start () {
  if (this.observer)
    { this.observer.observe(this.view.dom, observeOptions); }
  if (useCharData)
    { this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData); }
  this.connectSelection();
};

DOMObserver.prototype.stop = function stop () {
    var this$1 = this;

  if (this.observer) {
    var take = this.observer.takeRecords();
    if (take.length) {
      for (var i = 0; i < take.length; i++) { this.queue.push(take[i]); }
      window.setTimeout(function () { return this$1.flush(); }, 20);
    }
    this.observer.disconnect();
  }
  if (useCharData) { this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData); }
  this.disconnectSelection();
};

DOMObserver.prototype.connectSelection = function connectSelection () {
  this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.disconnectSelection = function disconnectSelection () {
  this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
};

DOMObserver.prototype.suppressSelectionUpdates = function suppressSelectionUpdates () {
    var this$1 = this;

  this.suppressingSelectionUpdates = true;
  setTimeout(function () { return this$1.suppressingSelectionUpdates = false; }, 50);
};

DOMObserver.prototype.onSelectionChange = function onSelectionChange () {
  if (!hasFocusAndSelection(this.view)) { return }
  if (this.suppressingSelectionUpdates) { return selectionToDOM(this.view) }
  // Deletions on IE11 fire their events in the wrong order, giving
  // us a selection change event before the DOM changes are
  // reported.
  if (result.ie && result.ie_version <= 11 && !this.view.state.selection.empty) {
    var sel = this.view.root.getSelection();
    // Selection.isCollapsed isn't reliable on IE
    if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
      { return this.flushSoon() }
  }
  this.flush();
};

DOMObserver.prototype.setCurSelection = function setCurSelection () {
  this.currentSelection.set(this.view.root.getSelection());
};

DOMObserver.prototype.ignoreSelectionChange = function ignoreSelectionChange (sel) {
  if (sel.rangeCount == 0) { return true }
  var container = sel.getRangeAt(0).commonAncestorContainer;
  var desc = this.view.docView.nearestDesc(container);
  if (desc && desc.ignoreMutation({type: "selection", target: container.nodeType == 3 ? container.parentNode : container})) {
    this.setCurSelection();
    return true
  }
};

DOMObserver.prototype.flush = function flush () {
  if (!this.view.docView || this.flushingSoon > -1) { return }
  var mutations = this.observer ? this.observer.takeRecords() : [];
  if (this.queue.length) {
    mutations = this.queue.concat(mutations);
    this.queue.length = 0;
  }

  var sel = this.view.root.getSelection();
  var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(this.view) && !this.ignoreSelectionChange(sel);

  var from = -1, to = -1, typeOver = false, added = [];
  if (this.view.editable) {
    for (var i = 0; i < mutations.length; i++) {
      var result$1 = this.registerMutation(mutations[i], added);
      if (result$1) {
        from = from < 0 ? result$1.from : Math.min(result$1.from, from);
        to = to < 0 ? result$1.to : Math.max(result$1.to, to);
        if (result$1.typeOver) { typeOver = true; }
      }
    }
  }

  if (result.gecko && added.length > 1) {
    var brs = added.filter(function (n) { return n.nodeName == "BR"; });
    if (brs.length == 2) {
      var a = brs[0];
        var b = brs[1];
      if (a.parentNode && a.parentNode.parentNode == b.parentNode) { b.remove(); }
      else { a.remove(); }
    }
  }

  if (from > -1 || newSel) {
    if (from > -1) {
      this.view.docView.markDirty(from, to);
      checkCSS(this.view);
    }
    this.handleDOMChange(from, to, typeOver, added);
    if (this.view.docView && this.view.docView.dirty) { this.view.updateState(this.view.state); }
    else if (!this.currentSelection.eq(sel)) { selectionToDOM(this.view); }
    this.currentSelection.set(sel);
  }
};

DOMObserver.prototype.registerMutation = function registerMutation (mut, added) {
  // Ignore mutations inside nodes that were already noted as inserted
  if (added.indexOf(mut.target) > -1) { return null }
  var desc = this.view.docView.nearestDesc(mut.target);
  if (mut.type == "attributes" &&
      (desc == this.view.docView || mut.attributeName == "contenteditable" ||
       // Firefox sometimes fires spurious events for null/empty styles
       (mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))))
    { return null }
  if (!desc || desc.ignoreMutation(mut)) { return null }

  if (mut.type == "childList") {
    for (var i = 0; i < mut.addedNodes.length; i++) { added.push(mut.addedNodes[i]); }
    if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
      { return {from: desc.posBefore, to: desc.posAfter} }
    var prev = mut.previousSibling, next = mut.nextSibling;
    if (result.ie && result.ie_version <= 11 && mut.addedNodes.length) {
      // IE11 gives us incorrect next/prev siblings for some
      // insertions, so if there are added nodes, recompute those
      for (var i$1 = 0; i$1 < mut.addedNodes.length; i$1++) {
        var ref = mut.addedNodes[i$1];
          var previousSibling = ref.previousSibling;
          var nextSibling = ref.nextSibling;
        if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) { prev = previousSibling; }
        if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) { next = nextSibling; }
      }
    }
    var fromOffset = prev && prev.parentNode == mut.target
        ? domIndex(prev) + 1 : 0;
    var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
    var toOffset = next && next.parentNode == mut.target
        ? domIndex(next) : mut.target.childNodes.length;
    var to = desc.localPosFromDOM(mut.target, toOffset, 1);
    return {from: from, to: to}
  } else if (mut.type == "attributes") {
    return {from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border}
  } else { // "characterData"
    return {
      from: desc.posAtStart,
      to: desc.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: mut.target.nodeValue == mut.oldValue
    }
  }
};

var cssChecked = false;

function checkCSS(view) {
  if (cssChecked) { return }
  cssChecked = true;
  if (getComputedStyle(view.dom).whiteSpace == "normal")
    { console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."); }
}

// A collection of DOM events that occur within the editor, and callback functions
// to invoke when the event fires.
var handlers = {}, editHandlers = {};

function initInput(view) {
  view.shiftKey = false;
  view.mouseDown = null;
  view.lastKeyCode = null;
  view.lastKeyCodeTime = 0;
  view.lastClick = {time: 0, x: 0, y: 0, type: ""};
  view.lastSelectionOrigin = null;
  view.lastSelectionTime = 0;

  view.lastIOSEnter = 0;
  view.lastIOSEnterFallbackTimeout = null;
  view.lastAndroidDelete = 0;

  view.composing = false;
  view.composingTimeout = null;
  view.compositionNodes = [];
  view.compositionEndedAt = -2e8;

  view.domObserver = new DOMObserver(view, function (from, to, typeOver, added) { return readDOMChange(view, from, to, typeOver, added); });
  view.domObserver.start();
  // Used by hacks like the beforeinput handler to check whether anything happened in the DOM
  view.domChangeCount = 0;

  view.eventHandlers = Object.create(null);
  var loop = function ( event ) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&
          (view.editable || !(event.type in editHandlers)))
        { handler(view, event); }
    });
  };

  for (var event in handlers) loop( event );
  // On Safari, for reasons beyond my understanding, adding an input
  // event handler makes an issue where the composition vanishes when
  // you press enter go away.
  if (result.safari) { view.dom.addEventListener("input", function () { return null; }); }

  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.lastSelectionOrigin = origin;
  view.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();
  for (var type in view.eventHandlers)
    { view.dom.removeEventListener(type, view.eventHandlers[type]); }
  clearTimeout(view.composingTimeout);
  clearTimeout(view.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) { if (!view.eventHandlers[type])
      { view.dom.addEventListener(type, view.eventHandlers[type] = function (event) { return runCustomHandler(view, event); }); } }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false
  })
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) { return true }
  if (event.defaultPrevented) { return false }
  for (var node = event.target; node != view.dom; node = node.parentNode)
    { if (!node || node.nodeType == 11 ||
        (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))
      { return false } }
  return true
}

function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] &&
      (view.editable || !(event.type in editHandlers)))
    { handlers[event.type](view, event); }
}

editHandlers.keydown = function (view, event) {
  view.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) { return }
  view.lastKeyCode = event.keyCode;
  view.lastKeyCodeTime = Date.now();
  // Suppress enter key events on Chrome Android, because those tend
  // to be part of a confused sequence of composition events fired,
  // and handling them eagerly tends to corrupt the input.
  if (result.android && result.chrome && event.keyCode == 13) { return }
  if (event.keyCode != 229) { view.domObserver.forceFlush(); }

  // On iOS, if we preventDefault enter key presses, the virtual
  // keyboard gets confused. So the hack here is to set a flag that
  // makes the DOM change code recognize that what just happens should
  // be replaced by whatever the Enter key handlers do.
  if (result.ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.lastIOSEnter = now;
    view.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(13, "Enter")); });
        view.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) { return f(view, event); }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, e) {
  if (e.keyCode == 16) { view.shiftKey = false; }
};

editHandlers.keypress = function (view, event) {
  if (inOrNearComposition(view, event) || !event.charCode ||
      event.ctrlKey && !event.altKey || result.mac && event.metaKey) { return }

  if (view.someProp("handleKeyPress", function (f) { return f(view, event); })) {
    event.preventDefault();
    return
  }

  var sel = view.state.selection;
  if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!view.someProp("handleTextInput", function (f) { return f(view, sel.$from.pos, sel.$to.pos, text); }))
      { view.dispatch(view.state.tr.insertText(text).scrollIntoView()); }
    event.preventDefault();
  }
};

function eventCoords(event) { return {left: event.clientX, top: event.clientY} }

function isNear(event, click) {
  var dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside);
  var loop = function ( i ) {
    if (view.someProp(propName, function (f) { return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)
                                                    : f(view, pos, $pos.node(i), $pos.before(i), event, false); }))
      { return { v: true } }
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

function updateSelection(view, selection, origin) {
  if (!view.focused) { view.focus(); }
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") { tr.setMeta("pointer", true); }
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) { return false }
  var $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos), "pointer");
    return true
  }
  return false
}

function selectClickedNode(view, inside) {
  if (inside == -1) { return false }
  var sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) { selectedNode = sel.node; }

  var $pos = view.state.doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 &&
          i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        { selectAt = $pos.before(sel.$from.depth); }
      else
        { selectAt = $pos.before(i); }
      break
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true
  } else {
    return false
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) ||
    view.someProp("handleClick", function (f) { return f(view, pos, event); }) ||
    (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside))
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) ||
    view.someProp("handleDoubleClick", function (f) { return f(view, pos, event); })
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) ||
    view.someProp("handleTripleClick", function (f) { return f(view, pos, event); }) ||
    defaultTripleClick(view, inside, event)
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) { return false }
  var doc = view.state.doc;
  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true
    }
    return false
  }

  var $pos = doc.resolve(inside);
  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent)
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer"); }
    else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(node))
      { updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, nodePos), "pointer"); }
    else
      { continue }
    return true
  }
}

function forceDOMFlush(view) {
  return endComposition(view)
}

var selectNodeModifier = result.mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, event) {
  view.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(), type = "singleClick";
  if (now - view.lastClick.time < 500 && isNear(event, view.lastClick) && !event[selectNodeModifier]) {
    if (view.lastClick.type == "singleClick") { type = "doubleClick"; }
    else if (view.lastClick.type == "doubleClick") { type = "tripleClick"; }
  }
  view.lastClick = {time: now, x: event.clientX, y: event.clientY, type: type};

  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) { return }

  if (type == "singleClick") {
    if (view.mouseDown) { view.mouseDown.done(); }
    view.mouseDown = new MouseDown(view, pos, event, flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function MouseDown(view, pos, event, flushed) {
  var this$1 = this;

  this.view = view;
  this.startDoc = view.state.doc;
  this.pos = pos;
  this.event = event;
  this.flushed = flushed;
  this.selectNode = event[selectNodeModifier];
  this.allowDefault = event.shiftKey;
  this.delayedSelectionSync = false;

  var targetNode, targetPos;
  if (pos.inside > -1) {
    targetNode = view.state.doc.nodeAt(pos.inside);
    targetPos = pos.inside;
  } else {
    var $pos = view.state.doc.resolve(pos.pos);
    targetNode = $pos.parent;
    targetPos = $pos.depth ? $pos.before() : 0;
  }

  this.mightDrag = null;

  var target = flushed ? null : event.target;
  var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
  this.target = targetDesc ? targetDesc.dom : null;

  var ref = view.state;
  var selection = ref.selection;
  if (event.button == 0 &&
      targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||
      selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)
    { this.mightDrag = {node: targetNode,
                      pos: targetPos,
                      addAttr: this.target && !this.target.draggable,
                      setUneditable: this.target && result.gecko && !this.target.hasAttribute("contentEditable")}; }

  if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.draggable = true; }
    if (this.mightDrag.setUneditable)
      { setTimeout(function () {
        if (this$1.view.mouseDown == this$1) { this$1.target.setAttribute("contentEditable", "false"); }
      }, 20); }
    this.view.domObserver.start();
  }

  view.root.addEventListener("mouseup", this.up = this.up.bind(this));
  view.root.addEventListener("mousemove", this.move = this.move.bind(this));
  setSelectionOrigin(view, "pointer");
};

MouseDown.prototype.done = function done () {
    var this$1 = this;

  this.view.root.removeEventListener("mouseup", this.up);
  this.view.root.removeEventListener("mousemove", this.move);
  if (this.mightDrag && this.target) {
    this.view.domObserver.stop();
    if (this.mightDrag.addAttr) { this.target.removeAttribute("draggable"); }
    if (this.mightDrag.setUneditable) { this.target.removeAttribute("contentEditable"); }
    this.view.domObserver.start();
  }
  if (this.delayedSelectionSync) { setTimeout(function () { return selectionToDOM(this$1.view); }); }
  this.view.mouseDown = null;
};

MouseDown.prototype.up = function up (event) {
  this.done();

  if (!this.view.dom.contains(event.target.nodeType == 3 ? event.target.parentNode : event.target))
    { return }

  var pos = this.pos;
  if (this.view.state.doc != this.startDoc) { pos = this.view.posAtCoords(eventCoords(event)); }

  if (this.allowDefault || !pos) {
    setSelectionOrigin(this.view, "pointer");
  } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
    event.preventDefault();
  } else if (event.button == 0 &&
             (this.flushed ||
              // Safari ignores clicks on draggable elements
              (result.safari && this.mightDrag && !this.mightDrag.node.isAtom) ||
              // Chrome will sometimes treat a node selection as a
              // cursor, but still report that the node is selected
              // when asked through getSelection. You'll then get a
              // situation where clicking at the point where that
              // (hidden) cursor is doesn't change the selection, and
              // thus doesn't get a reaction from ProseMirror. This
              // works around that.
              (result.chrome && !(this.view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) &&
               Math.min(Math.abs(pos.pos - this.view.state.selection.from),
                        Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {
    updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
    event.preventDefault();
  } else {
    setSelectionOrigin(this.view, "pointer");
  }
};

MouseDown.prototype.move = function move (event) {
  if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||
                             Math.abs(this.event.y - event.clientY) > 4))
    { this.allowDefault = true; }
  setSelectionOrigin(this.view, "pointer");
  if (event.buttons == 0) { this.done(); }
};

handlers.touchdown = function (view) {
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) { return forceDOMFlush(view); };

function inOrNearComposition(view, event) {
  if (view.composing) { return true }
  // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.
  // On Japanese input method editors (IMEs), the Enter key is used to confirm character
  // selection. On Safari, when Enter is pressed, compositionend and keydown events are
  // emitted. The keydown event triggers newline insertion, which we don't want.
  // This method returns true if the keydown event should be ignored.
  // We only ignore it once, as pressing Enter a second time *should* insert a newline.
  // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.
  // This guards against the case where compositionend is triggered without the keyboard
  // (e.g. character confirmation may be done with the mouse), and keydown is triggered
  // afterwards- we wouldn't want to ignore the keydown event in this case.
  if (result.safari && Math.abs(event.timeStamp - view.compositionEndedAt) < 500) {
    view.compositionEndedAt = -2e8;
    return true
  }
  return false
}

// Drop active composition after 5 seconds of inactivity on Android
var timeoutComposition = result.android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state;
    var $pos = state.selection.$from;
    if (state.selection.empty &&
        (state.storedMarks ||
         (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) { return m.type.spec.inclusive === false; })))) {
      // Need to wrap the cursor in mark nodes different from the ones in the DOM context
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);
      // In firefox, if the cursor is after but outside a marked node,
      // the inserted text won't inherit the marks. So this moves it
      // inside if necessary.
      if (result.gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.root.getSelection();
        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) { break }
          if (before.nodeType == 3) {
            sel.collapse(before, before.nodeValue.length);
            break
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }
    view.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = event.timeStamp;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.composingTimeout);
  if (delay > -1) { view.composingTimeout = setTimeout(function () { return endComposition(view); }, delay); }
}

function clearComposition(view) {
  if (view.composing) {
    view.composing = false;
    view.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.compositionNodes.length > 0) { view.compositionNodes.pop().markParentsDirty(); }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp
}

function endComposition(view, forceUpdate) {
  if (result.android && view.domObserver.flushingSoon >= 0) { return }
  view.domObserver.forceFlush();
  clearComposition(view);
  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) { view.dispatch(view.state.tr.setSelection(sel)); }
    else { view.updateState(view.state); }
    return true
  }
  return false
}

function captureCopy(view, dom) {
  // The extra wrapper is somehow necessary on IE/Edge to prevent the
  // content from being mangled when it is put onto the clipboard
  if (!view.dom.parentNode) { return }
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  // Done because IE will fire a selectionchange moving the selection
  // to its start when removeAllRanges is called and the editor still
  // has focus (which will mess up the editor's selection state).
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) { wrap.parentNode.removeChild(wrap); }
    view.focus();
  }, 50);
}

// This is very crude, but unfortunately both these browsers _pretend_
// that they have a clipboard API—all the objects and methods are
// there, they just don't work, and they are hard to test.
var brokenClipboardAPI = (result.ie && result.ie_version < 15) ||
      (result.ios && result.webkit_version < 604);

handlers.copy = editHandlers.cut = function (view, e) {
  var sel = view.state.selection, cut = e.type == "cut";
  if (sel.empty) { return }

  // IE and Edge's clipboard interface is completely broken
  var data = brokenClipboardAPI ? null : e.clipboardData;
  var slice = sel.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  if (data) {
    e.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut) { view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")); }
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null
}

function capturePaste(view, e) {
  if (!view.dom.parentNode) { return }
  var plainText = view.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) { target.contentEditable = "true"; }
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) { target.parentNode.removeChild(target); }
    if (plainText) { doPaste(view, target.value, null, e); }
    else { doPaste(view, target.textContent, target.innerHTML, e); }
  }, 50);
}

function doPaste(view, text, html, e) {
  var slice = parseFromClipboard(view, text, html, view.shiftKey, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty); })) { return true }
  if (!slice) { return false }

  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true
}

editHandlers.paste = function (view, e) {
  // Handling paste from JavaScript during composition is very poorly
  // handled by browsers, so as a dodgy but preferable kludge, we just
  // let the browser do its native thing there, except on Android,
  // where the editor is almost always composing.
  if (view.composing && !result.android) { return }
  var data = brokenClipboardAPI ? null : e.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), e)) { e.preventDefault(); }
  else { capturePaste(view, e); }
};

var Dragging = function Dragging(slice, move) {
  this.slice = slice;
  this.move = move;
};

var dragCopyModifier = result.mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, e) {
  var mouseDown = view.mouseDown;
  if (mouseDown) { mouseDown.done(); }
  if (!e.dataTransfer) { return }

  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(e));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection ? sel.to - 1: sel.to)) ; else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (e.target && e.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(e.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      { view.dispatch(view.state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, desc.posBefore))); }
  }
  var slice = view.state.selection.content();
  var ref = serializeForClipboard(view, slice);
  var dom = ref.dom;
  var text = ref.text;
  e.dataTransfer.clearData();
  e.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  // See https://github.com/ProseMirror/prosemirror/issues/1156
  e.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) { e.dataTransfer.setData("text/plain", text); }
  view.dragging = new Dragging(slice, !e[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging)  { view.dragging = null; }
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) { return e.preventDefault(); };

editHandlers.drop = function (view, e) {
  var dragging = view.dragging;
  view.dragging = null;

  if (!e.dataTransfer) { return }

  var eventPos = view.posAtCoords(eventCoords(e));
  if (!eventPos) { return }
  var $mouse = view.state.doc.resolve(eventPos.pos);
  if (!$mouse) { return }
  var slice = dragging && dragging.slice;
  if (slice) {
    view.someProp("transformPasted", function (f) { slice = f(slice); });
  } else {
    slice = parseFromClipboard(view, e.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"),
                               brokenClipboardAPI ? null : e.dataTransfer.getData("text/html"), false, $mouse);
  }
  var move = dragging && !e[dragCopyModifier];
  if (view.someProp("handleDrop", function (f) { return f(view, e, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty, move); })) {
    e.preventDefault();
    return
  }
  if (!slice) { return }

  e.preventDefault();
  var insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) { insertPos = $mouse.pos; }

  var tr = view.state.tr;
  if (move) { tr.deleteSelection(); }

  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode)
    { tr.replaceRangeWith(pos, pos, slice.content.firstChild); }
  else
    { tr.replaceRange(pos, pos, slice); }
  if (tr.doc.eq(beforeInsert)) { return }

  var $pos = tr.doc.resolve(pos);
  if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(slice.content.firstChild) &&
      $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.root.getSelection()))
        { selectionToDOM(view); }
    }, 20);
  }
};

handlers.blur = function (view, e) {
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (e.relatedTarget && view.dom.contains(e.relatedTarget))
      { view.domObserver.currentSelection.set({}); }
    view.focused = false;
  }
};

handlers.beforeinput = function (view, event) {
  // We should probably do more with beforeinput events, but support
  // is so spotty that I'm still waiting to see where they are going.

  // Very specific hack to deal with backspace sometimes failing on
  // Chrome Android when after an uneditable node.
  if (result.chrome && result.android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.domChangeCount;
    setTimeout(function () {
      if (view.domChangeCount != domChangeCount) { return } // Event already had some effect
      // This bug tends to close the virtual keyboard, so we refocus
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) { return f(view, keyEvent(8, "Backspace")); })) { return }
      var ref = view.state.selection;
      var $cursor = ref.$cursor;
      // Crude approximation of backspace behavior when no command handled it
      if ($cursor && $cursor.pos > 0) { view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView()); }
    }, 50);
  }
};

// Make sure all handlers get registered
for (var prop in editHandlers) { handlers[prop] = editHandlers[prop]; }

function compareObjs(a, b) {
  if (a == b) { return true }
  for (var p in a) { if (a[p] !== b[p]) { return false } }
  for (var p$1 in b) { if (!(p$1 in a)) { return false } }
  return true
}

var WidgetType = function WidgetType(toDOM, spec) {
  this.spec = spec || noSpec;
  this.side = this.spec.side || 0;
  this.toDOM = toDOM;
};

WidgetType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var ref = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    var pos = ref.pos;
    var deleted = ref.deleted;
  return deleted ? null : new Decoration(pos - offset, pos - offset, this)
};

WidgetType.prototype.valid = function valid () { return true };

WidgetType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof WidgetType &&
     (this.spec.key && this.spec.key == other.spec.key ||
      this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)))
};

WidgetType.prototype.destroy = function destroy (node) {
  if (this.spec.destroy) { this.spec.destroy(node); }
};

var InlineType = function InlineType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

InlineType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
  var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
  return from >= to ? null : new Decoration(from, to, this)
};

InlineType.prototype.valid = function valid (_, span) { return span.from < span.to };

InlineType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

InlineType.is = function is (span) { return span.type instanceof InlineType };

var NodeType = function NodeType(attrs, spec) {
  this.spec = spec || noSpec;
  this.attrs = attrs;
};

NodeType.prototype.map = function map (mapping, span, offset, oldOffset) {
  var from = mapping.mapResult(span.from + oldOffset, 1);
  if (from.deleted) { return null }
  var to = mapping.mapResult(span.to + oldOffset, -1);
  if (to.deleted || to.pos <= from.pos) { return null }
  return new Decoration(from.pos - offset, to.pos - offset, this)
};

NodeType.prototype.valid = function valid (node, span) {
  var ref = node.content.findIndex(span.from);
    var index = ref.index;
    var offset = ref.offset;
    var child;
  return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to
};

NodeType.prototype.eq = function eq (other) {
  return this == other ||
    (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&
     compareObjs(this.spec, other.spec))
};

// ::- Decoration objects can be provided to the view through the
// [`decorations` prop](#view.EditorProps.decorations). They come in
// several variants—see the static members of this class for details.
var Decoration = function Decoration(from, to, type) {
  // :: number
  // The start position of the decoration.
  this.from = from;
  // :: number
  // The end position. Will be the same as `from` for [widget
  // decorations](#view.Decoration^widget).
  this.to = to;
  this.type = type;
};

var prototypeAccessors$1 = { spec: { configurable: true },inline: { configurable: true } };

Decoration.prototype.copy = function copy (from, to) {
  return new Decoration(from, to, this.type)
};

Decoration.prototype.eq = function eq (other, offset) {
    if ( offset === void 0 ) offset = 0;

  return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to
};

Decoration.prototype.map = function map (mapping, offset, oldOffset) {
  return this.type.map(mapping, this, offset, oldOffset)
};

// :: (number, union<(view: EditorView, getPos: () → number) → dom.Node, dom.Node>, ?Object) → Decoration
// Creates a widget decoration, which is a DOM node that's shown in
// the document at the given position. It is recommended that you
// delay rendering the widget by passing a function that will be
// called when the widget is actually drawn in a view, but you can
// also directly pass a DOM node. `getPos` can be used to find the
// widget's current document position.
//
// spec::- These options are supported:
//
//   side:: ?number
//   Controls which side of the document position this widget is
//   associated with. When negative, it is drawn before a cursor
//   at its position, and content inserted at that position ends
//   up after the widget. When zero (the default) or positive, the
//   widget is drawn after the cursor and content inserted there
//   ends up before the widget.
//
//   When there are multiple widgets at a given position, their
//   `side` values determine the order in which they appear. Those
//   with lower values appear first. The ordering of widgets with
//   the same `side` value is unspecified.
//
//   When `marks` is null, `side` also determines the marks that
//   the widget is wrapped in—those of the node before when
//   negative, those of the node after when positive.
//
//   marks:: ?[Mark]
//   The precise set of marks to draw around the widget.
//
//   stopEvent:: ?(event: dom.Event) → bool
//   Can be used to control which DOM events, when they bubble out
//   of this widget, the editor view should ignore.
//
//   ignoreSelection:: ?bool
//   When set (defaults to false), selection changes inside the
//   widget are ignored, and don't cause ProseMirror to try and
//   re-sync the selection with its selection state.
//
//   key:: ?string
//   When comparing decorations of this type (in order to decide
//   whether it needs to be redrawn), ProseMirror will by default
//   compare the widget DOM node by identity. If you pass a key,
//   that key will be compared instead, which can be useful when
//   you generate decorations on the fly and don't want to store
//   and reuse DOM nodes. Make sure that any widgets with the same
//   key are interchangeable—if widgets differ in, for example,
//   the behavior of some event handler, they should get
//   different keys.
//
//   destroy:: ?(node: dom.Node)
//   Called when the widget decoration is removed as a result of
//   mapping
Decoration.widget = function widget (pos, toDOM, spec) {
  return new Decoration(pos, pos, new WidgetType(toDOM, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates an inline decoration, which adds the given attributes to
// each inline node between `from` and `to`.
//
// spec::- These options are recognized:
//
//   inclusiveStart:: ?bool
//   Determines how the left side of the decoration is
//   [mapped](#transform.Position_Mapping) when content is
//   inserted directly at that position. By default, the decoration
//   won't include the new content, but you can set this to `true`
//   to make it inclusive.
//
//   inclusiveEnd:: ?bool
//   Determines how the right side of the decoration is mapped.
//   See
//   [`inclusiveStart`](#view.Decoration^inline^spec.inclusiveStart).
Decoration.inline = function inline (from, to, attrs, spec) {
  return new Decoration(from, to, new InlineType(attrs, spec))
};

// :: (number, number, DecorationAttrs, ?Object) → Decoration
// Creates a node decoration. `from` and `to` should point precisely
// before and after a node in the document. That node, and only that
// node, will receive the given attributes.
//
// spec::-
//
// Optional information to store with the decoration. It
// is also used when comparing decorators for equality.
Decoration.node = function node (from, to, attrs, spec) {
  return new Decoration(from, to, new NodeType(attrs, spec))
};

// :: Object
// The spec provided when creating this decoration. Can be useful
// if you've stored extra information in that object.
prototypeAccessors$1.spec.get = function () { return this.type.spec };

prototypeAccessors$1.inline.get = function () { return this.type instanceof InlineType };

Object.defineProperties( Decoration.prototype, prototypeAccessors$1 );

// DecorationAttrs:: interface
// A set of attributes to add to a decorated node. Most properties
// simply directly correspond to DOM attributes of the same name,
// which will be set to the property's value. These are exceptions:
//
//   class:: ?string
//   A CSS class name or a space-separated set of class names to be
//   _added_ to the classes that the node already had.
//
//   style:: ?string
//   A string of CSS to be _added_ to the node's existing `style` property.
//
//   nodeName:: ?string
//   When non-null, the target node is wrapped in a DOM element of
//   this type (and the other attributes are applied to this element).

var none = [], noSpec = {};

// :: class extends DecorationSource
// A collection of [decorations](#view.Decoration), organized in
// such a way that the drawing algorithm can efficiently use and
// compare them. This is a persistent data structure—it is not
// modified, updates create a new value.
var DecorationSet = function DecorationSet(local, children) {
  this.local = local && local.length ? local : none;
  this.children = children && children.length ? children : none;
};

// :: (Node, [Decoration]) → DecorationSet
// Create a set of decorations, using the structure of the given
// document.
DecorationSet.create = function create (doc, decorations) {
  return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty
};

// :: (?number, ?number, ?(spec: Object) → bool) → [Decoration]
// Find all decorations in this set which touch the given range
// (including decorations that start or end directly at the
// boundaries) and match the given predicate on their spec. When
// `start` and `end` are omitted, all decorations in the set are
// considered. When `predicate` isn't given, all decorations are
// assumed to match.
DecorationSet.prototype.find = function find (start, end, predicate) {
  var result = [];
  this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
  return result
};

DecorationSet.prototype.findInner = function findInner (start, end, result, offset, predicate) {
  for (var i = 0; i < this.local.length; i++) {
    var span = this.local[i];
    if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))
      { result.push(span.copy(span.from + offset, span.to + offset)); }
  }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3) {
    if (this.children[i$1] < end && this.children[i$1 + 1] > start) {
      var childOff = this.children[i$1] + 1;
      this.children[i$1 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
    }
  }
};

// :: (Mapping, Node, ?Object) → DecorationSet
// Map the set of decorations in response to a change in the
// document.
//
// options::- An optional set of options.
//
//   onRemove:: ?(decorationSpec: Object)
//   When given, this function will be called for each decoration
//   that gets dropped as a result of the mapping, passing the
//   spec of that decoration.
DecorationSet.prototype.map = function map (mapping, doc, options) {
  if (this == empty || mapping.maps.length == 0) { return this }
  return this.mapInner(mapping, doc, 0, 0, options || noSpec)
};

DecorationSet.prototype.mapInner = function mapInner (mapping, node, offset, oldOffset, options) {
  var newLocal;
  for (var i = 0; i < this.local.length; i++) {
    var mapped = this.local[i].map(mapping, offset, oldOffset);
    if (mapped && mapped.type.valid(node, mapped)) { (newLocal || (newLocal = [])).push(mapped); }
    else if (options.onRemove) { options.onRemove(this.local[i].spec); }
  }

  if (this.children.length)
    { return mapChildren(this.children, newLocal, mapping, node, offset, oldOffset, options) }
  else
    { return newLocal ? new DecorationSet(newLocal.sort(byPos)) : empty }
};

// :: (Node, [Decoration]) → DecorationSet
// Add the given array of decorations to the ones in the set,
// producing a new set. Needs access to the current document to
// create the appropriate tree structure.
DecorationSet.prototype.add = function add (doc, decorations) {
  if (!decorations.length) { return this }
  if (this == empty) { return DecorationSet.create(doc, decorations) }
  return this.addInner(doc, decorations, 0)
};

DecorationSet.prototype.addInner = function addInner (doc, decorations, offset) {
    var this$1 = this;

  var children, childIndex = 0;
  doc.forEach(function (childNode, childOffset) {
    var baseOffset = childOffset + offset, found;
    if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) { return }

    if (!children) { children = this$1.children.slice(); }
    while (childIndex < children.length && children[childIndex] < childOffset) { childIndex += 3; }
    if (children[childIndex] == childOffset)
      { children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1); }
    else
      { children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec)); }
    childIndex += 3;
  });

  var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);
  for (var i = 0; i < local.length; i++) { if (!local[i].type.valid(doc, local[i])) { local.splice(i--, 1); } }

  return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local,
                           children || this.children)
};

// :: ([Decoration]) → DecorationSet
// Create a new set that contains the decorations in this set, minus
// the ones in the given array.
DecorationSet.prototype.remove = function remove (decorations) {
  if (decorations.length == 0 || this == empty) { return this }
  return this.removeInner(decorations, 0)
};

DecorationSet.prototype.removeInner = function removeInner (decorations, offset) {
  var children = this.children, local = this.local;
  for (var i = 0; i < children.length; i += 3) {
    var found = (void 0), from = children[i] + offset, to = children[i + 1] + offset;
    for (var j = 0, span = (void 0); j < decorations.length; j++) { if (span = decorations[j]) {
      if (span.from > from && span.to < to) {
        decorations[j] = null
        ;(found || (found = [])).push(span);
      }
    } }
    if (!found) { continue }
    if (children == this.children) { children = this.children.slice(); }
    var removed = children[i + 2].removeInner(found, from + 1);
    if (removed != empty) {
      children[i + 2] = removed;
    } else {
      children.splice(i, 3);
      i -= 3;
    }
  }
  if (local.length) { for (var i$1 = 0, span$1 = (void 0); i$1 < decorations.length; i$1++) { if (span$1 = decorations[i$1]) {
    for (var j$1 = 0; j$1 < local.length; j$1++) { if (local[j$1].eq(span$1, offset)) {
      if (local == this.local) { local = this.local.slice(); }
      local.splice(j$1--, 1);
    } }
  } } }
  if (children == this.children && local == this.local) { return this }
  return local.length || children.length ? new DecorationSet(local, children) : empty
};

DecorationSet.prototype.forChild = function forChild (offset, node) {
  if (this == empty) { return this }
  if (node.isLeaf) { return DecorationSet.empty }

  var child, local;
  for (var i = 0; i < this.children.length; i += 3) { if (this.children[i] >= offset) {
    if (this.children[i] == offset) { child = this.children[i + 2]; }
    break
  } }
  var start = offset + 1, end = start + node.content.size;
  for (var i$1 = 0; i$1 < this.local.length; i$1++) {
    var dec = this.local[i$1];
    if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {
      var from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;
      if (from < to) { (local || (local = [])).push(dec.copy(from, to)); }
    }
  }
  if (local) {
    var localSet = new DecorationSet(local.sort(byPos));
    return child ? new DecorationGroup([localSet, child]) : localSet
  }
  return child || empty
};

DecorationSet.prototype.eq = function eq (other) {
  if (this == other) { return true }
  if (!(other instanceof DecorationSet) ||
      this.local.length != other.local.length ||
      this.children.length != other.children.length) { return false }
  for (var i = 0; i < this.local.length; i++)
    { if (!this.local[i].eq(other.local[i])) { return false } }
  for (var i$1 = 0; i$1 < this.children.length; i$1 += 3)
    { if (this.children[i$1] != other.children[i$1] ||
        this.children[i$1 + 1] != other.children[i$1 + 1] ||
        !this.children[i$1 + 2].eq(other.children[i$1 + 2])) { return false } }
  return true
};

DecorationSet.prototype.locals = function locals (node) {
  return removeOverlap(this.localsInner(node))
};

DecorationSet.prototype.localsInner = function localsInner (node) {
  if (this == empty) { return none }
  if (node.inlineContent || !this.local.some(InlineType.is)) { return this.local }
  var result = [];
  for (var i = 0; i < this.local.length; i++) {
    if (!(this.local[i].type instanceof InlineType))
      { result.push(this.local[i]); }
  }
  return result
};

// DecorationSource:: interface
// An object that can [provide](#view.EditorProps.decorations)
// decorations. Implemented by [`DecorationSet`](#view.DecorationSet),
// and passed to [node views](#view.EditorProps.nodeViews).
//
//   map:: (Mapping, Node) → DecorationSource
//   Map the set of decorations in response to a change in the
//   document.

var empty = new DecorationSet();

// :: DecorationSet
// The empty set of decorations.
DecorationSet.empty = empty;

DecorationSet.removeOverlap = removeOverlap;

// :- An abstraction that allows the code dealing with decorations to
// treat multiple DecorationSet objects as if it were a single object
// with (a subset of) the same interface.
var DecorationGroup = function DecorationGroup(members) {
  this.members = members;
};

DecorationGroup.prototype.map = function map (mapping, doc) {
  var mappedDecos = this.members.map(
    function (member) { return member.map(mapping, doc, noSpec); }
  );
  return DecorationGroup.from(mappedDecos)
};

DecorationGroup.prototype.forChild = function forChild (offset, child) {
  if (child.isLeaf) { return DecorationSet.empty }
  var found = [];
  for (var i = 0; i < this.members.length; i++) {
    var result = this.members[i].forChild(offset, child);
    if (result == empty) { continue }
    if (result instanceof DecorationGroup) { found = found.concat(result.members); }
    else { found.push(result); }
  }
  return DecorationGroup.from(found)
};

DecorationGroup.prototype.eq = function eq (other) {
  if (!(other instanceof DecorationGroup) ||
      other.members.length != this.members.length) { return false }
  for (var i = 0; i < this.members.length; i++)
    { if (!this.members[i].eq(other.members[i])) { return false } }
  return true
};

DecorationGroup.prototype.locals = function locals (node) {
  var result, sorted = true;
  for (var i = 0; i < this.members.length; i++) {
    var locals = this.members[i].localsInner(node);
    if (!locals.length) { continue }
    if (!result) {
      result = locals;
    } else {
      if (sorted) {
        result = result.slice();
        sorted = false;
      }
      for (var j = 0; j < locals.length; j++) { result.push(locals[j]); }
    }
  }
  return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none
};

// : ([DecorationSet]) → union<DecorationSet, DecorationGroup>
// Create a group for the given array of decoration sets, or return
// a single set when possible.
DecorationGroup.from = function from (members) {
  switch (members.length) {
    case 0: return empty
    case 1: return members[0]
    default: return new DecorationGroup(members)
  }
};

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  // Mark the children that are directly touched by changes, and
  // move those that are after the changes.
  var shift = function (oldStart, oldEnd, newStart, newEnd) {
    for (var i = 0; i < children.length; i += 3) {
      var end = children[i + 1], dSize = (void 0);
      if (end < 0 || oldStart > end + oldOffset) { continue }
      var start = children[i] + oldOffset;
      if (oldEnd >= start) {
        children[i + 1] = oldStart <= start ? -2 : -1;
      } else if (newStart >= offset && (dSize = (newEnd - newStart) - (oldEnd - oldStart))) {
        children[i] += dSize;
        children[i + 1] += dSize;
      }
    }
  };
  for (var i = 0; i < mapping.maps.length; i++) { mapping.maps[i].forEach(shift); }

  // Find the child nodes that still correspond to a single node,
  // recursively call mapInner on them and update their positions.
  var mustRebuild = false;
  for (var i$1 = 0; i$1 < children.length; i$1 += 3) { if (children[i$1 + 1] < 0) { // Touched nodes
    if (children[i$1 + 1] == -2) {
      mustRebuild = true;
      children[i$1 + 1] = -1;
      continue
    }
    var from = mapping.map(oldChildren[i$1] + oldOffset), fromLocal = from - offset;
    if (fromLocal < 0 || fromLocal >= node.content.size) {
      mustRebuild = true;
      continue
    }
    // Must read oldChildren because children was tagged with -1
    var to = mapping.map(oldChildren[i$1 + 1] + oldOffset, -1), toLocal = to - offset;
    var ref = node.content.findIndex(fromLocal);
    var index = ref.index;
    var childOffset = ref.offset;
    var childNode = node.maybeChild(index);
    if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
      var mapped = children[i$1 + 2].mapInner(mapping, childNode, from + 1, oldChildren[i$1] + oldOffset + 1, options);
      if (mapped != empty) {
        children[i$1] = fromLocal;
        children[i$1 + 1] = toLocal;
        children[i$1 + 2] = mapped;
      } else {
        children[i$1 + 1] = -2;
        mustRebuild = true;
      }
    } else {
      mustRebuild = true;
    }
  } }

  // Remaining children must be collected and rebuilt into the appropriate structure
  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal || [], mapping,
                                                       offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (var i$2 = 0; i$2 < children.length; i$2 += 3) { if (children[i$2 + 1] < 0) {
      children.splice(i$2, 3);
      i$2 -= 3;
    } }
    for (var i$3 = 0, j = 0; i$3 < built.children.length; i$3 += 3) {
      var from$1 = built.children[i$3];
      while (j < children.length && children[j] < from$1) { j += 3; }
      children.splice(j, 0, built.children[i$3], built.children[i$3 + 1], built.children[i$3 + 2]);
    }
  }

  return new DecorationSet(newLocal && newLocal.sort(byPos), children)
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) { return spans }
  var result = [];
  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }
  return result
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  // Gather all decorations from the remaining marked children
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) { decorations.push(mapped); }
      else if (options.onRemove) { options.onRemove(set.local[i].spec); }
    }
    for (var i$1 = 0; i$1 < set.children.length; i$1 += 3)
      { gather(set.children[i$1 + 2], set.children[i$1] + oldOffset + 1); }
  }
  for (var i = 0; i < children.length; i += 3) { if (children[i + 1] == -1)
    { gather(children[i + 2], oldChildren[i] + oldOffset + 1); } }

  return decorations
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) { return null }
  var end = offset + node.nodeSize, found = null;
  for (var i = 0, span = (void 0); i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
(found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found
}

function withoutNulls(array) {
  var result = [];
  for (var i = 0; i < array.length; i++)
    { if (array[i] != null) { result.push(array[i]); } }
  return result
}

// : ([Decoration], Node, number) → DecorationSet
// Build up a tree that corresponds to a set of decorations. `offset`
// is a base offset that should be subtracted from the `from` and `to`
// positions in the spans (so that we don't have to allocate new spans
// for recursive calls).
function buildTree(spans, node, offset, options) {
  var children = [], hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);
    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty)
        { children.push(localStart, localStart + childNode.nodeSize, subtree); }
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);
  for (var i = 0; i < locals.length; i++) { if (!locals[i].type.valid(node, locals[i])) {
    if (options.onRemove) { options.onRemove(locals[i].spec); }
    locals.splice(i--, 1);
  } }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty
}

// : (Decoration, Decoration) → number
// Used to sort decorations so that ones with a low start position
// come first, and within a set with the same start position, those
// with an smaller end position come first.
function byPos(a, b) {
  return a.from - b.from || a.to - b.to
}

// : ([Decoration]) → [Decoration]
// Scan a sorted array of decorations for partially overlapping spans,
// and split those so that only fully overlapping spans are left (to
// make subsequent rendering easier). Will return the input array if
// no partially overlapping spans are found (the common case).
function removeOverlap(spans) {
  var working = spans;
  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) { for (var j = i + 1; j < working.length; j++) {
      var next = working[j];
      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) { working = spans.slice(); }
          // Followed by a partially overlapping larger span. Split that
          // span.
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }
        continue
      } else {
        if (next.from < span.to) {
          if (working == spans) { working = spans.slice(); }
          // The end of this one overlaps with a subsequent span. Split
          // this one.
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }
        break
      }
    } }
  }
  return working
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) { i++; }
  array.splice(i, 0, deco);
}

// : (EditorView) → union<DecorationSet, DecorationGroup>
// Get the decorations associated with the current props of a view.
function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) { found.push(result); }
  });
  if (view.cursorWrapper)
    { found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco])); }
  return DecorationGroup.from(found)
}

// ::- An editor view manages the DOM structure that represents an
// editable document. Its state and behavior are determined by its
// [props](#view.DirectEditorProps).
var EditorView = function EditorView(place, props) {
  this._props = props;
  // :: EditorState
  // The view's current [state](#state.EditorState).
  this.state = props.state;

  this.directPlugins = props.plugins || [];
  this.directPlugins.forEach(checkStateComponent);

  this.dispatch = this.dispatch.bind(this);

  this._root = null;
  this.focused = false;
  // Kludge used to work around a Chrome bug
  this.trackWrites = null;

  // :: dom.Element
  // An editable DOM node containing the document. (You probably
  // should not directly interfere with its content.)
  this.dom = (place && place.mount) || document.createElement("div");
  if (place) {
    if (place.appendChild) { place.appendChild(this.dom); }
    else if (place.apply) { place(this.dom); }
    else if (place.mount) { this.mounted = true; }
  }

  // :: bool
  // Indicates whether the editor is currently [editable](#view.EditorProps.editable).
  this.editable = getEditable(this);
  this.markCursor = null;
  this.cursorWrapper = null;
  updateCursorWrapper(this);
  this.nodeViews = buildNodeViews(this);
  this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);

  this.lastSelectedViewDesc = null;
  // :: ?{slice: Slice, move: bool}
  // When editor content is being dragged, this object contains
  // information about the dragged slice and whether it is being
  // copied or moved. At any other time, it is null.
  this.dragging = null;

  initInput(this);

  this.prevDirectPlugins = [];
  this.pluginViews = [];
  this.updatePluginViews();
};

var prototypeAccessors$2 = { props: { configurable: true },root: { configurable: true },isDestroyed: { configurable: true } };

// composing:: boolean
// Holds `true` when a
// [composition](https://w3c.github.io/uievents/#events-compositionevents)
// is active.

// :: DirectEditorProps
// The view's current [props](#view.EditorProps).
prototypeAccessors$2.props.get = function () {
  if (this._props.state != this.state) {
    var prev = this._props;
    this._props = {};
    for (var name in prev) { this._props[name] = prev[name]; }
    this._props.state = this.state;
  }
  return this._props
};

// :: (DirectEditorProps)
// Update the view's props. Will immediately cause an update to
// the DOM.
EditorView.prototype.update = function update (props) {
  if (props.handleDOMEvents != this._props.handleDOMEvents) { ensureListeners(this); }
  this._props = props;
  if (props.plugins) {
    props.plugins.forEach(checkStateComponent);
    this.directPlugins = props.plugins;
  }
  this.updateStateInner(props.state, true);
};

// :: (DirectEditorProps)
// Update the view by updating existing props object with the object
// given as argument. Equivalent to `view.update(Object.assign({},
// view.props, props))`.
EditorView.prototype.setProps = function setProps (props) {
  var updated = {};
  for (var name in this._props) { updated[name] = this._props[name]; }
  updated.state = this.state;
  for (var name$1 in props) { updated[name$1] = props[name$1]; }
  this.update(updated);
};

// :: (EditorState)
// Update the editor's `state` prop, without touching any of the
// other props.
EditorView.prototype.updateState = function updateState (state) {
  this.updateStateInner(state, this.state.plugins != state.plugins);
};

EditorView.prototype.updateStateInner = function updateStateInner (state, reconfigured) {
    var this$1 = this;

  var prev = this.state, redraw = false, updateSel = false;
  // When stored marks are added, stop composition, so that they can
  // be displayed.
  if (state.storedMarks && this.composing) {
    clearComposition(this);
    updateSel = true;
  }
  this.state = state;
  if (reconfigured) {
    var nodeViews = buildNodeViews(this);
    if (changedNodeViews(nodeViews, this.nodeViews)) {
      this.nodeViews = nodeViews;
      redraw = true;
    }
    ensureListeners(this);
  }

  this.editable = getEditable(this);
  updateCursorWrapper(this);
  var innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);

  var scroll = reconfigured ? "reset"
      : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
  var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
  if (updateDoc || !state.selection.eq(prev.selection)) { updateSel = true; }
  var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

  if (updateSel) {
    this.domObserver.stop();
    // Work around an issue in Chrome, IE, and Edge where changing
    // the DOM around an active selection puts it into a broken
    // state where the thing the user sees differs from the
    // selection reported by the Selection object (#710, #973,
    // #1011, #1013, #1035).
    var forceSelUpdate = updateDoc && (result.ie || result.chrome) && !this.composing &&
        !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
    if (updateDoc) {
      // If the node that the selection points into is written to,
      // Chrome sometimes starts misreporting the selection, so this
      // tracks that and forces a selection reset when our update
      // did write to the node.
      var chromeKludge = result.chrome ? (this.trackWrites = this.root.getSelection().focusNode) : null;
      if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
        this.docView.updateOuterDeco([]);
        this.docView.destroy();
        this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
      }
      if (chromeKludge && !this.trackWrites) { forceSelUpdate = true; }
    }
    // Work around for an issue where an update arriving right between
    // a DOM selection change and the "selectionchange" event for it
    // can cause a spurious DOM selection update, disrupting mouse
    // drag selection.
    if (forceSelUpdate ||
        !(this.mouseDown && this.domObserver.currentSelection.eq(this.root.getSelection()) && anchorInRightPlace(this))) {
      selectionToDOM(this, forceSelUpdate);
    } else {
      syncNodeSelection(this, state.selection);
      this.domObserver.setCurSelection();
    }
    this.domObserver.start();
  }

  this.updatePluginViews(prev);

  if (scroll == "reset") {
    this.dom.scrollTop = 0;
  } else if (scroll == "to selection") {
    var startDOM = this.root.getSelection().focusNode;
    if (this.someProp("handleScrollToSelection", function (f) { return f(this$1); }))
      ; // Handled
    else if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection)
      { scrollRectIntoView(this, this.docView.domAfterPos(state.selection.from).getBoundingClientRect(), startDOM); }
    else
      { scrollRectIntoView(this, this.coordsAtPos(state.selection.head, 1), startDOM); }
  } else if (oldScrollPos) {
    resetScrollPos(oldScrollPos);
  }
};

EditorView.prototype.destroyPluginViews = function destroyPluginViews () {
  var view;
  while (view = this.pluginViews.pop()) { if (view.destroy) { view.destroy(); } }
};

EditorView.prototype.updatePluginViews = function updatePluginViews (prevState) {
  if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
    this.prevDirectPlugins = this.directPlugins;
    this.destroyPluginViews();
    for (var i = 0; i < this.directPlugins.length; i++) {
      var plugin = this.directPlugins[i];
      if (plugin.spec.view) { this.pluginViews.push(plugin.spec.view(this)); }
    }
    for (var i$1 = 0; i$1 < this.state.plugins.length; i$1++) {
      var plugin$1 = this.state.plugins[i$1];
      if (plugin$1.spec.view) { this.pluginViews.push(plugin$1.spec.view(this)); }
    }
  } else {
    for (var i$2 = 0; i$2 < this.pluginViews.length; i$2++) {
      var pluginView = this.pluginViews[i$2];
      if (pluginView.update) { pluginView.update(this, prevState); }
    }
  }
};

// :: (string, ?(prop: *) → *) → *
// Goes over the values of a prop, first those provided directly,
// then those from plugins given to the view, then from plugins in
// the state (in order), and calls `f` every time a non-undefined
// value is found. When `f` returns a truthy value, that is
// immediately returned. When `f` isn't provided, it is treated as
// the identity function (the prop value is returned directly).
EditorView.prototype.someProp = function someProp (propName, f) {
  var prop = this._props && this._props[propName], value;
  if (prop != null && (value = f ? f(prop) : prop)) { return value }
  for (var i = 0; i < this.directPlugins.length; i++) {
    var prop$1 = this.directPlugins[i].props[propName];
    if (prop$1 != null && (value = f ? f(prop$1) : prop$1)) { return value }
  }
  var plugins = this.state.plugins;
  if (plugins) { for (var i$1 = 0; i$1 < plugins.length; i$1++) {
    var prop$2 = plugins[i$1].props[propName];
    if (prop$2 != null && (value = f ? f(prop$2) : prop$2)) { return value }
  } }
};

// :: () → bool
// Query whether the view has focus.
EditorView.prototype.hasFocus = function hasFocus () {
  return this.root.activeElement == this.dom
};

// :: ()
// Focus the editor.
EditorView.prototype.focus = function focus () {
  this.domObserver.stop();
  if (this.editable) { focusPreventScroll(this.dom); }
  selectionToDOM(this);
  this.domObserver.start();
};

// :: union<dom.Document, dom.DocumentFragment>
// Get the document root in which the editor exists. This will
// usually be the top-level `document`, but might be a [shadow
// DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
// root if the editor is inside one.
prototypeAccessors$2.root.get = function () {
  var cached = this._root;
  if (cached == null) { for (var search = this.dom.parentNode; search; search = search.parentNode) {
    if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {
      if (!search.getSelection) { Object.getPrototypeOf(search).getSelection = function () { return document.getSelection(); }; }
      return this._root = search
    }
  } }
  return cached || document
};

// :: ({left: number, top: number}) → ?{pos: number, inside: number}
// Given a pair of viewport coordinates, return the document
// position that corresponds to them. May return null if the given
// coordinates aren't inside of the editor. When an object is
// returned, its `pos` property is the position nearest to the
// coordinates, and its `inside` property holds the position of the
// inner node that the position falls inside of, or -1 if it is at
// the top level, not in any node.
EditorView.prototype.posAtCoords = function posAtCoords$1 (coords) {
  return posAtCoords(this, coords)
};

// :: (number, number) → {left: number, right: number, top: number, bottom: number}
// Returns the viewport rectangle at a given document position.
// `left` and `right` will be the same number, as this returns a
// flat cursor-ish rectangle. If the position is between two things
// that aren't directly adjacent, `side` determines which element is
// used. When < 0, the element before the position is used,
// otherwise the element after.
EditorView.prototype.coordsAtPos = function coordsAtPos$1 (pos, side) {
    if ( side === void 0 ) side = 1;

  return coordsAtPos(this, pos, side)
};

// :: (number, number) → {node: dom.Node, offset: number}
// Find the DOM position that corresponds to the given document
// position. When `side` is negative, find the position as close as
// possible to the content before the position. When positive,
// prefer positions close to the content after the position. When
// zero, prefer as shallow a position as possible.
//
// Note that you should **not** mutate the editor's internal DOM,
// only inspect it (and even that is usually not necessary).
EditorView.prototype.domAtPos = function domAtPos (pos, side) {
    if ( side === void 0 ) side = 0;

  return this.docView.domFromPos(pos, side)
};

// :: (number) → ?dom.Node
// Find the DOM node that represents the document node after the
// given position. May return `null` when the position doesn't point
// in front of a node or if the node is inside an opaque node view.
//
// This is intended to be able to call things like
// `getBoundingClientRect` on that DOM node. Do **not** mutate the
// editor DOM directly, or add styling this way, since that will be
// immediately overriden by the editor as it redraws the node.
EditorView.prototype.nodeDOM = function nodeDOM (pos) {
  var desc = this.docView.descAt(pos);
  return desc ? desc.nodeDOM : null
};

// :: (dom.Node, number, ?number) → number
// Find the document position that corresponds to a given DOM
// position. (Whenever possible, it is preferable to inspect the
// document structure directly, rather than poking around in the
// DOM, but sometimes—for example when interpreting an event
// target—you don't have a choice.)
//
// The `bias` parameter can be used to influence which side of a DOM
// node to use when the position is inside a leaf node.
EditorView.prototype.posAtDOM = function posAtDOM (node, offset, bias) {
    if ( bias === void 0 ) bias = -1;

  var pos = this.docView.posFromDOM(node, offset, bias);
  if (pos == null) { throw new RangeError("DOM position not inside the editor") }
  return pos
};

// :: (union<"up", "down", "left", "right", "forward", "backward">, ?EditorState) → bool
// Find out whether the selection is at the end of a textblock when
// moving in a given direction. When, for example, given `"left"`,
// it will return true if moving left from the current cursor
// position would leave that position's parent textblock. Will apply
// to the view's current state by default, but it is possible to
// pass a different state.
EditorView.prototype.endOfTextblock = function endOfTextblock$1 (dir, state) {
  return endOfTextblock(this, state || this.state, dir)
};

// :: ()
// Removes the editor from the DOM and destroys all [node
// views](#view.NodeView).
EditorView.prototype.destroy = function destroy () {
  if (!this.docView) { return }
  destroyInput(this);
  this.destroyPluginViews();
  if (this.mounted) {
    this.docView.update(this.state.doc, [], viewDecorations(this), this);
    this.dom.textContent = "";
  } else if (this.dom.parentNode) {
    this.dom.parentNode.removeChild(this.dom);
  }
  this.docView.destroy();
  this.docView = null;
};

// :: boolean
// This is true when the view has been
// [destroyed](#view.EditorView.destroy) (and thus should not be
// used anymore).
prototypeAccessors$2.isDestroyed.get = function () {
  return this.docView == null
};

// Used for testing.
EditorView.prototype.dispatchEvent = function dispatchEvent$1 (event) {
  return dispatchEvent(this, event)
};

// :: (Transaction)
// Dispatch a transaction. Will call
// [`dispatchTransaction`](#view.DirectEditorProps.dispatchTransaction)
// when given, and otherwise defaults to applying the transaction to
// the current state and calling
// [`updateState`](#view.EditorView.updateState) with the result.
// This method is bound to the view instance, so that it can be
// easily passed around.
EditorView.prototype.dispatch = function dispatch (tr) {
  var dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction) { dispatchTransaction.call(this, tr); }
  else { this.updateState(this.state.apply(tr)); }
};

Object.defineProperties( EditorView.prototype, prototypeAccessors$2 );

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  attrs.translate = "no";

  view.someProp("attributes", function (value) {
    if (typeof value == "function") { value = value(view.state); }
    if (value) { for (var attr in value) {
      if (attr == "class")
        { attrs.class += " " + value[attr]; }
      if (attr == "style") {
        attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
      }
      else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
        { attrs[attr] = String(value[attr]); }
    } }
  });

  return [Decoration.node(0, view.state.doc.content.size, attrs)]
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = {dom: dom, deco: Decoration.widget(view.state.selection.head, dom, {raw: true, marks: view.markCursor})};
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) { return value(view.state) === false; })
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth)
}

function buildNodeViews(view) {
  var result = {};
  view.someProp("nodeViews", function (obj) {
    for (var prop in obj) { if (!Object.prototype.hasOwnProperty.call(result, prop))
      { result[prop] = obj[prop]; } }
  });
  return result
}

function changedNodeViews(a, b) {
  var nA = 0, nB = 0;
  for (var prop in a) {
    if (a[prop] != b[prop]) { return true }
    nA++;
  }
  for (var _ in b) { nB++; }
  return nA != nB
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    { throw new RangeError("Plugins passed directly to the view must not have a state component") }
}

// EditorProps:: interface
//
// Props are configuration values that can be passed to an editor view
// or included in a plugin. This interface lists the supported props.
//
// The various event-handling functions may all return `true` to
// indicate that they handled the given event. The view will then take
// care to call `preventDefault` on the event, except with
// `handleDOMEvents`, where the handler itself is responsible for that.
//
// How a prop is resolved depends on the prop. Handler functions are
// called one at a time, starting with the base props and then
// searching through the plugins (in order of appearance) until one of
// them returns true. For some props, the first plugin that yields a
// value gets precedence.
//
//   handleDOMEvents:: ?Object<(view: EditorView, event: dom.Event) → bool>
//   Can be an object mapping DOM event type names to functions that
//   handle them. Such functions will be called before any handling
//   ProseMirror does of events fired on the editable DOM element.
//   Contrary to the other event handling props, when returning true
//   from such a function, you are responsible for calling
//   `preventDefault` yourself (or not, if you want to allow the
//   default behavior).
//
//   handleKeyDown:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Called when the editor receives a `keydown` event.
//
//   handleKeyPress:: ?(view: EditorView, event: dom.KeyboardEvent) → bool
//   Handler for `keypress` events.
//
//   handleTextInput:: ?(view: EditorView, from: number, to: number, text: string) → bool
//   Whenever the user directly input text, this handler is called
//   before the input is applied. If it returns `true`, the default
//   behavior of actually inserting the text is suppressed.
//
//   handleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a click, from the inside out. The
//   `direct` flag will be true for the inner node.
//
//   handleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is clicked, after `handleClickOn` handlers
//   have been called.
//
//   handleDoubleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a double click.
//
//   handleDoubleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is double-clicked, after `handleDoubleClickOn`.
//
//   handleTripleClickOn:: ?(view: EditorView, pos: number, node: Node, nodePos: number, event: dom.MouseEvent, direct: bool) → bool
//   Called for each node around a triple click.
//
//   handleTripleClick:: ?(view: EditorView, pos: number, event: dom.MouseEvent) → bool
//   Called when the editor is triple-clicked, after `handleTripleClickOn`.
//
//   handlePaste:: ?(view: EditorView, event: dom.ClipboardEvent, slice: Slice) → bool
//   Can be used to override the behavior of pasting. `slice` is the
//   pasted content parsed by the editor, but you can directly access
//   the event to get at the raw content.
//
//   handleDrop:: ?(view: EditorView, event: dom.Event, slice: Slice, moved: bool) → bool
//   Called when something is dropped on the editor. `moved` will be
//   true if this drop moves from the current selection (which should
//   thus be deleted).
//
//   handleScrollToSelection:: ?(view: EditorView) → bool
//   Called when the view, after updating its state, tries to scroll
//   the selection into view. A handler function may return false to
//   indicate that it did not handle the scrolling and further
//   handlers or the default behavior should be tried.
//
//   createSelectionBetween:: ?(view: EditorView, anchor: ResolvedPos, head: ResolvedPos) → ?Selection
//   Can be used to override the way a selection is created when
//   reading a DOM selection between the given anchor and head.
//
//   domParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading editor changes
//   from the DOM. Defaults to calling
//   [`DOMParser.fromSchema`](#model.DOMParser^fromSchema) on the
//   editor's schema.
//
//   transformPastedHTML:: ?(html: string) → string
//   Can be used to transform pasted HTML text, _before_ it is parsed,
//   for example to clean it up.
//
//   clipboardParser:: ?DOMParser
//   The [parser](#model.DOMParser) to use when reading content from
//   the clipboard. When not given, the value of the
//   [`domParser`](#view.EditorProps.domParser) prop is used.
//
//   transformPastedText:: ?(text: string, plain: bool) → string
//   Transform pasted plain text. The `plain` flag will be true when
//   the text is pasted as plain text.
//
//   clipboardTextParser:: ?(text: string, $context: ResolvedPos, plain: bool) → Slice
//   A function to parse text from the clipboard into a document
//   slice. Called after
//   [`transformPastedText`](#view.EditorProps.transformPastedText).
//   The default behavior is to split the text into lines, wrap them
//   in `<p>` tags, and call
//   [`clipboardParser`](#view.EditorProps.clipboardParser) on it.
//   The `plain` flag will be true when the text is pasted as plain text.
//
//   transformPasted:: ?(Slice) → Slice
//   Can be used to transform pasted content before it is applied to
//   the document.
//
//   nodeViews:: ?Object<(node: Node, view: EditorView, getPos: () → number, decorations: [Decoration], innerDecorations: DecorationSource) → NodeView>
//   Allows you to pass custom rendering and behavior logic for nodes
//   and marks. Should map node and mark names to constructor
//   functions that produce a [`NodeView`](#view.NodeView) object
//   implementing the node's display behavior. For nodes, the third
//   argument `getPos` is a function that can be called to get the
//   node's current position, which can be useful when creating
//   transactions to update it. For marks, the third argument is a
//   boolean that indicates whether the mark's content is inline.
//
//   `decorations` is an array of node or inline decorations that are
//   active around the node. They are automatically drawn in the
//   normal way, and you will usually just want to ignore this, but
//   they can also be used as a way to provide context information to
//   the node view without adding it to the document itself.
//
//   `innerDecorations` holds the decorations for the node's content.
//   You can safely ignore this if your view has no content or a
//   `contentDOM` property, since the editor will draw the decorations
//   on the content. But if you, for example, want to create a nested
//   editor with the content, it may make sense to provide it with the
//   inner decorations.
//
//   clipboardSerializer:: ?DOMSerializer
//   The DOM serializer to use when putting content onto the
//   clipboard. If not given, the result of
//   [`DOMSerializer.fromSchema`](#model.DOMSerializer^fromSchema)
//   will be used. This object will only have its
//   [`serializeFragment`](#model.DOMSerializer.serializeFragment)
//   method called, and you may provide an alternative object type
//   implementing a compatible method.
//
//   clipboardTextSerializer:: ?(Slice) → string
//   A function that will be called to get the text for the current
//   selection when copying text to the clipboard. By default, the
//   editor will use [`textBetween`](#model.Node.textBetween) on the
//   selected range.
//
//   decorations:: ?(state: EditorState) → ?DecorationSource
//   A set of [document decorations](#view.Decoration) to show in the
//   view.
//
//   editable:: ?(state: EditorState) → bool
//   When this returns false, the content of the view is not directly
//   editable.
//
//   attributes:: ?union<Object<string>, (EditorState) → ?Object<string>>
//   Control the DOM attributes of the editable element. May be either
//   an object or a function going from an editor state to an object.
//   By default, the element will get a class `"ProseMirror"`, and
//   will have its `contentEditable` attribute determined by the
//   [`editable` prop](#view.EditorProps.editable). Additional classes
//   provided here will be added to the class. For other attributes,
//   the value provided first (as in
//   [`someProp`](#view.EditorView.someProp)) will be used.
//
//   scrollThreshold:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the distance (in pixels) between the cursor and the
//   end of the visible viewport at which point, when scrolling the
//   cursor into view, scrolling takes place. Defaults to 0.
//
//   scrollMargin:: ?union<number, {top: number, right: number, bottom: number, left: number}>
//   Determines the extra space (in pixels) that is left above or
//   below the cursor when it is scrolled into view. Defaults to 5.

// DirectEditorProps:: interface extends EditorProps
//
// The props object given directly to the editor view supports some
// fields that can't be used in plugins:
//
//   state:: EditorState
//   The current state of the editor.
//
//   plugins:: [Plugin]
//   A set of plugins to use in the view, applying their [plugin
//   view](#state.PluginSpec.view) and
//   [props](#state.PluginSpec.props). Passing plugins with a state
//   component (a [state field](#state.PluginSpec.state) field or a
//   [transaction](#state.PluginSpec.filterTransaction) filter or
//   appender) will result in an error, since such plugins must be
//   present in the state to work.
//
//   dispatchTransaction:: ?(tr: Transaction)
//   The callback over which to send transactions (state updates)
//   produced by the view. If you specify this, you probably want to
//   make sure this ends up calling the view's
//   [`updateState`](#view.EditorView.updateState) method with a new
//   state that has the transaction
//   [applied](#state.EditorState.apply). The callback will be bound to have
//   the view instance as its `this` binding.


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 97 */
/***/ ((module) => {

"use strict";


module.exports = string => {
	if (typeof string !== 'string') {
		throw new TypeError('Expected a string');
	}

	// Escape characters with special meaning either inside or outside character sets.
	// Use a simple backslash escape when it’s always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.
	return string
		.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&')
		.replace(/-/g, '\\x2d');
};


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorState = __webpack_require__(40);
var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var _defineProperty = __webpack_require__(15);
var _classPrivateFieldSet = __webpack_require__(91);
var _classPrivateFieldGet = __webpack_require__(94);
var prosemirrorView = __webpack_require__(96);
var coreHelpers = __webpack_require__(20);
var escapeStringRegex = __webpack_require__(97);
var coreConstants = __webpack_require__(17);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var escapeStringRegex__default = /*#__PURE__*/_interopDefault(escapeStringRegex);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

/**
 * This [[`Suggester`]] interface defines all the options required to create a
 * suggestion within your editor.
 *
 * @remarks
 *
 * The options are passed to the [[`suggest`]] method which uses them.
 */

/**
 * A function for checking whether the next selection is valid.
 *
 * It is called for all registered suggesters before any of the onChange
 * handlers are fired.
 *
 * @param $pos - the next valid position that supports text selections.
 * @param tr - the transaction that can be mutated when `appendTransaction` is
 * set to true.
 * @param matches - the possibly undefined exit and change matcher names. These
 * can be used to check if the name matches the current suggester.
 */

/**
 * A function that can be used to determine whether the decoration should be set
 * or not.
 *
 * @param match - the current active match
 * @param resolvedRange - the range of the match with each position resolved.
 */

/**
 * The potential reasons for an exit of a mention.
 */
exports.ExitReason = void 0;
/**
 * The potential reason for changes
 */

(function (ExitReason) {
  ExitReason["End"] = "exit-end";
  ExitReason["Removed"] = "delete";
  ExitReason["Split"] = "exit-split";
  ExitReason["InvalidSplit"] = "invalid-exit-split";
  ExitReason["MoveEnd"] = "move-end";
  ExitReason["MoveStart"] = "move-start";
  ExitReason["JumpForward"] = "jump-forward-exit";
  ExitReason["JumpBackward"] = "jump-backward-exit";
  ExitReason["SelectionOutside"] = "selection-outside";
})(exports.ExitReason || (exports.ExitReason = {}));

exports.ChangeReason = void 0;
/**
 * The parameters needed for the [[`SuggestIgnoreProps.addIgnored`]] action
 * method available to the suggest plugin handlers.
 *
 * @remarks
 *
 * See:
 * - [[`RemoveIgnoredProps`]]
 */

(function (ChangeReason) {
  ChangeReason["Start"] = "start";
  ChangeReason["Text"] = "change-character";
  ChangeReason["SelectionInside"] = "selection-inside";
  ChangeReason["Move"] = "move";
  ChangeReason["JumpBackward"] = "jump-backward-change";
  ChangeReason["JumpForward"] = "jump-forward-change";
})(exports.ChangeReason || (exports.ChangeReason = {}));

/**
 * Is this a change in the current suggestion (added or deleted characters)?
 */

function isChange(compare) {
  return !!(compare.prev && compare.next && compare.prev.text.full !== compare.next.text.full);
}
/**
 * Has the cursor moved within the current suggestion (added or deleted
 * characters)?
 */

function isMove(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.cursor !== compare.next.range.cursor);
}
/**
 * Are we entering a new suggestion?
 */

function isEntry(compare) {
  return !!(!compare.prev && compare.next);
}
/**
 * Are we exiting a suggestion?
 */

function isExit(compare) {
  return !!(compare.prev && !compare.next);
}
/**
 * Is this a jump from one suggestion to another?
 */

function isJump(compare) {
  return !!(compare.prev && compare.next && compare.prev.range.from !== compare.next.range.from);
}
/**
 * Check that the passed in value is an [[`ExitReason`]].
 */

function isExitReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ExitReason).includes(value);
}
/**
 * Check that that the passed in value is a [[`ChangeReason`]].
 */

function isChangeReason(value) {
  return coreHelpers.isString(value) && Object.values(exports.ChangeReason).includes(value);
}
var selectionExitReasons = [exports.ExitReason.MoveEnd, exports.ExitReason.MoveStart, exports.ExitReason.SelectionOutside, exports.ExitReason.JumpForward, exports.ExitReason.JumpBackward];
/**
 * An exit which is caused by a change in the selection and no other change in
 * the document.
 */

function isSelectionExitReason(value) {
  return coreHelpers.includes(selectionExitReasons, value);
}
var selectionChangeReasons = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward, exports.ChangeReason.Move, exports.ChangeReason.SelectionInside];
function isSelectionChangeReason(value) {
  return coreHelpers.includes(selectionChangeReasons, value);
}
/**
 * Checks that the reason passed is a split reason. This typically means that we
 * should default to a partial update / creation of the mention.
 */

function isSplitReason(value) {
  return value === exports.ExitReason.Split;
}
/**
 * Checks that the reason was caused by a split at a point where there is no
 * query.
 */

function isInvalidSplitReason(value) {
  return value === exports.ExitReason.InvalidSplit;
}
/**
 * Checks that the reason was caused by a deletion.
 */

function isRemovedReason(value) {
  return value === exports.ExitReason.Removed;
} // Constants for the jump reasons

var exitJump = [exports.ExitReason.JumpBackward, exports.ExitReason.JumpForward];
var changeJump = [exports.ChangeReason.JumpBackward, exports.ChangeReason.JumpForward];
/**
 * Checks to see if this is a jump reason.
 */

function isJumpReason(map) {
  var _map$exit, _map$change;

  return coreHelpers.includes(exitJump, (_map$exit = map.exit) === null || _map$exit === void 0 ? void 0 : _map$exit.exitReason) || coreHelpers.includes(changeJump, (_map$change = map.change) === null || _map$change === void 0 ? void 0 : _map$change.changeReason);
}
/**
 * True when the match is currently active (i.e. it's query has a value)
 */

function isValidMatch(match) {
  return !!(match && match.query.full.length >= match.suggester.matchOffset);
}
/**
 * True when the current selection is outside the match.
 */

function selectionOutsideMatch(props) {
  var match = props.match,
      selection = props.selection;
  return !!match && (selection.from < match.range.from || selection.from > match.range.to);
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof prosemirrorState.TextSelection;
}

/**
 * Small utility method for creating a match with the reason property available.
 */
function createMatchWithReason(props) {
  var match = props.match,
      changeReason = props.changeReason,
      exitReason = props.exitReason;
  return _objectSpread(_objectSpread({}, match), {}, {
    changeReason,
    exitReason
  });
}

/**
 * Checks to see if the text before the matching character is a valid prefix.
 *
 * @param prefix - the prefix to test
 * @param options - see [[`IsPrefixValidOptions`]]
 */
function isPrefixValid(prefix, options) {
  var invalidPrefixCharacters = options.invalidPrefixCharacters,
      validPrefixCharacters = options.validPrefixCharacters; // Will ignore the empty string intentionally.

  if (invalidPrefixCharacters) {
    var regex = new RegExp(regexToString(invalidPrefixCharacters));
    return !regex.test(prefix);
  }

  {
    var _regex = new RegExp(regexToString(validPrefixCharacters));

    return _regex.test(prefix);
  }
}
/**
 * Find the position of a mention for a given selection and character
 *
 * @param props - see [[`FindPositionProps`]]
 */


function findPosition(props) {
  var text = props.text,
      regexp = props.regexp,
      $pos = props.$pos,
      suggester = props.suggester; // The starting position for matches

  var start = $pos.start();
  var position;
  coreHelpers.findMatches(text, regexp).forEach(match => {
    // Check the character before the current match to ensure it is not one of
    // the supported characters
    var matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);

    if (isPrefixValid(matchPrefix, suggester)) {
      // The absolute position of the matching parent node
      var from = match.index + start; // The full match of the created regex.

      var fullMatch = match[0]; // The matching text for the `char` regex or string is always captured as
      // the first matching group.

      var charMatch = match[1];

      if (!coreHelpers.isString(fullMatch) || !coreHelpers.isString(charMatch)) {
        return;
      } // The position where the match ends


      var to = from + fullMatch.length; // The cursor position (or end position whichever is greater)

      var cursor = Math.min(to, $pos.pos); // The length of the current match

      var matchLength = cursor - from; // If the $position is located within the matched substring, return that
      // range.

      if (from < $pos.pos && to >= $pos.pos) {
        position = {
          range: {
            from,
            to,
            cursor
          },
          match,
          query: {
            partial: fullMatch.slice(charMatch.length, matchLength),
            full: fullMatch.slice(charMatch.length)
          },
          text: {
            partial: fullMatch.slice(0, matchLength),
            full: fullMatch
          },
          textAfter: $pos.doc.textBetween(to, $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          textBefore: $pos.doc.textBetween(start, from, coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER),
          suggester
        };
      }
    }
  });
  return position;
}

/**
 * Checks if any matches exist at the current selection so that the suggesters
 * can be activated or deactivated.
 */
function findMatch(props) {
  var $pos = props.$pos,
      suggester = props.suggester;
  var char = suggester.char,
      name = suggester.name,
      startOfLine = suggester.startOfLine,
      supportedCharacters = suggester.supportedCharacters,
      matchOffset = suggester.matchOffset,
      multiline = suggester.multiline,
      caseInsensitive = suggester.caseInsensitive,
      unicode = suggester.unicode; // Create the regular expression to match the text against

  var regexp = createRegexFromSuggester({
    char,
    matchOffset,
    startOfLine,
    supportedCharacters,
    multiline,
    caseInsensitive,
    unicode
  }); // All the text in the current node

  var text = $pos.doc.textBetween($pos.before(), $pos.end(), coreConstants.NULL_CHARACTER, coreConstants.NULL_CHARACTER); // Find the position and return it

  return findPosition({
    suggester,
    text,
    regexp,
    $pos,
    char,
    name
  });
}

/**
 * Checks the provided match and generates a new match. This is useful for
 * determining the kind of change that has happened.
 *
 * If the match still exists and it is different then it's likely a split has
 * occurred.
 */
function recheckMatch(props) {
  var state = props.state,
      match = props.match;

  try {
    // Wrapped in try/catch because it's possible for everything to be deleted
    // and the doc.resolve will fail.
    return findMatch({
      $pos: state.doc.resolve(match.range.cursor),
      suggester: match.suggester
    });
  } catch (_unused) {
    return;
  }
}

/**
 * Check whether the insert action occurred at the end, in the middle or caused
 * the suggestion to be invalid.
 *
 * Prev refers to the original previous and next refers to the updated version
 * after the split
 */
function createInsertReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state; // Has the text been removed? TODO how to tests for deletions mid document?

  if (!next && prev.range.from >= state.doc.nodeSize) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.Removed
      })
    };
  } // Are we within an invalid split?


  if (!next || !prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.InvalidSplit
      })
    };
  } // Are we at the end position?


  if (prev.range.to === next.range.cursor) {
    // It seems that this never gets called. Revisit the logic and check whether
    // it's even necessary.
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.End
      })
    };
  } // Are we in the middle of the mention


  if (prev.query.partial) {
    return {
      exit: createMatchWithReason({
        match: next,
        exitReason: exports.ExitReason.Split
      })
    };
  }

  return {};
}

/**
 * Find the reason for the Jump between two suggesters.
 */
function findJumpReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state;
  var value = coreHelpers.object();
  var updatedPrevious = recheckMatch({
    state,
    match: prev
  });

  var _ref = updatedPrevious && updatedPrevious.query.full !== prev.query.full // has query changed
  ? createInsertReason({
    prev,
    next: updatedPrevious,
    state
  }) : value,
      exit = _ref.exit;

  var isJumpForward = prev.range.from < next.range.from;

  if (isJumpForward) {
    return {
      exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
        match: prev,
        exitReason: exports.ExitReason.JumpForward
      }),
      change: createMatchWithReason({
        match: next,
        changeReason: exports.ChangeReason.JumpForward
      })
    };
  }

  return {
    exit: exit !== null && exit !== void 0 ? exit : createMatchWithReason({
      match: prev,
      exitReason: exports.ExitReason.JumpBackward
    }),
    change: createMatchWithReason({
      match: next,
      changeReason: exports.ChangeReason.JumpBackward
    })
  };
}

/**
 * Find the reason for the exit.
 *
 * This provides some context and helps sets up a helper command with sane
 * defaults.
 */
function findExitReason(props) {
  var match = props.match,
      state = props.state,
      $pos = props.$pos;
  var selection = state.selection;
  var updatedPrevious = recheckMatch({
    match,
    state
  }); // Exit created a split

  if (!updatedPrevious || updatedPrevious.text.full !== match.text.full) {
    return createInsertReason({
      prev: match,
      next: updatedPrevious,
      state
    });
  } // Exit caused by a selection


  if (!selection.empty && (selection.from <= match.range.from || selection.to >= match.range.to)) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.SelectionOutside
      })
    };
  } // Exit happened at the end of previous suggestion


  if ($pos.pos > match.range.to) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveEnd
      })
    };
  } // Exit happened at the start of previous suggestion


  if ($pos.pos <= match.range.from) {
    return {
      exit: createMatchWithReason({
        match,
        exitReason: exports.ExitReason.MoveStart
      })
    };
  }

  return {};
}

/**
 * Creates an array of the actions taken based on the current prev and next
 * state field
 */
function findReason(props) {
  var prev = props.prev,
      next = props.next,
      state = props.state,
      $pos = props.$pos;
  var value = coreHelpers.object();

  if (!prev && !next) {
    return value;
  }

  var compare = {
    prev,
    next
  }; // Check for a Jump

  if (isJump(compare)) {
    return findJumpReason({
      prev: compare.prev,
      next: compare.next,
      state
    });
  } // Entered into a new suggestion


  if (isEntry(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Start
      })
    };
  } // Exited a suggestion


  if (isExit(compare)) {
    return findExitReason({
      $pos,
      match: compare.prev,
      state
    });
  }

  if (isChange(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: exports.ChangeReason.Text
      })
    };
  }

  if (isMove(compare)) {
    return {
      change: createMatchWithReason({
        match: compare.next,
        changeReason: state.selection.empty ? exports.ChangeReason.Move : exports.ChangeReason.SelectionInside
      })
    };
  }

  return value;
}
/**
 * Check to see if the current $pos has a parent node matching the type.
 */

function hasParentNode($pos, types) {
  for (var depth = $pos.depth; depth > 0; depth--) {
    var node = $pos.node(depth);

    if (types.includes(node.type.name)) {
      return true;
    }
  }

  return false;
}
/**
 * Check whether the mark is active anywhere between `$from` and `$end`.
 *
 * Currently this is not doing exactly what it should. I've decided to be lazy
 * and only check the following.
 *
 * - Do any of the requested marks span the entire range using `rangeHasMarks`?
 * - Does the starting position have a mark?
 * - Does the cursor have a mark?
 * - Does the end position have a mark?
 *
 * In reality I should also check for each position within the range to see if a
 * target mark is active but I won't for now.
 */


function markActiveInRange(resolvedRange, marks) {
  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Check if there is a mark spanning the range of marks.

  if (rangeHasMarks(resolvedRange, marks)) {
    return true;
  } // Check if any of the positions in the available range have the active mark
  // associated with


  return coreHelpers.range($from.pos, $to.pos).some(value => positionHasMarks($from.doc.resolve(value), marks));
}
/**
 * Check if the entire matching range `from` the start point all the way through
 * `to` the end point, has any of the provided marks that span it.
 */

function rangeHasMarks(resolvedRange, marks) {
  var _$from$marksAcross;

  var $from = resolvedRange.$from,
      $to = resolvedRange.$to; // Get the set of marks which span across the whole range.

  var setOfMarks = new Set(((_$from$marksAcross = $from.marksAcross($to)) !== null && _$from$marksAcross !== void 0 ? _$from$marksAcross : []).map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Check if the provided position has the given marks.
 */

function positionHasMarks($pos, marks) {
  // Get the set of marks for the current `$pos` which is used to check firstly
  // whether the set of marks is valid, and secondly whether the set of marks
  // includes any invalid marks.
  var setOfMarks = new Set($pos.marks().map(mark => mark.type.name));
  return marks.some(item => setOfMarks.has(item));
}
/**
 * Checks if the suggester is in an invalid position.
 */

function isPositionValidForSuggester(suggester, resolvedRange) {
  var $cursor = resolvedRange.$cursor;
  var validMarks = suggester.validMarks,
      validNodes = suggester.validNodes,
      invalidMarks = suggester.invalidMarks,
      invalidNodes = suggester.invalidNodes; // Break early in the default case.

  if (!validMarks && !validNodes && coreHelpers.isEmptyArray(invalidMarks) && coreHelpers.isEmptyArray(invalidNodes)) {
    return true;
  }

  if (validMarks && !rangeHasMarks(resolvedRange, validMarks)) {
    return false;
  }

  if (validNodes && !hasParentNode($cursor, validNodes)) {
    return false;
  }

  if (!validMarks && markActiveInRange(resolvedRange, invalidMarks)) {
    return false;
  }

  if (!validNodes && hasParentNode($cursor, invalidNodes)) {
    return false;
  }

  return true;
}
/**
 * Find a match for the provided matchers.
 */


function findFromSuggesters(props) {
  var suggesters = props.suggesters,
      $pos = props.$pos,
      selectionEmpty = props.selectionEmpty; // Find the first match and break when done

  var _iterator = _createForOfIteratorHelper(suggesters),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var suggester = _step.value;

      // Make sure the selection is valid for this `suggester`.
      if (suggester.emptySelectionsOnly && !selectionEmpty) {
        continue;
      }

      try {
        var match = findMatch({
          suggester,
          $pos
        });

        if (!match) {
          continue;
        } // The resolved positions where `to` represents the cursor position.


        var resolvedRange = {
          $from: $pos.doc.resolve(match.range.from),
          $to: $pos.doc.resolve(match.range.to),
          $cursor: $pos
        };

        if (isPositionValidForSuggester(suggester, resolvedRange) && suggester.isValidPosition(resolvedRange, match)) {
          return match;
        } // Break early and return the match which was found.

      } catch (_unused2) {// Captures any errors which can pop up when all the content in the editor
        // is deleted or an invalid position was provided.
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return;
}
/**
 * Convert a RegExp into a string
 *
 * @param regexOrString
 */

function regexToString(regexOrString) {
  return coreHelpers.isRegExp(regexOrString) ? regexOrString.source : regexOrString;
}
/**
 * Find regex prefix when depending on whether the mention only supports the
 * start of a line or not
 *
 * @param onlyStartOfLine
 */


function getRegexPrefix(onlyStartOfLine) {
  return onlyStartOfLine ? '^' : '';
}
/**
 * Get the supported characters regex string.
 */


function getRegexSupportedCharacters(supportedCharacters, matchOffset) {
  return "(?:".concat(regexToString(supportedCharacters), "){").concat(matchOffset, ",}");
}
/**
 * Get the `char` from the `suggester` as regex.
 */


function getCharAsRegex(char) {
  return coreHelpers.isString(char) ? new RegExp(escapeStringRegex__default["default"](char)) : char;
}

/**
 * Create a regex expression which evaluate matches directly from the suggester
 * properties.
 */
function createRegexFromSuggester(props) {
  var char = props.char,
      matchOffset = props.matchOffset,
      startOfLine = props.startOfLine,
      supportedCharacters = props.supportedCharacters,
      _props$captureChar = props.captureChar,
      captureChar = _props$captureChar === void 0 ? true : _props$captureChar,
      _props$caseInsensitiv = props.caseInsensitive,
      caseInsensitive = _props$caseInsensitiv === void 0 ? false : _props$caseInsensitiv,
      _props$multiline = props.multiline,
      multiline = _props$multiline === void 0 ? false : _props$multiline,
      _props$unicode = props.unicode,
      unicode = _props$unicode === void 0 ? false : _props$unicode;
  var flags = "g".concat(multiline ? 'm' : '').concat(caseInsensitive ? 'i' : '').concat(unicode ? 'u' : '');
  var charRegex = getCharAsRegex(char).source;

  if (captureChar) {
    charRegex = "(".concat(charRegex, ")");
  }

  return new RegExp("".concat(getRegexPrefix(startOfLine)).concat(charRegex).concat(getRegexSupportedCharacters(supportedCharacters, matchOffset)), flags);
}
/**
 * The default value for the suggester.
 */

var DEFAULT_SUGGESTER = {
  appendTransaction: false,
  priority: 50,
  ignoredTag: 'span',
  matchOffset: 0,
  disableDecorations: false,
  startOfLine: false,
  suggestClassName: 'suggest',
  suggestTag: 'span',
  supportedCharacters: /\w+/,
  validPrefixCharacters: /^[\s\0]?$/,
  invalidPrefixCharacters: null,
  ignoredClassName: null,
  invalidMarks: [],
  invalidNodes: [],
  validMarks: null,
  validNodes: null,
  isValidPosition: () => true,
  checkNextValidSelection: null,
  emptySelectionsOnly: false,
  caseInsensitive: false,
  multiline: false,
  unicode: false,
  captureChar: true
};
/**
 * This can be added to the meta data of an update to let the suggestion plugin
 * know that it should ignore the update.
 */

var IGNORE_SUGGEST_META_KEY = '__ignore_prosemirror_suggest_update__';
/**
 * Takes the passed through `suggester` and adds all the missing default values.
 */

function getSuggesterWithDefaults(suggester) {
  return _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);
}

/**
 * The `prosemirror-suggest` state which manages the list of suggesters.
 */

var _docChanged = /*#__PURE__*/new WeakMap();

var _ignoreNextExit = /*#__PURE__*/new WeakMap();

var _suggesters = /*#__PURE__*/new WeakMap();

var _next = /*#__PURE__*/new WeakMap();

var _prev = /*#__PURE__*/new WeakMap();

var _handlerMatches = /*#__PURE__*/new WeakMap();

var _ignored = /*#__PURE__*/new WeakMap();

var _removed = /*#__PURE__*/new WeakMap();

var _lastChangeFromAppend = /*#__PURE__*/new WeakMap();

class SuggestState {
  /**
   * Create an instance of the SuggestState class.
   */
  static create(suggesters) {
    return new SuggestState(suggesters);
  }
  /**
   * True when the doc changed in the most recently applied transaction.
   */


  /**
   * The set of all decorations.
   */
  get decorationSet() {
    return _classPrivateFieldGet(this, _ignored);
  }
  /**
   * True when the most recent change was to remove a mention.
   *
   * @remarks
   *
   * This is needed because sometimes removing a prosemirror `Mark` has no
   * effect. Hence we need to keep track of whether it's removed and then later
   * in the apply step check that a removal has happened and reset the
   * `handlerMatches` to prevent an infinite loop.
   */


  get removed() {
    return _classPrivateFieldGet(this, _removed);
  }
  /**
   * Returns the current active suggester state field if one exists
   */


  get match() {
    return _classPrivateFieldGet(this, _next) ? _classPrivateFieldGet(this, _next) : _classPrivateFieldGet(this, _prev) && _classPrivateFieldGet(this, _handlerMatches).exit ? _classPrivateFieldGet(this, _prev) : undefined;
  }
  /**
   * Create the state for the `prosemirror-suggest` plugin.
   *
   * @remarks
   *
   * Each suggester must provide a name value which is globally unique since it
   * acts as the identifier.
   *
   * It is possible to register multiple suggesters with identical `char`
   * properties. The matched suggester is based on the specificity of the
   * `regex` and the order in which they are passed in. Earlier suggesters are
   * prioritized.
   */


  constructor(_suggesters2) {
    _classPrivateFieldInitSpec(this, _docChanged, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _ignoreNextExit, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _suggesters, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _next, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _prev, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _handlerMatches, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _ignored, {
      writable: true,
      value: prosemirrorView.DecorationSet.empty
    });

    _classPrivateFieldInitSpec(this, _removed, {
      writable: true,
      value: false
    });

    _classPrivateFieldInitSpec(this, _lastChangeFromAppend, {
      writable: true,
      value: false
    });

    _defineProperty(this, "setMarkRemoved", () => {
      _classPrivateFieldSet(this, _removed, true);
    });

    _defineProperty(this, "findNextTextSelection", selection => {
      var doc = selection.$from.doc; // Make sure the position doesn't exceed the bounds of the document.

      var pos = Math.min(doc.nodeSize - 2, selection.to + 1);
      var $pos = doc.resolve(pos); // Get the position furthest along in the editor to pass back to suggesters
      // which have the handler.

      var nextSelection = prosemirrorState.Selection.findFrom($pos, 1, true); // Ignore non-text selections and null / undefined values. This is needed
      // for TS mainly, since the `true` in the `Selection.findFrom` method means
      // only `TextSelection` instances will be returned.

      if (!isTextSelection(nextSelection)) {
        return;
      }

      return nextSelection;
    });

    _defineProperty(this, "ignoreNextExit", () => {
      _classPrivateFieldSet(this, _ignoreNextExit, true);
    });

    _defineProperty(this, "addIgnored", _ref => {
      var from = _ref.from,
          name = _ref.name,
          _ref$specific = _ref.specific,
          specific = _ref$specific === void 0 ? false : _ref$specific;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;
      var to = from + offset;
      var attributes = suggester.ignoredClassName ? {
        class: suggester.ignoredClassName
      } : {};
      var decoration = prosemirrorView.Decoration.inline(from, to, _objectSpread({
        nodeName: suggester.ignoredTag
      }, attributes), {
        name,
        specific,
        char: suggester.char
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).add(this.view.state.doc, [decoration]));
    });

    _defineProperty(this, "removeIgnored", _ref2 => {
      var from = _ref2.from,
          name = _ref2.name;

      var suggester = _classPrivateFieldGet(this, _suggesters).find(value => value.name === name);

      if (!suggester) {
        throw new Error("No suggester exists for the name provided: ".concat(name));
      }

      var offset = coreHelpers.isString(suggester.char) ? suggester.char.length : 1;

      var decoration = _classPrivateFieldGet(this, _ignored).find(from, from + offset)[0];

      if (!decoration || decoration.spec.name !== name) {
        return;
      }

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove([decoration]));
    });

    _defineProperty(this, "clearIgnored", name => {
      if (!name) {
        _classPrivateFieldSet(this, _ignored, prosemirrorView.DecorationSet.empty);

        return;
      }

      var decorations = _classPrivateFieldGet(this, _ignored).find();

      var decorationsToClear = decorations.filter(_ref3 => {
        var spec = _ref3.spec;
        return spec.name === name;
      });

      _classPrivateFieldSet(this, _ignored, _classPrivateFieldGet(this, _ignored).remove(decorationsToClear));
    });

    _defineProperty(this, "findMatchAtPosition", ($pos, name) => {
      var suggesters = name ? _classPrivateFieldGet(this, _suggesters).filter(suggester => suggester.name === name) : _classPrivateFieldGet(this, _suggesters);
      return findFromSuggesters({
        suggesters,
        $pos,
        docChanged: false,
        selectionEmpty: true
      });
    });

    _defineProperty(this, "setLastChangeFromAppend", () => {
      _classPrivateFieldSet(this, _lastChangeFromAppend, true);
    });

    var mapper = createSuggesterMapper();

    _classPrivateFieldSet(this, _suggesters, _suggesters2.map(mapper));

    _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(_classPrivateFieldGet(this, _suggesters), (a, b) => b.priority - a.priority));
  }
  /**
   * Initialize the SuggestState with a view which is stored for use later.
   */


  init(view) {
    this.view = view;
    return this;
  }
  /**
   * Sets the removed property to be true.
   *
   * This is useful when working with marks.
   */


  /**
   * Create the props which should be passed into each action handler
   */
  createProps(match) {
    var _match$suggester = match.suggester,
        name = _match$suggester.name,
        char = _match$suggester.char;
    return _objectSpread({
      view: this.view,
      addIgnored: this.addIgnored,
      clearIgnored: this.clearIgnored,
      ignoreNextExit: this.ignoreNextExit,
      setMarkRemoved: this.setMarkRemoved,
      name,
      char
    }, match);
  }
  /**
   * Check whether the exit callback is valid at this time.
   */


  shouldRunExit() {
    if (_classPrivateFieldGet(this, _ignoreNextExit)) {
      _classPrivateFieldSet(this, _ignoreNextExit, false);

      return false;
    }

    return true;
  }
  /**
   * Find the next text selection from the current selection.
   */


  /**
   * Update all the suggesters with the next valid selection. This is called
   * within the `appendTransaction` ProseMirror method before any of the change
   * handlers are called.
   *
   * @internal
   */
  updateWithNextSelection(tr) {
    // Get the position furthest along in the editor to pass back to suggesters
    // which have the handler.
    var nextSelection = this.findNextTextSelection(tr.selection);

    if (!nextSelection) {
      return;
    } // Update every suggester with a method attached.


    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _suggesters)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _classPrivateFieldGet2, _classPrivateFieldGet3, _suggester$checkNextV;

        var suggester = _step.value;
        var change = (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _handlerMatches).change) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.suggester.name;
        var exit = (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _handlerMatches).exit) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.suggester.name;
        (_suggester$checkNextV = suggester.checkNextValidSelection) === null || _suggester$checkNextV === void 0 ? void 0 : _suggester$checkNextV.call(suggester, nextSelection.$from, tr, {
          change,
          exit
        });
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Call the `onChange` handlers.
   *
   * @internal
   */


  changeHandler(tr, appendTransaction) {
    var _classPrivateFieldGet4 = _classPrivateFieldGet(this, _handlerMatches),
        change = _classPrivateFieldGet4.change,
        exit = _classPrivateFieldGet4.exit;

    var match = this.match; // Cancel update when a suggester isn't active

    if (!change && !exit || !isValidMatch(match)) {
      return;
    }

    var shouldRunExit = appendTransaction === (exit === null || exit === void 0 ? void 0 : exit.suggester.appendTransaction) && this.shouldRunExit();
    var shouldRunChange = appendTransaction === (change === null || change === void 0 ? void 0 : change.suggester.appendTransaction);

    if (!shouldRunExit && !shouldRunChange) {
      return;
    } // When a jump happens run the action that involves the position that occurs
    // later in the document. This is so that changes don't affect previous
    // positions.


    if (change && exit && isJumpReason({
      change,
      exit
    })) {
      var exitDetails = this.createProps(exit);
      var changeDetails = this.createProps(change); // Whether the jump was forwards or backwards. A forwards jump means that
      // the user was within a suggester nearer the beginning of the document,
      // before jumping forward to a point later on in the document.

      var movedForwards = exit.range.from < change.range.from;

      if (movedForwards) {
        // Subtle change to call exit first. Conceptually it happens before the
        // change so call the handler before the change handler.
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      } else {
        shouldRunExit && exit.suggester.onChange(exitDetails, tr);
        shouldRunChange && change.suggester.onChange(changeDetails, tr);
      }

      if (shouldRunExit) {
        _classPrivateFieldSet(this, _removed, false);
      }

      return;
    }

    if (change && shouldRunChange) {
      change.suggester.onChange(this.createProps(change), tr);
    }

    if (exit && shouldRunExit) {
      exit.suggester.onChange(this.createProps(exit), tr);

      _classPrivateFieldSet(this, _removed, false);

      if (isInvalidSplitReason(exit.exitReason)) {
        // When the split has made the match invalid, remove the matches before
        // the next input.
        _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());
      }
    }

    return;
  }
  /**
   * Update the current ignored decorations based on the latest changes to the
   * prosemirror document.
   */


  mapIgnoredDecorations(tr) {
    // Map over and update the ignored decorations.
    var ignored = _classPrivateFieldGet(this, _ignored).map(tr.mapping, tr.doc);

    var decorations = ignored.find(); // For suggesters with multiple characters it is possible for a `paste` or
    // any edit action within the decoration to expand the ignored section. We
    // check for that here and if the section size has changed it should be
    // marked as invalid and removed from the ignored `DecorationSet`.

    var invalid = decorations.filter(_ref4 => {
      var from = _ref4.from,
          to = _ref4.to,
          spec = _ref4.spec;
      var charLength = coreHelpers.isString(spec.char) ? spec.char.length : 1;

      if (to - from !== charLength) {
        return true;
      }

      return false;
    });

    _classPrivateFieldSet(this, _ignored, ignored.remove(invalid));
  }
  /**
   * This sets the next exit to not trigger the exit reason inside the
   * `onChange` callback.
   *
   * This can be useful when you trigger a command, that exists the suggestion
   * match and want to prevent further onChanges from occurring for the
   * currently active suggester.
   */


  /**
   * Checks whether a match should be ignored.
   *
   * TODO add logic here to decide whether to ignore a match based on the active
   * node, or mark.
   */
  shouldIgnoreMatch(_ref5) {
    var range = _ref5.range,
        name = _ref5.suggester.name;

    var decorations = _classPrivateFieldGet(this, _ignored).find();

    var shouldIgnore = decorations.some(_ref6 => {
      var spec = _ref6.spec,
          from = _ref6.from;

      if (from !== range.from) {
        return false;
      }

      return spec.specific ? spec.name === name : true;
    });
    return shouldIgnore;
  }
  /**
   * Reset the state.
   */


  resetState() {
    _classPrivateFieldSet(this, _handlerMatches, coreHelpers.object());

    _classPrivateFieldSet(this, _next, undefined);

    _classPrivateFieldSet(this, _removed, false);

    _classPrivateFieldSet(this, _lastChangeFromAppend, false);
  }
  /**
   * Update the next state value.
   */


  updateReasons(props) {
    var $pos = props.$pos,
        state = props.state;

    var docChanged = _classPrivateFieldGet(this, _docChanged);

    var suggesters = _classPrivateFieldGet(this, _suggesters);

    var selectionEmpty = state.selection.empty;
    var match = isTextSelection(state.selection) ? findFromSuggesters({
      suggesters,
      $pos,
      docChanged,
      selectionEmpty
    }) : undefined; // Track the next match if not being ignored.

    _classPrivateFieldSet(this, _next, match && this.shouldIgnoreMatch(match) ? undefined : match); // Store the matches with reasons


    _classPrivateFieldSet(this, _handlerMatches, findReason({
      next: _classPrivateFieldGet(this, _next),
      prev: _classPrivateFieldGet(this, _prev),
      state,
      $pos
    }));
  }
  /**
   * A helper method to check is a match exists for the provided suggester name
   * at the provided position.
   */


  /**
   * Add a new suggest or replace it if it already exists.
   */
  addSuggester(suggester) {
    var previous = _classPrivateFieldGet(this, _suggesters).find(item => item.name === suggester.name);

    var mapper = createSuggesterMapper();

    if (previous) {
      _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).map(item => item === previous ? mapper(suggester) : item));
    } else {
      var suggesters = [..._classPrivateFieldGet(this, _suggesters), mapper(suggester)];

      _classPrivateFieldSet(this, _suggesters, coreHelpers.sort(suggesters, (a, b) => b.priority - a.priority));
    }

    return () => this.removeSuggester(suggester.name);
  }
  /**
   * Remove a suggester if it exists.
   */


  removeSuggester(suggester) {
    var name = coreHelpers.isString(suggester) ? suggester : suggester.name;

    _classPrivateFieldSet(this, _suggesters, _classPrivateFieldGet(this, _suggesters).filter(item => item.name !== name)); // When removing a suggester make sure to clear the ignored sections.


    this.clearIgnored(name);
  }

  toJSON() {
    return this.match;
  }
  /**
   * Applies updates to the state to be used within the plugins apply method.
   *
   * @param - params
   */


  apply(props) {
    var _classPrivateFieldGet5 = _classPrivateFieldGet(this, _handlerMatches),
        exit = _classPrivateFieldGet5.exit,
        change = _classPrivateFieldGet5.change;

    if (_classPrivateFieldGet(this, _lastChangeFromAppend)) {
      _classPrivateFieldSet(this, _lastChangeFromAppend, false);

      if (!(exit !== null && exit !== void 0 && exit.suggester.appendTransaction) && !(change !== null && change !== void 0 && change.suggester.appendTransaction)) {
        return this;
      }
    }

    var tr = props.tr,
        state = props.state;
    var transactionHasChanged = tr.docChanged || tr.selectionSet;
    var shouldIgnoreUpdate = tr.getMeta(IGNORE_SUGGEST_META_KEY);

    if (shouldIgnoreUpdate || !transactionHasChanged && !_classPrivateFieldGet(this, _removed)) {
      return this;
    }

    _classPrivateFieldSet(this, _docChanged, tr.docChanged);

    this.mapIgnoredDecorations(tr); // If the previous run was an exit, reset the suggester matches.

    if (exit) {
      this.resetState();
    } // Track the previous match.


    _classPrivateFieldSet(this, _prev, _classPrivateFieldGet(this, _next)); // Match against the current selection position


    this.updateReasons({
      $pos: tr.selection.$from,
      state
    });
    return this;
  }
  /**
   * Handle the decorations which wrap the mention while it is active and not
   * yet complete.
   */


  createDecorations(state) {
    var match = this.match;

    if (!isValidMatch(match)) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var disableDecorations = match.suggester.disableDecorations;
    var shouldSkip = coreHelpers.isFunction(disableDecorations) ? disableDecorations(state, match) : disableDecorations;

    if (shouldSkip) {
      return _classPrivateFieldGet(this, _ignored);
    }

    var range = match.range,
        suggester = match.suggester;
    var name = suggester.name,
        suggestTag = suggester.suggestTag,
        suggestClassName = suggester.suggestClassName;
    var from = range.from,
        to = range.to;
    return this.shouldIgnoreMatch(match) ? _classPrivateFieldGet(this, _ignored) : _classPrivateFieldGet(this, _ignored).add(state.doc, [prosemirrorView.Decoration.inline(from, to, {
      nodeName: suggestTag,
      class: name ? "".concat(suggestClassName, " suggest-").concat(name) : suggestClassName
    }, {
      name
    })]);
  }
  /**
   * Set that the last change was caused by an appended transaction.
   *
   * @internal
   */


}

/**
 * Map over the suggesters provided and make sure they have all the required
 * properties.
 */
function createSuggesterMapper() {
  var names = new Set();
  return suggester => {
    if (names.has(suggester.name)) {
      throw new Error("A suggester already exists with the name '".concat(suggester.name, "'. The name provided must be unique."));
    } // Attach the defaults to the passed in suggester.


    var suggesterWithDefaults = _objectSpread(_objectSpread({}, DEFAULT_SUGGESTER), suggester);

    names.add(suggester.name);
    return suggesterWithDefaults;
  };
}
/**
 * This key is stored to provide access to the plugin state.
 */


var suggestPluginKey = new prosemirrorState.PluginKey('suggest');

/**
 * Get the state of the suggest plugin.
 *
 * @param state - the editor state.
 */

function getSuggestPluginState(state) {
  return suggestPluginKey.getState(state);
}
/**
 * Add a new suggester or replace it if the name already exists in the existing
 * configuration.
 *
 * Will return a function for disposing of the added suggester.
 */

function addSuggester(state, suggester) {
  return getSuggestPluginState(state).addSuggester(suggester);
}
/**
 * Call this method with a transaction to skip the suggest plugin checks for the
 * next update.
 *
 * This can be used for updates that don't need to trigger a recheck of the
 * suggest state.
 */

function ignoreUpdateForSuggest(tr) {
  tr.setMeta(IGNORE_SUGGEST_META_KEY, true);
}
/**
 * Remove a suggester if it exists. Pass in the name or the full suggester
 * object.
 */

function removeSuggester(state, suggester) {
  return getSuggestPluginState(state).removeSuggester(suggester);
}
/**
 * This creates a suggest plugin with all the suggesters that you provide.
 *
 * The priority of the suggesters is the order in which they are passed into
 * this function.
 *
 * - `const plugin = suggest(two, one, three)` - Here `two` will be checked
 *   first, then `one` and then `three`.
 *
 * Only one suggester can match at any given time. The order and specificity of
 * the regex parameters help determines which suggester will be active.
 *
 * @param suggesters - a list of suggesters in the order they should be
 * evaluated.
 */

function suggest() {
  for (var _len = arguments.length, suggesters = new Array(_len), _key = 0; _key < _len; _key++) {
    suggesters[_key] = arguments[_key];
  }

  // Create the initial plugin state for the suggesters.
  var pluginState = SuggestState.create(suggesters);
  return new prosemirrorState.Plugin({
    key: suggestPluginKey,
    // Handle the plugin view
    view: _view => {
      // Initialize the state with the required view before it is used.
      pluginState.init(_view);
      return {
        update: view => {
          return pluginState.changeHandler(view.state.tr, false);
        }
      };
    },
    state: {
      // Initialize the state
      init: () => {
        return pluginState;
      },
      // Apply changes to the state
      apply: (tr, _pluginState, _oldState, state) => {
        return pluginState.apply({
          tr,
          state
        });
      }
    },

    /** Append a transaction via the onChange handlers */
    appendTransaction: (_, __, state) => {
      var tr = state.tr; // Run the transaction updater for the next selection.

      pluginState.updateWithNextSelection(tr); // Run the change handler.

      pluginState.changeHandler(tr, true); // Check if the transaction has been amended in any way.

      if (tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet) {
        pluginState.setLastChangeFromAppend();
        return tr;
      }

      return null;
    },
    props: {
      // Sets up a decoration (styling options) on the currently active
      // decoration
      decorations: state => {
        return pluginState.createDecorations(state);
      }
    }
  });
}

exports.DEFAULT_SUGGESTER = DEFAULT_SUGGESTER;
exports.IGNORE_SUGGEST_META_KEY = IGNORE_SUGGEST_META_KEY;
exports.addSuggester = addSuggester;
exports.createRegexFromSuggester = createRegexFromSuggester;
exports.findFromSuggesters = findFromSuggesters;
exports.getSuggestPluginState = getSuggestPluginState;
exports.getSuggesterWithDefaults = getSuggesterWithDefaults;
exports.ignoreUpdateForSuggest = ignoreUpdateForSuggest;
exports.isChangeReason = isChangeReason;
exports.isExitReason = isExitReason;
exports.isInvalidSplitReason = isInvalidSplitReason;
exports.isJumpReason = isJumpReason;
exports.isRemovedReason = isRemovedReason;
exports.isSelectionChangeReason = isSelectionChangeReason;
exports.isSelectionExitReason = isSelectionExitReason;
exports.isSplitReason = isSplitReason;
exports.isValidMatch = isValidMatch;
exports.markActiveInRange = markActiveInRange;
exports.positionHasMarks = positionHasMarks;
exports.rangeHasMarks = rangeHasMarks;
exports.removeSuggester = removeSuggester;
exports.selectionOutsideMatch = selectionOutsideMatch;
exports.suggest = suggest;


/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorSuggest = __webpack_require__(89);



Object.keys(prosemirrorSuggest).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorSuggest[k]; }
	});
});


/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(101);
} else {
  module.exports = __webpack_require__(102);
}


/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var _objectWithoutProperties = __webpack_require__(48);
var _objectSpread = __webpack_require__(14);
var _slicedToArray = __webpack_require__(8);
__webpack_require__(17);
var coreHelpers = __webpack_require__(20);

var _excluded = ["state", "dispatch", "view", "tr"];

/**
 * Creates a fake state that can be used on ProseMirror library commands to make
 * them chainable. The provided Transaction `tr` can be a shared one.
 *
 * @param tr - the chainable transaction that should be amended.
 * @param state - the state of the editor (available via `view.state`).
 *
 * This should not be used other than for passing to `prosemirror-*` library
 * commands.
 */
function chainableEditorState(tr, state) {
  // Get the prototype of the state which is used to allow this chainable editor
  // state to pass `instanceof` checks.
  var proto = Object.getPrototypeOf(state); // Every time the `state.tr` property is accessed these values are updated to
  // reflect the current `transaction` value for the doc, selection and
  // storedMarks. This way they can be mostly be constant within the scope of
  // the command this state is used in.

  var selection = tr.selection;
  var doc = tr.doc;
  var storedMarks = tr.storedMarks; // Container for the enumerable properties on the current state object.

  var properties = coreHelpers.object();

  for (var _i = 0, _Object$entries = Object.entries(state); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    // Store the enumerable state value.
    properties[key] = {
      value
    };
  }

  return Object.create(proto, _objectSpread(_objectSpread({}, properties), {}, {
    storedMarks: {
      get() {
        return storedMarks;
      }

    },
    selection: {
      get() {
        return selection;
      }

    },
    doc: {
      get() {
        return doc;
      }

    },
    tr: {
      get() {
        selection = tr.selection;
        doc = tr.doc;
        storedMarks = tr.storedMarks;
        return tr;
      }

    }
  }));
}
/**
 * Wraps the default [[ProsemirrorCommandFunction]] and makes it compatible with
 * the default **remirror** [[CommandFunction]] call signature.
 *
 * It extracts all the public APIs of the state object and assigns the
 * chainable transaction to the `state.tr` property to support chaining.
 */

function convertCommand(commandFunction) {
  return _ref => {
    var state = _ref.state,
        dispatch = _ref.dispatch,
        view = _ref.view,
        tr = _ref.tr;
    return commandFunction(chainableEditorState(tr, state), dispatch, view);
  };
}
/**
 * Marks a command function as non chainable. It will throw an error when
 * chaining is attempted.
 *
 * @remarks
 *
 * ```ts
 * const command = nonChainable(({ state, dispatch }) => {...});
 * ```
 */

function nonChainable(commandFunction) {
  return props => {
    var _props$view;

    !(props.dispatch === undefined || props.dispatch === ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch)) ? coreHelpers.invariant(false) : void 0;
    return commandFunction(props);
  };
}
/**
 * Similar to the chainCommands from the `prosemirror-commands` library. Allows
 * multiple commands to be chained together and runs until one of them returns
 * true.
 */

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return _ref2 => {
    var state = _ref2.state,
        dispatch = _ref2.dispatch,
        view = _ref2.view,
        tr = _ref2.tr,
        rest = _objectWithoutProperties(_ref2, _excluded);

    var _iterator = _createForOfIteratorHelper(commands),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;

        if (element(_objectSpread({
          state,
          dispatch,
          view,
          tr
        }, rest))) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  };
}

exports.chainCommands = chainCommands;
exports.chainableEditorState = chainableEditorState;
exports.convertCommand = convertCommand;
exports.nonChainable = nonChainable;


/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var _objectWithoutProperties = __webpack_require__(48);
var _objectSpread = __webpack_require__(14);
var _slicedToArray = __webpack_require__(8);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);

var _excluded = ["state", "dispatch", "view", "tr"];

/**
 * Creates a fake state that can be used on ProseMirror library commands to make
 * them chainable. The provided Transaction `tr` can be a shared one.
 *
 * @param tr - the chainable transaction that should be amended.
 * @param state - the state of the editor (available via `view.state`).
 *
 * This should not be used other than for passing to `prosemirror-*` library
 * commands.
 */
function chainableEditorState(tr, state) {
  // Get the prototype of the state which is used to allow this chainable editor
  // state to pass `instanceof` checks.
  var proto = Object.getPrototypeOf(state); // Every time the `state.tr` property is accessed these values are updated to
  // reflect the current `transaction` value for the doc, selection and
  // storedMarks. This way they can be mostly be constant within the scope of
  // the command this state is used in.

  var selection = tr.selection;
  var doc = tr.doc;
  var storedMarks = tr.storedMarks; // Container for the enumerable properties on the current state object.

  var properties = coreHelpers.object();

  for (var _i = 0, _Object$entries = Object.entries(state); _i < _Object$entries.length; _i++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
        key = _Object$entries$_i[0],
        value = _Object$entries$_i[1];

    // Store the enumerable state value.
    properties[key] = {
      value
    };
  }

  return Object.create(proto, _objectSpread(_objectSpread({}, properties), {}, {
    storedMarks: {
      get() {
        return storedMarks;
      }

    },
    selection: {
      get() {
        return selection;
      }

    },
    doc: {
      get() {
        return doc;
      }

    },
    tr: {
      get() {
        selection = tr.selection;
        doc = tr.doc;
        storedMarks = tr.storedMarks;
        return tr;
      }

    }
  }));
}
/**
 * Wraps the default [[ProsemirrorCommandFunction]] and makes it compatible with
 * the default **remirror** [[CommandFunction]] call signature.
 *
 * It extracts all the public APIs of the state object and assigns the
 * chainable transaction to the `state.tr` property to support chaining.
 */

function convertCommand(commandFunction) {
  return _ref => {
    var state = _ref.state,
        dispatch = _ref.dispatch,
        view = _ref.view,
        tr = _ref.tr;
    return commandFunction(chainableEditorState(tr, state), dispatch, view);
  };
}
/**
 * Marks a command function as non chainable. It will throw an error when
 * chaining is attempted.
 *
 * @remarks
 *
 * ```ts
 * const command = nonChainable(({ state, dispatch }) => {...});
 * ```
 */

function nonChainable(commandFunction) {
  return props => {
    var _props$view;

    !(props.dispatch === undefined || props.dispatch === ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch)) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.NON_CHAINABLE_COMMAND
    }) : coreHelpers.invariant(false) : void 0;
    return commandFunction(props);
  };
}
/**
 * Similar to the chainCommands from the `prosemirror-commands` library. Allows
 * multiple commands to be chained together and runs until one of them returns
 * true.
 */

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return _ref2 => {
    var state = _ref2.state,
        dispatch = _ref2.dispatch,
        view = _ref2.view,
        tr = _ref2.tr,
        rest = _objectWithoutProperties(_ref2, _excluded);

    var _iterator = _createForOfIteratorHelper(commands),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var element = _step.value;

        if (element(_objectSpread({
          state,
          dispatch,
          view,
          tr
        }, rest))) {
          return true;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return false;
  };
}

exports.chainCommands = chainCommands;
exports.chainableEditorState = chainableEditorState;
exports.convertCommand = convertCommand;
exports.nonChainable = nonChainable;


/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Document = __webpack_require__(104);

module.exports = new Document();


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var domWalk = __webpack_require__(105)

var Comment = __webpack_require__(106)
var DOMText = __webpack_require__(107)
var DOMElement = __webpack_require__(108)
var DocumentFragment = __webpack_require__(113)
var Event = __webpack_require__(114)
var dispatchEvent = __webpack_require__(109)
var addEventListener = __webpack_require__(110)
var removeEventListener = __webpack_require__(111)

module.exports = Document;

function Document() {
    if (!(this instanceof Document)) {
        return new Document();
    }

    this.head = this.createElement("head")
    this.body = this.createElement("body")
    this.documentElement = this.createElement("html")
    this.documentElement.appendChild(this.head)
    this.documentElement.appendChild(this.body)
    this.childNodes = [this.documentElement]
    this.nodeType = 9
}

var proto = Document.prototype;
proto.createTextNode = function createTextNode(value) {
    return new DOMText(value, this)
}

proto.createElementNS = function createElementNS(namespace, tagName) {
    var ns = namespace === null ? null : String(namespace)
    return new DOMElement(tagName, this, ns)
}

proto.createElement = function createElement(tagName) {
    return new DOMElement(tagName, this)
}

proto.createDocumentFragment = function createDocumentFragment() {
    return new DocumentFragment(this)
}

proto.createEvent = function createEvent(family) {
    return new Event(family)
}

proto.createComment = function createComment(data) {
    return new Comment(data, this)
}

proto.getElementById = function getElementById(id) {
    id = String(id)

    var result = domWalk(this.childNodes, function (node) {
        if (String(node.id) === id) {
            return node
        }
    })

    return result || null
}

proto.getElementsByClassName = DOMElement.prototype.getElementsByClassName
proto.getElementsByTagName = DOMElement.prototype.getElementsByTagName
proto.contains = DOMElement.prototype.contains

proto.removeEventListener = removeEventListener
proto.addEventListener = addEventListener
proto.dispatchEvent = dispatchEvent


/***/ }),
/* 105 */
/***/ ((module) => {

var slice = Array.prototype.slice

module.exports = iterativelyWalk

function iterativelyWalk(nodes, cb) {
    if (!('length' in nodes)) {
        nodes = [nodes]
    }
    
    nodes = slice.call(nodes)

    while(nodes.length) {
        var node = nodes.shift(),
            ret = cb(node)

        if (ret) {
            return ret
        }

        if (node.childNodes && node.childNodes.length) {
            nodes = slice.call(node.childNodes).concat(nodes)
        }
    }
}


/***/ }),
/* 106 */
/***/ ((module) => {

module.exports = Comment

function Comment(data, owner) {
    if (!(this instanceof Comment)) {
        return new Comment(data, owner)
    }

    this.data = data
    this.nodeValue = data
    this.length = data.length
    this.ownerDocument = owner || null
}

Comment.prototype.nodeType = 8
Comment.prototype.nodeName = "#comment"

Comment.prototype.toString = function _Comment_toString() {
    return "[object Comment]"
}


/***/ }),
/* 107 */
/***/ ((module) => {

module.exports = DOMText

function DOMText(value, owner) {
    if (!(this instanceof DOMText)) {
        return new DOMText(value)
    }

    this.data = value || ""
    this.length = this.data.length
    this.ownerDocument = owner || null
}

DOMText.prototype.type = "DOMTextNode"
DOMText.prototype.nodeType = 3
DOMText.prototype.nodeName = "#text"

DOMText.prototype.toString = function _Text_toString() {
    return this.data
}

DOMText.prototype.replaceData = function replaceData(index, length, value) {
    var current = this.data
    var left = current.substring(0, index)
    var right = current.substring(index + length, current.length)
    this.data = left + value + right
    this.length = this.data.length
}


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var domWalk = __webpack_require__(105)
var dispatchEvent = __webpack_require__(109)
var addEventListener = __webpack_require__(110)
var removeEventListener = __webpack_require__(111)
var serializeNode = __webpack_require__(112)

var htmlns = "http://www.w3.org/1999/xhtml"

module.exports = DOMElement

function DOMElement(tagName, owner, namespace) {
    if (!(this instanceof DOMElement)) {
        return new DOMElement(tagName)
    }

    var ns = namespace === undefined ? htmlns : (namespace || null)

    this.tagName = ns === htmlns ? String(tagName).toUpperCase() : tagName
    this.nodeName = this.tagName
    this.className = ""
    this.dataset = {}
    this.childNodes = []
    this.parentNode = null
    this.style = {}
    this.ownerDocument = owner || null
    this.namespaceURI = ns
    this._attributes = {}

    if (this.tagName === 'INPUT') {
      this.type = 'text'
    }
}

DOMElement.prototype.type = "DOMElement"
DOMElement.prototype.nodeType = 1

DOMElement.prototype.appendChild = function _Element_appendChild(child) {
    if (child.parentNode) {
        child.parentNode.removeChild(child)
    }

    this.childNodes.push(child)
    child.parentNode = this

    return child
}

DOMElement.prototype.replaceChild =
    function _Element_replaceChild(elem, needle) {
        // TODO: Throw NotFoundError if needle.parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem)
        }

        var index = this.childNodes.indexOf(needle)

        needle.parentNode = null
        this.childNodes[index] = elem
        elem.parentNode = this

        return needle
    }

DOMElement.prototype.removeChild = function _Element_removeChild(elem) {
    // TODO: Throw NotFoundError if elem.parentNode !== this

    var index = this.childNodes.indexOf(elem)
    this.childNodes.splice(index, 1)

    elem.parentNode = null
    return elem
}

DOMElement.prototype.insertBefore =
    function _Element_insertBefore(elem, needle) {
        // TODO: Throw NotFoundError if referenceElement is a dom node
        // and parentNode !== this

        if (elem.parentNode) {
            elem.parentNode.removeChild(elem)
        }

        var index = needle === null || needle === undefined ?
            -1 :
            this.childNodes.indexOf(needle)

        if (index > -1) {
            this.childNodes.splice(index, 0, elem)
        } else {
            this.childNodes.push(elem)
        }

        elem.parentNode = this
        return elem
    }

DOMElement.prototype.setAttributeNS =
    function _Element_setAttributeNS(namespace, name, value) {
        var prefix = null
        var localName = name
        var colonPosition = name.indexOf(":")
        if (colonPosition > -1) {
            prefix = name.substr(0, colonPosition)
            localName = name.substr(colonPosition + 1)
        }
        if (this.tagName === 'INPUT' && name === 'type') {
          this.type = value;
        }
        else {
          var attributes = this._attributes[namespace] || (this._attributes[namespace] = {})
          attributes[localName] = {value: value, prefix: prefix}
        }
    }

DOMElement.prototype.getAttributeNS =
    function _Element_getAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        var value = attributes && attributes[name] && attributes[name].value
        if (this.tagName === 'INPUT' && name === 'type') {
          return this.type;
        }
        if (typeof value !== "string") {
            return null
        }
        return value
    }

DOMElement.prototype.removeAttributeNS =
    function _Element_removeAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace];
        if (attributes) {
            delete attributes[name]
        }
    }

DOMElement.prototype.hasAttributeNS =
    function _Element_hasAttributeNS(namespace, name) {
        var attributes = this._attributes[namespace]
        return !!attributes && name in attributes;
    }

DOMElement.prototype.setAttribute = function _Element_setAttribute(name, value) {
    return this.setAttributeNS(null, name, value)
}

DOMElement.prototype.getAttribute = function _Element_getAttribute(name) {
    return this.getAttributeNS(null, name)
}

DOMElement.prototype.removeAttribute = function _Element_removeAttribute(name) {
    return this.removeAttributeNS(null, name)
}

DOMElement.prototype.hasAttribute = function _Element_hasAttribute(name) {
    return this.hasAttributeNS(null, name)
}

DOMElement.prototype.removeEventListener = removeEventListener
DOMElement.prototype.addEventListener = addEventListener
DOMElement.prototype.dispatchEvent = dispatchEvent

// Un-implemented
DOMElement.prototype.focus = function _Element_focus() {
    return void 0
}

DOMElement.prototype.toString = function _Element_toString() {
    return serializeNode(this)
}

DOMElement.prototype.getElementsByClassName = function _Element_getElementsByClassName(classNames) {
    var classes = classNames.split(" ");
    var elems = []

    domWalk(this, function (node) {
        if (node.nodeType === 1) {
            var nodeClassName = node.className || ""
            var nodeClasses = nodeClassName.split(" ")

            if (classes.every(function (item) {
                return nodeClasses.indexOf(item) !== -1
            })) {
                elems.push(node)
            }
        }
    })

    return elems
}

DOMElement.prototype.getElementsByTagName = function _Element_getElementsByTagName(tagName) {
    tagName = tagName.toLowerCase()
    var elems = []

    domWalk(this.childNodes, function (node) {
        if (node.nodeType === 1 && (tagName === '*' || node.tagName.toLowerCase() === tagName)) {
            elems.push(node)
        }
    })

    return elems
}

DOMElement.prototype.contains = function _Element_contains(element) {
    return domWalk(this, function (node) {
        return element === node
    }) || false
}


/***/ }),
/* 109 */
/***/ ((module) => {

module.exports = dispatchEvent

function dispatchEvent(ev) {
    var elem = this
    var type = ev.type

    if (!ev.target) {
        ev.target = elem
    }

    if (!elem.listeners) {
        elem.listeners = {}
    }

    var listeners = elem.listeners[type]

    if (listeners) {
        return listeners.forEach(function (listener) {
            ev.currentTarget = elem
            if (typeof listener === 'function') {
                listener(ev)
            } else {
                listener.handleEvent(ev)
            }
        })
    }

    if (elem.parentNode) {
        elem.parentNode.dispatchEvent(ev)
    }
}


/***/ }),
/* 110 */
/***/ ((module) => {

module.exports = addEventListener

function addEventListener(type, listener) {
    var elem = this

    if (!elem.listeners) {
        elem.listeners = {}
    }

    if (!elem.listeners[type]) {
        elem.listeners[type] = []
    }

    if (elem.listeners[type].indexOf(listener) === -1) {
        elem.listeners[type].push(listener)
    }
}


/***/ }),
/* 111 */
/***/ ((module) => {

module.exports = removeEventListener

function removeEventListener(type, listener) {
    var elem = this

    if (!elem.listeners) {
        return
    }

    if (!elem.listeners[type]) {
        return
    }

    var list = elem.listeners[type]
    var index = list.indexOf(listener)
    if (index !== -1) {
        list.splice(index, 1)
    }
}


/***/ }),
/* 112 */
/***/ ((module) => {

module.exports = serializeNode

var voidElements = ["area","base","br","col","embed","hr","img","input","keygen","link","menuitem","meta","param","source","track","wbr"];

function serializeNode(node) {
    switch (node.nodeType) {
        case 3:
            return escapeText(node.data)
        case 8:
            return "<!--" + node.data + "-->"
        default:
            return serializeElement(node)
    }
}

function serializeElement(elem) {
    var strings = []

    var tagname = elem.tagName

    if (elem.namespaceURI === "http://www.w3.org/1999/xhtml") {
        tagname = tagname.toLowerCase()
    }

    strings.push("<" + tagname + properties(elem) + datasetify(elem))

    if (voidElements.indexOf(tagname) > -1) {
        strings.push(" />")
    } else {
        strings.push(">")

        if (elem.childNodes.length) {
            strings.push.apply(strings, elem.childNodes.map(serializeNode))
        } else if (elem.textContent || elem.innerText) {
            strings.push(escapeText(elem.textContent || elem.innerText))
        } else if (elem.innerHTML) {
            strings.push(elem.innerHTML)
        }

        strings.push("</" + tagname + ">")
    }

    return strings.join("")
}

function isProperty(elem, key) {
    var type = typeof elem[key]

    if (key === "style" && Object.keys(elem.style).length > 0) {
      return true
    }

    return elem.hasOwnProperty(key) &&
        (type === "string" || type === "boolean" || type === "number") &&
        key !== "nodeName" && key !== "className" && key !== "tagName" &&
        key !== "textContent" && key !== "innerText" && key !== "namespaceURI" &&  key !== "innerHTML"
}

function stylify(styles) {
    if (typeof styles === 'string') return styles
    var attr = ""
    Object.keys(styles).forEach(function (key) {
        var value = styles[key]
        key = key.replace(/[A-Z]/g, function(c) {
            return "-" + c.toLowerCase();
        })
        attr += key + ":" + value + ";"
    })
    return attr
}

function datasetify(elem) {
    var ds = elem.dataset
    var props = []

    for (var key in ds) {
        props.push({ name: "data-" + key, value: ds[key] })
    }

    return props.length ? stringify(props) : ""
}

function stringify(list) {
    var attributes = []
    list.forEach(function (tuple) {
        var name = tuple.name
        var value = tuple.value

        if (name === "style") {
            value = stylify(value)
        }

        attributes.push(name + "=" + "\"" + escapeAttributeValue(value) + "\"")
    })

    return attributes.length ? " " + attributes.join(" ") : ""
}

function properties(elem) {
    var props = []
    for (var key in elem) {
        if (isProperty(elem, key)) {
            props.push({ name: key, value: elem[key] })
        }
    }

    for (var ns in elem._attributes) {
      for (var attribute in elem._attributes[ns]) {
        var prop = elem._attributes[ns][attribute]
        var name = (prop.prefix ? prop.prefix + ":" : "") + attribute
        props.push({ name: name, value: prop.value })
      }
    }

    if (elem.className) {
        props.push({ name: "class", value: elem.className })
    }

    return props.length ? stringify(props) : ""
}

function escapeText(s) {
    var str = '';

    if (typeof(s) === 'string') { 
        str = s; 
    } else if (s) {
        str = s.toString();
    }

    return str
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
}

function escapeAttributeValue(str) {
    return escapeText(str).replace(/"/g, "&quot;")
}


/***/ }),
/* 113 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DOMElement = __webpack_require__(108)

module.exports = DocumentFragment

function DocumentFragment(owner) {
    if (!(this instanceof DocumentFragment)) {
        return new DocumentFragment()
    }

    this.childNodes = []
    this.parentNode = null
    this.ownerDocument = owner || null
}

DocumentFragment.prototype.type = "DocumentFragment"
DocumentFragment.prototype.nodeType = 11
DocumentFragment.prototype.nodeName = "#document-fragment"

DocumentFragment.prototype.appendChild  = DOMElement.prototype.appendChild
DocumentFragment.prototype.replaceChild = DOMElement.prototype.replaceChild
DocumentFragment.prototype.removeChild  = DOMElement.prototype.removeChild

DocumentFragment.prototype.toString =
    function _DocumentFragment_toString() {
        return this.childNodes.map(function (node) {
            return String(node)
        }).join("")
    }


/***/ }),
/* 114 */
/***/ ((module) => {

module.exports = Event

function Event(family) {}

Event.prototype.initEvent = function _Event_initEvent(type, bubbles, cancelable) {
    this.type = type
    this.bubbles = bubbles
    this.cancelable = cancelable
}

Event.prototype.preventDefault = function _Event_preventDefault() {
    
}


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var _objectSpread = __webpack_require__(14);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);
var state = __webpack_require__(38);
var transform = __webpack_require__(45);
var _objectWithoutProperties = __webpack_require__(48);
var _slicedToArray = __webpack_require__(8);
var cssInJsUtils = __webpack_require__(50);
var model = __webpack_require__(64);
var parse = __webpack_require__(67);
var messages = __webpack_require__(68);
var inputrules = __webpack_require__(83);
var suggest = __webpack_require__(87);
var pm = __webpack_require__(100);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var parse__default = /*#__PURE__*/_interopDefault(parse);

/// <reference types="node" />

/**
 * A object with flags identifying the current environment.
 */
var environment = {
  /**
   * Verifies that the environment has both a window and window.document
   */
  get isBrowser() {
    return !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && window.navigator && window.navigator.userAgent);
  },

  /**
   * Verifies that the environment is JSDOM
   */
  get isJSDOM() {
    return environment.isBrowser && window.navigator.userAgent.includes('jsdom');
  },

  /**
   * Verifies that the environment has a nodejs process and is therefore a node environment
   */
  get isNode() {
    return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;
  },

  /**
   * True when on an iOS device.
   */
  get isIos() {
    return environment.isBrowser && /iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * True when running on macOS
   */
  get isMac() {
    return environment.isBrowser && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
  },

  /**
   * Verify that this is an apple device either on the client or server.
   */
  get isApple() {
    return environment.isNode ? process.platform === 'darwin' : environment.isBrowser ? /Mac|iPod|iPhone|iPad/.test(window.navigator.platform) : false;
  },

  /**
   * True when running in DEVELOPMENT environment
   */
  get isDevelopment() {
    return process.env.NODE_ENV === 'development';
  },

  /**
   * True when running unit tests
   */
  get isTest() {
    return process.env.NODE_ENV === 'test';
  },

  /**
   * True when running in PRODUCTION environment
   */
  get isProduction() {
    return process.env.NODE_ENV === 'production';
  }

};

/**
 * Get the styles for a given property of an element.
 */

function getStyle(element, property) {
  var _element$ownerDocumen, _element$ownerDocumen2;

  var view = (_element$ownerDocumen = (_element$ownerDocumen2 = element.ownerDocument) === null || _element$ownerDocumen2 === void 0 ? void 0 : _element$ownerDocumen2.defaultView) !== null && _element$ownerDocumen !== void 0 ? _element$ownerDocumen : window;
  var style = view.getComputedStyle(element);
  return style.getPropertyValue(property);
}
/**
 * Set more styles to the given element.
 */

function setStyle(target, styles) {
  return Object.assign(target.style, styles);
}
var DOM_SIZE_UNITS = ['px', 'rem', 'em', 'in', 'q', 'mm', 'cm', 'pt', 'pc', 'vh', 'vw', 'vmin', 'vmax'];

/**
 * Matches a CSS dimension returning a group containing the unit name
 * i.e. '10rem' returns the group 'rem'
 */
var CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
/**
 * Parse the font size and font unit from the provided value. When the value
 * type is unsupported it default to `px`.
 */

function parseSizeUnit() {
  var _match$;

  var fontSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0';
  var length = fontSize || '0';
  var value = Number.parseFloat(length);
  var match = length.match(CSS_DIMENSION_REGEX);
  var unit = ((_match$ = match === null || match === void 0 ? void 0 : match[1]) !== null && _match$ !== void 0 ? _match$ : 'px').toLowerCase(); // Defaults to pixels

  return [value, coreHelpers.includes(DOM_SIZE_UNITS, unit) ? unit : 'px'];
}
var PIXELS_PER_INCH = 96;
var MILLIMETERS_PER_INCH = 25.4;
var POINTS_PER_INCH = 72;
var PICAS_PER_INCH = 6;
function getFontSize(element) {
  return isElementDomNode(element) ? getStyle(element, 'font-size') || getFontSize(element.parentElement) : getStyle(window.document.documentElement, 'font-size');
}

function createUnitConverter(element) {
  var _element$ownerDocumen3, _element$ownerDocumen4;

  var view = (_element$ownerDocumen3 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen4 = element.ownerDocument) === null || _element$ownerDocumen4 === void 0 ? void 0 : _element$ownerDocumen4.defaultView) !== null && _element$ownerDocumen3 !== void 0 ? _element$ownerDocumen3 : window;
  var root = view.document.documentElement || view.document.body;
  return (value, unit) => {
    switch (unit) {
      case 'rem':
        return value * extractPixelSize(getFontSize(root));

      case 'em':
        return value * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

      case 'in':
        return value * PIXELS_PER_INCH;

      case 'q':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH / 4;

      case 'mm':
        return value * PIXELS_PER_INCH / MILLIMETERS_PER_INCH;

      case 'cm':
        return value * PIXELS_PER_INCH * 10 / MILLIMETERS_PER_INCH;

      case 'pt':
        return value * PIXELS_PER_INCH / POINTS_PER_INCH;

      case 'pc':
        return value * PIXELS_PER_INCH / PICAS_PER_INCH;

      case 'vh':
        return (value * view.innerHeight || root.clientWidth) / 100;

      case 'vw':
        return (value * view.innerWidth || root.clientHeight) / 100;

      case 'vmin':
        return value * Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      case 'vmax':
        return value * Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) / 100;

      default:
        return value;
    }
  };
}
/**
 * Matches a CSS function returning groups containing the function name and arguments
 * i.e. 'min(10px, 20px)' returns groups 'min' and '10px, 20px'
 */


var CSS_FUNCTION_REGEX = /^([a-z]+)\((.+)\)$/i;
/**
 * Recursively evaluates CSS functions by parsing into bracket groups
 *
 * Does not support the `calc` function
 *
 * @param cssFunc a string matching CSS_FUNCTION_REGEX
 * @param unitConvertor
 */

function parseCSSFunction(cssFunc, unitConvertor) {
  if (!CSS_FUNCTION_REGEX.test(cssFunc)) {
    return Number.NaN;
  }

  var tokens = parse__default["default"](cssFunc, {
    brackets: ['()'],
    escape: '_',
    flat: true
  });

  if (!tokens || tokens.length === 0) {
    return Number.NaN;
  }

  function replaceTokenReferences(str) {
    return str.replace(/_(\d+)_/g, (_, refIndex) => {
      var _tokens$tokenIndex;

      var tokenIndex = Number.parseFloat(refIndex);
      return (_tokens$tokenIndex = tokens[tokenIndex]) !== null && _tokens$tokenIndex !== void 0 ? _tokens$tokenIndex : '';
    });
  }

  var firstToken = getMatchString(tokens, 0);

  var _iterator = _createForOfIteratorHelper(coreHelpers.findMatches(firstToken, CSS_FUNCTION_REGEX)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var match = _step.value;
      var funcName = getMatchString(match, 1);
      var funcArgs = replaceTokenReferences(getMatchString(match, 2));
      var args = funcArgs.split(/\s*,\s*/);
      var values = args.map(arg => {
        if (CSS_FUNCTION_REGEX.test(arg)) {
          var nestedFunction = replaceTokenReferences(arg);
          return parseCSSFunction(nestedFunction, unitConvertor);
        }

        return parseCSSDimension(arg, unitConvertor);
      });

      switch (funcName) {
        case 'min':
          return Math.min(...values);

        case 'max':
          return Math.max(...values);

        case 'clamp':
          {
            var _values = _slicedToArray(values, 3),
                min = _values[0],
                _value = _values[1],
                max = _values[2];

            if (coreHelpers.isNumber(min) && coreHelpers.isNumber(_value) && coreHelpers.isNumber(max)) {
              return coreHelpers.clamp({
                min,
                max,
                value: _value
              });
            }

            break;
          }

        case 'calc':
          // Not practical to implement calc due to the vast amount of operations possible
          return Number.NaN;

        default:
          return Number.NaN;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return Number.NaN;
}

function parseCSSDimension(dimension, unitConvertor) {
  var _parseSizeUnit = parseSizeUnit(dimension),
      _parseSizeUnit2 = _slicedToArray(_parseSizeUnit, 2),
      value = _parseSizeUnit2[0],
      unit = _parseSizeUnit2[1];

  return unitConvertor(value, unit);
}
/**
 * Extract the pixel value from a dimension string or CSS function.
 *
 * Supports the CSS functions `min`, `max` and `clamp` even when nested.
 *
 * Does not support percentage units or the `calc` function.
 *
 * Adapted from https://github.com/PacoteJS/pacote/blob/20cb1e3a999ed47a8d52b03b750290cf36b8e270/packages/pixels/src/index.ts
 */


function extractPixelSize(size, element) {
  var unitConvertor = createUnitConverter(element);
  return CSS_FUNCTION_REGEX.test(size) ? parseCSSFunction(size.toLowerCase(), unitConvertor) : parseCSSDimension(size, unitConvertor);
}
/**
 * Convert the received font size to a valid unit
 */

function convertPixelsToDomUnit(size, to, element) {
  var _element$ownerDocumen5, _element$ownerDocumen6;

  var view = (_element$ownerDocumen5 = element === null || element === void 0 ? void 0 : (_element$ownerDocumen6 = element.ownerDocument) === null || _element$ownerDocumen6 === void 0 ? void 0 : _element$ownerDocumen6.defaultView) !== null && _element$ownerDocumen5 !== void 0 ? _element$ownerDocumen5 : window;
  var root = view.document.documentElement || view.document.body;
  var pixelValue = extractPixelSize(size, element);

  switch (to) {
    case 'px':
      return pixelValue;

    case 'rem':
      return pixelValue / extractPixelSize(getFontSize(root));

    case 'em':
      return pixelValue * extractPixelSize(getFontSize(element), element === null || element === void 0 ? void 0 : element.parentElement);

    case 'in':
      return pixelValue / PIXELS_PER_INCH;

    case 'q':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH * 4;

    case 'mm':
      return pixelValue / PIXELS_PER_INCH * MILLIMETERS_PER_INCH;

    case 'cm':
      return pixelValue / PIXELS_PER_INCH / 10 * MILLIMETERS_PER_INCH;

    case 'pt':
      return pixelValue / PIXELS_PER_INCH * POINTS_PER_INCH;

    case 'pc':
      return pixelValue / PIXELS_PER_INCH * PICAS_PER_INCH;

    case 'vh':
      return pixelValue / (view.innerHeight || root.clientWidth) * 100;

    case 'vw':
      return pixelValue / (view.innerWidth || root.clientHeight) * 100;

    case 'vmin':
      return pixelValue / Math.min(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    case 'vmax':
      return pixelValue / Math.max(view.innerWidth || root.clientWidth, view.innerHeight || root.clientHeight) * 100;

    default:
      return pixelValue;
  }
}
/**
 * Checks whether the passed value is a valid dom node
 *
 * @param domNode - the dom node
 */

function isDomNode(domNode) {
  return typeof document !== 'undefined' && (coreHelpers.isObject(Node) ? domNode instanceof Node : coreHelpers.isObject(domNode) && coreHelpers.isNumber(coreHelpers.Cast(domNode).nodeType) && coreHelpers.isString(coreHelpers.Cast(domNode).nodeName));
}
/**
 * Checks for an element node like `<p>` or `<div>`.
 *
 * @param domNode - the dom node
 */

function isElementDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.ELEMENT_NODE;
}
/**
 * Checks for a text node.
 *
 * @param domNode - the dom node
 */

function isTextDomNode(domNode) {
  return isDomNode(domNode) && domNode.nodeType === Node.TEXT_NODE;
}

/**
 * Checks if the type a given `node` has a given `nodeType`.
 */
function isNodeOfType(props) {
  var types = props.types,
      node = props.node;

  if (!node) {
    return false;
  }

  var matches = type => {
    return type === node.type || type === node.type.name;
  };

  if (coreHelpers.isArray(types)) {
    return types.some(matches);
  }

  return matches(types);
}

/**
 * Creates a new transaction object from a given transaction. This is useful
 * when applying changes to a transaction, that you may want to rollback.
 *
 * ```ts
 * function() applyUpdateIfValid(state: EditorState) {
 *   const tr = cloneTransaction(state.tr);
 *
 *   tr.insertText('hello');
 *
 *   if (!checkValid(tr)) {
 *     return;
 *   }
 *
 *   applyClonedTransaction({ clone: tr, tr: state.tr });
 * }
 * ```
 *
 * The above example applies a transaction to the cloned transaction then checks
 * to see if the changes are still valid and if they are applies the mutative
 * changes to the original state transaction.
 *
 * @param tr - the prosemirror transaction
 */
function cloneTransaction(tr) {
  return Object.assign(Object.create(tr), tr).setTime(Date.now());
}

/**
 * Get the diff between two ordered arrays with a reference equality check.
 */
function diff(primary, other) {
  return primary.filter((item, index) => item !== other[index]);
}
/**
 * Apply the steps of a cloned transaction to the original transaction `tr`.
 */


function applyClonedTransaction(props) {
  var clone = props.clone,
      tr = props.tr;
  var steps = diff(clone.steps, tr.steps);

  var _iterator = _createForOfIteratorHelper(steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      tr.step(step);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/**
 * Returns a new transaction by combining all steps of the passed transactions onto the previous state
 */

function composeTransactionSteps(transactions, oldState) {
  var tr = oldState.tr;
  transactions.forEach(transaction => {
    transaction.steps.forEach(step => {
      tr.step(step);
    });
  });
  return tr;
}
/**
 * Checks if the type a given `node` has a given `nodeType`.
 */

function markEqualsType(props) {
  var types = props.types,
      mark = props.mark;
  return mark ? Array.isArray(types) && types.includes(mark.type) || mark.type === types : false;
}

/**
 * Performs a `delete` transaction that removes a node at a given position with
 * the given `node`. `position` should point at the position immediately before
 * the node.
 *
 * @param position - the prosemirror position
 */
function removeNodeAtPosition(_ref) {
  var pos = _ref.pos,
      tr = _ref.tr;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.delete(pos, pos + node.nodeSize);
  }

  return tr;
}

/**
 * Replaces the node at the provided position with the provided content.
 */
function replaceNodeAtPosition(_ref2) {
  var pos = _ref2.pos,
      tr = _ref2.tr,
      content = _ref2.content;
  var node = tr.doc.nodeAt(pos);

  if (node) {
    tr.replaceWith(pos, pos + node.nodeSize, content);
  }

  return tr;
}
/**
 * Returns DOM reference of a node at a given `position`.
 *
 * @remarks
 *
 * If the node type is of type `TEXT_NODE` it will return the reference of the
 * parent node.
 *
 * A simple use case
 *
 * ```ts
 * const element = findElementAtPosition($from.pos, view);
 * ```
 *
 * @param position - the prosemirror position
 * @param view - the editor view
 */

function findElementAtPosition(position, view) {
  var dom = view.domAtPos(position);
  var node = dom.node.childNodes[dom.offset];

  if (isTextDomNode(dom.node)) {
    return dom.node.parentNode;
  }

  if (coreHelpers.isNullOrUndefined(node) || isTextDomNode(node)) {
    return dom.node;
  }

  return node;
}
/**
 * Iterates over parent nodes, returning the closest node and its start position
 * that the `predicate` returns truthy for. `start` points to the start position
 * of the node, `pos` points directly before the node.
 *
 * ```ts
 * const predicate = node => node.type === schema.nodes.blockquote;
 * const parent = findParentNode({ predicate, selection });
 * ```
 */

function findParentNode(props) {
  var predicate = props.predicate,
      selection = props.selection;
  var $pos = isEditorState(selection) ? selection.selection.$from : isSelection(selection) ? selection.$from : selection;

  for (var depth = $pos.depth; depth > 0; depth--) {
    var _node = $pos.node(depth);

    var _pos = depth > 0 ? $pos.before(depth) : 0;

    var start = $pos.start(depth);
    var end = _pos + _node.nodeSize;

    if (predicate(_node, _pos)) {
      return {
        pos: _pos,
        depth,
        node: _node,
        start,
        end
      };
    }
  }

  return;
}
/**
 * Finds the node at the resolved position.
 *
 * @param $pos - the resolve position in the document
 */

function findNodeAtPosition($pos) {
  var depth = $pos.depth;
  var pos = depth > 0 ? $pos.before(depth) : 0;
  var node = $pos.node(depth);
  var start = $pos.start(depth);
  var end = pos + node.nodeSize;
  return {
    pos,
    start,
    node,
    end,
    depth
  };
}
/**
 * Finds the node at the passed selection.
 */

function findNodeAtSelection(selection) {
  var parentNode = findParentNode({
    predicate: () => true,
    selection
  });
  !parentNode ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    message: 'No parent node found for the selection provided.'
  }) : coreHelpers.invariant(false) : void 0;
  return parentNode;
}

/**
 *  Iterates over parent nodes, returning closest node of a given `nodeType`.
 *  `start` points to the start position of the node, `pos` points directly
 *  before the node.
 *
 *  ```ts
 *  const parent = findParentNodeOfType({types: schema.nodes.paragraph, selection});
 *  ```
 */
function findParentNodeOfType(props) {
  var types = props.types,
      selection = props.selection;
  return findParentNode({
    predicate: node => isNodeOfType({
      types,
      node
    }),
    selection
  });
}
/**
 * Returns position of the previous node.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */

function findPositionOfNodeBefore(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeBefore = $pos.nodeBefore;
  var selection = state.Selection.findFrom($pos, -1);

  if (!selection || !nodeBefore) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeBefore.type,
    selection
  });
  return parent ? parent : {
    node: nodeBefore,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Updates the provided transaction to remove the node before.
 *
 * ```ts
 * dispatch(
 *    removeNodeBefore(state.tr)
 * );
 * ```
 *
 * @param tr
 */

function removeNodeBefore(tr) {
  var result = findPositionOfNodeBefore(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}

/**
 * Returns a node of a given `nodeType` if it is selected. `start` points to the
 * start position of the node, `pos` points directly before the node.
 *
 * ```ts
 * const { extension, inlineExtension, bodiedExtension } = schema.nodes;
 *
 * const selectedNode = findSelectedNodeOfType({
 *   types: [extension, inlineExtension, bodiedExtension],
 *   selection,
 * });
 * ```
 */
function findSelectedNodeOfType(props) {
  var types = props.types,
      selection = props.selection;

  if (!isNodeSelection(selection) || !isNodeOfType({
    types,
    node: selection.node
  })) {
    return;
  }

  return {
    pos: selection.$from.pos,
    depth: selection.$from.depth,
    start: selection.$from.start(),
    end: selection.$from.pos + selection.node.nodeSize,
    node: selection.node
  };
}

/**
 * Returns the position of the node after the current position, selection or
 * state.
 *
 * ```ts
 * const pos = findPositionOfNodeBefore(tr.selection);
 * ```
 *
 * @param selection - the prosemirror selection
 */
function findPositionOfNodeAfter(value) {
  var $pos = isResolvedPos(value) ? value : isSelection(value) ? value.$from : value.selection.$from;

  if (coreHelpers.isNullOrUndefined($pos)) {
    throw new Error('Invalid value passed in.');
  }

  var nodeAfter = $pos.nodeAfter;
  var selection = state.Selection.findFrom($pos, 1);

  if (!selection || !nodeAfter) {
    return;
  }

  var parent = findParentNodeOfType({
    types: nodeAfter.type,
    selection
  });
  return parent ? parent : {
    node: nodeAfter,
    pos: selection.$from.pos,
    end: selection.$from.end(),
    depth: selection.$from.depth + 1,
    start: selection.$from.start(selection.$from.depth + 1)
  };
}
/**
 * Update the transaction to delete the node after the current selection.
 *
 * ```ts
 * dispatch(removeNodeBefore(state.tr));
 * ```
 *
 * @param tr
 */

function removeNodeAfter(tr) {
  var result = findPositionOfNodeAfter(tr.selection);

  if (result) {
    removeNodeAtPosition({
      pos: result.pos,
      tr
    });
  }

  return tr;
}
/**
 * Checks whether the selection or state is currently empty.
 *
 * @param value - the transaction selection or state
 */

function isSelectionEmpty(value) {
  return isSelection(value) ? value.empty : value.selection.empty;
}
/**
 * Check to see if a transaction has changed either the document or the current
 * selection.
 *
 * @param tr - the transaction to check
 */

function hasTransactionChanged(tr) {
  return tr.docChanged || tr.selectionSet;
}
/**
 * Checks whether the node type passed in is active within the region. Used by
 * extensions to implement the `active` method.
 *
 * To ignore `attrs` just leave the attrs object empty or undefined.
 *
 * @param props - see [[`GetActiveAttrsProps`]]
 */

function isNodeActive(props) {
  return !!getActiveNode(props);
}

/**
 * Get node of a provided type with the provided attributes if it exists as a
 * parent. Returns positional data for the node that was found.
 */
function getActiveNode(props) {
  var _findSelectedNodeOfTy;

  var state = props.state,
      type = props.type,
      attrs = props.attrs;
  var selection = state.selection,
      doc = state.doc;
  var nodeType = coreHelpers.isString(type) ? doc.type.schema.nodes[type] : type;
  !nodeType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.SCHEMA,
    message: "No node exists for ".concat(type)
  }) : coreHelpers.invariant(false) : void 0;
  var active = (_findSelectedNodeOfTy = findSelectedNodeOfType({
    selection,
    types: type
  })) !== null && _findSelectedNodeOfTy !== void 0 ? _findSelectedNodeOfTy : findParentNode({
    predicate: node => node.type === nodeType,
    selection
  });

  if (!attrs || coreHelpers.isEmptyObject(attrs) || !active) {
    return active;
  }

  return active.node.hasMarkup(nodeType, _objectSpread(_objectSpread({}, active.node.attrs), attrs)) ? active : undefined;
}
/**
 * The ProseMirror `Schema` as a JSON object.
 */

/**
 * Converts a `schema` to a JSON compatible object.
 */
function schemaToJSON(schema) {
  var nodes = coreHelpers.object();
  var marks = coreHelpers.object();

  var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(schema.nodes)),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _slicedToArray(_step2.value, 2),
          key = _step2$value[0],
          spec = _step2$value[1].spec;

      nodes[key] = spec;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var _iterator3 = _createForOfIteratorHelper(coreHelpers.entries(schema.marks)),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _key = _step3$value[0],
          _spec = _step3$value[1].spec;

      marks[_key] = _spec;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return {
    nodes,
    marks
  };
}
/**
 * Chains together keybindings, allowing for the same key binding to be used
 * across multiple extensions without overriding behavior.
 *
 * @remarks
 *
 * When `next` is called it hands over full control of the keybindings to the
 * function that invokes it.
 */

function chainKeyBindingCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    commands[_key2] = arguments[_key2];
  }

  return props => {
    // When no commands are passed just ignore and continue.
    if (!coreHelpers.isNonEmptyArray(commands)) {
      return false;
    }

    var command = commands[0],
        rest = commands.slice(1); // Keeps track of whether the `next` method has been called. If it has been
    // called we return the result and skip the rest of the downstream commands.

    var calledNext = false;
    /**
     * Create the next function call. Updates the outer closure when the next
     * method has been called.
     */

    var createNext = function createNext() {
      for (var _len2 = arguments.length, nextCommands = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
        nextCommands[_key3] = arguments[_key3];
      }

      return () => {
        // If there are no commands then this can be ignored and continued.
        if (!coreHelpers.isNonEmptyArray(nextCommands)) {
          return false;
        } // Update the closure with information that the next method was invoked by
        // this command.


        calledNext = true;
        var nextRest = nextCommands.slice(1); // Recursively call the key bindings method.

        return chainKeyBindingCommands(...nextCommands)(_objectSpread(_objectSpread({}, props), {}, {
          next: createNext(...nextRest)
        }));
      };
    };

    var next = createNext(...rest);
    var exitEarly = command(_objectSpread(_objectSpread({}, props), {}, {
      next
    })); // Exit the chain of commands early if either:
    // - a) next was called
    // - b) the command returned true

    if (calledNext || exitEarly) {
      return exitEarly;
    } // Continue to the next function in the chain of commands.


    return next();
  };
}
/**
 * Used to merge key bindings together in a sensible way. Identical key bindings
 * likely have the same key. as a result a naive merge would result in the
 * binding added later in the merge being the only one the editor sees.
 *
 * This creator is used to create a merge that steps from the highest priority
 * to the lowest priority giving each keybinding in the chain an opportunity to
 * be run, and defer to the next command in the chain or choose not to.
 *
 * - It is used to create the [[`mergeKeyBindings`]] function helper.
 * - It is used to create the [[`mergeProsemirrorKeyBindings`]] function helper.
 *
 * @template [Schema] - the schema that is being used to create this command.
 * @template [Type] - the mapper type signature which is what the `mapper`
 * param transforms the [[`KeyBindingCommandFunction`]]  into.
 *
 * @param extensionKeymaps - the list of extension keymaps similar to the
 * following:
 *   ```ts
 *     [{ Enter: () => false}, { Escape: () => true }, { Enter: () => true }]
 *   ```
 * @param mapper - used to convert the [[`KeyBindingCommandFunction`]] into a
 * function with a different signature. It's application can be seen in
 * [[`mergeKeyBindings`]] and [[`mergeProsemirrorKeyBindings`]].
 *
 */

function mergeKeyBindingCreator(extensionKeymaps, mapper) {
  // Keep track of the previous commands as we loop through the `extensionKeymaps`.
  var previousCommandsMap = new Map(); // This is the combined mapping of commands. Essentially this function turns
  // the `extensionKeymaps` array into a single object `extensionKeymap` which
  // composes each function to give full control to the developer.

  var mappedCommands = coreHelpers.object(); // Outer loop iterates over each object keybinding.

  var _iterator4 = _createForOfIteratorHelper(extensionKeymaps),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var extensionKeymap = _step4.value;

      // Inner loop checks each keybinding on the keybinding object. `key` refers
      // to the name of the keyboard combination, like `Shift-Enter` or
      // `Cmd-Escape`.
      var _iterator5 = _createForOfIteratorHelper(coreHelpers.entries(extensionKeymap)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _previousCommandsMap$;

          var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              newCommand = _step5$value[1];

          // Get the previous commands for this key if it already exists
          var previousCommands = (_previousCommandsMap$ = previousCommandsMap.get(key)) !== null && _previousCommandsMap$ !== void 0 ? _previousCommandsMap$ : []; // Update the commands array. This will be added to the
          // `previousCommandsMap` to track the current keyboard combination.

          var commands = [...previousCommands, newCommand]; // Chain the keyboard binding so that you have all the niceties, like
          // being able to call `next` to run the remaining commands in the chain.

          var _command = chainKeyBindingCommands(...commands); // Update the previous commands with the new commands that are now being used.


          previousCommandsMap.set(key, commands); // Store a copy of the mapped commands. If this was the last time this
          // loop ran, then this is the command that would be called when a users
          // enters the keyboard combination specified by the `key` in this context.

          mappedCommands[key] = mapper(_command);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return mappedCommands;
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This is for use on remirror keybindings. See `mergeProsemirrorKeyBindings`
 * for transforming the methods into `ProsemirrorCommandFunction`'s.
 */


function mergeKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, command => command);
}
/**
 * This merges an array of keybindings into one keybinding with the priority
 * given to the items earlier in the array. `index: 0` has priority over `index:
 * 1` which has priority over `index: 2` and so on.
 *
 * This supports the [[ProsemirrorCommandFunction]] type signature where the
 * `state`, `dispatch` and `view` are passed as separate arguments.
 */

function mergeProsemirrorKeyBindings(extensionKeymaps) {
  return mergeKeyBindingCreator(extensionKeymaps, // Convert the command to have a signature of the
  // [[`ProsemirrorCommandFunction`]].
  command => (state, dispatch, view) => {
    return command({
      state,
      dispatch,
      view,
      tr: state.tr,
      next: () => false
    });
  });
}
/**
 * Determines if a Node or Mark contains the given attributes in its attributes set
 *
 * @param nodeOrMark - The Node or Mark to check
 * @param attrs - The set of attributes it must contain
 */

function containsAttributes(nodeOrMark, attrs) {
  var _nodeOrMark$attrs;

  var currentAttrs = (_nodeOrMark$attrs = nodeOrMark.attrs) !== null && _nodeOrMark$attrs !== void 0 ? _nodeOrMark$attrs : {};
  return Object.entries(attrs).every(_ref3 => {
    var _ref4 = _slicedToArray(_ref3, 2),
        name = _ref4[0],
        value = _ref4[1];

    return currentAttrs[name] === value;
  });
}

var _excluded$1 = ["content", "schema", "document", "fragment"],
    _excluded2$1 = ["json", "schema"];

function isRangeStep(step) {
  return isValidStep(step, [transform.AddMarkStep, transform.ReplaceAroundStep, transform.ReplaceStep, transform.RemoveMarkStep]);
}
/**
 * Identifies the value as having a remirror identifier. This is the core
 * predicate check for the remirror library.
 *
 * @param value - the value to be checked
 *
 * @internal
 */


function isRemirrorType(value) {
  return coreHelpers.isObject(value);
}
/**
 * Checks that the provided remirror shape is of a given type.
 *
 * @param value - any remirror shape
 * @param type - the remirror identifier type to check for
 *
 * @internal
 */

function isIdentifierOfType(value, type) {
  return coreHelpers.isArray(type) ? coreHelpers.includes(type, value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]) : type === value[coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__];
}
/**
 * Check to see if the passed value is a NodeType.
 *
 * @param value - the value to check
 */

function isNodeType(value) {
  return coreHelpers.isObject(value) && value instanceof model.NodeType;
}
/**
 * Get the node type from a potential string value.
 */

function getNodeType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.nodes, type) : type;
}
/**
 * Check to see if the passed value is a MarkType.
 *
 * @param value - the value to check
 */

function isMarkType(value) {
  return coreHelpers.isObject(value) && value instanceof model.MarkType;
}
/**
 * Get the mark type from a potential string value.
 */

function getMarkType(type, schema) {
  return coreHelpers.isString(type) ? coreHelpers.assertGet(schema.marks, type) : type;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorNode(value) {
  return coreHelpers.isObject(value) && value instanceof model.Node;
}
/**
 * Checks to see if the passed value is a ProsemirrorNode
 *
 * @param value - the value to check
 */

function isProsemirrorFragment(value) {
  return coreHelpers.isObject(value) && value instanceof model.Fragment;
}
/**
 * Checks to see if the passed value is a ProsemirrorMark
 *
 * @param value - the value to check
 */

function isProsemirrorMark(value) {
  return coreHelpers.isObject(value) && value instanceof model.Mark;
}
/**
 * Checks to see if the passed value is a Prosemirror Editor State
 *
 * @param value - the value to check
 */

function isEditorState(value) {
  return coreHelpers.isObject(value) && value instanceof state.EditorState;
}
/**
 * Checks to see if the passed value is a Prosemirror Transaction
 *
 * @param value - the value to check
 */

function isTransaction(value) {
  return coreHelpers.isObject(value) && value instanceof state.Transaction;
}
/**
 * Checks to see if the passed value is an instance of the editor schema
 *
 * @param value - the value to check
 */

function isEditorSchema(value) {
  return coreHelpers.isObject(value) && value instanceof model.Schema;
}
/**
 * Predicate checking whether the selection is a `TextSelection`.
 *
 * @param value - the value to check
 */

function isTextSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.TextSelection;
}
/**
 * Predicate checking whether the selection is an `AllSelection`.
 *
 * @param value - the value to check
 */

function isAllSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.AllSelection;
}
/**
 * Predicate checking whether the value is a Selection
 *
 * @param value - the value to check
 */

function isSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.Selection;
}
/**
 * Predicate checking whether the value is a ResolvedPosition.
 *
 * @param value - the value to check
 */

function isResolvedPos(value) {
  return coreHelpers.isObject(value) && value instanceof model.ResolvedPos;
}

/**
 * A wrapper for ProsemirrorNode.rangeHasMark that can also compare mark attributes (if supplied)
 *
 * @param props - see [[`RangeHasMarkProps`]] for options
 */
function rangeHasMark(props) {
  var trState = props.trState,
      from = props.from,
      to = props.to,
      type = props.type,
      _props$attrs = props.attrs,
      attrs = _props$attrs === void 0 ? {} : _props$attrs;
  var doc = trState.doc;
  var markType = getMarkType(type, doc.type.schema);

  if (Object.keys(attrs).length === 0) {
    return doc.rangeHasMark(from, to, markType);
  }

  var found = false;

  if (to > from) {
    doc.nodesBetween(from, to, node => {
      var _node$marks;

      if (found) {
        return false;
      }

      var marks = (_node$marks = node.marks) !== null && _node$marks !== void 0 ? _node$marks : [];
      found = marks.some(mark => {
        if (mark.type !== markType) {
          return false;
        }

        return containsAttributes(mark, attrs);
      }); // Don't descend if found

      return !found;
    });
  }

  return found;
}
/**
 * Predicate checking whether the selection is a NodeSelection
 *
 * @param value - the value to check
 */

function isNodeSelection(value) {
  return coreHelpers.isObject(value) && value instanceof state.NodeSelection;
}

/**
 * Checks that a mark is active within the selected region, or the current
 * selection point is within a region with the mark active. Used by extensions
 * to implement their active methods.
 *
 * @param props - see [[`IsMarkActiveProps`]] for options
 */
function isMarkActive(props) {
  var trState = props.trState,
      type = props.type,
      _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      from = props.from,
      to = props.to;
  var selection = trState.selection,
      doc = trState.doc,
      storedMarks = trState.storedMarks;
  var markType = coreHelpers.isString(type) ? doc.type.schema.marks[type] : type;
  !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.SCHEMA,
    message: "Mark type: ".concat(type, " does not exist on the current schema.")
  }) : coreHelpers.invariant(false) : void 0;

  if (from && to) {
    try {
      return Math.max(from, to) < doc.nodeSize && rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
        from,
        to
      }));
    } catch (_unused) {
      return false;
    }
  }

  if (selection.empty) {
    var marks = storedMarks !== null && storedMarks !== void 0 ? storedMarks : selection.$from.marks();
    return marks.some(mark => {
      if (mark.type !== type) {
        return false;
      }

      return containsAttributes(mark, attrs !== null && attrs !== void 0 ? attrs : {});
    });
  }

  return rangeHasMark(_objectSpread(_objectSpread({}, props), {}, {
    from: selection.from,
    to: selection.to
  }));
}
/**
 * Check if the specified type (NodeType) can be inserted at the current
 * selection point.
 *
 * @param state - the editor state
 * @param type - the node type
 */

function canInsertNode(state, type) {
  var $from = state.selection.$from;

  for (var depth = $from.depth; depth >= 0; depth--) {
    var index = $from.index(depth);

    try {
      if ($from.node(depth).canReplaceWith(index, index, type)) {
        return true;
      }
    } catch (_unused2) {
      return false;
    }
  }

  return false;
}
/**
 * Checks if a node looks like an empty document.
 *
 * @param node - the prosemirror node
 */

function isDocNodeEmpty(node) {
  var nodeChild = node.content.firstChild;

  if (node.childCount !== 1 || !nodeChild) {
    return false;
  }

  return nodeChild.type.isBlock && !nodeChild.childCount && nodeChild.nodeSize === 2 && (coreHelpers.isNullOrUndefined(nodeChild.marks) || nodeChild.marks.length === 0);
}

/**
 * Check whether the provided doc node has the same value as the default empty
 * node for the document. Basically checks that the document is untouched.
 *
 * This is useful for extensions like the placeholder which only should be shown
 * when the document matches the default empty state.
 */
function isDefaultDocNode(doc) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var defaultDoc = getDefaultDocNode(doc.type.schema); // Make sure the `doc` was created.

  if (!defaultDoc) {
    // No default doc exists for the current schema.
    return false;
  }

  var ignoreAttributes = options.ignoreAttributes,
      ignoreDocAttributes = options.ignoreDocAttributes;

  if (ignoreAttributes) {
    return prosemirrorNodeEquals(defaultDoc, doc);
  }

  if (ignoreDocAttributes) {
    return defaultDoc.content.eq(doc.content);
  }

  return defaultDoc.eq(doc);
}
/**
 * Check that two nodes are equal while ignoring all attributes.
 *
 * This is an alternative to the `node.eq()` method.
 */

function prosemirrorNodeEquals(node, other) {
  // The values are equivalent so return `true` early.
  if (node === other) {
    return true;
  } // Check if the markup is the same (ignoring attributes)


  var identicalMarkup = node.type === other.type && model.Mark.sameSet(node.marks, other.marks);

  function contentEquals() {
    if (node.content === other.content) {
      return true;
    }

    if (node.content.size !== other.content.size) {
      return false;
    }

    var nodeChildren = [];
    var otherChildren = [];
    node.content.forEach(node => nodeChildren.push(node));
    other.content.forEach(node => otherChildren.push(node));

    var _iterator = _createForOfIteratorHelper(nodeChildren.entries()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            index = _step$value[0],
            nodeChild = _step$value[1];

        var otherChild = otherChildren[index];

        if (!otherChild) {
          return false;
        }

        if (!prosemirrorNodeEquals(nodeChild, otherChild)) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return identicalMarkup && contentEquals();
}
/**
 * Get the default `doc` node for a given schema.
 */

function getDefaultDocNode(schema) {
  var _schema$nodes$doc$cre, _schema$nodes$doc;

  return (_schema$nodes$doc$cre = (_schema$nodes$doc = schema.nodes.doc) === null || _schema$nodes$doc === void 0 ? void 0 : _schema$nodes$doc.createAndFill()) !== null && _schema$nodes$doc$cre !== void 0 ? _schema$nodes$doc$cre : undefined;
}
/**
 * Get the default block node from the schema.
 */

function getDefaultBlockNode(schema) {
  // Set the default block node from the schema.
  for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
    var type = _Object$values[_i];

    if (type.name === 'doc') {
      continue;
    } // Break as soon as the first non 'doc' block node is encountered.


    if (type.isBlock || type.isTextblock) {
      return type;
    }
  }

  process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.SCHEMA,
    message: 'No default block node found for the provided schema.'
  }) : coreHelpers.invariant(false) ;
}
/**
 * Check if the provided node is a default block node.
 */

function isDefaultBlockNode(node) {
  return node.type === getDefaultBlockNode(node.type.schema);
}
/**
 * Checks if the current node is a block node and empty.
 *
 * @param node - the prosemirror node
 */

function isEmptyBlockNode(node) {
  return !!node && node.type.isBlock && !node.textContent && !node.childCount;
}
/**
 * Retrieve the attributes for a mark.
 *
 * @param trState - the editor state or a transaction
 * @param type - the mark type
 */

function getMarkAttributes(trState, type) {
  // Get the current range of the cursor selection.
  var _trState$selection = trState.selection,
      from = _trState$selection.from,
      to = _trState$selection.to; // The container which will be used to store the marks.

  var marks = []; // Find the nodes and add all the marks contained to the above mark container.

  trState.doc.nodesBetween(from, to, node => {
    marks.push(...node.marks);
  }); // Search for the first mark with the same type as requested

  var mark = marks.find(markItem => markItem.type.name === type.name); // Return the mark attrs when found.

  if (mark) {
    return mark.attrs;
  } // Return false to denote the mark could not be found.


  return false;
}

/**
 * Retrieve the `start` and `end` position of a mark. The `$pos` value should be
 * calculated via `tr.doc.resolve(number)`.
 *
 * @remarks
 *
 * @param $pos - the resolved ProseMirror position
 * @param type - the mark type
 * @param $end - the end position to search until. When this is provided the
 * mark will be checked for all point up until the `$end`. The first mark within
 * the range will be returned.
 *
 * To find all marks within a selection use [[`getMarkRanges`]].
 */
function getMarkRange($pos, type, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var typeName = coreHelpers.isString(type) ? type : type.name; // Find the mark if it exists.

  var mark = start.node.marks.find(_ref => {
    var markType = _ref.type;
    return markType.name === typeName;
  });
  var startIndex = $pos.index();
  var startPos = $pos.start() + start.offset;
  var endIndex = startIndex + 1;
  var endPos = startPos + start.node.nodeSize; // If the mark wasn't found then no range can be calculated. Exit early.

  if (!mark) {
    if ($end && endPos < $end.pos) {
      return getMarkRange($pos.doc.resolve(endPos + 1), type, $end);
    }

    return;
  }

  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }

  while (endIndex < $pos.parent.childCount && mark.isInSet($pos.parent.child(endIndex).marks)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }

  var text = $pos.doc.textBetween(startPos, endPos, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from: startPos,
    to: endPos,
    text,
    mark
  };
}
/**
 * Get all the ranges which contain marks for the provided selection.
 */

function getMarkRanges(selection, type) {
  var markRanges = [];
  var $from = selection.$from,
      $to = selection.$to;
  var $pos = $from;

  while (true) {
    var range = getMarkRange($pos, type, $to);

    if (!range) {
      return markRanges;
    }

    markRanges.push(range);

    if (range.to < $to.pos) {
      $pos = $from.doc.resolve(range.to + 1);
      continue;
    }

    return markRanges;
  }
}
/**
 * Return true if the step provided an instance of any of the provided step
 * constructors.
 *
 * @param step - the step to check
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function isValidStep(step, StepTypes) {
  return StepTypes.length === 0 || StepTypes.some(Constructor => step instanceof Constructor);
}

/**
 * Get all the ranges of changes for the provided transaction.
 *
 * This can be used to gather specific parts of the document which require
 * decorations to be recalculated or where nodes should be updated.
 *
 * This is adapted from the answer
 * [here](https://discuss.prosemirror.net/t/find-new-node-instances-and-track-them/96/7)
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */
function getChangedRanges(tr) {
  var StepTypes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  // The holder for the ranges value which will be returned from this function.
  var ranges = [];
  var rawRanges = [];

  var _iterator2 = _createForOfIteratorHelper(tr.steps),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var step = _step2.value;

      if (!isValidStep(step, StepTypes)) {
        continue;
      }

      var stepMap = step.getMap(); // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore @see https://github.com/ProseMirror/prosemirror/issues/1075

      if (stepMap.ranges.length === 0 && isRangeStep(step)) {
        var from = step.from,
            to = step.to;

        if (from === undefined || to === undefined) {
          continue;
        }

        rawRanges.push({
          from,
          to
        });
      } else {
        step.getMap().forEach((from, to) => {
          rawRanges.push({
            from,
            to
          });
        });
      }
    } // Sort the ranges.

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var sortedRanges = coreHelpers.sort(rawRanges, (a, z) => a.from - z.from); // Merge sorted ranges into the new range.

  var _iterator3 = _createForOfIteratorHelper(sortedRanges),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          _from = _step3$value.from,
          _to = _step3$value.to;
      // The last item in the accumulated `ranges`.
      var lastRange = ranges[ranges.length - 1]; // True when range added has no overlap with the previous end value.

      var noOverlap = !lastRange || lastRange.to < _from;

      if (noOverlap) {
        // Add the new range when no overlap is found.
        var newFrom = tr.mapping.map(_from, -1);
        var newTo = tr.mapping.map(_to);
        ranges.push({
          from: newFrom,
          to: newTo,
          prevFrom: tr.mapping.invert().map(newFrom, -1),
          prevTo: tr.mapping.invert().map(newTo)
        });
      } else if (lastRange) {
        // Update the lastRange's end value.
        lastRange.to = Math.max(lastRange.from, _to);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return coreHelpers.uniqueBy(ranges, _ref2 => {
    var from = _ref2.from,
        to = _ref2.to,
        prevFrom = _ref2.prevFrom,
        prevTo = _ref2.prevTo;
    return "".concat(from, "_").concat(to, "_").concat(prevFrom, "_").concat(prevTo);
  });
}
/**
 * Get all the changed node ranges for a provided transaction.
 *
 * @param tr - the transaction received with updates applied.
 * @param StepTypes - the valid Step Constructors. Set to an empty array to
 * accept all Steps.
 */

function getChangedNodeRanges(tr, StepTypes) {
  // The container of the ranges to be returned from this function.
  var nodeRanges = [];
  var ranges = getChangedRanges(tr, StepTypes);

  var _iterator4 = _createForOfIteratorHelper(ranges),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var range = _step4.value;

      try {
        var $from = tr.doc.resolve(range.from);
        var $to = tr.doc.resolve(range.to); // Find the node range for this provided range.

        var nodeRange = $from.blockRange($to); // Make sure a valid node is available.

        if (nodeRange) {
          nodeRanges.push(nodeRange);
        }
      } catch (_unused3) {// Changed ranged outside the document
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return nodeRanges;
}
/**
 * Retrieves the text content from a slice
 *
 * @remarks
 * A utility that's useful for pulling text content from a slice which is
 * usually created via `selection.content()`
 *
 * @param slice - the prosemirror slice
 */

function getTextContentFromSlice(slice) {
  var _slice$content$firstC, _slice$content$firstC2;

  return (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
}

/**
 * Takes an empty selection and expands it out to the nearest group not matching
 * the excluded characters.
 *
 * @remarks
 *
 * Can be used to find the nearest selected word. See {@link getSelectedWord}
 *
 * @param state - the editor state or a transaction
 * @param exclude - the regex pattern to exclude
 * @returns false if not a text selection or if no expansion available
 */
function getSelectedGroup(state$1, exclude) {
  if (!isTextSelection(state$1.selection)) {
    return;
  }

  var _state$selection = state$1.selection,
      from = _state$selection.from,
      to = _state$selection.to;

  var getChar = (start, end) => getTextContentFromSlice(state.TextSelection.create(state$1.doc, start, end).content());

  for (var char = getChar(from - 1, from); char && !exclude.test(char); from--, char = getChar(from - 1, from)) {// Step backwards until reaching first excluded character or empty text
    // content.
  }

  for (var _char = getChar(to, to + 1); _char && !exclude.test(_char); to++, _char = getChar(to, to + 1)) {// Step forwards until reaching the first excluded character or empty text
    // content
  }

  if (from === to) {
    return;
  }

  var text = state$1.doc.textBetween(from, to, coreConstants.LEAF_NODE_REPLACING_CHARACTER, '\n\n');
  return {
    from,
    to,
    text
  };
}
/**
 * Retrieves the nearest space separated word from the current selection.
 *
 * @remarks
 *
 * This always expands outward so that given: `The tw<start>o words<end>` The
 * selection would become `The <start>two words<end>`
 *
 * In other words it expands until it meets an invalid character.
 *
 * @param state - the editor state or transaction.
 */

function getSelectedWord(state) {
  return getSelectedGroup(state, /\W/);
}
/**
 * Get matching string from a list or single value
 *
 * @remarks
 * Get attrs can be called with a direct match string or array of string
 * matches. This method should be used to retrieve the required string.
 *
 * The index of the matched array used defaults to 0 but can be updated via the
 * second parameter.
 *
 * @param match - the match(es)
 * @param index - the zero-index point from which to start
 */

function getMatchString(match) {
  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var value = coreHelpers.isArray(match) ? match[index] : match; // Throw an error if value is not defined for the index.

  coreHelpers.assert(coreHelpers.isString(value), "No match string found for match ".concat(match));
  return value !== null && value !== void 0 ? value : '';
}
/**
 * Checks whether the cursor is at the end of the state.doc
 *
 * @param state - the editor state
 */

function atDocEnd(state) {
  return state.doc.nodeSize - state.selection.$to.pos - 2 === state.selection.$to.depth;
}
/**
 * Checks whether the cursor is at the beginning of the state.doc
 *
 * @param state - the editor state
 */

function atDocStart(state) {
  return state.selection.$from.pos === state.selection.$from.depth;
}
/**
 * Get the start position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function startPositionOfParent($pos) {
  return $pos.start($pos.depth);
}
/**
 * Get the end position of the parent of the current resolve position
 *
 * @param $pos - the resolved `ProseMirror` position
 */

function endPositionOfParent($pos) {
  return $pos.end($pos.depth) + 1;
}
/**
 * Retrieve the current position of the cursor
 *
 * @param selection - the editor selection
 * @returns a resolved position only when the selection is a text selection
 */

function getCursor(selection) {
  return isTextSelection(selection) ? selection.$cursor : undefined;
}
/**
 * Checks whether a Prosemirror node is the top level `doc` node
 *
 * @param node - the prosemirror node
 * @param schema - the prosemirror schema to check against
 */

function isDocNode(node, schema) {
  if (!isProsemirrorNode(node)) {
    return false;
  }

  if (schema) {
    return node.type === schema.nodes.doc;
  }

  return node.type.name === 'doc';
}
/**
 * Checks whether the passed in JSON is a valid object node
 *
 * @param value - the value to check
 */

function isRemirrorJSON(value) {
  return coreHelpers.isObject(value) && value.type === 'doc' && Array.isArray(value.content);
}
/**
 * This type is the combination of all the registered string handlers for the
 * extension. This is used rather than the `StringHandlers` in order to enforce
 * the type signature of the handler method, which isn't possible with the
 * interface.
 */

/**
 * Return true when the provided value is an anchor / head selection property
 */
function isAnchorHeadObject(value) {
  return coreHelpers.isObject(value) && coreHelpers.isNumber(value.anchor) && coreHelpers.isNumber(value.head);
}
/**
 * Get the nearest valid text selection to the provided selection parameter.
 */

function getTextSelection(selection, doc) {
  var max = doc.nodeSize - 2;
  var min = 0;
  var pos;
  /** Ensure the selection is within the current document range */

  var clampToDocument = value => coreHelpers.clamp({
    min,
    max,
    value
  });

  if (isSelection(selection)) {
    return selection;
  }

  if (selection === 'all') {
    return new state.AllSelection(doc);
  }

  if (selection === 'start') {
    pos = min;
  } else if (selection === 'end') {
    pos = max;
  } else if (isResolvedPos(selection)) {
    pos = selection.pos;
  } else {
    pos = selection;
  }

  if (coreHelpers.isNumber(pos)) {
    pos = clampToDocument(pos);
    return state.TextSelection.near(doc.resolve(pos));
  }

  if (isAnchorHeadObject(pos)) {
    var _anchor = clampToDocument(pos.anchor);

    var _head = clampToDocument(pos.head);

    return state.TextSelection.create(doc, _anchor, _head);
  } // In this case assume that `from` is the fixed anchor and `to` is the movable
  // head.


  var anchor = clampToDocument(pos.from);
  var head = clampToDocument(pos.to);
  return state.TextSelection.create(doc, anchor, head);
}
/**
 * A function that converts a string into a `ProsemirrorNode`.
 */

// The maximum attempts to check invalid content before throwing an an error.
var MAX_ATTEMPTS = 3;
/**
 * Creates a document node from the passed in content and schema.
 *
 * @remirror
 *
 * This supports a primitive form of error handling. When an error occurs, the
 * `onError` handler will be called along with the error produced by the Schema
 * and it is up to you as a developer to decide how to transform the invalid
 * content into valid content.
 *
 * Please note that the `onError` is only called when the content is a JSON
 * object. It is not called for a `string`, the `ProsemirrorNode` or the
 * `EditorState`. The reason for this is that the `string` requires a `stringHandler`
 * which is defined by the developer and transforms the content. That is the
 * point that error's should be handled. The editor state and the
 * `ProsemirrorNode` are similar. They need to be created by the developer and
 * as a result, the errors should be handled at the point of creation rather
 * than when the document is being applied to the editor.
 */

function createDocumentNode(props) {
  var content = props.content,
      schema = props.schema,
      document = props.document,
      stringHandler = props.stringHandler,
      onError = props.onError,
      _props$attempts = props.attempts,
      attempts = _props$attempts === void 0 ? 0 : _props$attempts; // If there is an `onError` handler then check the attempts does not exceed
  // the maximum, otherwise only allow one attempt.

  var attemptsRemaining = onError && attempts <= MAX_ATTEMPTS || attempts === 0;
  !attemptsRemaining ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.INVALID_CONTENT,
    message: 'The invalid content has been called recursively more than ${MAX_ATTEMPTS} times. The content is invalid and the error handler has not been able to recover properly.'
  }) : coreHelpers.invariant(false) : void 0;

  if (coreHelpers.isString(content)) {
    !stringHandler ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_CONTENT,
      message: "The string '".concat(content, "' was added to the editor, but no `stringHandler` was added. Please provide a valid string handler which transforms your content to a `ProsemirrorNode` to prevent this error.")
    }) : coreHelpers.invariant(false) : void 0;
    var options = {
      document,
      content,
      schema
    }; // With string content it is up to you the developer to ensure there are no
    // errors in the produced content.

    return stringHandler(options);
  } // If passing in an editor state, it is left to the developer to make sure the
  // state they created is valid.


  if (isEditorState(content)) {
    return content.doc;
  } // When passing the prosemirror no error checking is done. Before creating the
  // node you should manually ensure that it is valid.


  if (isProsemirrorNode(content)) {
    return content;
  } // At this point the only possible solution is that the content is a json
  // object so we try to convert the json to a valid object.


  try {
    // This will throw an error for invalid content.
    return schema.nodeFromJSON(content);
  } catch (error) {
    var details = getInvalidContent({
      schema,
      error,
      json: content
    });
    var transformedContent = onError === null || onError === void 0 ? void 0 : onError(details);
    !transformedContent ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_CONTENT,
      message: "An error occurred when processing the content. Please provide an `onError` handler to process the invalid content: ".concat(JSON.stringify(details.invalidContent, null, 2))
    }) : coreHelpers.invariant(false) : void 0;
    return createDocumentNode(_objectSpread(_objectSpread({}, props), {}, {
      content: transformedContent,
      attempts: attempts + 1
    }));
  }
}
/**
 * Checks which environment should be used. Returns true when we are in the dom
 * environment.
 *
 * @param forceEnvironment - force a specific environment to override the
 * outcome
 */

function shouldUseDomEnvironment(forceEnvironment) {
  return forceEnvironment === 'dom' || environment.isBrowser && !forceEnvironment;
}
/**
 * Get the document implementation within a node environment. This is only
 * included in the build when using node.
 */

function getDocumentForNodeEnvironment() {
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'jsdom'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
        JSDOM = _require.JSDOM;

    return new JSDOM('').window.document;
  } catch (_unused4) {
    try {
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      return Object(function webpackMissingModule() { var e = new Error("Cannot find module 'domino'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())();
    } catch (_unused5) {
      return __webpack_require__(103);
    }
  }
}
/**
 * Retrieves the document based on the environment we are currently in.
 *
 * @param forceEnvironment - force a specific environment
 */


function getDocument(forceEnvironment) {
  if (typeof document !== 'undefined') {
    return document;
  }

  return shouldUseDomEnvironment(forceEnvironment) ? document : getDocumentForNodeEnvironment();
}

/**
 * Convert a node into its DOM representative
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 */
function prosemirrorNodeToDom(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var fragment = isDocNode(node, node.type.schema) ? node.content : model.Fragment.from(node);
  return model.DOMSerializer.fromSchema(node.type.schema).serializeFragment(fragment, {
    document
  });
}

function elementFromString(html, document) {
  var _defaultView, _ref3;

  var parser = new ((_defaultView = (_ref3 = document !== null && document !== void 0 ? document : getDocument()) === null || _ref3 === void 0 ? void 0 : _ref3.defaultView) !== null && _defaultView !== void 0 ? _defaultView : window).DOMParser();
  return parser.parseFromString("<body>".concat(html, "</body>"), 'text/html').body;
}
/**
 * Convert the provided `node` to a html string.
 *
 * @param node - the node to extract html from.
 * @param document - the document to use for the DOM
 *
 * ```ts
 * import { EditorState, prosemirrorNodeToHtml } from 'remirror';
 *
 * function convertStateToHtml(state: EditorState): string {
 *   return prosemirrorNodeToHtml(state.doc);
 * }
 * ```
 */


function prosemirrorNodeToHtml(node) {
  var document = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getDocument();
  var element = document.createElement('div');
  element.append(prosemirrorNodeToDom(node, document));
  return element.innerHTML;
}
function htmlToProsemirrorNode(props) {
  var content = props.content,
      schema = props.schema;
      props.document;
      var _props$fragment = props.fragment,
      fragment = _props$fragment === void 0 ? false : _props$fragment,
      parseOptions = _objectWithoutProperties(props, _excluded$1);

  var element = elementFromString(content);
  var parser = model.DOMParser.fromSchema(schema);
  return fragment ? parser.parseSlice(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions)).content : parser.parse(element, _objectSpread(_objectSpread({}, defaultParseOptions), parseOptions));
}
var defaultParseOptions = {
  preserveWhitespace: false
};
/**
 * A wrapper around `state.doc.toJSON` which returns the state as a
 * `RemirrorJSON` object.
 */

function getRemirrorJSON(content) {
  return isProsemirrorNode(content) ? content.toJSON() : content.doc.toJSON();
}

/**
 * Check if two states are equal.
 */
function areStatesEqual(stateA, stateB) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  // The states are identical, so they're equal.
  if (stateA === stateB) {
    return true;
  } // If the content is different then, no, not equal.


  if (!stateA.doc.eq(stateB.doc)) {
    return false;
  } // If we care about selection and selection is not the same, then not equal.


  if (options.checkSelection && !stateA.selection.eq(stateB.selection)) {
    return false;
  } // If the schema are not compatible then no, not equal.


  if (!areSchemasCompatible(stateA.schema, stateB.schema)) {
    return false;
  }

  return true;
}
/**
 * Check that the nodes and marks present on `schemaA` are also present on
 * `schemaB`.
 */

function areSchemasCompatible(schemaA, schemaB) {
  if (schemaA === schemaB) {
    return true;
  }

  var marksA = coreHelpers.keys(schemaA.marks);
  var marksB = coreHelpers.keys(schemaB.marks);
  var nodesA = coreHelpers.keys(schemaA.nodes);
  var nodesB = coreHelpers.keys(schemaB.nodes);

  if (marksA.length !== marksB.length || nodesA.length !== nodesB.length) {
    return false;
  }

  var _iterator5 = _createForOfIteratorHelper(marksA),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var mark = _step5.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!marksB.includes(mark)) {
        return false;
      }
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  var _iterator6 = _createForOfIteratorHelper(nodesA),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var node = _step6.value;

      // No reverse check needed since we know the keys are unique and the lengths
      // are identical.
      if (!nodesB.includes(node)) {
        return false;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return true;
}
/**
 * Return attributes for a node excluding those that were provided as extra
 * attributes.
 *
 * @param attrs - The source attributes
 * @param extra - The extra attribute schema for this node
 */

function omitExtraAttributes(attrs, extra) {
  var extraAttributeNames = coreHelpers.keys(extra.defaults());
  return coreHelpers.omit(_objectSpread({}, attrs), extraAttributeNames);
}
/**
 * Take the `style` string attribute and combine it with the provided style
 * object.
 */

function joinStyles(styleObject, initialStyles) {
  var start = '';

  if (initialStyles) {
    start = "".concat(initialStyles.trim());
  }

  var end = cssInJsUtils.cssifyObject(styleObject);

  if (!end) {
    return start;
  }

  var separator = start.endsWith(';') ? ' ' : ' ';
  return "".concat(start).concat(separator).concat(end);
}

/**
 * Find the different ranges of text between a provided range with support for
 * traversing multiple nodes.
 */
function textBetween(props) {
  var from = props.from,
      to = props.to,
      doc = props.doc;
  var positions = [];
  doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isText || !node.text) {
      return;
    }

    var offset = Math.max(from, pos) - pos;
    positions.push({
      pos: pos + offset,
      text: node.text.slice(offset, to - pos)
    });
  });
  return positions;
}
/**
 * Get the full range of the selectable content in the ProseMirror `doc`.
 */

function getDocRange(doc) {
  var _AllSelection = new state.AllSelection(doc),
      from = _AllSelection.from,
      to = _AllSelection.to;

  return {
    from,
    to
  };
}
/**
 * A description of an invalid content block (representing a node or a mark).
 */

var transformers = {
  /**
   * Remove every invalid block from the editor. This is a destructive action
   * and should only be applied if you're sure it's the best strategy.
   *
   * @param json - the content as a json object.
   * @param invalidContent - the list of invalid items as passed to the error
   * handler.
   */
  remove(json, invalidContent) {
    var newJSON = json;

    var _iterator7 = _createForOfIteratorHelper(invalidContent),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var block = _step7.value;

        if (block.invalidParentNode) {
          continue;
        }

        newJSON = coreHelpers.unset(block.path, newJSON);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return newJSON;
  }

};

/**
 * Get the invalid parameter which is passed to the `onError` handler.
 */
function getInvalidContent(_ref4) {
  var json = _ref4.json,
      schema = _ref4.schema,
      extra = _objectWithoutProperties(_ref4, _excluded2$1);

  var validMarks = new Set(coreHelpers.keys(schema.marks));
  var validNodes = new Set(coreHelpers.keys(schema.nodes));
  var invalidContent = checkForInvalidContent({
    json,
    path: [],
    validNodes,
    validMarks
  });
  return _objectSpread({
    json,
    invalidContent,
    transformers
  }, extra);
}

/**
 * Get the invalid content from the `RemirrorJSON`.
 */
function checkForInvalidContent(props) {
  var json = props.json,
      validMarks = props.validMarks,
      validNodes = props.validNodes,
      _props$path = props.path,
      path = _props$path === void 0 ? [] : _props$path;
  var valid = {
    validMarks,
    validNodes
  };
  var invalidNodes = [];
  var type = json.type,
      marks = json.marks,
      content = json.content;
  var _props$invalidParentM = props.invalidParentMark,
      invalidParentMark = _props$invalidParentM === void 0 ? false : _props$invalidParentM,
      _props$invalidParentN = props.invalidParentNode,
      invalidParentNode = _props$invalidParentN === void 0 ? false : _props$invalidParentN;

  if (marks) {
    var invalidMarks = [];

    var _iterator8 = _createForOfIteratorHelper(marks.entries()),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var _step8$value = _slicedToArray(_step8.value, 2),
            index = _step8$value[0],
            mark = _step8$value[1];

        var name = coreHelpers.isString(mark) ? mark : mark.type;

        if (validMarks.has(name)) {
          continue;
        }

        invalidMarks.unshift({
          name,
          path: [...path, 'marks', "".concat(index)],
          type: 'mark',
          invalidParentMark,
          invalidParentNode
        });
        invalidParentMark = true;
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    invalidNodes.push(...invalidMarks);
  }

  if (!validNodes.has(type)) {
    invalidNodes.push({
      name: type,
      type: 'node',
      path,
      invalidParentMark,
      invalidParentNode
    });
    invalidParentNode = true;
  }

  if (content) {
    var invalidContent = [];

    var _iterator9 = _createForOfIteratorHelper(content.entries()),
        _step9;

    try {
      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
        var _step9$value = _slicedToArray(_step9.value, 2),
            _index = _step9$value[0],
            value = _step9$value[1];

        invalidContent.unshift(...checkForInvalidContent(_objectSpread(_objectSpread({}, valid), {}, {
          json: value,
          path: [...path, 'content', "".concat(_index)],
          invalidParentMark,
          invalidParentNode
        })));
      }
    } catch (err) {
      _iterator9.e(err);
    } finally {
      _iterator9.f();
    }

    invalidNodes.unshift(...invalidContent);
  }

  return invalidNodes;
}
/**
 * Checks that the selection is an empty text selection at the end of its parent
 * node.
 */


function isEndOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset >= selection.$cursor.parent.content.size);
}
/**
 * Checks that the selection is an empty text selection at the start of its
 * parent node.
 */

function isStartOfTextBlock(selection) {
  return !!(isTextSelection(selection) && selection.$cursor && selection.$cursor.parentOffset <= 0);
}
/**
 * Returns true when the selection is a text selection at the start of the
 * document.
 */

function isStartOfDoc(selection) {
  var selectionAtStart = state.Selection.atStart(selection.$anchor.doc);
  return !!(isStartOfTextBlock(selection) && selectionAtStart.anchor === selection.anchor);
}

/**
 * Update the selection with the provided MarkType.
 *
 * @param props - see [[`UpdateMarkProps`]] for options
 */
function updateMark(props) {
  return _ref => {
    var dispatch = _ref.dispatch,
        tr = _ref.tr;
    var type = props.type,
        _props$attrs = props.attrs,
        attrs = _props$attrs === void 0 ? coreHelpers.object() : _props$attrs,
        appendText = props.appendText,
        range = props.range;
    var selection = range ? state.TextSelection.create(tr.doc, range.from, range.to) : tr.selection;
    var $from = selection.$from,
        from = selection.from,
        to = selection.to;
    var applicable = $from.depth === 0 ? tr.doc.type.allowsMarkType(type) : false;
    tr.doc.nodesBetween(from, to, node => {
      if (applicable) {
        return false;
      }

      if (node.inlineContent && node.type.allowsMarkType(type)) {
        applicable = true;
        return;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, type.create(attrs)) && appendText ? tr.insertText(appendText) : tr);
    return true;
  };
}
/**
 * Lift the selected block, or the closest ancestor block of the selection that
 * can be lifted, out of its parent node.
 *
 * Adapted from
 * https://github.com/ProseMirror/prosemirror-commands/blob/3126d5c625953ba590c5d3a0db7f1009f46f1571/src/commands.js#L212-L221
 */

function lift(_ref2) {
  var tr = _ref2.tr,
      dispatch = _ref2.dispatch;
  var _tr$selection = tr.selection,
      $from = _tr$selection.$from,
      $to = _tr$selection.$to;
  var range = $from.blockRange($to);
  var target = range && transform.liftTarget(range);

  if (!coreHelpers.isNumber(target) || !range) {
    return false;
  }

  dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.lift(range, target).scrollIntoView());
  return true;
}
/**
 * Wrap the selection or the provided text in a node of the given type with the
 * given attributes.
 */

function wrapIn(type) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var nodeType = coreHelpers.isString(type) ? coreHelpers.assertGet(state.schema.nodes, type) : type;

    var _getTextSelection = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection.from,
        to = _getTextSelection.to;

    var $from = tr.doc.resolve(from);
    var $to = tr.doc.resolve(to);
    var blockRange = $from.blockRange($to);
    var wrapping = blockRange && transform.findWrapping(blockRange, nodeType, attrs);

    if (!wrapping || !blockRange) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.wrap(blockRange, wrapping).scrollIntoView());
    return true;
  };
}
/**
 * Toggle between wrapping an inactive node with the provided node type, and
 * lifting it up into it's parent.
 *
 * @param nodeType - the node type to toggle
 * @param attrs - the attrs to use for the node
 */

function toggleWrap(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var selection = arguments.length > 2 ? arguments[2] : undefined;
  return props => {
    var tr = props.tr,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });

    if (activeNode) {
      return lift(props);
    }

    return wrapIn(nodeType, attrs, selection)(props);
  };
}
/**
 * Returns a command that tries to set the selected textblocks to the
 * given node type with the given attributes.
 *
 * @param nodeType - the name of the node or the [[`NodeType`]].
 */

function setBlockType(nodeType, attrs, selection) {
  var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  return function (props) {
    var tr = props.tr,
        dispatch = props.dispatch,
        state = props.state;
    var type = coreHelpers.isString(nodeType) ? coreHelpers.assertGet(state.schema.nodes, nodeType) : nodeType;

    var _getTextSelection2 = getTextSelection(selection !== null && selection !== void 0 ? selection : tr.selection, tr.doc),
        from = _getTextSelection2.from,
        to = _getTextSelection2.to;

    var applicable = false;
    var activeAttrs;
    tr.doc.nodesBetween(from, to, (node, pos) => {
      if (applicable) {
        // Exit early and don't descend.
        return false;
      }

      if (!node.isTextblock || node.hasMarkup(type, attrs)) {
        return;
      }

      if (node.type === type) {
        applicable = true;
        activeAttrs = node.attrs;
        return;
      }

      var $pos = tr.doc.resolve(pos);
      var index = $pos.index();
      applicable = $pos.parent.canReplaceWith(index, index + 1, type);

      if (applicable) {
        activeAttrs = $pos.parent.attrs;
      }

      return;
    });

    if (!applicable) {
      return false;
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setBlockType(from, to, type, _objectSpread(_objectSpread({}, preserveAttrs ? activeAttrs : {}), attrs)).scrollIntoView());
    return true;
  };
}

/**
 * Toggle a block between the provided type and toggleType.
 *
 * @param toggleProps - see [[`ToggleBlockItemProps`]] for available options
 */
function toggleBlockItem(toggleProps) {
  return props => {
    var _toggleProps$toggleTy;

    var tr = props.tr,
        state = props.state;
    var type = toggleProps.type,
        attrs = toggleProps.attrs,
        _toggleProps$preserve = toggleProps.preserveAttrs,
        preserveAttrs = _toggleProps$preserve === void 0 ? true : _toggleProps$preserve;
    var activeNode = getActiveNode({
      state: tr,
      type,
      attrs
    });
    var toggleType = (_toggleProps$toggleTy = toggleProps.toggleType) !== null && _toggleProps$toggleTy !== void 0 ? _toggleProps$toggleTy : getDefaultBlockNode(state.schema);

    if (activeNode) {
      return setBlockType(toggleType, _objectSpread(_objectSpread({}, preserveAttrs ? activeNode.node.attrs : {}), attrs))(props);
    }

    var toggleNode = getActiveNode({
      state: tr,
      type: toggleType,
      attrs
    });
    return setBlockType(type, _objectSpread(_objectSpread({}, preserveAttrs ? toggleNode === null || toggleNode === void 0 ? void 0 : toggleNode.node.attrs : {}), attrs))(props);
  };
}

/**
 * Taken from https://stackoverflow.com/a/4900484
 *
 * Check that the browser is chrome. Supports passing a minimum version to check
 * that it is a greater than or equal to this version.
 */
function isChrome() {
  var minVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var parsedAgent = navigator.userAgent.match(/Chrom(e|ium)\/(\d+)\./);
  return parsedAgent ? Number.parseInt(coreHelpers.assertGet(parsedAgent, 2), 10) >= minVersion : false;
}
/**
 * Checks the selection for the current state and updates the active transaction
 * to a selection that is consistent with the initial selection.
 *
 * @param state - the editor state before any updates
 * @param tr - the transaction which has been updated and may have impacted the
 * selection.
 */

function preserveSelection(selection, tr) {
  // Get the previous movable part of the cursor selection.
  var head = selection.head,
      empty = selection.empty,
      anchor = selection.anchor; // Map this movable cursor selection through each of the steps that have happened in
  // the transaction.

  var _iterator = _createForOfIteratorHelper(tr.steps),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var step = _step.value;
      var map = step.getMap();
      head = map.map(head);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (empty) {
    // Update the transaction with the new text selection.
    tr.setSelection(state.TextSelection.create(tr.doc, head));
  } else {
    tr.setSelection(state.TextSelection.create(tr.doc, anchor, head));
  }
}
/**
 * Replaces text with an optional appended string at the end.
 *
 * @param props - see [[`ReplaceTextProps`]]
 */

function replaceText(props) {
  var _props$attrs2 = props.attrs,
      attrs = _props$attrs2 === void 0 ? {} : _props$attrs2,
      _props$appendText = props.appendText,
      appendText = _props$appendText === void 0 ? '' : _props$appendText,
      _props$content = props.content,
      content = _props$content === void 0 ? '' : _props$content,
      _props$keepSelection = props.keepSelection,
      keepSelection = _props$keepSelection === void 0 ? false : _props$keepSelection,
      range = props.range;
  return _ref3 => {
    var _ref4, _props$selection, _schema$nodes$props$t;

    var state = _ref3.state,
        tr = _ref3.tr,
        dispatch = _ref3.dispatch;
    var schema = state.schema;
    var selection = getTextSelection((_ref4 = (_props$selection = props.selection) !== null && _props$selection !== void 0 ? _props$selection : range) !== null && _ref4 !== void 0 ? _ref4 : tr.selection, tr.doc);
    var index = selection.$from.index();
    var from = selection.from,
        to = selection.to,
        $from = selection.$from;
    var type = coreHelpers.isString(props.type) ? (_schema$nodes$props$t = schema.nodes[props.type]) !== null && _schema$nodes$props$t !== void 0 ? _schema$nodes$props$t : schema.marks[props.type] : props.type;
    !(coreHelpers.isString(props.type) ? type : true) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.SCHEMA,
      message: "Schema contains no marks or nodes with name ".concat(type)
    }) : coreHelpers.invariant(false) : void 0;

    if (isNodeType(type)) {
      if (!$from.parent.canReplaceWith(index, index, type)) {
        return false;
      }

      tr.replaceWith(from, to, type.create(attrs, content ? schema.text(content) : undefined));
    } else {
      !content ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        message: '`replaceText` cannot be called without content when using a mark type'
      }) : coreHelpers.invariant(false) : void 0;
      tr.replaceWith(from, to, schema.text(content, isMarkType(type) ? [type.create(attrs)] : undefined));
    } // Only append the text if text is provided (ignore the empty string).


    if (appendText) {
      tr.insertText(appendText);
    }

    if (keepSelection) {
      preserveSelection(state.selection, tr);
    }

    if (dispatch) {
      // A workaround for a chrome bug
      // https://github.com/ProseMirror/prosemirror/issues/710#issuecomment-338047650
      if (isChrome(60)) {
        var _document$getSelectio;

        (_document$getSelectio = document.getSelection()) === null || _document$getSelectio === void 0 ? void 0 : _document$getSelectio.empty();
      }

      dispatch(tr);
    }

    return true;
  };
}
/**
 * Retrieve the first mark at a given resolved position `$pos` or range
 *
 * @remarks
 *
 * If multiple marks are present, the returned mark will be the mark with highest priority.
 *
 * @param $pos - the resolved ProseMirror position
 * @param $end - the end position to search until. When this is provided
 * it will search for a mark until the `$end`. The first mark within
 * the range will be returned.
 */

function getFirstMark($pos, $end) {
  // Get the start position of the current node that the `$pos` value was
  // calculated for.
  var start = $pos.parent.childAfter($pos.parentOffset); // If the position provided was incorrect and no node exists for this start
  // position exit early.

  if (!start.node) {
    return;
  }

  var _start$node = start.node,
      marks = _start$node.marks,
      nodeSize = _start$node.nodeSize;

  if (marks[0]) {
    return marks[0].type;
  }

  var startPos = $pos.start() + start.offset;
  var endPos = startPos + nodeSize;
  return getFirstMark($pos.doc.resolve(endPos + 1));
}

/**
 * Removes a mark from the current selection or provided range.
 *
 * @param props - see [[`RemoveMarkProps`]] for options
 */
function removeMark(props) {
  return _ref5 => {
    var _ref6, _props$selection2;

    var dispatch = _ref5.dispatch,
        tr = _ref5.tr,
        state = _ref5.state;
    var type = props.type,
        _props$expand = props.expand,
        expand = _props$expand === void 0 ? true : _props$expand,
        range = props.range;
    var selection = getTextSelection((_ref6 = (_props$selection2 = props.selection) !== null && _props$selection2 !== void 0 ? _props$selection2 : range) !== null && _ref6 !== void 0 ? _ref6 : tr.selection, tr.doc);
    var from = selection.from,
        to = selection.to,
        $from = selection.$from,
        $to = selection.$to;
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;

    if (markType !== null) {
      !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        code: coreConstants.ErrorConstant.SCHEMA,
        message: "Mark type: ".concat(type, " does not exist on the current schema.")
      }) : coreHelpers.invariant(false) : void 0;
    } // If no mark type was supplied, get the first mark present on this node to determine a mark range


    var rangeMark = markType !== null && markType !== void 0 ? markType : getFirstMark($from);

    if (!rangeMark) {
      return false;
    }

    var markRange = getMarkRange($from, rangeMark, $to);

    if (expand && markRange) {
      // Expand the from position to the mark range (if it is smaller) - keep bound within doc
      from = Math.max(0, Math.min(from, markRange.from)); // Expand the to position to the mark range (if it is larger) - keep bound within doc

      to = Math.min(Math.max(to, markRange.to), tr.doc.nodeSize - 2);
    }

    dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, coreHelpers.isNumber(to) ? to : from, isMarkType(markType) ? markType : undefined));
    return true;
  };
}

/**
 * Return true when the provided key is the the Command (⌘) key. Takes into
 * account the platform.
 */

function isCommandKey(key) {
  var allowedKeys = ['command', 'cmd', 'meta'];

  if (environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}
/**
 * Return true when the provided key is the the Control (⌃) key. Takes into
 * account the platform.
 */


function isControlKey(key) {
  var allowedKeys = ['control', 'ctrl'];

  if (!environment.isMac) {
    allowedKeys.push('mod');
  }

  return allowedKeys.includes(key);
}

/**
 * Convert a keyboard shortcut into symbols which and keys.
 */
function getShortcutSymbols(shortcut) {
  var symbols = [];

  var _iterator = _createForOfIteratorHelper(shortcut.split('-')),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      key = key.toLowerCase();

      if (isCommandKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '⌘',
          key: 'command',
          i18n: messages.CoreUtilsMessages.COMMAND_KEY
        });
        continue;
      }

      if (isControlKey(key)) {
        symbols.push({
          type: 'modifier',
          symbol: '⌃',
          key: 'control',
          i18n: messages.CoreUtilsMessages.CONTROL_KEY
        });
        continue;
      }

      switch (key) {
        case 'shift':
          symbols.push({
            type: 'modifier',
            symbol: '⇧',
            key,
            i18n: messages.CoreUtilsMessages.SHIFT_KEY
          });
          continue;

        case 'alt':
          symbols.push({
            type: 'modifier',
            symbol: '⌥',
            key,
            i18n: messages.CoreUtilsMessages.ALT_KEY
          });
          continue;

        case '\n':
        case '\r':
        case 'enter':
          symbols.push({
            type: 'named',
            symbol: '↵',
            key,
            i18n: messages.CoreUtilsMessages.ENTER_KEY
          });
          continue;

        case 'backspace':
          symbols.push({
            type: 'named',
            symbol: '⌫',
            key,
            i18n: messages.CoreUtilsMessages.BACKSPACE_KEY
          });
          continue;

        case 'delete':
          symbols.push({
            type: 'named',
            symbol: '⌦',
            key,
            i18n: messages.CoreUtilsMessages.DELETE_KEY
          });
          continue;

        case 'escape':
          symbols.push({
            type: 'named',
            symbol: '␛',
            key,
            i18n: messages.CoreUtilsMessages.ESCAPE_KEY
          });
          continue;

        case 'tab':
          symbols.push({
            type: 'named',
            symbol: '⇥',
            key,
            i18n: messages.CoreUtilsMessages.TAB_KEY
          });
          continue;

        case 'capslock':
          symbols.push({
            type: 'named',
            symbol: '⇪',
            key,
            i18n: messages.CoreUtilsMessages.CAPS_LOCK_KEY
          });
          continue;

        case 'space':
          symbols.push({
            type: 'named',
            symbol: '␣',
            key,
            i18n: messages.CoreUtilsMessages.SPACE_KEY
          });
          continue;

        case 'pageup':
          symbols.push({
            type: 'named',
            symbol: '⤒',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_UP_KEY
          });
          continue;

        case 'pagedown':
          symbols.push({
            type: 'named',
            symbol: '⤓',
            key,
            i18n: messages.CoreUtilsMessages.PAGE_DOWN_KEY
          });
          continue;

        case 'home':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.HOME_KEY
          });
          continue;

        case 'end':
          symbols.push({
            type: 'named',
            key,
            i18n: messages.CoreUtilsMessages.END_KEY
          });
          continue;

        case 'arrowleft':
          symbols.push({
            type: 'named',
            symbol: '←',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_LEFT_KEY
          });
          continue;

        case 'arrowright':
          symbols.push({
            type: 'named',
            symbol: '→',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_RIGHT_KEY
          });
          continue;

        case 'arrowup':
          symbols.push({
            type: 'named',
            symbol: '→',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_UP_KEY
          });
          continue;

        case 'arrowdown':
          symbols.push({
            type: 'named',
            symbol: '↓',
            key,
            i18n: messages.CoreUtilsMessages.ARROW_DOWN_KEY
          });
          continue;

        default:
          symbols.push({
            type: 'char',
            key
          });
          continue;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return symbols;
}

var _excluded = ["attrs"],
    _excluded2 = ["type"],
    _excluded3 = ["type"];

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findChildren({
 *   node: state.doc,
 *   predicate: child => child.isText,
 *   descend: false
 * });
 * ```
 */
function findChildren(props) {
  var node = props.node,
      predicate = props.predicate,
      _props$descend = props.descend,
      descend = _props$descend === void 0 ? true : _props$descend,
      action = props.action; // Ensure that the node provided is a `ProsemirrorNode`.

  !isProsemirrorNode(node) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.INTERNAL,
    message: 'Invalid "node" parameter passed to "findChildren".'
  }) : coreHelpers.invariant(false) : void 0; // Ensure that the predicate is a function.

  !coreHelpers.isFunction(predicate) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.INTERNAL,
    message: 'Invalid "predicate" parameter passed to "findChildren".'
  }) : coreHelpers.invariant(false) : void 0; // This is used to keep track of all the node positions.

  var result = []; // Start descending into the provided node. This can be an expensive operation
  // if the document is very large or deeply nested.

  node.descendants((child, pos) => {
    var nodeWithPosition = {
      node: child,
      pos
    }; // True when this call matches the required condition - returns `true`.

    var isMatch = predicate(nodeWithPosition);

    if (!isMatch) {
      // Move onto the next node or descendant depending on the value of
      // `descend`.
      return descend;
    } // Store the result and run the provided action if it exists.


    result.push(nodeWithPosition);
    action === null || action === void 0 ? void 0 : action(nodeWithPosition);
    return descend;
  });
  return result;
}
/**
 * A utility for creating methods that find a node by a specific condition.
 */

function findNodeByPredicate(_ref) {
  var predicate = _ref.predicate;
  return props => findChildren(_objectSpread(_objectSpread({}, props), {}, {
    predicate
  }));
}
/**
 * Returns text nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const textNodes = findTextNodes({ node });
 * ```
 */


var findTextNodes = findNodeByPredicate({
  predicate: child => child.node.isText
});
/**
 * Returns inline nodes of a given `node`.
 *
 * @remarks
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const inlineNodes = findInlineNodes(node);
 * ```
 */

var findInlineNodes = findNodeByPredicate({
  predicate: child => child.node.isInline
});
/**
 * Returns block descendants of a given `node`.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const blockNodes = findBlockNodes(node);
 * ```
 */

var findBlockNodes = findNodeByPredicate({
  predicate: child => child.node.isBlock
});

/**
 * Iterates over descendants of a given `node`, returning child nodes predicate
 * returns truthy for.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * The following will match any node with an `id` of any value (as long as the
 * attribute exists) and a `colspan` of `2`.
 *
 * ```ts
 * const mergedCells = findChildrenByAttribute({
 *   node: table,
 *   attrs: { colspan: 2, id: (_, exists) => exists }
 * });
 * ```
 */
function findChildrenByAttribute(props) {
  var attrs = props.attrs,
      rest = _objectWithoutProperties(props, _excluded);
  /**
   * The predicate function which loops through the provided attributes check if
   * they are valid.
   */


  function predicate(nodeWithPos) {
    var attributeKeys = new Set(coreHelpers.keys(nodeWithPos.node.attrs));

    var _iterator = _createForOfIteratorHelper(coreHelpers.entries(attrs)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _step$value = _slicedToArray(_step.value, 2),
            attr = _step$value[0],
            expectedValue = _step$value[1];

        var value = nodeWithPos.node.attrs[attr];

        if ( // The user has passed in a predicate checking function.
        coreHelpers.isFunction(expectedValue)) {
          var exists = attributeKeys.has(attr);

          if ( // Check if the predicate checker returns false, in which case we can
          // exit early.
          !expectedValue({
            value,
            exists
          })) {
            return false;
          }

          continue;
        }

        if ( // If the value doesn't match the expected value, exit early.
        value !== expectedValue) {
          return false;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return true;
  }

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes of a given
 * nodeType.
 *
 * @remarks
 *
 * It doesn't descend into a node when descend argument is `false` (defaults to
 * `true`).
 *
 * ```ts
 * const cells = findChildrenByNode({ node: state.doc, type: state.schema.nodes.tableCell });
 * ```
 */
function findChildrenByNode(props) {
  var type = props.type,
      rest = _objectWithoutProperties(props, _excluded2);

  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => child.node.type === type
  }));
}

/**
 * Iterates over descendants of a given `node`, returning child nodes that have
 * a mark of a given markType.
 *
 * @remarks
 *
 * It doesn't descend into a `node` when descend argument is `false` (defaults
 * to `true`).
 *
 * ```ts
 * const nodes = findChildrenByMark({ node: state.doc, type: schema.marks.strong });
 * ```
 */
function findChildrenByMark(paramter) {
  var type = paramter.type,
      rest = _objectWithoutProperties(paramter, _excluded3);

  var markType;
  return findChildren(_objectSpread(_objectSpread({}, rest), {}, {
    predicate: child => {
      if (!markType) {
        markType = coreHelpers.isString(type) ? child.node.type.schema.marks[type] : type;
        !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
          code: coreConstants.ErrorConstant.SCHEMA,
          message: "Mark type: ".concat(type, " does not exist on the current schema.")
        }) : coreHelpers.invariant(false) : void 0;
      }

      return !!markType.isInSet(child.node.marks);
    }
  }));
}

/**
 * Returns `true` if a given node contains nodes of a given `nodeType`.
 *
 * @remarks
 *
 * ```ts
 * if (containsNodesOfType({ node: state.doc, type: schema.nodes.listItem })) {
 *   log('contained')
 * }
 * ```
 */
function containsNodesOfType(props) {
  var node = props.node,
      type = props.type;
  return findChildrenByNode({
    node,
    type
  }).length > 0;
}

/**
 * Get all the changed nodes from the provided transaction.
 *
 * The following example will give us all the text nodes in the provided
 * transaction.
 *
 * ```ts
 * import { getChangedNodes } from 'remirror/core';
 *
 * const changedTextNodes = getChangeNodes(tr, { descend: true, predicate: (node) => node.isText });
 * ```
 */
function getChangedNodes(tr) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$descend = options.descend,
      descend = _options$descend === void 0 ? false : _options$descend,
      predicate = options.predicate,
      StepTypes = options.StepTypes;
  var nodeRange = getChangedNodeRanges(tr, StepTypes); // The container for the nodes which have been added..

  var nodes = [];

  var _iterator2 = _createForOfIteratorHelper(nodeRange),
      _step2;

  try {
    var _loop = function _loop() {
      var range = _step2.value;
      var start = range.start,
          end = range.end; // Find all the nodes between the provided node range.

      tr.doc.nodesBetween(start, end, (node, pos) => {
        var _predicate;

        // Check wether this is a node that should be added.
        var shouldAdd = (_predicate = predicate === null || predicate === void 0 ? void 0 : predicate(node, pos, range)) !== null && _predicate !== void 0 ? _predicate : true;

        if (shouldAdd) {
          nodes.push({
            node,
            pos
          });
        }

        return descend;
      });
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return nodes;
}

/**
 * Creates an input rule based on the provided regex for the provided mark type.
 */
function markInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      _props$ignoreWhitespa = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa === void 0 ? false : _props$ignoreWhitespa,
      beforeDispatch = props.beforeDispatch,
      updateCaptured = props.updateCaptured,
      shouldSkip = props.shouldSkip,
      invalidMarks = props.invalidMarks;
  var markType;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var tr = state.tr,
        schema = state.schema;

    if (!markType) {
      markType = coreHelpers.isString(type) ? schema.marks[type] : type;
      !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        code: coreConstants.ErrorConstant.SCHEMA,
        message: "Mark type: ".concat(type, " does not exist on the current schema.")
      }) : coreHelpers.invariant(false) : void 0;
    }

    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var markEnd = end;
    var initialStoredMarks = [];

    if (captureGroup) {
      var _tr$storedMarks;

      var startSpaces = fullMatch.search(/\S/);
      var textStart = start + fullMatch.indexOf(captureGroup);
      var textEnd = textStart + captureGroup.length;
      initialStoredMarks = (_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : [];

      if (textEnd < end) {
        tr.delete(textEnd, end);
      }

      if (textStart > start) {
        tr.delete(start + startSpaces, textStart);
      }

      markEnd = start + startSpaces + captureGroup.length;
    }

    tr.addMark(start, markEnd, markType.create(attributes)); // Make sure not to reactivate any marks which had previously been
    // deactivated. By keeping track of the initial stored marks we are able to
    // discard any unintended consequences of deleting text and adding it again.

    tr.setStoredMarks(initialStoredMarks); // Allow the caller of this method to update the transaction before it is
    // returned and dispatched by ProseMirror.

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}
/**
 * Creates a node input rule based on the provided regex for the provided node
 * type.
 *
 * Input rules transform content as the user types based on whether a match is
 * found with a sequence of characters.
 */

function nodeInputRule(props) {
  var regexp = props.regexp,
      type = props.type,
      getAttributes = props.getAttributes,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa2 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa2 === void 0 ? false : _props$ignoreWhitespa2,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match) : getAttributes;
    var tr = state.tr,
        schema = state.schema;
    var nodeType = coreHelpers.isString(type) ? schema.nodes[type] : type;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;
    !nodeType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.SCHEMA,
      message: "No node exists for ".concat(type, " in the schema.")
    }) : coreHelpers.invariant(false) : void 0;
    var content = nodeType.createAndFill(attributes);

    if (content) {
      var _captureGroup;

      tr.replaceRangeWith(nodeType.isBlock ? tr.doc.resolve(start).before() : start, end, content);
      beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
        tr,
        match: [fullMatch, (_captureGroup = captureGroup) !== null && _captureGroup !== void 0 ? _captureGroup : ''],
        start,
        end
      });
    }

    return tr;
  });
  return rule;
}
/**
 * Creates a plain rule based on the provided regex. You can see this being used
 * in the `@remirror/extension-emoji` when it is setup to use plain text.
 */

function plainInputRule(props) {
  var regexp = props.regexp,
      transformMatch = props.transformMatch,
      beforeDispatch = props.beforeDispatch,
      shouldSkip = props.shouldSkip,
      _props$ignoreWhitespa3 = props.ignoreWhitespace,
      ignoreWhitespace = _props$ignoreWhitespa3 === void 0 ? false : _props$ignoreWhitespa3,
      updateCaptured = props.updateCaptured,
      invalidMarks = props.invalidMarks;
  var rule = new inputrules.InputRule(regexp, (state, match, start, end) => {
    var value = transformMatch(match);

    if (coreHelpers.isNullOrUndefined(value)) {
      return null;
    }

    var tr = state.tr,
        schema = state.schema;
    var captureGroup = match[1];
    var fullMatch = match[0]; // These are the attributes which are added to the mark and they can be
    // obtained from the match if a function is provided.

    var details = gatherDetails({
      captureGroup,
      fullMatch,
      end,
      start,
      rule,
      state,
      ignoreWhitespace,
      invalidMarks,
      shouldSkip,
      updateCaptured
    });

    if (!details) {
      return null;
    }

    start = details.start;
    end = details.end;
    captureGroup = details.captureGroup;
    fullMatch = details.fullMatch;

    if (value === '') {
      tr.delete(start, end);
    } else {
      tr.replaceWith(start, end, schema.text(value));
    }

    beforeDispatch === null || beforeDispatch === void 0 ? void 0 : beforeDispatch({
      tr,
      match,
      start,
      end
    });
    return tr;
  });
  return rule;
}

/**
 * This is a monster of a function.
 *
 * TODO make it make sense.
 */
function gatherDetails(_ref) {
  var _updateCaptured, _details$captureGroup, _details$fullMatch, _details$start, _details$end, _captureGroup2, _rule$shouldSkip;

  var captureGroup = _ref.captureGroup,
      fullMatch = _ref.fullMatch,
      end = _ref.end,
      start = _ref.start,
      rule = _ref.rule,
      ignoreWhitespace = _ref.ignoreWhitespace,
      shouldSkip = _ref.shouldSkip,
      updateCaptured = _ref.updateCaptured,
      state = _ref.state,
      invalidMarks = _ref.invalidMarks;

  if (fullMatch == null) {
    return null;
  } // Update the internal values with the user provided method.


  var details = (_updateCaptured = updateCaptured === null || updateCaptured === void 0 ? void 0 : updateCaptured({
    captureGroup,
    fullMatch,
    start,
    end
  })) !== null && _updateCaptured !== void 0 ? _updateCaptured : {}; // Store the updated values or the original.

  captureGroup = (_details$captureGroup = details.captureGroup) !== null && _details$captureGroup !== void 0 ? _details$captureGroup : captureGroup;
  fullMatch = (_details$fullMatch = details.fullMatch) !== null && _details$fullMatch !== void 0 ? _details$fullMatch : fullMatch;
  start = (_details$start = details.start) !== null && _details$start !== void 0 ? _details$start : start;
  end = (_details$end = details.end) !== null && _details$end !== void 0 ? _details$end : end;
  var $from = state.doc.resolve(start);
  var $to = state.doc.resolve(end);

  if ( // Skip when the range contains an excluded mark.
  invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, invalidMarks) || rule.invalidMarks && suggest.markActiveInRange({
    $from,
    $to
  }, rule.invalidMarks) || // Skip pure whitespace updates
  ignoreWhitespace && ((_captureGroup2 = captureGroup) === null || _captureGroup2 === void 0 ? void 0 : _captureGroup2.trim()) === '' || // Skip when configured to do
  shouldSkip !== null && shouldSkip !== void 0 && shouldSkip({
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  }) || (_rule$shouldSkip = rule.shouldSkip) !== null && _rule$shouldSkip !== void 0 && _rule$shouldSkip.call(rule, {
    state,
    captureGroup,
    fullMatch,
    start,
    end,
    ruleType: 'mark'
  })) {
    return null;
  }

  return {
    captureGroup,
    end,
    fullMatch,
    start
  };
}

Object.defineProperty(exports, "chainCommands", ({
  enumerable: true,
  get: function () { return pm.chainCommands; }
}));
Object.defineProperty(exports, "chainableEditorState", ({
  enumerable: true,
  get: function () { return pm.chainableEditorState; }
}));
Object.defineProperty(exports, "convertCommand", ({
  enumerable: true,
  get: function () { return pm.convertCommand; }
}));
Object.defineProperty(exports, "nonChainable", ({
  enumerable: true,
  get: function () { return pm.nonChainable; }
}));
exports.DOM_SIZE_UNITS = DOM_SIZE_UNITS;
exports.applyClonedTransaction = applyClonedTransaction;
exports.areSchemasCompatible = areSchemasCompatible;
exports.areStatesEqual = areStatesEqual;
exports.atDocEnd = atDocEnd;
exports.atDocStart = atDocStart;
exports.canInsertNode = canInsertNode;
exports.chainKeyBindingCommands = chainKeyBindingCommands;
exports.cloneTransaction = cloneTransaction;
exports.composeTransactionSteps = composeTransactionSteps;
exports.containsAttributes = containsAttributes;
exports.containsNodesOfType = containsNodesOfType;
exports.convertPixelsToDomUnit = convertPixelsToDomUnit;
exports.createDocumentNode = createDocumentNode;
exports.endPositionOfParent = endPositionOfParent;
exports.environment = environment;
exports.extractPixelSize = extractPixelSize;
exports.findBlockNodes = findBlockNodes;
exports.findChildren = findChildren;
exports.findChildrenByAttribute = findChildrenByAttribute;
exports.findChildrenByMark = findChildrenByMark;
exports.findChildrenByNode = findChildrenByNode;
exports.findElementAtPosition = findElementAtPosition;
exports.findInlineNodes = findInlineNodes;
exports.findNodeAtPosition = findNodeAtPosition;
exports.findNodeAtSelection = findNodeAtSelection;
exports.findParentNode = findParentNode;
exports.findParentNodeOfType = findParentNodeOfType;
exports.findPositionOfNodeAfter = findPositionOfNodeAfter;
exports.findPositionOfNodeBefore = findPositionOfNodeBefore;
exports.findSelectedNodeOfType = findSelectedNodeOfType;
exports.findTextNodes = findTextNodes;
exports.getActiveNode = getActiveNode;
exports.getChangedNodeRanges = getChangedNodeRanges;
exports.getChangedNodes = getChangedNodes;
exports.getChangedRanges = getChangedRanges;
exports.getCursor = getCursor;
exports.getDefaultBlockNode = getDefaultBlockNode;
exports.getDefaultDocNode = getDefaultDocNode;
exports.getDocRange = getDocRange;
exports.getDocument = getDocument;
exports.getFontSize = getFontSize;
exports.getInvalidContent = getInvalidContent;
exports.getMarkAttributes = getMarkAttributes;
exports.getMarkRange = getMarkRange;
exports.getMarkRanges = getMarkRanges;
exports.getMarkType = getMarkType;
exports.getMatchString = getMatchString;
exports.getNodeType = getNodeType;
exports.getRemirrorJSON = getRemirrorJSON;
exports.getSelectedGroup = getSelectedGroup;
exports.getSelectedWord = getSelectedWord;
exports.getShortcutSymbols = getShortcutSymbols;
exports.getStyle = getStyle;
exports.getTextContentFromSlice = getTextContentFromSlice;
exports.getTextSelection = getTextSelection;
exports.hasTransactionChanged = hasTransactionChanged;
exports.htmlToProsemirrorNode = htmlToProsemirrorNode;
exports.isAllSelection = isAllSelection;
exports.isChrome = isChrome;
exports.isDefaultBlockNode = isDefaultBlockNode;
exports.isDefaultDocNode = isDefaultDocNode;
exports.isDocNode = isDocNode;
exports.isDocNodeEmpty = isDocNodeEmpty;
exports.isDomNode = isDomNode;
exports.isEditorSchema = isEditorSchema;
exports.isEditorState = isEditorState;
exports.isElementDomNode = isElementDomNode;
exports.isEmptyBlockNode = isEmptyBlockNode;
exports.isEndOfTextBlock = isEndOfTextBlock;
exports.isIdentifierOfType = isIdentifierOfType;
exports.isMarkActive = isMarkActive;
exports.isMarkType = isMarkType;
exports.isNodeActive = isNodeActive;
exports.isNodeOfType = isNodeOfType;
exports.isNodeSelection = isNodeSelection;
exports.isNodeType = isNodeType;
exports.isProsemirrorFragment = isProsemirrorFragment;
exports.isProsemirrorMark = isProsemirrorMark;
exports.isProsemirrorNode = isProsemirrorNode;
exports.isRemirrorJSON = isRemirrorJSON;
exports.isRemirrorType = isRemirrorType;
exports.isResolvedPos = isResolvedPos;
exports.isSelection = isSelection;
exports.isSelectionEmpty = isSelectionEmpty;
exports.isStartOfDoc = isStartOfDoc;
exports.isStartOfTextBlock = isStartOfTextBlock;
exports.isTextDomNode = isTextDomNode;
exports.isTextSelection = isTextSelection;
exports.isTransaction = isTransaction;
exports.joinStyles = joinStyles;
exports.lift = lift;
exports.markEqualsType = markEqualsType;
exports.markInputRule = markInputRule;
exports.mergeKeyBindings = mergeKeyBindings;
exports.mergeProsemirrorKeyBindings = mergeProsemirrorKeyBindings;
exports.nodeInputRule = nodeInputRule;
exports.omitExtraAttributes = omitExtraAttributes;
exports.parseSizeUnit = parseSizeUnit;
exports.plainInputRule = plainInputRule;
exports.preserveSelection = preserveSelection;
exports.prosemirrorNodeToDom = prosemirrorNodeToDom;
exports.prosemirrorNodeToHtml = prosemirrorNodeToHtml;
exports.rangeHasMark = rangeHasMark;
exports.removeMark = removeMark;
exports.removeNodeAfter = removeNodeAfter;
exports.removeNodeAtPosition = removeNodeAtPosition;
exports.removeNodeBefore = removeNodeBefore;
exports.replaceNodeAtPosition = replaceNodeAtPosition;
exports.replaceText = replaceText;
exports.schemaToJSON = schemaToJSON;
exports.setBlockType = setBlockType;
exports.setStyle = setStyle;
exports.shouldUseDomEnvironment = shouldUseDomEnvironment;
exports.startPositionOfParent = startPositionOfParent;
exports.textBetween = textBetween;
exports.toggleBlockItem = toggleBlockItem;
exports.toggleWrap = toggleWrap;
exports.updateMark = updateMark;
exports.wrapIn = wrapIn;


/***/ }),
/* 116 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(117);
} else {
  module.exports = __webpack_require__(119);
}


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorCommands = __webpack_require__(118);



Object.keys(prosemirrorCommands).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorCommands[k]; }
	});
});


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "autoJoin": () => (/* binding */ autoJoin),
/* harmony export */   "baseKeymap": () => (/* binding */ baseKeymap),
/* harmony export */   "chainCommands": () => (/* binding */ chainCommands),
/* harmony export */   "createParagraphNear": () => (/* binding */ createParagraphNear),
/* harmony export */   "deleteSelection": () => (/* binding */ deleteSelection),
/* harmony export */   "exitCode": () => (/* binding */ exitCode),
/* harmony export */   "joinBackward": () => (/* binding */ joinBackward),
/* harmony export */   "joinDown": () => (/* binding */ joinDown),
/* harmony export */   "joinForward": () => (/* binding */ joinForward),
/* harmony export */   "joinUp": () => (/* binding */ joinUp),
/* harmony export */   "lift": () => (/* binding */ lift),
/* harmony export */   "liftEmptyBlock": () => (/* binding */ liftEmptyBlock),
/* harmony export */   "macBaseKeymap": () => (/* binding */ macBaseKeymap),
/* harmony export */   "newlineInCode": () => (/* binding */ newlineInCode),
/* harmony export */   "pcBaseKeymap": () => (/* binding */ pcBaseKeymap),
/* harmony export */   "selectAll": () => (/* binding */ selectAll),
/* harmony export */   "selectNodeBackward": () => (/* binding */ selectNodeBackward),
/* harmony export */   "selectNodeForward": () => (/* binding */ selectNodeForward),
/* harmony export */   "selectParentNode": () => (/* binding */ selectParentNode),
/* harmony export */   "selectTextblockEnd": () => (/* binding */ selectTextblockEnd),
/* harmony export */   "selectTextblockStart": () => (/* binding */ selectTextblockStart),
/* harmony export */   "setBlockType": () => (/* binding */ setBlockType),
/* harmony export */   "splitBlock": () => (/* binding */ splitBlock),
/* harmony export */   "splitBlockKeepMarks": () => (/* binding */ splitBlockKeepMarks),
/* harmony export */   "toggleMark": () => (/* binding */ toggleMark),
/* harmony export */   "wrapIn": () => (/* binding */ wrapIn)
/* harmony export */ });
/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(43);
/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41);
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);




// :: (EditorState, ?(tr: Transaction)) → bool
// Delete the selection, if there is one.
function deleteSelection(state, dispatch) {
  if (state.selection.empty) { return false }
  if (dispatch) { dispatch(state.tr.deleteSelection().scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and at the start of a textblock, try to
// reduce the distance between that block and the one before it—if
// there's a block directly before it that can be joined, join them.
// If not, try to move the selected block closer to the next one in
// the document structure by lifting it out of its parent or moving it
// into a parent of the previous block. Will use the view for accurate
// (bidi-aware) start-of-textblock detection if given.
function joinBackward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state)
                        : $cursor.parentOffset > 0))
    { return false }

  var $cut = findCutBefore($cursor);

  // If there is no node before this, try to lift
  if (!$cut) {
    var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
    if (target == null) { return false }
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  var before = $cut.nodeBefore;
  // Apply the joining algorithm
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch))
    { return true }

  // If the node below has no content and the node above is
  // selectable, delete the node below and select the one above.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(before, "end") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(before))) {
    var delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)
                        : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }
      return true
    }
  }

  // If the node before is an atom, delete it
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView()); }
    return true
  }

  return false
}

function textblockAt(node, side, only) {
  for (; node; node = (side == "start" ? node.firstChild : node.lastChild)) {
    if (node.isTextblock) { return true }
    if (only && node.childCount != 1) { return false }
  }
  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the start of a textblock, select
// the node before that textblock, if possible. This is intended to be
// bound to keys like backspace, after
// [`joinBackward`](#commands.joinBackward) or other deleting
// commands, as a fall-back behavior when the schema doesn't allow
// deletion at the selected point.
function selectNodeBackward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) { return false }
    $cut = findCutBefore($head);
  }
  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView()); }
  return true
}

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) { return $pos.doc.resolve($pos.before(i + 1)) }
    if ($pos.node(i).type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// If the selection is empty and the cursor is at the end of a
// textblock, try to reduce or remove the boundary between that block
// and the one after it, either by joining them or by moving the other
// block closer to this one in the tree structure. Will use the view
// for accurate start-of-textblock detection if given.
function joinForward(state, dispatch, view) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state)
                        : $cursor.parentOffset < $cursor.parent.content.size))
    { return false }

  var $cut = findCutAfter($cursor);

  // If there is no node after this, there's nothing to do
  if (!$cut) { return false }

  var after = $cut.nodeAfter;
  // Try the joining algorithm
  if (deleteBarrier(state, $cut, dispatch)) { return true }

  // If the node above has no content and the node below is
  // selectable, delete the node above and select the one below.
  if ($cursor.parent.content.size == 0 &&
      (textblockAt(after, "start") || prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(after))) {
    var delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty);
    if (delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)
                        : prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true
    }
  }

  // If the next node is an atom, delete it
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) { dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView()); }
    return true
  }

  return false
}

// :: (EditorState, ?(tr: Transaction), ?EditorView) → bool
// When the selection is empty and at the end of a textblock, select
// the node coming after that textblock, if possible. This is intended
// to be bound to keys like delete, after
// [`joinForward`](#commands.joinForward) and similar deleting
// commands, to provide a fall-back behavior when the schema doesn't
// allow deletion at the selected point.
function selectNodeForward(state, dispatch, view) {
  var ref = state.selection;
  var $head = ref.$head;
  var empty = ref.empty;
  var $cut = $head;
  if (!empty) { return false }
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      { return false }
    $cut = findCutAfter($head);
  }
  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.isSelectable(node)) { return false }
  if (dispatch)
    { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView()); }
  return true
}

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) { for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) { return $pos.doc.resolve($pos.after(i + 1)) }
    if (parent.type.spec.isolating) { break }
  } }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block or, if there is a text selection, the
// closest ancestor block of the selection that can be joined, with
// the sibling above it.
function joinUp(state, dispatch) {
  var sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from)) { return false }
    point = sel.from;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);
    if (point == null) { return false }
  }
  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) { tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize)); }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Join the selected block, or the closest ancestor of the selection
// that can be joined, with the sibling after it.
function joinDown(state, dispatch) {
  var sel = state.selection, point;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection) {
    if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to)) { return false }
    point = sel.to;
  } else {
    point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);
    if (point == null) { return false }
  }
  if (dispatch)
    { dispatch(state.tr.join(point).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Lift the selected block, or the closest ancestor block of the
// selection that can be lifted, out of its parent node.
function lift(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  var range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the selection is in a node whose type has a truthy
// [`code`](#model.NodeSpec.code) property in its spec, replace the
// selection with a newline character.
function newlineInCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  if (dispatch) { dispatch(state.tr.insertText("\n").scrollIntoView()); }
  return true
}

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var ref = match.edge(i);
    var type = ref.type;
    if (type.isTextblock && !type.hasRequiredAttrs()) { return type }
  }
  return null
}

// :: (EditorState, ?(tr: Transaction)) → bool
// When the selection is in a node with a truthy
// [`code`](#model.NodeSpec.code) property in its spec, create a
// default block after the code block, and move the cursor there.
function exitCode(state, dispatch) {
  var ref = state.selection;
  var $head = ref.$head;
  var $anchor = ref.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) { return false }
  var above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!above.canReplaceWith(after, after, type)) { return false }
  if (dispatch) {
    var pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If a block node is selected, create an empty paragraph before (if
// it is its parent's first child) or after it.
function createParagraphNear(state, dispatch) {
  var sel = state.selection;
  var $from = sel.$from;
  var $to = sel.$to;
  if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) { return false }
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) { return false }
  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// If the cursor is in an empty textblock that can be lifted, lift the
// block.
function liftEmptyBlock(state, dispatch) {
  var ref = state.selection;
  var $cursor = ref.$cursor;
  if (!$cursor || $cursor.parent.content.size) { return false }
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();
    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {
      if (dispatch) { dispatch(state.tr.split(before).scrollIntoView()); }
      return true
    }
  }
  var range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target == null) { return false }
  if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Split the parent block of the selection. If the selection is a text
// selection, also delete its content.
function splitBlock(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var $to = ref.$to;
  if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos)) { return false }
    if (dispatch) { dispatch(state.tr.split($from.pos).scrollIntoView()); }
    return true
  }

  if (!$from.parent.isBlock) { return false }

  if (dispatch) {
    var atEnd = $to.parentOffset == $to.parent.content.size;
    var tr = state.tr;
    if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection) { tr.deleteSelection(); }
    var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    var types = atEnd && deflt ? [{type: deflt}] : null;
    var can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt && [{type: deflt}])) {
      types = [{type: deflt}];
      can = true;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
        var first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))
          { tr.setNodeMarkup(tr.mapping.map($from.before()), deflt); }
      }
    }
    dispatch(tr.scrollIntoView());
  }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Acts like [`splitBlock`](#commands.splitBlock), but without
// resetting the set of active marks at the cursor.
function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && (function (tr) {
    var marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());
    if (marks) { tr.ensureMarks(marks); }
    dispatch(tr);
  }))
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Move the selection to the node wrapping the current selection, if
// any. (Will not select the document node.)
function selectParentNode(state, dispatch) {
  var ref = state.selection;
  var $from = ref.$from;
  var to = ref.to;
  var pos;
  var same = $from.sharedDepth(to);
  if (same == 0) { return false }
  pos = $from.before(same);
  if (dispatch) { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.NodeSelection.create(state.doc, pos))); }
  return true
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Select the whole document.
function selectAll(state, dispatch) {
  if (dispatch) { dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.AllSelection(state.doc))); }
  return true
}

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) { return false }
  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) { dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView()); }
    return true
  }
  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))
    { return false }
  if (dispatch)
    { dispatch(state.tr
             .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))
             .join($pos.pos)
             .scrollIntoView()); }
  return true
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  if (before.type.spec.isolating || after.type.spec.isolating) { return false }
  if (joinMaybeClear(state, $cut, dispatch)) { return true }

  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter &&
      (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&
      match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
      for (var i = conn.length - 1; i >= 0; i--)
        { wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(conn[i].create(null, wrap)); }
      wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinAt)) { tr.join(joinAt); }
      dispatch(tr.scrollIntoView());
    }
    return true
  }

  var selAfter = prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch) { dispatch(state.tr.lift(range, target).scrollIntoView()); }
    return true
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before, wrap$1 = [];
    for (;;) {
      wrap$1.push(at);
      if (at.isTextblock) { break }
      at = at.lastChild;
    }
    var afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild) { afterDepth++; }
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;
        for (var i$1 = wrap$1.length - 1; i$1 >= 0; i$1--) { end$1 = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(wrap$1[i$1].copy(end$1)); }
        var tr$1 = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap$1.length, $cut.pos + after.nodeSize,
                                                     $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth,
                                                     new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(end$1, wrap$1.length, 0), 0, true));
        dispatch(tr$1.scrollIntoView());
      }
      return true
    }
  }

  return false
}

function selectTextblockSide(side) {
  return function(state, dispatch) {
    var sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth) { return false }
      depth--;
    }
    if (!$pos.node(depth).isTextblock) { return false }
    if (dispatch)
      { dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.TextSelection.create(
        state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth)))); }
    return true
  }
}

// :: (EditorState, ?(tr: Transaction)) → bool
// Moves the cursor to the start of current text block.
var selectTextblockStart = selectTextblockSide(-1);

// :: (EditorState, ?(tr: Transaction)) → bool
// Moves the cursor to the end of current text block.
var selectTextblockEnd = selectTextblockSide(1);

// Parameterized commands

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Wrap the selection in a node of the given type with the given
// attributes.
function wrapIn(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var $from = ref.$from;
    var $to = ref.$to;
    var range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);
    if (!wrapping) { return false }
    if (dispatch) { dispatch(state.tr.wrap(range, wrapping).scrollIntoView()); }
    return true
  }
}

// :: (NodeType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Returns a command that tries to set the selected textblocks to the
// given node type with the given attributes.
function setBlockType(nodeType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var from = ref.from;
    var to = ref.to;
    var applicable = false;
    state.doc.nodesBetween(from, to, function (node, pos) {
      if (applicable) { return false }
      if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) { return }
      if (node.type == nodeType) {
        applicable = true;
      } else {
        var $pos = state.doc.resolve(pos), index = $pos.index();
        applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
      }
    });
    if (!applicable) { return false }
    if (dispatch) { dispatch(state.tr.setBlockType(from, to, nodeType, attrs).scrollIntoView()); }
    return true
  }
}

function markApplies(doc, ranges, type) {
  var loop = function ( i ) {
    var ref = ranges[i];
    var $from = ref.$from;
    var $to = ref.$to;
    var can = $from.depth == 0 ? doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) { return false }
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) { return { v: true } }
  };

  for (var i = 0; i < ranges.length; i++) {
    var returned = loop( i );

    if ( returned ) return returned.v;
  }
  return false
}

// :: (MarkType, ?Object) → (state: EditorState, dispatch: ?(tr: Transaction)) → bool
// Create a command function that toggles the given mark with the
// given attributes. Will return `false` when the current selection
// doesn't support that mark. This will remove the mark if any marks
// of that type exist in the selection, or add it otherwise. If the
// selection is empty, this applies to the [stored
// marks](#state.EditorState.storedMarks) instead of a range of the
// document.
function toggleMark(markType, attrs) {
  return function(state, dispatch) {
    var ref = state.selection;
    var empty = ref.empty;
    var $cursor = ref.$cursor;
    var ranges = ref.ranges;
    if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType)) { return false }
    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks()))
          { dispatch(state.tr.removeStoredMark(markType)); }
        else
          { dispatch(state.tr.addStoredMark(markType.create(attrs))); }
      } else {
        var has = false, tr = state.tr;
        for (var i = 0; !has && i < ranges.length; i++) {
          var ref$1 = ranges[i];
          var $from = ref$1.$from;
          var $to = ref$1.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }
        for (var i$1 = 0; i$1 < ranges.length; i$1++) {
          var ref$2 = ranges[i$1];
          var $from$1 = ref$2.$from;
          var $to$1 = ref$2.$to;
          if (has) {
            tr.removeMark($from$1.pos, $to$1.pos, markType);
          } else {
            var from = $from$1.pos, to = $to$1.pos, start = $from$1.nodeAfter, end = $to$1.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;
            if (from + spaceStart < to) { from += spaceStart; to -= spaceEnd; }
            tr.addMark(from, to, markType.create(attrs));
          }
        }
        dispatch(tr.scrollIntoView());
      }
    }
    return true
  }
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) { return dispatch(tr) }

    var ranges = [];
    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];
      for (var j = 0; j < ranges.length; j++)
        { ranges[j] = map.map(ranges[j]); }
      map.forEach(function (_s, _e, from, to) { return ranges.push(from, to); });
    }

    // Figure out which joinable points exist inside those ranges,
    // by checking all node boundaries in their parent nodes.
    var joinable = [];
    for (var i$1 = 0; i$1 < ranges.length; i$1 += 2) {
      var from = ranges[i$1], to = ranges[i$1 + 1];
      var $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);
      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) { break }
        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after))
            { joinable.push(pos); }
        }
        pos += after.nodeSize;
      }
    }
    // Join the joinable points
    joinable.sort(function (a, b) { return a - b; });
    for (var i$2 = joinable.length - 1; i$2 >= 0; i$2--) {
      if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i$2])) { tr.join(joinable[i$2]); }
    }
    dispatch(tr);
  }
}

// :: ((state: EditorState, ?(tr: Transaction)) → bool, union<(before: Node, after: Node) → bool, [string]>) → (state: EditorState, ?(tr: Transaction)) → bool
// Wrap a command so that, when it produces a transform that causes
// two joinable nodes to end up next to each other, those are joined.
// Nodes are considered joinable when they are of the same type and
// when the `isJoinable` predicate returns true for them or, if an
// array of strings was passed, if their node type name is in that
// array.
function autoJoin(command, isJoinable) {
  if (Array.isArray(isJoinable)) {
    var types = isJoinable;
    isJoinable = function (node) { return types.indexOf(node.type.name) > -1; };
  }
  return function (state, dispatch, view) { return command(state, dispatch && wrapDispatchForJoin(dispatch, isJoinable), view); }
}

// :: (...[(EditorState, ?(tr: Transaction), ?EditorView) → bool]) → (EditorState, ?(tr: Transaction), ?EditorView) → bool
// Combine a number of command functions into a single function (which
// calls them one by one until one returns true).
function chainCommands() {
  var commands = [], len = arguments.length;
  while ( len-- ) commands[ len ] = arguments[ len ];

  return function(state, dispatch, view) {
    for (var i = 0; i < commands.length; i++)
      { if (commands[i](state, dispatch, view)) { return true } }
    return false
  }
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);

// :: Object
// A basic keymap containing bindings not specific to any schema.
// Binds the following keys (when multiple commands are listed, they
// are chained with [`chainCommands`](#commands.chainCommands)):
//
// * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
// * **Mod-Enter** to `exitCode`
// * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
// * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
// * **Mod-a** to `selectAll`
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};

// :: Object
// A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
// **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
// **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
// Ctrl-Delete.
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};
for (var key in pcBaseKeymap) { macBaseKeymap[key] = pcBaseKeymap[key]; }

// declare global: os, navigator
var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
          : typeof os != "undefined" ? os.platform() == "darwin" : false;

// :: Object
// Depending on the detected platform, this will hold
// [`pcBasekeymap`](#commands.pcBaseKeymap) or
// [`macBaseKeymap`](#commands.macBaseKeymap).
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorCommands = __webpack_require__(118);



Object.keys(prosemirrorCommands).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorCommands[k]; }
	});
});


/***/ }),
/* 120 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(121);
} else {
  module.exports = __webpack_require__(125);
}


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var types = __webpack_require__(122);



Object.keys(types).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return types[k]; }
  });
});


/***/ }),
/* 122 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(123);
} else {
  module.exports = __webpack_require__(124);
}


/***/ }),
/* 123 */
/***/ (() => {

"use strict";




/***/ }),
/* 124 */
/***/ (() => {

"use strict";




/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var types = __webpack_require__(122);



Object.keys(types).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return types[k]; }
  });
});


/***/ }),
/* 126 */
/***/ ((module) => {

let createNanoEvents = () => ({
  events: {},
  emit(event, ...args) {
    ;(this.events[event] || []).forEach(i => i(...args))
  },
  on(event, cb) {
    ;(this.events[event] = this.events[event] || []).push(cb)
    return () =>
      (this.events[event] = (this.events[event] || []).filter(i => i !== cb))
  }
})

module.exports = { createNanoEvents }


/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isProduction = process.env.NODE_ENV === 'production';
function warning(condition, message) {
  if (!isProduction) {
    if (condition) {
      return;
    }

    var text = "Warning: " + message;

    if (typeof console !== 'undefined') {
      console.warn(text);
    }

    try {
      throw Error(text);
    } catch (x) {}
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (warning);


/***/ }),
/* 128 */
/***/ ((module) => {

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;

  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }

  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);

  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }

  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }

  return desc;
}

module.exports = _applyDecoratedDescriptor, module.exports.__esModule = true, module.exports["default"] = module.exports;

/***/ }),
/* 129 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(130);
} else {
  module.exports = __webpack_require__(131);
}


/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorView = __webpack_require__(96);



Object.keys(prosemirrorView).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorView[k]; }
	});
});


/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorView = __webpack_require__(96);



Object.keys(prosemirrorView).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorView[k]; }
	});
});


/***/ }),
/* 132 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(133);
} else {
  module.exports = __webpack_require__(136);
}


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorKeymap = __webpack_require__(134);



Object.keys(prosemirrorKeymap).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorKeymap[k]; }
	});
});


/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keydownHandler": () => (/* binding */ keydownHandler),
/* harmony export */   "keymap": () => (/* binding */ keymap)
/* harmony export */ });
/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(135);
/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);



// declare global: navigator

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space") { result = " "; }
  var alt, ctrl, shift, meta;
  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) { meta = true; }
    else if (/^a(lt)?$/i.test(mod)) { alt = true; }
    else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
    else if (/^s(hift)?$/i.test(mod)) { shift = true; }
    else if (/^mod$/i.test(mod)) { if (mac) { meta = true; } else { ctrl = true; } }
    else { throw new Error("Unrecognized modifier name: " + mod) }
  }
  if (alt) { result = "Alt-" + result; }
  if (ctrl) { result = "Ctrl-" + result; }
  if (meta) { result = "Meta-" + result; }
  if (shift) { result = "Shift-" + result; }
  return result
}

function normalize(map) {
  var copy = Object.create(null);
  for (var prop in map) { copy[normalizeKeyName(prop)] = map[prop]; }
  return copy
}

function modifiers(name, event, shift) {
  if (event.altKey) { name = "Alt-" + name; }
  if (event.ctrlKey) { name = "Ctrl-" + name; }
  if (event.metaKey) { name = "Meta-" + name; }
  if (shift !== false && event.shiftKey) { name = "Shift-" + name; }
  return name
}

// :: (Object) → Plugin
// Create a keymap plugin for the given set of bindings.
//
// Bindings should map key names to [command](#commands)-style
// functions, which will be called with `(EditorState, dispatch,
// EditorView)` arguments, and should return true when they've handled
// the key. Note that the view argument isn't part of the command
// protocol, but can be used as an escape hatch if a binding needs to
// directly interact with the UI.
//
// Key names may be strings like `"Shift-Ctrl-Enter"`—a key
// identifier prefixed with zero or more modifiers. Key identifiers
// are based on the strings that can appear in
// [`KeyEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).
// Use lowercase letters to refer to letter keys (or uppercase letters
// if you want shift to be held). You may use `"Space"` as an alias
// for the `" "` name.
//
// Modifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or
// `a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or
// `Meta-`) are recognized. For characters that are created by holding
// shift, the `Shift-` prefix is implied, and should not be added
// explicitly.
//
// You can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on
// other platforms.
//
// You can add multiple keymap plugins to an editor. The order in
// which they appear determines their precedence (the ones early in
// the array get to dispatch first).
function keymap(bindings) {
  return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({props: {handleKeyDown: keydownHandler(bindings)}})
}

// :: (Object) → (view: EditorView, event: dom.Event) → bool
// Given a set of bindings (using the same format as
// [`keymap`](#keymap.keymap)), return a [keydown
// handler](#view.EditorProps.handleKeyDown) that handles them.
function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function(view, event) {
    var name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), isChar = name.length == 1 && name != " ", baseName;
    var direct = map[modifiers(name, event, !isChar)];
    if (direct && direct(view.state, view.dispatch, view)) { return true }
    if (isChar && (event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&
        (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {
      // Try falling back to the keyCode when there's a modifier
      // active or the character produced isn't ASCII, and our table
      // produces a different name from the the keyCode. See #668,
      // #1060
      var fromCode = map[modifiers(baseName, event, true)];
      if (fromCode && fromCode(view.state, view.dispatch, view)) { return true }
    } else if (isChar && event.shiftKey) {
      // Otherwise, if shift is active, also try the binding with the
      // Shift- prefix enabled. See #997
      var withShift = map[modifiers(name, event, true)];
      if (withShift && withShift(view.state, view.dispatch, view)) { return true }
    }
    return false
  }
}


//# sourceMappingURL=index.es.js.map


/***/ }),
/* 135 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "base": () => (/* binding */ base),
/* harmony export */   "keyName": () => (/* binding */ keyName),
/* harmony export */   "shift": () => (/* binding */ shift)
/* harmony export */ });
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'",
  229: "q"
}

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\"",
  229: "Q"
}

var chrome = typeof navigator != "undefined" && /Chrome\/(\d+)/.exec(navigator.userAgent)
var safari = typeof navigator != "undefined" && /Apple Computer/.test(navigator.vendor)
var gecko = typeof navigator != "undefined" && /Gecko\/\d+/.test(navigator.userAgent)
var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform)
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent)
var brokenModifierNames = chrome && (mac || +chrome[1] < 57) || gecko && mac

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32)
  shift[i] = String.fromCharCode(i)
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]

function keyName(event) {
  // Don't trust event.key in Chrome when there are modifiers until
  // they fix https://bugs.chromium.org/p/chromium/issues/detail?id=633838
  var ignoreKey = brokenModifierNames && (event.ctrlKey || event.altKey || event.metaKey) ||
    (safari || ie) && event.shiftKey && event.key && event.key.length == 1
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified"
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape"
  if (name == "Del") name = "Delete"
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft"
  if (name == "Up") name = "ArrowUp"
  if (name == "Right") name = "ArrowRight"
  if (name == "Down") name = "ArrowDown"
  return name
}


/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorKeymap = __webpack_require__(134);



Object.keys(prosemirrorKeymap).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorKeymap[k]; }
	});
});


/***/ }),
/* 137 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(138);
} else {
  module.exports = __webpack_require__(142);
}


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorPasteRules = __webpack_require__(139);



Object.keys(prosemirrorPasteRules).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorPasteRules[k]; }
	});
});


/***/ }),
/* 139 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (process.env.NODE_ENV === "production") {
  module.exports = __webpack_require__(140);
} else {
  module.exports = __webpack_require__(141);
}


/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var prosemirrorModel = __webpack_require__(41);
var prosemirrorState = __webpack_require__(40);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);

/**
 * Create the paste plugin handler.
 */

function pasteRules(pasteRules) {
  var sortedPasteRules = coreHelpers.sort(pasteRules, (a, z) => {
    var _z$priority, _a$priority;

    return ((_z$priority = z.priority) !== null && _z$priority !== void 0 ? _z$priority : coreConstants.ExtensionPriority.Low) - ((_a$priority = a.priority) !== null && _a$priority !== void 0 ? _a$priority : coreConstants.ExtensionPriority.Low);
  }); // Container for the regex based paste rules.

  var regexPasteRules = []; // Container for the file based paste rules.

  var filePasteRules = [];

  var _iterator = _createForOfIteratorHelper(sortedPasteRules),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var rule = _step.value;

      if (isRegexPastRule(rule)) {
        regexPasteRules.push(rule);
      } else {
        filePasteRules.push(rule);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _view;

  return new prosemirrorState.Plugin({
    key: pastePluginKey,
    view: editorView => {
      _view = editorView;
      return {};
    },
    props: {
      // The regex based paste rules are passed into this function to take care of.
      transformPasted: slice => {
        var $pos = _view.state.selection.$from;
        var nodeName = $pos.node().type.name;
        var markNames = new Set($pos.marks().map(mark => mark.type.name)); // Iterate over each rule by order of priority and update the slice each time.

        var _iterator2 = _createForOfIteratorHelper(regexPasteRules),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _rule$ignoredNodes, _rule$ignoredMarks, _slice$content$firstC, _slice$content$firstC2;

            var rule = _step2.value;

            if ( // The parent node is ignored.
            (_rule$ignoredNodes = rule.ignoredNodes) !== null && _rule$ignoredNodes !== void 0 && _rule$ignoredNodes.includes(nodeName) || // The current position contains ignored marks.
            (_rule$ignoredMarks = rule.ignoredMarks) !== null && _rule$ignoredMarks !== void 0 && _rule$ignoredMarks.some(ignored => markNames.has(ignored))) {
              continue;
            }

            var textContent = (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
            var canBeReplaced = !_view.state.selection.empty && slice.content.childCount === 1 && textContent;
            var _match = coreHelpers.findMatches(textContent, rule.regexp)[0];

            if (canBeReplaced && _match && rule.type === 'mark' && rule.replaceSelection) {
              var _view$state$selection = _view.state.selection,
                  from = _view$state$selection.from,
                  to = _view$state$selection.to;

              var textSlice = _view.state.doc.slice(from, to);

              var _textContent = textSlice.content.textBetween(0, textSlice.content.size);

              if (typeof rule.replaceSelection !== 'boolean' ? rule.replaceSelection(_textContent) : rule.replaceSelection) {
                var _ret = function () {
                  var newTextNodes = [];
                  var getAttributes = rule.getAttributes,
                      markType = rule.markType;
                  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(_match, true) : getAttributes;
                  var mark = markType.create(attributes);
                  textSlice.content.forEach(textNode => {
                    if (textNode.isText) {
                      var marks = mark.addToSet(textNode.marks);
                      newTextNodes.push(textNode.mark(marks));
                    }
                  });
                  return {
                    v: prosemirrorModel.Slice.maxOpen(prosemirrorModel.Fragment.fromArray(newTextNodes))
                  };
                }();

                if (typeof _ret === "object") return _ret.v;
              }
            }

            var _regexPasteRuleHandle = regexPasteRuleHandler(slice.content, rule, _view.state.schema),
                transformedNodes = _regexPasteRuleHandle.nodes,
                transformed = _regexPasteRuleHandle.transformed;

            if (transformed) {
              // If we have created a block node, we don't want to keep the slice's open depth for both side.
              slice = rule.type === 'node' && rule.nodeType.isBlock ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), 0, 0) : new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), slice.openStart, slice.openEnd);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return slice;
      },
      handleDOMEvents: {
        // Handle paste for pasting content.
        paste: (view, event) => {
          var _view$props$editable, _view$props;

          if (!((_view$props$editable = (_view$props = view.props).editable) !== null && _view$props$editable !== void 0 && _view$props$editable.call(_view$props, view.state))) {
            return false;
          }

          var clipboardData = event.clipboardData;

          if (!clipboardData) {
            return false;
          }

          var allFiles = [...clipboardData.items].map(data => data.getAsFile()).filter(file => !!file);

          if (allFiles.length === 0) {
            return false;
          }

          var selection = view.state.selection;

          var _iterator3 = _createForOfIteratorHelper(filePasteRules),
              _step3;

          try {
            var _loop = function _loop() {
              var _step3$value = _step3.value,
                  fileHandler = _step3$value.fileHandler,
                  regexp = _step3$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                selection,
                view,
                type: 'paste'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _ret2 = _loop();

              if (_ret2 === "continue") continue;
              if (typeof _ret2 === "object") return _ret2.v;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return false;
        },
        // Handle drop for pasting content.
        drop: (view, event) => {
          var _view$props$editable2, _view$props2, _view$posAtCoords$pos, _view$posAtCoords;

          if (!((_view$props$editable2 = (_view$props2 = view.props).editable) !== null && _view$props$editable2 !== void 0 && _view$props$editable2.call(_view$props2, view.state))) {
            return false;
          }

          var dataTransfer = event.dataTransfer,
              clientX = event.clientX,
              clientY = event.clientY;

          if (!dataTransfer) {
            return false;
          }

          var allFiles = getDataTransferFiles(event);

          if (allFiles.length === 0) {
            return false;
          }

          var pos = (_view$posAtCoords$pos = (_view$posAtCoords = view.posAtCoords({
            left: clientX,
            top: clientY
          })) === null || _view$posAtCoords === void 0 ? void 0 : _view$posAtCoords.pos) !== null && _view$posAtCoords$pos !== void 0 ? _view$posAtCoords$pos : view.state.selection.anchor;

          var _iterator4 = _createForOfIteratorHelper(filePasteRules),
              _step4;

          try {
            var _loop2 = function _loop2() {
              var _step4$value = _step4.value,
                  fileHandler = _step4$value.fileHandler,
                  regexp = _step4$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                pos,
                view,
                type: 'drop'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _ret3 = _loop2();

              if (_ret3 === "continue") continue;
              if (typeof _ret3 === "object") return _ret3.v;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return false;
        }
      }
    }
  });
}
var pastePluginKey = new prosemirrorState.PluginKey('pasteRule');
/**
 * @template RegexPasteRule
 */

/**
 * Factory for creating paste rules.
 */
function createPasteRuleHandler(transformer, schema) {
  return function handler(props) {
    var fragment = props.fragment,
        rule = props.rule,
        nodes = props.nodes;
    var regexp = rule.regexp,
        ignoreWhitespace = rule.ignoreWhitespace,
        ignoredMarks = rule.ignoredMarks,
        ignoredNodes = rule.ignoredNodes;
    var transformed = false;
    fragment.forEach(child => {
      var _child$text;

      // Check if this node should be ignored.
      if (ignoredNodes !== null && ignoredNodes !== void 0 && ignoredNodes.includes(child.type.name) || isCodeNode(child)) {
        nodes.push(child);
        return;
      } // When the current node is not a text node, recursively dive into it's child nodes.


      if (!child.isText) {
        var childResult = handler({
          fragment: child.content,
          rule,
          nodes: []
        });
        transformed || (transformed = childResult.transformed);
        var content = prosemirrorModel.Fragment.fromArray(childResult.nodes);

        if (child.type.validContent(content)) {
          nodes.push(child.copy(content));
        } else {
          nodes.push(...childResult.nodes);
        }

        return;
      } // When this is a text node ignore this child if it is wrapped by an ignored
      // mark or a code mark.


      if (child.marks.some(mark => isCodeMark(mark) || (ignoredMarks === null || ignoredMarks === void 0 ? void 0 : ignoredMarks.includes(mark.type.name)))) {
        nodes.push(child);
        return;
      }

      var text = (_child$text = child.text) !== null && _child$text !== void 0 ? _child$text : '';
      var pos = 0; // Find all matches and add the defined mark.

      var _iterator5 = _createForOfIteratorHelper(coreHelpers.findMatches(text, regexp)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _match2 = _step5.value;
          // The captured value from the regex.
          var capturedValue = _match2[1];
          var fullValue = _match2[0];

          if ( // This helps prevent matches which are only whitespace from triggering
          // an update.
          ignoreWhitespace && (capturedValue === null || capturedValue === void 0 ? void 0 : capturedValue.trim()) === '' || !fullValue) {
            return;
          }

          var start = _match2.index;
          var end = start + fullValue.length;

          if (start > 0) {
            nodes.push(child.cut(pos, start));
          }

          var textNode = child.cut(start, end); // When a capture value is provided use it.

          if (fullValue && capturedValue) {
            var startSpaces = fullValue.search(/\S/);
            var textStart = start + fullValue.indexOf(capturedValue);
            var textEnd = textStart + capturedValue.length;

            if (startSpaces) {
              nodes.push(child.cut(start, start + startSpaces));
            }

            textNode = child.cut(textStart, textEnd);
          } // A transformer to push the required nodes.


          transformer({
            nodes,
            rule,
            textNode,
            match: _match2,
            schema
          });
          transformed = true;
          pos = end;
        } // Add the rest of the node to the gathered nodes if any characters are
        // remaining.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      if (text && pos < text.length) {
        nodes.push(child.cut(pos));
      }
    });
    return {
      nodes,
      transformed
    };
  };
}
/**
 * Mark rule transformer which pushes the transformed mark into the provided
 * nodes.
 */


function markRuleTransformer(props) {
  var _textNode$text;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch,
      getAttributes = rule.getAttributes,
      markType = rule.markType;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var text = (_textNode$text = textNode.text) !== null && _textNode$text !== void 0 ? _textNode$text : '';
  var mark = markType.create(attributes);
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty text

  if (transformedCapturedValue === '') {
    return;
  } // remove the mark if transformMatch returns false


  if (transformedCapturedValue === false) {
    nodes.push(schema.text(text, textNode.marks));
    return;
  }

  var marks = mark.addToSet(textNode.marks);
  nodes.push(schema.text(transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : text, marks));
}
/**
 * Support for pasting and transforming text content into the editor.
 */


function textRuleTransformer(props) {
  var _ref;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch;
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty string or false

  if (transformedCapturedValue === '' || transformedCapturedValue === false) {
    return;
  }

  var text = (_ref = transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : textNode.text) !== null && _ref !== void 0 ? _ref : '';
  nodes.push(schema.text(text, textNode.marks));
}
/**
 * Support for pasting node content into the editor.
 */


function nodeRuleTransformer(props) {
  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match;
  var getAttributes = rule.getAttributes,
      nodeType = rule.nodeType,
      getContent = rule.getContent;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var content = (getContent ? getContent(match) : textNode) || undefined;
  nodes.push(nodeType.createChecked(attributes, content));
}
/**
 * The run the handlers for the regex paste rules on the content which has been transformed by prosemirror.
 */


function regexPasteRuleHandler(fragment, rule, schema) {
  var nodes = [];

  switch (rule.type) {
    case 'mark':
      return createPasteRuleHandler(markRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    case 'node':
      return createPasteRuleHandler(nodeRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    default:
      return createPasteRuleHandler(textRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
  }
}

var regexPasteRules = ['mark', 'node', 'text'];

/**
 * Check if the paste rule is regex based.
 */
function isRegexPastRule(rule) {
  return coreHelpers.includes(regexPasteRules, rule.type);
}

/**
 * Check whether the current selection is completely contained within a code block or mark.
 */
function isInCode(selection) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$contained = _ref2.contained,
      contained = _ref2$contained === void 0 ? true : _ref2$contained;

  if (selection.empty) {
    return resolvedPosInCode(selection.$head);
  }

  if (contained) {
    return resolvedPosInCode(selection.$head) && resolvedPosInCode(selection.$anchor);
  }

  return resolvedPosInCode(selection.$head) || resolvedPosInCode(selection.$anchor);
}
/**
 * Check if the provided position is within a code mark or node.
 */

function resolvedPosInCode($pos) {
  // Start at the current depth and work down until a depth of 1.
  var _iterator6 = _createForOfIteratorHelper(coreHelpers.range($pos.depth, 1)),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var depth = _step6.value;

      if (isCodeNode($pos.node(depth))) {
        return true;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var _iterator7 = _createForOfIteratorHelper($pos.marks()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var mark = _step7.value;

      if (isCodeMark(mark)) {
        return true;
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return false;
}
/**
 * Check if the current node is a code node.
 */


function isCodeNode(node) {
  var _node$type$spec$group;

  return node.type.spec.code || ((_node$type$spec$group = node.type.spec.group) === null || _node$type$spec$group === void 0 ? void 0 : _node$type$spec$group.split(' ').includes('code'));
}
/**
 * Check if the current mark is a code mark.
 */


function isCodeMark(mark) {
  var _mark$type$spec$group;

  return mark.type.name === 'code' || ((_mark$type$spec$group = mark.type.spec.group) === null || _mark$type$spec$group === void 0 ? void 0 : _mark$type$spec$group.split(' ').includes('code'));
}

function getDataTransferFiles(event) {
  var _dataTransfer$files, _dataTransfer$items;

  var dataTransfer = event.dataTransfer;

  if (!dataTransfer) {
    return [];
  }

  if (((_dataTransfer$files = dataTransfer.files) === null || _dataTransfer$files === void 0 ? void 0 : _dataTransfer$files.length) > 0) {
    return [...dataTransfer.files];
  }

  if ((_dataTransfer$items = dataTransfer.items) !== null && _dataTransfer$items !== void 0 && _dataTransfer$items.length) {
    // During the drag even the dataTransfer.files is null
    // but Chrome implements some drag store, which is accesible via dataTransfer.items
    return [...dataTransfer.items].map(item => item.getAsFile()).filter(item => !!item);
  }

  return [];
}

exports.isInCode = isInCode;
exports.pasteRules = pasteRules;


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _createForOfIteratorHelper = __webpack_require__(16);
var prosemirrorModel = __webpack_require__(41);
var prosemirrorState = __webpack_require__(40);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);

/**
 * Create the paste plugin handler.
 */

function pasteRules(pasteRules) {
  var sortedPasteRules = coreHelpers.sort(pasteRules, (a, z) => {
    var _z$priority, _a$priority;

    return ((_z$priority = z.priority) !== null && _z$priority !== void 0 ? _z$priority : coreConstants.ExtensionPriority.Low) - ((_a$priority = a.priority) !== null && _a$priority !== void 0 ? _a$priority : coreConstants.ExtensionPriority.Low);
  }); // Container for the regex based paste rules.

  var regexPasteRules = []; // Container for the file based paste rules.

  var filePasteRules = [];

  var _iterator = _createForOfIteratorHelper(sortedPasteRules),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var rule = _step.value;

      if (isRegexPastRule(rule)) {
        regexPasteRules.push(rule);
      } else {
        filePasteRules.push(rule);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _view;

  return new prosemirrorState.Plugin({
    key: pastePluginKey,
    view: editorView => {
      _view = editorView;
      return {};
    },
    props: {
      // The regex based paste rules are passed into this function to take care of.
      transformPasted: slice => {
        var $pos = _view.state.selection.$from;
        var nodeName = $pos.node().type.name;
        var markNames = new Set($pos.marks().map(mark => mark.type.name)); // Iterate over each rule by order of priority and update the slice each time.

        var _iterator2 = _createForOfIteratorHelper(regexPasteRules),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _rule$ignoredNodes, _rule$ignoredMarks, _slice$content$firstC, _slice$content$firstC2;

            var rule = _step2.value;

            if ( // The parent node is ignored.
            (_rule$ignoredNodes = rule.ignoredNodes) !== null && _rule$ignoredNodes !== void 0 && _rule$ignoredNodes.includes(nodeName) || // The current position contains ignored marks.
            (_rule$ignoredMarks = rule.ignoredMarks) !== null && _rule$ignoredMarks !== void 0 && _rule$ignoredMarks.some(ignored => markNames.has(ignored))) {
              continue;
            }

            var textContent = (_slice$content$firstC = (_slice$content$firstC2 = slice.content.firstChild) === null || _slice$content$firstC2 === void 0 ? void 0 : _slice$content$firstC2.textContent) !== null && _slice$content$firstC !== void 0 ? _slice$content$firstC : '';
            var canBeReplaced = !_view.state.selection.empty && slice.content.childCount === 1 && textContent;
            var _match = coreHelpers.findMatches(textContent, rule.regexp)[0];

            if (canBeReplaced && _match && rule.type === 'mark' && rule.replaceSelection) {
              var _view$state$selection = _view.state.selection,
                  from = _view$state$selection.from,
                  to = _view$state$selection.to;

              var textSlice = _view.state.doc.slice(from, to);

              var _textContent = textSlice.content.textBetween(0, textSlice.content.size);

              if (typeof rule.replaceSelection !== 'boolean' ? rule.replaceSelection(_textContent) : rule.replaceSelection) {
                var _ret = function () {
                  var newTextNodes = [];
                  var getAttributes = rule.getAttributes,
                      markType = rule.markType;
                  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(_match, true) : getAttributes;
                  var mark = markType.create(attributes);
                  textSlice.content.forEach(textNode => {
                    if (textNode.isText) {
                      var marks = mark.addToSet(textNode.marks);
                      newTextNodes.push(textNode.mark(marks));
                    }
                  });
                  return {
                    v: prosemirrorModel.Slice.maxOpen(prosemirrorModel.Fragment.fromArray(newTextNodes))
                  };
                }();

                if (typeof _ret === "object") return _ret.v;
              }
            }

            var _regexPasteRuleHandle = regexPasteRuleHandler(slice.content, rule, _view.state.schema),
                transformedNodes = _regexPasteRuleHandle.nodes,
                transformed = _regexPasteRuleHandle.transformed;

            if (transformed) {
              // If we have created a block node, we don't want to keep the slice's open depth for both side.
              slice = rule.type === 'node' && rule.nodeType.isBlock ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), 0, 0) : new prosemirrorModel.Slice(prosemirrorModel.Fragment.fromArray(transformedNodes), slice.openStart, slice.openEnd);
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return slice;
      },
      handleDOMEvents: {
        // Handle paste for pasting content.
        paste: (view, event) => {
          var _view$props$editable, _view$props;

          if (!((_view$props$editable = (_view$props = view.props).editable) !== null && _view$props$editable !== void 0 && _view$props$editable.call(_view$props, view.state))) {
            return false;
          }

          var clipboardData = event.clipboardData;

          if (!clipboardData) {
            return false;
          }

          var allFiles = [...clipboardData.items].map(data => data.getAsFile()).filter(file => !!file);

          if (allFiles.length === 0) {
            return false;
          }

          var selection = view.state.selection;

          var _iterator3 = _createForOfIteratorHelper(filePasteRules),
              _step3;

          try {
            var _loop = function _loop() {
              var _step3$value = _step3.value,
                  fileHandler = _step3$value.fileHandler,
                  regexp = _step3$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                selection,
                view,
                type: 'paste'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _ret2 = _loop();

              if (_ret2 === "continue") continue;
              if (typeof _ret2 === "object") return _ret2.v;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return false;
        },
        // Handle drop for pasting content.
        drop: (view, event) => {
          var _view$props$editable2, _view$props2, _view$posAtCoords$pos, _view$posAtCoords;

          if (!((_view$props$editable2 = (_view$props2 = view.props).editable) !== null && _view$props$editable2 !== void 0 && _view$props$editable2.call(_view$props2, view.state))) {
            return false;
          }

          var dataTransfer = event.dataTransfer,
              clientX = event.clientX,
              clientY = event.clientY;

          if (!dataTransfer) {
            return false;
          }

          var allFiles = getDataTransferFiles(event);

          if (allFiles.length === 0) {
            return false;
          }

          var pos = (_view$posAtCoords$pos = (_view$posAtCoords = view.posAtCoords({
            left: clientX,
            top: clientY
          })) === null || _view$posAtCoords === void 0 ? void 0 : _view$posAtCoords.pos) !== null && _view$posAtCoords$pos !== void 0 ? _view$posAtCoords$pos : view.state.selection.anchor;

          var _iterator4 = _createForOfIteratorHelper(filePasteRules),
              _step4;

          try {
            var _loop2 = function _loop2() {
              var _step4$value = _step4.value,
                  fileHandler = _step4$value.fileHandler,
                  regexp = _step4$value.regexp;
              var files = regexp ? allFiles.filter(file => regexp.test(file.type)) : allFiles;

              if (files.length === 0) {
                return "continue";
              }

              if (fileHandler({
                event,
                files,
                pos,
                view,
                type: 'drop'
              })) {
                event.preventDefault();
                return {
                  v: true
                };
              }
            };

            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _ret3 = _loop2();

              if (_ret3 === "continue") continue;
              if (typeof _ret3 === "object") return _ret3.v;
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          return false;
        }
      }
    }
  });
}
var pastePluginKey = new prosemirrorState.PluginKey('pasteRule');
/**
 * @template RegexPasteRule
 */

/**
 * Factory for creating paste rules.
 */
function createPasteRuleHandler(transformer, schema) {
  return function handler(props) {
    var fragment = props.fragment,
        rule = props.rule,
        nodes = props.nodes;
    var regexp = rule.regexp,
        ignoreWhitespace = rule.ignoreWhitespace,
        ignoredMarks = rule.ignoredMarks,
        ignoredNodes = rule.ignoredNodes;
    var transformed = false;
    fragment.forEach(child => {
      var _child$text;

      // Check if this node should be ignored.
      if (ignoredNodes !== null && ignoredNodes !== void 0 && ignoredNodes.includes(child.type.name) || isCodeNode(child)) {
        nodes.push(child);
        return;
      } // When the current node is not a text node, recursively dive into it's child nodes.


      if (!child.isText) {
        var childResult = handler({
          fragment: child.content,
          rule,
          nodes: []
        });
        transformed || (transformed = childResult.transformed);
        var content = prosemirrorModel.Fragment.fromArray(childResult.nodes);

        if (child.type.validContent(content)) {
          nodes.push(child.copy(content));
        } else {
          nodes.push(...childResult.nodes);
        }

        return;
      } // When this is a text node ignore this child if it is wrapped by an ignored
      // mark or a code mark.


      if (child.marks.some(mark => isCodeMark(mark) || (ignoredMarks === null || ignoredMarks === void 0 ? void 0 : ignoredMarks.includes(mark.type.name)))) {
        nodes.push(child);
        return;
      }

      var text = (_child$text = child.text) !== null && _child$text !== void 0 ? _child$text : '';
      var pos = 0; // Find all matches and add the defined mark.

      var _iterator5 = _createForOfIteratorHelper(coreHelpers.findMatches(text, regexp)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _match2 = _step5.value;
          // The captured value from the regex.
          var capturedValue = _match2[1];
          var fullValue = _match2[0];

          if ( // This helps prevent matches which are only whitespace from triggering
          // an update.
          ignoreWhitespace && (capturedValue === null || capturedValue === void 0 ? void 0 : capturedValue.trim()) === '' || !fullValue) {
            return;
          }

          var start = _match2.index;
          var end = start + fullValue.length;

          if (start > 0) {
            nodes.push(child.cut(pos, start));
          }

          var textNode = child.cut(start, end); // When a capture value is provided use it.

          if (fullValue && capturedValue) {
            var startSpaces = fullValue.search(/\S/);
            var textStart = start + fullValue.indexOf(capturedValue);
            var textEnd = textStart + capturedValue.length;

            if (startSpaces) {
              nodes.push(child.cut(start, start + startSpaces));
            }

            textNode = child.cut(textStart, textEnd);
          } // A transformer to push the required nodes.


          transformer({
            nodes,
            rule,
            textNode,
            match: _match2,
            schema
          });
          transformed = true;
          pos = end;
        } // Add the rest of the node to the gathered nodes if any characters are
        // remaining.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      if (text && pos < text.length) {
        nodes.push(child.cut(pos));
      }
    });
    return {
      nodes,
      transformed
    };
  };
}
/**
 * Mark rule transformer which pushes the transformed mark into the provided
 * nodes.
 */


function markRuleTransformer(props) {
  var _textNode$text;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch,
      getAttributes = rule.getAttributes,
      markType = rule.markType;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var text = (_textNode$text = textNode.text) !== null && _textNode$text !== void 0 ? _textNode$text : '';
  var mark = markType.create(attributes);
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty text

  if (transformedCapturedValue === '') {
    return;
  } // remove the mark if transformMatch returns false


  if (transformedCapturedValue === false) {
    nodes.push(schema.text(text, textNode.marks));
    return;
  }

  var marks = mark.addToSet(textNode.marks);
  nodes.push(schema.text(transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : text, marks));
}
/**
 * Support for pasting and transforming text content into the editor.
 */


function textRuleTransformer(props) {
  var _ref;

  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match,
      schema = props.schema;
  var transformMatch = rule.transformMatch;
  var transformedCapturedValue = transformMatch === null || transformMatch === void 0 ? void 0 : transformMatch(match); // remove the text if transformMatch returns empty string or false

  if (transformedCapturedValue === '' || transformedCapturedValue === false) {
    return;
  }

  var text = (_ref = transformedCapturedValue !== null && transformedCapturedValue !== void 0 ? transformedCapturedValue : textNode.text) !== null && _ref !== void 0 ? _ref : '';
  nodes.push(schema.text(text, textNode.marks));
}
/**
 * Support for pasting node content into the editor.
 */


function nodeRuleTransformer(props) {
  var nodes = props.nodes,
      rule = props.rule,
      textNode = props.textNode,
      match = props.match;
  var getAttributes = rule.getAttributes,
      nodeType = rule.nodeType,
      getContent = rule.getContent;
  var attributes = coreHelpers.isFunction(getAttributes) ? getAttributes(match, false) : getAttributes;
  var content = (getContent ? getContent(match) : textNode) || undefined;
  nodes.push(nodeType.createChecked(attributes, content));
}
/**
 * The run the handlers for the regex paste rules on the content which has been transformed by prosemirror.
 */


function regexPasteRuleHandler(fragment, rule, schema) {
  var nodes = [];

  switch (rule.type) {
    case 'mark':
      return createPasteRuleHandler(markRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    case 'node':
      return createPasteRuleHandler(nodeRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });

    default:
      return createPasteRuleHandler(textRuleTransformer, schema)({
        fragment,
        nodes,
        rule
      });
  }
}

var regexPasteRules = ['mark', 'node', 'text'];

/**
 * Check if the paste rule is regex based.
 */
function isRegexPastRule(rule) {
  return coreHelpers.includes(regexPasteRules, rule.type);
}

/**
 * Check whether the current selection is completely contained within a code block or mark.
 */
function isInCode(selection) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$contained = _ref2.contained,
      contained = _ref2$contained === void 0 ? true : _ref2$contained;

  if (selection.empty) {
    return resolvedPosInCode(selection.$head);
  }

  if (contained) {
    return resolvedPosInCode(selection.$head) && resolvedPosInCode(selection.$anchor);
  }

  return resolvedPosInCode(selection.$head) || resolvedPosInCode(selection.$anchor);
}
/**
 * Check if the provided position is within a code mark or node.
 */

function resolvedPosInCode($pos) {
  // Start at the current depth and work down until a depth of 1.
  var _iterator6 = _createForOfIteratorHelper(coreHelpers.range($pos.depth, 1)),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var depth = _step6.value;

      if (isCodeNode($pos.node(depth))) {
        return true;
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var _iterator7 = _createForOfIteratorHelper($pos.marks()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var mark = _step7.value;

      if (isCodeMark(mark)) {
        return true;
      }
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return false;
}
/**
 * Check if the current node is a code node.
 */


function isCodeNode(node) {
  var _node$type$spec$group;

  return node.type.spec.code || ((_node$type$spec$group = node.type.spec.group) === null || _node$type$spec$group === void 0 ? void 0 : _node$type$spec$group.split(' ').includes('code'));
}
/**
 * Check if the current mark is a code mark.
 */


function isCodeMark(mark) {
  var _mark$type$spec$group;

  return mark.type.name === 'code' || ((_mark$type$spec$group = mark.type.spec.group) === null || _mark$type$spec$group === void 0 ? void 0 : _mark$type$spec$group.split(' ').includes('code'));
}

function getDataTransferFiles(event) {
  var _dataTransfer$files, _dataTransfer$items;

  var dataTransfer = event.dataTransfer;

  if (!dataTransfer) {
    return [];
  }

  if (((_dataTransfer$files = dataTransfer.files) === null || _dataTransfer$files === void 0 ? void 0 : _dataTransfer$files.length) > 0) {
    return [...dataTransfer.files];
  }

  if ((_dataTransfer$items = dataTransfer.items) !== null && _dataTransfer$items !== void 0 && _dataTransfer$items.length) {
    // During the drag even the dataTransfer.files is null
    // but Chrome implements some drag store, which is accesible via dataTransfer.items
    return [...dataTransfer.items].map(item => item.getAsFile()).filter(item => !!item);
  }

  return [];
}

exports.isInCode = isInCode;
exports.pasteRules = pasteRules;


/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var prosemirrorPasteRules = __webpack_require__(139);



Object.keys(prosemirrorPasteRules).forEach(function (k) {
	if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
		enumerable: true,
		get: function () { return prosemirrorPasteRules[k]; }
	});
});


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var _slicedToArray = __webpack_require__(8);
var _objectSpread = __webpack_require__(14);
var _createForOfIteratorHelper = __webpack_require__(16);
var _defineProperty = __webpack_require__(15);
var coreConstants = __webpack_require__(17);
var coreHelpers = __webpack_require__(20);
var coreUtils = __webpack_require__(36);
var commands = __webpack_require__(116);
var coreTypes = __webpack_require__(120);
var _classPrivateFieldSet = __webpack_require__(91);
var _classPrivateFieldGet = __webpack_require__(94);
var nanoevents = __webpack_require__(126);
var state = __webpack_require__(38);
var warning = __webpack_require__(127);
var _applyDecoratedDescriptor = __webpack_require__(128);
var messages = __webpack_require__(68);
var model = __webpack_require__(64);
var _objectWithoutProperties = __webpack_require__(48);
var view = __webpack_require__(129);
var inputrules = __webpack_require__(83);
var keymap = __webpack_require__(132);
var pasteRules = __webpack_require__(137);
var suggest = __webpack_require__(87);

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var warning__default = /*#__PURE__*/_interopDefault(warning);

function defaultEquals(valueA, valueB) {
  return valueA === valueB;
}
/**
 * Get the property changes and the next value from an update.
 */


function getChangedOptions(props) {
  var previousOptions = props.previousOptions,
      update = props.update,
      _props$equals = props.equals,
      equals = _props$equals === void 0 ? defaultEquals : _props$equals;
  var next = coreHelpers.freeze(_objectSpread(_objectSpread({}, previousOptions), update));
  var changes = coreHelpers.object();
  var optionKeys = coreHelpers.keys(previousOptions);

  var _iterator = _createForOfIteratorHelper(optionKeys),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var key = _step.value;
      var previousValue = previousOptions[key];
      var value = next[key];

      if (equals(previousValue, value)) {
        changes[key] = {
          changed: false
        };
        continue;
      }

      changes[key] = {
        changed: true,
        previousValue,
        value
      };
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var pickChanged = keys => {
    var picked = coreHelpers.object();

    var _iterator2 = _createForOfIteratorHelper(keys),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var key = _step2.value;
        var item = changes[key];

        if (item !== null && item !== void 0 && item.changed) {
          picked[key] = item.value;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return picked;
  };

  return {
    changes: coreHelpers.freeze(changes),
    options: next,
    pickChanged
  };
}
var codeLabelMap = {
  [coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES]: 'helper method',
  [coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES]: 'command method'
};
/**
 * Checks whether a given string is unique to the set. Add the name if it
 * doesn't already exist, or throw an error when `shouldThrow` is true.
 *
 * @param props - destructured params
 */

function throwIfNameNotUnique(props) {
  var name = props.name,
      set = props.set,
      code = props.code;
  var label = codeLabelMap[code];
  !!set.has(name) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code,
    message: "There is a naming conflict for the name: ".concat(name, " used in this '").concat(label, "'. Please rename or remove from the editor to avoid runtime errors.")
  }) : coreHelpers.invariant(false) : void 0;
  set.add(name);
}

var IGNORE = '__IGNORE__';
var GENERAL_OPTIONS = '__ALL__';
class BaseClass {
  /**
   * The default options for this extension.
   *
   * TODO see if this can be cast to something other than any and allow
   * composition.
   */

  /**
   * The static keys for this class.
   */

  /**
   * The event handler keys.
   */

  /**
   * Customize the way the handler should behave.
   */

  /**
   * The custom keys.
   */

  /**
   * The unique name of this extension.
   *
   * @remarks
   *
   * Every extension **must** have a name. The name should have a distinct type
   * to allow for better type inference for end users. By convention the name
   * should be `camelCased` and unique within your editor instance.
   *
   * ```ts
   * class SimpleExtension extends Extension {
   *   get name() {
   *     return 'simple' as const;
   *   }
   * }
   * ```
   */

  /**
   * The options for this extension.
   *
   * @remarks
   *
   * Options are composed of Static, Dynamic, Handlers and ObjectHandlers.
   *
   * - `Static` - set at instantiation by the constructor.
   * - `Dynamic` - optionally set at instantiation by the constructor and also
   *   set during the runtime.
   * - `Handlers` - can only be set during the runtime.
   * - `ObjectHandlers` - Can only be set during the runtime of the extension.
   */
  get options() {
    return this._options;
  }
  /**
   * Get the dynamic keys for this extension.
   */


  get dynamicKeys() {
    return this._dynamicKeys;
  }
  /**
   * The options that this instance was created with, merged with all the
   * default options.
   */


  get initialOptions() {
    return this._initialOptions;
  }
  /**
   * The initial options at creation (used to reset).
   */


  constructor(defaultOptions) {
    for (var _len = arguments.length, _ref = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      _ref[_key - 1] = arguments[_key];
    }

    var options = _ref[0];
    this._mappedHandlers = coreHelpers.object();
    this.populateMappedHandlers();
    this._options = this._initialOptions = coreHelpers.deepMerge(defaultOptions, this.constructor.defaultOptions, options !== null && options !== void 0 ? options : coreHelpers.object(), this.createDefaultHandlerOptions());
    this._dynamicKeys = this.getDynamicKeys(); // Triggers the `init` options update for this extension.

    this.init();
  }
  /**
   * This method is called by the extension constructor. It is not strictly a
   * lifecycle method since at this point the manager has not yet been
   * instantiated.
   *
   * @remarks
   *
   * It should be used instead of overriding the constructor which is strongly
   * advised against.
   *
   * There are some limitations when using this method.
   *
   * - Accessing `this.store` will throw an error since the manager hasn't been
   *   created and it hasn't yet been attached to the extensions.
   * - `this.type` in `NodeExtension` and `MarkExtension` will also throw an
   *   error since the schema hasn't been created yet.
   *
   * You should use this to setup any instance properties with the options
   * provided to the extension.
   */


  init() {}
  /**
   * Clone the current instance with the provided options. If nothing is
   * provided it uses the same initial options as the current instance.
   */


  /**
   * Get the dynamic keys for this extension.
   */
  getDynamicKeys() {
    var dynamicKeys = [];
    var _this$constructor = this.constructor,
        customHandlerKeys = _this$constructor.customHandlerKeys,
        handlerKeys = _this$constructor.handlerKeys,
        staticKeys = _this$constructor.staticKeys;

    var _iterator = _createForOfIteratorHelper(coreHelpers.keys(this._options)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _key2 = _step.value;

        if (staticKeys.includes(_key2) || handlerKeys.includes(_key2) || customHandlerKeys.includes(_key2)) {
          continue;
        }

        dynamicKeys.push(_key2);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return dynamicKeys;
  }
  /**
   * Throw an error if non dynamic keys are updated.
   */


  ensureAllKeysAreDynamic(update) {
    if (process.env.NODE_ENV === 'production') {
      return;
    }

    var invalid = [];

    var _iterator2 = _createForOfIteratorHelper(coreHelpers.keys(update)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _key3 = _step2.value;

        if (this._dynamicKeys.includes(_key3)) {
          continue;
        }

        invalid.push(_key3);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    !coreHelpers.isEmptyArray(invalid) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_SET_EXTENSION_OPTIONS,
      message: "Invalid properties passed into the 'setOptions()' method: ".concat(JSON.stringify(invalid), ".")
    }) : coreHelpers.invariant(false) : void 0;
  }
  /**
   * Update the properties with the provided partial value when changed.
   */


  setOptions(update) {
    var _this$onSetOptions;

    var previousOptions = this.getDynamicOptions();
    this.ensureAllKeysAreDynamic(update);

    var _getChangedOptions = getChangedOptions({
      previousOptions,
      update
    }),
        changes = _getChangedOptions.changes,
        options = _getChangedOptions.options,
        pickChanged = _getChangedOptions.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so the extension can respond to any relevant
    // property updates.

    (_this$onSetOptions = this.onSetOptions) === null || _this$onSetOptions === void 0 ? void 0 : _this$onSetOptions.call(this, {
      reason: 'set',
      changes,
      options,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Reset the extension properties to their default values.
   *
   * @nonVirtual
   */


  resetOptions() {
    var _this$onSetOptions2;

    var previousOptions = this.getDynamicOptions();

    var _getChangedOptions2 = getChangedOptions({
      previousOptions,
      update: this._initialOptions
    }),
        changes = _getChangedOptions2.changes,
        options = _getChangedOptions2.options,
        pickChanged = _getChangedOptions2.pickChanged;

    this.updateDynamicOptions(options); // Trigger the update handler so that child extension properties can also be
    // updated.

    (_this$onSetOptions2 = this.onSetOptions) === null || _this$onSetOptions2 === void 0 ? void 0 : _this$onSetOptions2.call(this, {
      reason: 'reset',
      options,
      changes,
      pickChanged,
      initialOptions: this._initialOptions
    });
  }
  /**
   * Override this to receive updates whenever the options have been updated on
   * this instance. This method is called after the updates have already been
   * applied to the instance. If you need more control over exactly how the
   * option should be applied you should set the option to be `Custom`.
   *
   * **Please Note**:
   *
   * This must be defined as a instance method and not a property since it is
   * called in the constructor.
   *
   * ```ts
   * class ThisPreset extends Preset {
   *   // GOOD ✅
   *   onSetOptions(props: OnSetOptionsProps<Options>) {}
   *
   *    // BAD ❌
   *   onSetOptions = (props: OnSetOptionsProps<Options>) => {}
   * }
   * ```
   *
   * @abstract
   */


  /**
   * Update the private options.
   */
  getDynamicOptions() {
    return coreHelpers.omit(this._options, [...this.constructor.customHandlerKeys, ...this.constructor.handlerKeys]);
  }
  /**
   * Update the dynamic options.
   */


  updateDynamicOptions(options) {
    this._options = _objectSpread(_objectSpread({}, this._options), options);
  }
  /**
   * Set up the mapped handlers object with default values (an empty array);
   */


  populateMappedHandlers() {
    var _iterator3 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _key4 = _step3.value;
        this._mappedHandlers[_key4] = [];
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  }
  /**
   * This is currently fudged together, I'm not sure it will work.
   */


  createDefaultHandlerOptions() {
    var _this = this;

    var methods = coreHelpers.object();

    var _iterator4 = _createForOfIteratorHelper(this.constructor.handlerKeys),
        _step4;

    try {
      var _loop = function _loop() {
        var key = _step4.value;

        methods[key] = function () {
          var _handlerKeyOptions$ke;

          var handlerKeyOptions = _this.constructor.handlerKeyOptions;
          var reducer = (_handlerKeyOptions$ke = handlerKeyOptions[key]) === null || _handlerKeyOptions$ke === void 0 ? void 0 : _handlerKeyOptions$ke.reducer;

          for (var _len2 = arguments.length, args = new Array(_len2), _key5 = 0; _key5 < _len2; _key5++) {
            args[_key5] = arguments[_key5];
          }

          var returnValue = reducer === null || reducer === void 0 ? void 0 : reducer.getDefault(...args);

          var _iterator5 = _createForOfIteratorHelper(_this._mappedHandlers[key]),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  handler = _step5$value[1];

              var _value = handler(...args);

              returnValue = reducer ? reducer.accumulator(returnValue, _value, ...args) : _value; // Check if the method should cause an early return, based on the
              // return value.

              if (shouldReturnEarly(handlerKeyOptions, returnValue, key)) {
                return returnValue;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          return returnValue;
        };
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        _loop();
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    return methods;
  }
  /**
   * Add a handler to the event handlers so that it is called along with all the
   * other handler methods.
   *
   * This is helpful for integrating react hooks which can be used in multiple
   * places. The original problem with fixed properties is that you can only
   * assign to a method once and it overwrites any other methods. This pattern
   * for adding handlers allows for multiple usages of the same handler in the
   * most relevant part of the code.
   *
   * More to come on this pattern.
   *
   * @nonVirtual
   */


  addHandler(key, method) {
    var priority = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : coreConstants.ExtensionPriority.Default;

    this._mappedHandlers[key].push([priority, method]);

    this.sortHandlers(key); // Return a method for disposing of the handler.

    return () => this._mappedHandlers[key] = this._mappedHandlers[key].filter(_ref2 => {
      var _ref3 = _slicedToArray(_ref2, 2),
          handler = _ref3[1];

      return handler !== method;
    });
  }
  /**
   * Determines if handlers exist for the given key.
   *
   * Checking the existence of a handler property directly gives wrong results.
   * `this.options.onHandlerName` is always truthy because it is a reference to
   * the wrapper function that calls each handler.
   *
   * ```ts
   *
   * // GOOD ✅
   * if (!this.hasHandlers('onHandlerName')) {
   *   return;
   * }
   *
   * // BAD ❌
   * if (!this.options.onHandlerName) {
   *   return;
   * }
   * ```
   *
   * @param key The handler to test
   */


  hasHandlers(key) {
    var _this$_mappedHandlers;

    return ((_this$_mappedHandlers = this._mappedHandlers[key]) !== null && _this$_mappedHandlers !== void 0 ? _this$_mappedHandlers : []).length > 0;
  }

  sortHandlers(key) {
    this._mappedHandlers[key] = coreHelpers.sort(this._mappedHandlers[key], // Sort from highest binding to the lowest.
    (_ref4, _ref5) => {
      var _ref6 = _slicedToArray(_ref4, 1),
          a = _ref6[0];

      var _ref7 = _slicedToArray(_ref5, 1),
          z = _ref7[0];

      return z - a;
    });
  }
  /**
   * A method that can be used to add a custom handler. It is up to the
   * extension creator to manage the handlers and dispose methods.
   */


  addCustomHandler(key, value) {
    var _this$onAddCustomHand, _this$onAddCustomHand2;

    return (_this$onAddCustomHand = (_this$onAddCustomHand2 = this.onAddCustomHandler) === null || _this$onAddCustomHand2 === void 0 ? void 0 : _this$onAddCustomHand2.call(this, {
      [key]: value
    })) !== null && _this$onAddCustomHand !== void 0 ? _this$onAddCustomHand : coreHelpers.noop;
  }
  /**
   * Override this method if you want to set custom handlers on your extension.
   *
   * This must return a dispose function.
   */


}

_defineProperty(BaseClass, "defaultOptions", {});

_defineProperty(BaseClass, "staticKeys", []);

_defineProperty(BaseClass, "handlerKeys", []);

_defineProperty(BaseClass, "handlerKeyOptions", {});

_defineProperty(BaseClass, "customHandlerKeys", []);

/**
 * A function used to determine whether the value provided by the handler
 * warrants an early return.
 */
function shouldReturnEarly(handlerKeyOptions, returnValue, handlerKey) {
  var generalOptions = handlerKeyOptions[GENERAL_OPTIONS];
  var handlerOptions = handlerKeyOptions[handlerKey];

  if (!generalOptions && !handlerOptions) {
    return false;
  } // First check if there are options set for the provided handlerKey


  if (handlerOptions && // Only proceed if the value should not be ignored.
  handlerOptions.earlyReturnValue !== IGNORE && (coreHelpers.isFunction(handlerOptions.earlyReturnValue) ? handlerOptions.earlyReturnValue(returnValue) === true : returnValue === handlerOptions.earlyReturnValue)) {
    return true;
  }

  if (generalOptions && // Only proceed if they are not ignored.
  generalOptions.earlyReturnValue !== IGNORE && ( // Check whether the `earlyReturnValue` is a predicate check.
  coreHelpers.isFunction(generalOptions.earlyReturnValue) ? // If it is a predicate and when called with the current
  // `returnValue` the value is `true` then we should return
  // early.
  generalOptions.earlyReturnValue(returnValue) === true : // Check the actual return value.
  returnValue === generalOptions.earlyReturnValue)) {
    return true;
  }

  return false;
}
/**
 * @internal
 */

/**
 * Auto infers the parameter for the constructor. If there is a required static
 * option then the TypeScript compiler will error if nothing is passed in.
 */

/**
 * Extensions are fundamental to the way that Remirror works by grouping
 * together the functionality and handling the management of similar concerns.
 *
 * @remarks
 *
 *  Extension can adjust editor functionality in any way. Here are some
 *  examples.
 *
 * - How the editor displays certain content, i.e. **bold**, _italic_,
 *   **underline**.
 * - Which commands should be made available e.g. `commands.toggleBold()` to
 *   toggle the weight of the selected text.
 * - Check if a command is currently enabled (i.e a successful dry run) e.g.
 *   `commands.toggleBold.isEnabled()`.
 * - Register Prosemirror `Plugin`s, `keymap`s, `InputRule`s `PasteRule`s,
 *   `Suggestions`, and custom `nodeViews` which affect the behavior of the
 *   editor.
 *
 * There are three types of `Extension`.
 *
 * - `NodeExtension` - For creating Prosemirror nodes in the editor. See
 *   {@link NodeExtension}
 * - `MarkExtension` - For creating Prosemirror marks in the editor. See
 *   {@link MarkExtension}
 * - `PlainExtension` - For behavior which doesn't map to a `ProsemirrorNode` or
 *   `Mark` and as a result doesn't directly affect the Prosemirror `Schema` or
 *   content. See {@link PlainExtension}.
 *
 * This `Extension` is an abstract class that should not be used directly but
 * rather extended to add the intended functionality.
 *
 * ```ts
 * import { PlainExtension, Static } from 'remirror';
 *
 * interface AwesomeExtensionOptions {
 *   isAwesome?: Static<boolean>;
 *   id?: string;
 * }
 *
 * class AwesomeExtension extends PlainExtension<AwesomeExtensionOptions> {
 *   static defaultOptions: DefaultExtensionOptions<AwesomeExtensionOptions> = {
 *     isAwesome: true,
 *     id: '',
 *   }
 *
 *   get name() {
 *     return 'awesome' as const;
 *   }
 * }
 * ```
 */
class Extension extends BaseClass {
  /**
   * The default priority for this family of extensions.
   */

  /**
   * The priority level for this instance of the extension. A higher value
   * corresponds to a higher priority extension
   */
  get priority() {
    var _ref, _this$priorityOverrid;

    return (_ref = (_this$priorityOverrid = this.priorityOverride) !== null && _this$priorityOverrid !== void 0 ? _this$priorityOverrid : this.options.priority) !== null && _ref !== void 0 ? _ref : this.constructor.defaultPriority;
  }
  /**
   * The name that the constructor should have, which doesn't get mangled in
   * production.
   */


  get constructorName() {
    return "".concat(coreHelpers.pascalCase(this.name), "Extension");
  }
  /**
   * The store is a shared object that's internal to each extension. It includes
   * often used items like the `view` and `schema` that are added by the
   * extension manager and also the lifecycle extension methods.
   *
   * **NOTE** - The store is not available until the manager has been created
   * and received the extension. As a result trying to access the store during
   * `init` and `constructor` will result in a runtime error.
   *
   * Some properties of the store are available at different phases. You should
   * check the inline documentation to know when a certain property is useable
   * in your extension.
   */


  get store() {
    !this._store ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
      message: "An error occurred while attempting to access the 'extension.store' when the Manager has not yet set created the lifecycle methods."
    }) : coreHelpers.invariant(false) : void 0;
    return coreHelpers.freeze(this._store, {
      requireKeys: true
    });
  }
  /**
   * The list of extensions added to the editor by this `Preset`.
   */


  get extensions() {
    return this._extensions;
  }
  /**
   * Private list of extension stored within this [[`Preset`]].
   */


  constructor() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    super(defaultOptions, ...args); // Create the extension list.

    this._extensions = coreHelpers.uniqueBy(this.createExtensions(), // Ensure that all the provided extensions are unique.
    extension => extension.constructor);
    this.extensionMap = new Map(); // Create the extension map for retrieving extensions from the `Preset`

    var _iterator = _createForOfIteratorHelper(this._extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;
        this.extensionMap.set(extension.constructor, extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * When there are duplicate extensions used within the editor the extension
   * manager will call this method and make sure all extension holders are using
   * the same instance of the `ExtensionConstructor`.
   *
   * @internal
   */


  replaceChildExtension(constructor, extension) {
    if (!this.extensionMap.has(constructor)) {
      return;
    }

    this.extensionMap.set(constructor, extension);
    this._extensions = this.extensions.map(currentExtension => extension.constructor === constructor ? extension : currentExtension);
  }
  /**
   * Not for usage. This is purely for types to make it easier to infer
   * available sub extension types.
   *
   * @internal
   */


  /**
   * Create the extensions which will be consumed by the preset. Override this
   * if you would like to make your extension a parent to other (holder)
   * extensions which don't make sense existing outside of the context of this
   * extension.
   *
   * @remarks
   *
   * Since this method is called in the constructor it should always be created
   * as an instance method and not a property. Properties aren't available for
   * the call to the parent class.
   *
   * ```ts
   * class HolderExtension extends PlainExtension {
   *   get name() {
   *     return 'holder'
   *   }
   *
   *   // GOOD ✅
   *   createExtensions() {
   *     return [];
   *   }
   *
   *   // BAD ❌
   *   createExtensions = () => {
   *     return [];
   *   }
   * }
   * ```
   */
  createExtensions() {
    return [];
  }
  /**
   * Get an extension from this holder extension by providing the desired
   * `Constructor`.
   *
   * @param Constructor - the extension constructor to find in the editor.
   *
   * @remarks
   *
   * This method will throw an error if the constructor doesn't exist within the
   * extension created by this extension.
   *
   * It can be used to forward options and attach handlers to the children
   * extensions. It is the spiritual replacement of the `Preset` extension.
   *
   * ```ts
   * import { PlainExtension, OnSetOptionsProps } from 'remirror';
   *
   * interface ParentOptions { weight?: string }
   *
   * class ParentExtension extends PlainExtension<ParentOptions> {
   *   get name() {
   *     return 'parent' as const;
   *   }
   *
   *   createExtensions() {
   *     return [new BoldExtension()]
   *   }
   *
   *   onSetOptions(options: OnSetOptionsProps<ParentOptions>): void {
   *     if (options.changes.weight.changed) {
   *       // Update the value of the provided extension.
   *       this.getExtension(BoldExtension).setOption({ weight: options.changes.weight.value });
   *     }
   *   }
   * }
   * ```
   */


  getExtension(Constructor) {
    var extension = this.extensionMap.get(Constructor); // Throws an error if attempting to get an extension which is not available
    // in this preset.

    !extension ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_GET_EXTENSION,
      message: "'".concat(Constructor.name, "' does not exist within the preset: '").concat(this.name, "'")
    }) : coreHelpers.invariant(false) : void 0;
    return extension;
  }
  /**
   * Check if the type of this extension's constructor matches the type of the
   * provided constructor.
   */


  isOfType(Constructor) {
    return this.constructor === Constructor;
  }
  /**
   * Pass a reference to the globally shared `ExtensionStore` for this
   * extension.
   *
   * @remarks
   *
   * The extension store allows extensions to access important variables without
   * complicating their creator methods.
   *
   * ```ts
   * import { PlainExtension } from 'remirror';
   *
   * class Awesome extends PlainExtension {
   *   customMethod() {
   *     if (this.store.view.hasFocus()) {
   *       log('dance dance dance');
   *     }
   *   }
   * }
   * ```
   *
   * This should only be called by the `RemirrorManager`.
   *
   * @internal
   * @nonVirtual
   */


  setStore(store) {
    if (this._store) {
      return;
    }

    this._store = store;
  }
  /**
   * Clone an extension.
   */


  clone() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return new this.constructor(...args);
  }
  /**
   * Set the priority override for this extension. This is used in the
   * `RemirrorManager` in order to override the priority of an extension.
   *
   * If you set the first parameter to `undefined` it will remove the priority
   * override.
   *
   * @internal
   */


  setPriority(priority) {
    this.priorityOverride = priority;
  }

}
/**
 * Declaration merging since the constructor property can't be defined on the
 * actual class.
 */


_defineProperty(Extension, "defaultPriority", coreConstants.ExtensionPriority.Default);

/**
 * Create a plain extension which doesn't directly map to Prosemirror nodes or
 * marks.
 *
 * Plain extensions are a great way to add custom behavior to your editor.
 */
class PlainExtension extends Extension {
  /** @internal */
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.PlainExtensionConstructor;
  }
  /** @internal */


  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.PlainExtension;
  }

}
/**
 * A mark extension is based on the `Mark` concept from from within prosemirror
 * {@link https://prosemirror.net/docs/guide/#schema.marks}
 *
 * @remarks
 *
 * Marks are used to add extra styling or other information to inline content.
 * Mark types are objects much like node types, used to tag mark objects and
 * provide additional information about them.
 */

class MarkExtension extends Extension {
  /** @internal */
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.MarkExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.MarkExtension;
  }
  /**
   * Provides access to the mark type from the schema.
   *
   * @remarks
   *
   * The type is available as soon as the schema is created by the
   * `SchemaExtension` which has the priority `Highest`. It should be safe to
   * access in any of the lifecycle methods.
   */


  get type() {
    return coreHelpers.assertGet(this.store.schema.marks, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `MarkExtension`.
   *
   * @remarks
   *
   * The main difference between the return value of this method and Prosemirror
   * `MarkSpec` is that that the `toDOM` method doesn't allow dom manipulation.
   * You can only return an array or string.
   *
   * For more advanced requirements, it may be possible to create a `nodeView`
   * to manage the dom interactions.
   */


}

_defineProperty(MarkExtension, "disableExtraAttributes", false);

/**
 * Defines the abstract class for extensions which can place nodes into the
 * prosemirror state.
 *
 * @remarks
 *
 * For more information see {@link https://prosemirror.net/docs/ref/#model.Node}
 */
class NodeExtension extends Extension {
  static get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.NodeExtensionConstructor;
  }
  /**
   * Whether to disable extra attributes for this extension.
   */


  /** @internal */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.NodeExtension;
  }
  /**
   * Provides access to the node type from the schema.
   */


  get type() {
    return coreHelpers.assertGet(this.store.schema.nodes, this.name);
  }

  constructor() {
    super(...arguments);
  }
  /**
   * Provide a method for creating the schema. This is required in order to
   * create a `NodeExtension`.
   *
   * @remarks
   *
   * A node schema defines the behavior of the content within the editor. This
   * is very tied to the prosemirror implementation and the best place to learn
   * more about it is in the
   * {@link https://prosemirror.net/docs/guide/#schema docs}.
   *
   * @params hole - a method that is meant to indicate where extra attributes
   * should be placed (if they exist).
   *
   * The `hole` is a function that augments the passed object adding a special
   * `secret` key which is used to insert the extra attributes setter.
   *
   * ```ts
   * import { NodeExtension, SpecHole } from 'remirror';
   *
   * class AwesomeExtension extends NodeExtension {
   *   get name() { return 'awesome' as const'; }
   *
   *   createNodeSpec() {
   *     return {
   *       toDOM: (node) => {
   *         return ['p', hole(), 0]
   *       }
   *     }
   *   }
   * }
   * ```
   *
   * The above example will have the `hole()` method call replaced with the
   * extra attributes.
   */


}

_defineProperty(NodeExtension, "disableExtraAttributes", false);

/**
 * These are the default options merged into every extension. They can be
 * overridden.
 */
var defaultOptions = {
  priority: undefined,
  extraAttributes: {},
  disableExtraAttributes: false,
  exclude: {}
};
/**
 * Mutate the default extension options.
 *
 * @remarks
 *
 * This is a dangerous method since it allows you to mutate the received object.
 * Don't use it unless you absolutely have to.
 *
 * A potential use case is for adding a new default option to all extensions. It
 * shows an example of how to accomplish this in a typesafe way.
 *
 * ```ts
 * import { mutateDefaultExtensionOptions } from 'remirror';
 *
 * mutateDefaultExtensionOptions((settings) => {
 *   // Set the default value of all extensions to have a property `customSetting` with value `false`.
 *   settings.customSetting = false;
 * })
 *
 * declare global {
 *   namespace Remirror {
 *     interface BaseExtensionOptions {
 *       customSetting?: boolean;
 *     }
 *   }
 * }
 *```
 *
 * The mutation must happen before any extension have been instantiated.
 */

function mutateDefaultExtensionOptions(mutatorMethod) {
  mutatorMethod(defaultOptions);
}
/**
 * Determines if the passed value is an extension.
 *
 * @param value - the value to test
 */

function isExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, [coreConstants.RemirrorIdentifier.PlainExtension, coreConstants.RemirrorIdentifier.MarkExtension, coreConstants.RemirrorIdentifier.NodeExtension]);
}
/**
 * Determines if the passed value is an extension constructor.
 *
 * @param value - the value to test
 */

function isExtensionConstructor(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, [coreConstants.RemirrorIdentifier.PlainExtensionConstructor, coreConstants.RemirrorIdentifier.MarkExtensionConstructor, coreConstants.RemirrorIdentifier.NodeExtensionConstructor]);
}
/**
 * Checks whether the provided value is a plain extension.
 *
 * @param value - the extension to check
 */

function isPlainExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.PlainExtension);
}
/**
 * Determines if the passed in extension is a node extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isNodeExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.NodeExtension);
}
/**
 * Determines if the passed in extension is a mark extension. Useful as a type
 * guard where a particular type of extension is needed.
 *
 * @param value - the extension to check
 */

function isMarkExtension(value) {
  return coreUtils.isRemirrorType(value) && coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.MarkExtension);
}

var _excluded$2 = ["defaultOptions", "customHandlerKeys", "handlerKeys", "staticKeys", "defaultPriority", "handlerKeyOptions"];

/**
 * A decorator for the remirror extension.
 *
 * This adds static properties to the extension constructor.
 */
function extension(options) {
  return ReadonlyConstructor => {
    var _ref, _ref2, _ref3;

    var defaultOptions = options.defaultOptions,
        customHandlerKeys = options.customHandlerKeys,
        handlerKeys = options.handlerKeys,
        staticKeys = options.staticKeys,
        defaultPriority = options.defaultPriority,
        handlerKeyOptions = options.handlerKeyOptions,
        rest = _objectWithoutProperties(options, _excluded$2);

    var Constructor = coreHelpers.Cast(ReadonlyConstructor);

    if (defaultOptions) {
      Constructor.defaultOptions = defaultOptions;
    }

    if (defaultPriority) {
      Constructor.defaultPriority = defaultPriority;
    }

    if (handlerKeyOptions) {
      Constructor.handlerKeyOptions = handlerKeyOptions;
    }

    Constructor.staticKeys = (_ref = staticKeys) !== null && _ref !== void 0 ? _ref : [];
    Constructor.handlerKeys = (_ref2 = handlerKeys) !== null && _ref2 !== void 0 ? _ref2 : [];
    Constructor.customHandlerKeys = (_ref3 = customHandlerKeys) !== null && _ref3 !== void 0 ? _ref3 : [];

    for (var _i = 0, _Object$entries = Object.entries(rest); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      if (Constructor[key]) {
        continue;
      }

      Constructor[key] = value;
    }

    return coreHelpers.Cast(Constructor);
  };
}
/**
 * @deprecated use `extension` instead.
 */

var extensionDecorator = extension;

/**
 * This extension allows others extension to add the `createAttributes` method
 * for adding attributes to the prosemirror dom element.
 *
 * @remarks
 *
 * Use this to include all the dynamically generated attributes provided by each
 * extension. High priority extensions have preference over the lower priority
 * extensions.
 *
 * @category Builtin Extension
 */

class AttributesExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "attributeList", []);

    _defineProperty(this, "attributeObject", coreHelpers.object());

    _defineProperty(this, "updateAttributes", function () {
      var triggerUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      _this.transformAttributes();

      if (triggerUpdate) {
        _this.store.commands.forceUpdate('attributes');
      }
    });
  }

  get name() {
    return 'attributes';
  }

  /**
   * Create the attributes object on initialization.
   *
   * @internal
   */
  onCreate() {
    this.transformAttributes();
    this.store.setExtensionStore('updateAttributes', this.updateAttributes);
  }

  transformAttributes() {
    var _this$store$managerSe;

    this.attributeObject = coreHelpers.object(); // Exit early when the manager excludes these settings.

    if ((_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.attributes) {
      this.store.setStoreKey('attributes', this.attributeObject);
      return;
    } // Reset this attributes


    this.attributeList = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$options$ex, _extension$createAttr, _extension$classNames;

        var extension = _step.value;

        if ((_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.attributes) {
          continue;
        }

        var createdAttributes = (_extension$createAttr = extension.createAttributes) === null || _extension$createAttr === void 0 ? void 0 : _extension$createAttr.call(extension);

        var attributes = _objectSpread(_objectSpread({}, createdAttributes), {}, {
          class: coreHelpers.cx(...((_extension$classNames = extension.classNames) !== null && _extension$classNames !== void 0 ? _extension$classNames : []), createdAttributes === null || createdAttributes === void 0 ? void 0 : createdAttributes.class)
        }); // Inserted at the start of the list so that when combining the full
        // attribute object the higher priority extension attributes are
        // preferred to the lower priority since they merge with the object
        // later.


        this.attributeList.unshift(attributes);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = _createForOfIteratorHelper(this.attributeList),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _attributes = _step2.value;
        this.attributeObject = _objectSpread(_objectSpread(_objectSpread({}, this.attributeObject), _attributes), {}, {
          class: coreHelpers.cx(this.attributeObject.class, _attributes.class)
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.store.setStoreKey('attributes', this.attributeObject);
  }

}

/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as helpers. This can be used as a replacement for the
 * `createHelpers` method.
 *
 * To allow the TypeScript compiler to automatically infer types, please create
 * your methods with the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { helper, Helper } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @helper()
 *   alwaysTrue(): Helper<boolean> {
 *     return true;
 *   }
 * }
 * ```
 *
 * The above helper can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { helpers } = useRemirrorContext();
 *
 *   return helpers.alwaysTrue() ? <button>My Button</button> : null
 * }
 * ```
 *
 * @category Method Decorator
 */
function helper() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedHelp;

    // Attach the options to the `decoratedCommands` property for this extension.
    ((_target$decoratedHelp = target.decoratedHelpers) !== null && _target$decoratedHelp !== void 0 ? _target$decoratedHelp : target.decoratedHelpers = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to top level methods on an extension to
 * identify them as commands. This can be used as a replacement for the
 * `createCommands` method.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createCommands`. Internally the decorators are being used as they are better
 * for documentation purposes.
 *
 * For automated type inference methods that use this decorator must implement
 * the following type signature.
 *
 * ```ts
 * import { CommandFunction } from '@remirror/core';
 *
 * type Signature = (...args: any[]) => CommandFunction;
 * ```
 *
 * The following is an example of how this can be used within your extension.
 *
 * ```ts
 * import { command, CommandFunction } from '@remirror/core';
 *
 * class MyExtension {
 *   get name() {
 *     return 'my';
 *   }
 *
 *   @command() myCommand(text: string): CommandFunction {return ({ tr, dispatch
 *   }) => {dispatch?.(tr.insertText('my command ' + text)); return true;
 *     }
 *   }
 * }
 * ```
 *
 * The above command can now be used within your editor instance.
 *
 * ```tsx
 * import { useRemirrorContext } from '@remirror/react';
 *
 * const MyEditorButton = () => {
 *   const { commands } = useRemirrorContext();
 *
 *   return <button onClick={() => commands.myCommand('hello')}>My Button</button>
 * }
 * ```
 *
 * @category Method Decorator
 */

function command() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedComm;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedComm = target.decoratedCommands) !== null && _target$decoratedComm !== void 0 ? _target$decoratedComm : target.decoratedCommands = {})[propertyKey] = options;
  };
}
/**
 * A decorator which can be applied to an extension method to
 * identify as a key binding method. This can be used as a replacement for
 * the `createKeymap` method depending on your preference.
 *
 * If you prefer not to use decorators, then you can continue using
 * `createKeymap`.
 *
 * @category Method Decorator
 */

function keyBinding(options) {
  return (target, propertyKey, _descriptor) => {
    var _target$decoratedKeyb;

    // Attach the options to the decoratedCommands property for this extension.
    ((_target$decoratedKeyb = target.decoratedKeybindings) !== null && _target$decoratedKeyb !== void 0 ? _target$decoratedKeyb : target.decoratedKeybindings = {})[propertyKey] = options;
  };
}

/**
 * Returns `true` when the provided value is a delayed value.
 */
function isDelayedValue(value) {
  return coreHelpers.isFunction(value) || coreHelpers.isPromise(value);
}
/**
 * Add tentative support for delayed commands in the editor.
 *
 * Delayed commands are commands that run an immediate action, like adding a
 * tracker to a position in the document. Once the promise that is provided is
 * returned the `onDone` parameter is run with the document in the current
 * state. The tracker that was added can now be used to insert content, delete
 * content or replace content.
 *
 * @experimental This is still being worked on and the API is subject to changes
 * in structure going forward.
 *
 * @deprecated use [[`DelayedCommand`]] instead.
 *
 */

function delayedCommand(_ref) {
  var immediate = _ref.immediate,
      promise = _ref.promise,
      onDone = _ref.onDone,
      onFail = _ref.onFail;
  return props => {
    var view = props.view;

    if ((immediate === null || immediate === void 0 ? void 0 : immediate(props)) === false) {
      return false;
    }

    if (!view) {
      return true;
    }

    var deferred = coreHelpers.isFunction(promise) ? promise() : promise;
    deferred.then(value => {
      // Run the command
      onDone({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view,
        value
      });
    }).catch(() => {
      // Run the failure command if it exists.
      onFail === null || onFail === void 0 ? void 0 : onFail({
        state: view.state,
        tr: view.state.tr,
        dispatch: view.dispatch,
        view
      });
    });
    return true;
  };
}
class DelayedCommand {
  constructor(promiseCreator) {
    _defineProperty(this, "failureHandlers", []);

    _defineProperty(this, "successHandlers", []);

    _defineProperty(this, "validateHandlers", []);

    _defineProperty(this, "generateCommand", () => {
      return props => {
        var isValid = true;
        var view = props.view,
            tr = props.tr,
            dispatch = props.dispatch;

        if (!view) {
          return false;
        }

        var _iterator = _createForOfIteratorHelper(this.validateHandlers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var handler = _step.value;

            if (!handler(_objectSpread(_objectSpread({}, props), {}, {
              dispatch: () => {}
            }))) {
              isValid = false;
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        if (!dispatch || !isValid) {
          return isValid;
        } // Start the promise.


        var deferred = this.promiseCreator(props);
        deferred.then(value => {
          this.runHandlers(this.successHandlers, {
            value,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        }).catch(error => {
          this.runHandlers(this.failureHandlers, {
            error,
            state: view.state,
            tr: view.state.tr,
            dispatch: view.dispatch,
            view
          });
        });
        dispatch(tr);
        return true;
      };
    });

    this.promiseCreator = promiseCreator;
  }
  /**
   * The commands that will immediately be run and used to evaluate whether to
   * proceed.
   */


  validate(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.validateHandlers[method](handler);
    return this;
  }
  /**
   * Add a success callback to the handler.
   */


  success(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.successHandlers[method](handler);
    return this;
  }
  /**
   * Add a failure callback to the handler.
   */


  failure(handler) {
    var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'push';
    this.failureHandlers[method](handler);
    return this;
  }

  runHandlers(handlers, param) {
    var _param$dispatch;

    var _iterator2 = _createForOfIteratorHelper(handlers),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var handler = _step2.value;

        if (!handler(_objectSpread(_objectSpread({}, param), {}, {
          dispatch: () => {}
        }))) {
          break;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    (_param$dispatch = param.dispatch) === null || _param$dispatch === void 0 ? void 0 : _param$dispatch.call(param, param.tr);
  }
  /**
   * Generate the `remirror` command.
   */


}

/**
 * A custom `toggleMark` function that works for the `remirror` codebase.
 *
 * Create a command function that toggles the given mark with the given
 * attributes. Will return `false` when the current selection doesn't support
 * that mark. This will remove the mark if any marks of that type exist in the
 * selection, or add it otherwise. If the selection is empty, this applies to
 * the [stored marks](#state.EditorState.storedMarks) instead of a range of the
 * document.
 *
 * The differences from the `prosemirror-commands` version.
 * - Acts on the transaction rather than the state to allow for commands to be
 *   chained together.
 * - Uses the ONE parameter function signature for compatibility with remirror.
 * - Supports passing a custom range.
 */
function toggleMark(props) {
  var type = props.type,
      attrs = props.attrs,
      range = props.range,
      selection = props.selection;
  return props => {
    var dispatch = props.dispatch,
        tr = props.tr,
        state = props.state;
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;
    !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type, " does not exist on the current schema.")
    }) : coreHelpers.invariant(false) : void 0;

    if (range || selection) {
      var _ref2;

      var _getTextSelection = coreUtils.getTextSelection((_ref2 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref2 !== void 0 ? _ref2 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to;

      coreUtils.isMarkActive(_objectSpread({
        trState: tr,
        type
      }, range)) ? dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.removeMark(from, to, markType)) : dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.addMark(from, to, markType.create(attrs)));
      return true;
    }

    return coreUtils.convertCommand(commands.toggleMark(markType, attrs))(props);
  };
}
/**
 * Verifies that the mark type can be applied to the current document.
 */

function markApplies(type, doc, ranges) {
  var _iterator3 = _createForOfIteratorHelper(ranges),
      _step3;

  try {
    var _loop = function _loop() {
      var _step3$value = _step3.value,
          $from = _step3$value.$from,
          $to = _step3$value.$to;
      var markIsAllowed = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
      doc.nodesBetween($from.pos, $to.pos, node => {
        if (markIsAllowed) {
          // This prevents diving deeper into child nodes.
          return false;
        }

        markIsAllowed = node.inlineContent && node.type.allowsMarkType(type);
        return;
      });

      if (markIsAllowed) {
        return {
          v: true
        };
      }
    };

    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _ret = _loop();

      if (typeof _ret === "object") return _ret.v;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return false;
}
/**
 * Apply the provided mark type and attributes.
 *
 * @param markType - the mark to apply.
 * @param attrs - the attributes to set on the applied mark.
 * @param selectionPoint - optionally specify where the mark should be applied.
 * Defaults to the current selection.
 */


function applyMark(type, attrs, selectionPoint) {
  return _ref3 => {
    var tr = _ref3.tr,
        dispatch = _ref3.dispatch,
        state = _ref3.state;
    var selection = coreUtils.getTextSelection(selectionPoint !== null && selectionPoint !== void 0 ? selectionPoint : tr.selection, tr.doc);
    var $cursor = coreUtils.getCursor(selection);
    var markType = coreHelpers.isString(type) ? state.schema.marks[type] : type;
    !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.SCHEMA,
      message: "Mark type: ".concat(type, " does not exist on the current schema.")
    }) : coreHelpers.invariant(false) : void 0;

    if (selection.empty && !$cursor || !markApplies(markType, tr.doc, selection.ranges)) {
      return false;
    }

    if (!dispatch) {
      return true;
    }

    if ($cursor) {
      tr.removeStoredMark(markType);

      if (attrs) {
        tr.addStoredMark(markType.create(attrs));
      }

      dispatch(tr);
      return true;
    }

    var containsMark = false;

    var _iterator4 = _createForOfIteratorHelper(selection.ranges),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _step4$value = _step4.value,
            $from = _step4$value.$from,
            $to = _step4$value.$to;

        if (containsMark) {
          break;
        }

        containsMark = tr.doc.rangeHasMark($from.pos, $to.pos, markType);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var _iterator5 = _createForOfIteratorHelper(selection.ranges),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _step5.value,
            _$from = _step5$value.$from,
            _$to = _step5$value.$to;

        if (containsMark) {
          tr.removeMark(_$from.pos, _$to.pos, markType);
        }

        if (attrs) {
          tr.addMark(_$from.pos, _$to.pos, markType.create(attrs));
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    dispatch(tr);
    return true;
  };
}

/**
 * Insert text into the dom at the current location by default. If a promise is
 * provided then the text will be inserted at the tracked position when the
 * promise is resolved.
 */
function insertText(text) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return _ref4 => {
    var tr = _ref4.tr,
        dispatch = _ref4.dispatch,
        state = _ref4.state;
    var schema = state.schema;
    var selection = tr.selection;
    var _options$from = options.from,
        from = _options$from === void 0 ? selection.from : _options$from,
        _options$to = options.to,
        to = _options$to === void 0 ? from !== null && from !== void 0 ? from : selection.to : _options$to,
        _options$marks = options.marks,
        marks = _options$marks === void 0 ? {} : _options$marks;

    if (!dispatch) {
      return true;
    } // Insert the text


    tr.insertText(text, from, to); // Map the end position after inserting the text to understand what needs to
    // be wrapped with a mark.

    var end = coreHelpers.assertGet(tr.steps, tr.steps.length - 1).getMap().map(to); // Loop through the provided marks to add the mark to the selection. This
    // uses the order of the map you created. If any marks are exclusive, they
    // will override the previous.

    var _iterator6 = _createForOfIteratorHelper(coreHelpers.entries(marks)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            markName = _step6$value[0],
            attributes = _step6$value[1];

        tr.addMark(from, end, coreHelpers.assertGet(schema.marks, markName).create(attributes));
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    dispatch(tr);
    return true;
  };
}

var _dec$a, _dec2$4, _dec3$4, _dec4$4, _dec5$3, _dec6$2, _dec7$2, _dec8$2, _dec9$1, _dec10$1, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _class$a, _class2$4;
var CommandsExtension = (_dec$a = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest,
  defaultOptions: {
    trackerClassName: 'remirror-tracker-position',
    trackerNodeName: 'span'
  },
  staticKeys: ['trackerClassName', 'trackerNodeName']
}), _dec2$4 = command(), _dec3$4 = command(), _dec4$4 = command(), _dec5$3 = command(), _dec6$2 = command(), _dec7$2 = command(), _dec8$2 = command(), _dec9$1 = command(), _dec10$1 = command(), _dec11 = command(), _dec12 = command(), _dec13 = command(), _dec14 = command(), _dec15 = command(), _dec16 = command(), _dec17 = command(), _dec18 = command(), _dec19 = command(), _dec20 = command(), _dec21 = command(), _dec22 = command(), _dec23 = command(), _dec24 = command(), _dec25 = command({
  description: _ref => {
    var t = _ref.t;
    return t(messages.CoreMessages.SELECT_ALL_DESCRIPTION);
  },
  label: _ref2 => {
    var t = _ref2.t;
    return t(messages.CoreMessages.SELECT_ALL_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.SelectAll
}), _dec26 = command({
  description: _ref3 => {
    var t = _ref3.t;
    return t(messages.CoreMessages.COPY_DESCRIPTION);
  },
  label: _ref4 => {
    var t = _ref4.t;
    return t(messages.CoreMessages.COPY_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Copy,
  icon: 'fileCopyLine'
}), _dec27 = command({
  description: _ref5 => {
    var t = _ref5.t;
    return t(messages.CoreMessages.PASTE_DESCRIPTION);
  },
  label: _ref6 => {
    var t = _ref6.t;
    return t(messages.CoreMessages.PASTE_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Paste,
  icon: 'clipboardLine'
}), _dec28 = command({
  description: _ref7 => {
    var t = _ref7.t;
    return t(messages.CoreMessages.CUT_DESCRIPTION);
  },
  label: _ref8 => {
    var t = _ref8.t;
    return t(messages.CoreMessages.CUT_LABEL);
  },
  shortcut: coreConstants.NamedShortcut.Cut,
  icon: 'scissorsFill'
}), _dec29 = command(), _dec30 = helper(), _dec31 = helper(), _dec32 = helper(), _dec$a(_class$a = (_class2$4 = class CommandsExtension extends PlainExtension {
  constructor() {
    var _this;

    super(...arguments);
    _this = this;

    _defineProperty(this, "decorated", new Map());

    _defineProperty(this, "forceUpdateTransaction", function (tr) {
      var _this$getCommandMeta = _this.getCommandMeta(tr),
          forcedUpdates = _this$getCommandMeta.forcedUpdates;

      for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        keys[_key - 1] = arguments[_key];
      }

      _this.setCommandMeta(tr, {
        forcedUpdates: coreHelpers.uniqueArray([...forcedUpdates, ...keys])
      });

      return tr;
    });
  }

  get name() {
    return 'commands';
  }
  /**
   * The current transaction which allows for making commands chainable.
   *
   * It is shared by all the commands helpers and can even be used in the
   * [[`KeymapExtension`]].
   *
   * @internal
   */


  get transaction() {
    // Make sure we have the most up to date state.
    var state = this.store.getState();

    if (!this._transaction) {
      // Since there is currently no transaction set, make sure to create a new
      // one. Behind the scenes `state.tr` creates a new transaction for us to
      // use.
      this._transaction = state.tr;
    } // Check that the current transaction is valid.


    var isValid = this._transaction.before.eq(state.doc); // Check whether the current transaction has any already applied to it.


    var hasSteps = !coreHelpers.isEmptyArray(this._transaction.steps);

    if (!isValid) {
      // Since the transaction is not valid we create a new one to prevent any
      // `mismatched` transaction errors.
      var _tr = state.tr; // Now checking if any steps had been added to the previous transaction
      // and adding them to the newly created transaction.

      if (hasSteps) {
        var _iterator = _createForOfIteratorHelper(this._transaction.steps),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var step = _step.value;

            _tr.step(step);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } // Make sure to store the transaction value to the instance of this
      // extension.


      this._transaction = _tr;
    }

    return this._transaction;
  }
  /**
   * This is the holder for the shared transaction which is shared by commands
   * in order to support chaining.
   *
   * @internal
   */


  onCreate() {
    this.store.setStoreKey('getForcedUpdates', this.getForcedUpdates.bind(this));
  }
  /**
   * Attach commands once the view is attached.
   */


  onView(view) {
    var _this2 = this;

    var _this$store = this.store,
        extensions = _this$store.extensions,
        helpers = _this$store.helpers;
    var commands = coreHelpers.object();
    var names = new Set();
    var allDecoratedCommands = coreHelpers.object();

    var chain = tr => {
      // This function allows for custom chaining.
      var customChain = coreHelpers.object();

      var getTr = () => tr !== null && tr !== void 0 ? tr : this.transaction;

      var commandChain = [];

      var getChain = () => commandChain;

      for (var _i = 0, _Object$entries = Object.entries(commands); _i < _Object$entries.length; _i++) {
        var _allDecoratedCommands;

        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
            name = _Object$entries$_i[0],
            _command = _Object$entries$_i[1];

        if ((_allDecoratedCommands = allDecoratedCommands[name]) !== null && _allDecoratedCommands !== void 0 && _allDecoratedCommands.disableChaining) {
          continue;
        }

        customChain[name] = this.chainedFactory({
          chain: customChain,
          command: _command.original,
          getTr,
          getChain
        });
      }
      /**
       * This function is used in place of the `view.dispatch` method which is
       * passed through to all commands.
       *
       * It is responsible for checking that the transaction which was
       * dispatched is the same as the shared transaction which makes chainable
       * commands possible.
       */


      var dispatch = transaction => {
        // Throw an error if the transaction being dispatched is not the same as
        // the currently stored transaction.
        !(transaction === getTr()) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
          message: 'Chaining currently only supports `CommandFunction` methods which do not use the `state.tr` property. Instead you should use the provided `tr` property.'
        }) : coreHelpers.invariant(false) : void 0;
      };

      customChain.run = function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var commands = commandChain;
        commandChain = [];

        var _iterator2 = _createForOfIteratorHelper(commands),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var cmd = _step2.value;

            // Exit early when the command returns false and the option is
            // provided.
            if (!cmd(dispatch) && options.exitEarly) {
              return;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        view.dispatch(getTr());
      };

      customChain.tr = () => {
        var commands = commandChain;
        commandChain = [];

        var _iterator3 = _createForOfIteratorHelper(commands),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var cmd = _step3.value;
            cmd(dispatch);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return getTr();
      };

      customChain.enabled = () => {
        var _iterator4 = _createForOfIteratorHelper(commandChain),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var cmd = _step4.value;

            if (!cmd()) {
              return false;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return true;
      };

      return customChain;
    };

    var _iterator5 = _createForOfIteratorHelper(extensions),
        _step5;

    try {
      var _loop = function _loop() {
        var _extension$createComm, _extension$createComm2, _extension$decoratedC;

        var extension = _step5.value;
        var extensionCommands = (_extension$createComm = (_extension$createComm2 = extension.createCommands) === null || _extension$createComm2 === void 0 ? void 0 : _extension$createComm2.call(extension)) !== null && _extension$createComm !== void 0 ? _extension$createComm : {};
        var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
        var active = {}; // Augment the decorated commands.

        allDecoratedCommands = _objectSpread(_objectSpread({}, allDecoratedCommands), {}, {
          decoratedCommands
        });

        var _loop2 = function _loop2() {
          var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i3], 2),
              commandName = _Object$entries3$_i[0],
              options = _Object$entries3$_i[1];

          var shortcut = coreHelpers.isString(options.shortcut) && options.shortcut.startsWith('_|') ? {
            shortcut: helpers.getNamedShortcut(options.shortcut, extension.options)
          } : undefined;

          _this2.updateDecorated(commandName, _objectSpread(_objectSpread({}, options), {}, {
            name: extension.name
          }, shortcut));

          extensionCommands[commandName] = extension[commandName].bind(extension);

          if (options.active) {
            active[commandName] = () => {
              var _options$active, _options$active2;

              return (_options$active = (_options$active2 = options.active) === null || _options$active2 === void 0 ? void 0 : _options$active2.call(options, extension.options, _this2.store)) !== null && _options$active !== void 0 ? _options$active : false;
            };
          }
        };

        for (var _i3 = 0, _Object$entries3 = Object.entries(decoratedCommands); _i3 < _Object$entries3.length; _i3++) {
          _loop2();
        }

        if (coreHelpers.isEmptyObject(extensionCommands)) {
          return "continue";
        } // Gather the returned commands object from the extension.


        _this2.addCommands({
          active,
          names,
          commands,
          extensionCommands
        });
      };

      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    var chainProperty = chain();

    for (var _i2 = 0, _Object$entries2 = Object.entries(chainProperty); _i2 < _Object$entries2.length; _i2++) {
      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),
          key = _Object$entries2$_i[0],
          _command2 = _Object$entries2$_i[1];

      chain[key] = _command2;
    }

    this.store.setStoreKey('commands', commands);
    this.store.setStoreKey('chain', chain);
    this.store.setExtensionStore('commands', commands);
    this.store.setExtensionStore('chain', chain);
  }
  /**
   * Update the cached transaction whenever the state is updated.
   */


  onStateUpdate(_ref9) {
    var state = _ref9.state;
    this._transaction = state.tr;
  }
  /**
   * Create a plugin that solely exists to track forced updates via the
   * generated plugin key.
   */


  createPlugin() {
    return {};
  }
  /**
   * Enable custom commands to be used within the editor by users.
   *
   * This is preferred to the initial idea of setting commands on the
   * manager or even as a prop. The problem is that there's no typechecking
   * and it should be just fine to add your custom commands here to see the
   * dispatched immediately.
   *
   * To use it, firstly define the command.
   *
   * ```ts
   * import { CommandFunction } from 'remirror';
   *
   * const myCustomCommand: CommandFunction = ({ tr, dispatch }) => {
   *   dispatch?.(tr.insertText('My Custom Command'));
   *
   *   return true;
   * }
   * ```
   *
   * And then use it within the component.
   *
   * ```ts
   * import React, { useCallback } from 'react';
   * import { useRemirror } from '@remirror/react';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(myCustomCommand);
   *   }, [commands])
   *
   *   return <button onClick={onClick}>Custom Command</button>
   * }
   * ```
   *
   * An alternative is to use a custom command directly from a
   * `prosemirror-*` library. This can be accomplished in the following way.
   *
   *
   * ```ts
   * import { joinDown } from 'prosemirror-commands';
   * import { convertCommand } from 'remirror';
   *
   * const MyEditorButton = () => {
   *   const { commands } = useRemirror();
   *   const onClick = useCallback(() => {
   *     commands.customDispatch(convertCommand(joinDown));
   *   }, [commands]);
   *
   *   return <button onClick={onClick}>Custom Command</button>;
   * };
   * ```
   */


  customDispatch(command) {
    return command;
  }
  /**
   * Insert text into the dom at the current location by default. If a
   * promise is provided instead of text the resolved value will be inserted
   * at the tracked position.
   */


  insertText(text) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (coreHelpers.isString(text)) {
      return insertText(text, options);
    }

    return this.store.createPlaceholderCommand({
      promise: text,
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, range, props) => {
        return this.insertText(value, _objectSpread(_objectSpread({}, options), range))(props);
      }
    }).generateCommand();
  }
  /**
   * Select the text within the provided range.
   *
   * Here are some ways it can be used.
   *
   * ```ts
   * // Set to the end of the document.
   * commands.selectText('end');
   *
   * // Set the selection to the start of the document.
   * commands.selectText('start');
   *
   * // Select all the text in the document.
   * commands.selectText('all')
   *
   * // Select a range of text. It's up to you to make sure the selected
   * // range is valid.
   * commands.selectText({ from: 10, to: 15 });
   *
   * // Specify the anchor and range in the selection.
   * commands.selectText({ anchor: 10, head: 15 });
   *
   * // Set to a specific position.
   * commands.selectText(10);
   *
   * // Use a ProseMirror selection
   * commands.selectText(new TextSelection(state.doc.resolve(10)))
   * ```
   *
   * Although this is called `selectText` you can provide your own selection
   * option which can be any type of selection.
   */


  selectText(selection) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref10 => {
      var tr = _ref10.tr,
          dispatch = _ref10.dispatch;
      var textSelection = coreUtils.getTextSelection(selection, tr.doc); // Check if the selection is unchanged (for example when refocusing on the
      // editor) and if it is, then the text doesn't need to be reselected.

      var selectionUnchanged = tr.selection.anchor === textSelection.anchor && tr.selection.head === textSelection.head;

      if (selectionUnchanged && !options.forceUpdate) {
        // Do nothing if the selection is unchanged.
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(textSelection));
      return true;
    };
  }
  /**
   * Select the link at the current location.
   */


  selectMark(type) {
    return props => {
      var tr = props.tr;
      var range = coreUtils.getMarkRange(tr.selection.$from, type);

      if (!range) {
        return false;
      }

      return this.store.commands.selectText.original({
        from: range.from,
        to: range.to
      })(props);
    };
  }
  /**
   * Delete the provided range or current selection.
   */


  delete(range) {
    return _ref11 => {
      var tr = _ref11.tr,
          dispatch = _ref11.dispatch;

      var _ref12 = range !== null && range !== void 0 ? range : tr.selection,
          from = _ref12.from,
          to = _ref12.to;

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(from, to));
      return true;
    };
  }
  /**
   * Fire an empty update to trigger an update to all decorations, and state
   * that may not yet have run.
   *
   * This can be used in extensions to trigger updates when certain options that
   * affect the editor state have changed.
   *
   * @param action - provide an action which is called just before the empty
   * update is dispatched (only when dispatch is available). This can be used in
   * chainable editor scenarios when you want to lazily invoke an action at the
   * point the update is about to be applied.
   */


  emptyUpdate(action) {
    return _ref13 => {
      var tr = _ref13.tr,
          dispatch = _ref13.dispatch;

      if (dispatch) {
        action === null || action === void 0 ? void 0 : action();
        dispatch(tr);
      }

      return true;
    };
  }
  /**
   * Force an update of the specific updatable ProseMirror props.
   *
   * This command is always available as a builtin command.
   *
   * @category Builtin Command
   */


  forceUpdate() {
    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    return _ref14 => {
      var tr = _ref14.tr,
          dispatch = _ref14.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(this.forceUpdateTransaction(tr, ...keys));
      return true;
    };
  }
  /**
   * Update the attributes for the node at the specified `pos` in the
   * editor.
   *
   * @category Builtin Command
   */


  updateNodeAttributes(pos, attrs) {
    return _ref15 => {
      var tr = _ref15.tr,
          dispatch = _ref15.dispatch;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setNodeMarkup(pos, undefined, attrs));
      return true;
    };
  }
  /**
   * Set the content of the editor while preserving history.
   *
   * Under the hood this is replacing the content in the document with the new
   * state.doc of the provided content.
   *
   * If the content is a string you will need to ensure you have the proper
   * string handler set up in the editor.
   */


  setContent(content, selection) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var state = this.store.manager.createState({
        content,
        selection
      });

      if (!state) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.replaceRangeWith(0, tr.doc.nodeSize - 2, state.doc));
      return true;
    };
  }
  /**
   * Reset the content of the editor while preserving the history.
   *
   * This means that undo and redo will still be active since the doc is replaced with a new doc.
   */


  resetContent() {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;
      var doc = this.store.manager.createEmptyDoc();

      if (doc) {
        return this.setContent(doc)(props);
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.delete(0, tr.doc.nodeSize));
      return true;
    };
  }
  /**
   * Fire an update to remove the current range selection. The cursor will
   * be placed at the anchor of the current range selection.
   *
   * A range selection is a non-empty text selection.
   *
   * @category Builtin Command
   */


  emptySelection() {
    return _ref16 => {
      var tr = _ref16.tr,
          dispatch = _ref16.dispatch;

      if (tr.selection.empty) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.setSelection(state.TextSelection.create(tr.doc, tr.selection.anchor)));
      return true;
    };
  }
  /**
   * Insert a new line into the editor.
   *
   * Depending on editor setup and where the cursor is placed this may have
   * differing impacts.
   *
   * @category Builtin Command
   */


  insertNewLine() {
    return _ref17 => {
      var dispatch = _ref17.dispatch,
          tr = _ref17.tr;

      if (!coreUtils.isTextSelection(tr.selection)) {
        return false;
      }

      dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.insertText('\n'));
      return true;
    };
  }
  /**
   * Insert a node into the editor with the provided content.
   *
   * @category Builtin Command
   */


  insertNode(node) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return _ref18 => {
      var _ref19, _options$marks;

      var dispatch = _ref18.dispatch,
          tr = _ref18.tr,
          state = _ref18.state;
      var attrs = options.attrs,
          range = options.range,
          selection = options.selection,
          _options$replaceEmpty = options.replaceEmptyParentBlock,
          replaceEmptyParentBlock = _options$replaceEmpty === void 0 ? false : _options$replaceEmpty;

      var _getTextSelection = coreUtils.getTextSelection((_ref19 = selection !== null && selection !== void 0 ? selection : range) !== null && _ref19 !== void 0 ? _ref19 : tr.selection, tr.doc),
          from = _getTextSelection.from,
          to = _getTextSelection.to,
          $from = _getTextSelection.$from;

      if (coreUtils.isProsemirrorNode(node) || coreUtils.isProsemirrorFragment(node)) {
        var pos = $from.before($from.depth);
        dispatch === null || dispatch === void 0 ? void 0 : dispatch(replaceEmptyParentBlock && from === to && coreUtils.isEmptyBlockNode($from.parent) ? tr.replaceWith(pos, pos + $from.parent.nodeSize, node) : tr.replaceWith(from, to, node));
        return true;
      }

      var nodeType = coreHelpers.isString(node) ? state.schema.nodes[node] : node;
      !nodeType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        code: coreConstants.ErrorConstant.SCHEMA,
        message: "The requested node type ".concat(node, " does not exist in the schema.")
      }) : coreHelpers.invariant(false) : void 0;
      var marks = (_options$marks = options.marks) === null || _options$marks === void 0 ? void 0 : _options$marks.map(mark => {
        if (mark instanceof model.Mark) {
          return mark;
        }

        var markType = coreHelpers.isString(mark) ? state.schema.marks[mark] : mark;
        !markType ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
          code: coreConstants.ErrorConstant.SCHEMA,
          message: "The requested mark type ".concat(mark, " does not exist in the schema.")
        }) : coreHelpers.invariant(false) : void 0;
        return markType.create();
      });
      var content = nodeType.createAndFill(attrs, coreHelpers.isString(options.content) ? state.schema.text(options.content) : options.content, marks);

      if (!content) {
        return false;
      } // This should not be treated as a replacement.


      var isReplacement = from !== to;
      dispatch === null || dispatch === void 0 ? void 0 : dispatch(isReplacement ? tr.replaceRangeWith(from, to, content) : tr.insert(from, content));
      return true;
    };
  }
  /**
   * Set the focus for the editor.
   *
   * If using this with chaining this should only be placed at the end of
   * the chain. It can cause hard to debug issues when used in the middle of
   * a chain.
   *
   * ```tsx
   * import { useCallback } from 'react';
   * import { useRemirrorContext } from '@remirror/react';
   *
   * const MenuButton = () => {
   *   const { chain } = useRemirrorContext();
   *   const onClick = useCallback(() => {
   *     chain
   *       .toggleBold()
   *       .focus('end')
   *       .run();
   *   }, [chain])
   *
   *   return <button onClick={onClick}>Bold</button>
   * }
   * ```
   */


  focus(position) {
    return props => {
      var dispatch = props.dispatch,
          tr = props.tr;
      var view = this.store.view;

      if (position === false) {
        return false;
      }

      if (view.hasFocus() && (position === undefined || position === true)) {
        return false;
      } // Keep the current selection when position is `true` or `undefined`.


      if (position === undefined || position === true) {
        var _tr$selection = tr.selection,
            _tr$selection$from = _tr$selection.from,
            from = _tr$selection$from === void 0 ? 0 : _tr$selection$from,
            _tr$selection$to = _tr$selection.to,
            to = _tr$selection$to === void 0 ? from : _tr$selection$to;
        position = {
          from,
          to
        };
      }

      if (dispatch) {
        // Focus only when dispatch is provided.
        this.delayedFocus();
      }

      return this.selectText(position)(props);
    };
  }
  /**
   * Blur focus from the editor and also update the selection at the same
   * time.
   */


  blur(position) {
    return props => {
      var view = this.store.view;

      if (!view.hasFocus()) {
        return false;
      }

      requestAnimationFrame(() => {
        view.dom.blur();
      });
      return position ? this.selectText(position)(props) : true;
    };
  }
  /**
   * Set the block type of the current selection or the provided range.
   *
   * @param nodeType - the node type to create
   * @param attrs - the attributes to add to the node type
   * @param selection - the position in the document to set the block node
   * @param preserveAttrs - when true preserve the attributes at the provided selection
   */


  setBlockNodeType(nodeType, attrs, selection) {
    var preserveAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    return coreUtils.setBlockType(nodeType, attrs, selection, preserveAttrs);
  }
  /**
   * Toggle between wrapping an inactive node with the provided node type, and
   * lifting it up into it's parent.
   *
   * @param nodeType - the node type to toggle
   * @param attrs - the attrs to use for the node
   * @param selection - the selection point in the editor to perform the action
   */


  toggleWrappingNode(nodeType, attrs, selection) {
    return coreUtils.toggleWrap(nodeType, attrs, selection);
  }
  /**
   * Toggle a block between the provided type and toggleType.
   */


  toggleBlockNodeItem(toggleProps) {
    return coreUtils.toggleBlockItem(toggleProps);
  }
  /**
   * Wrap the selection or the provided text in a node of the given type with the
   * given attributes.
   */


  wrapInNode(nodeType, attrs, range) {
    return coreUtils.wrapIn(nodeType, attrs, range);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  applyMark(markType, attrs, selection) {
    return applyMark(markType, attrs, selection);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  toggleMark(props) {
    return toggleMark(props);
  }
  /**
   * Removes a mark from the current selection or provided range.
   */


  removeMark(props) {
    return coreUtils.removeMark(props);
  }
  /**
   * Set the meta data to attach to the editor on the next update.
   */


  setMeta(name, value) {
    return _ref20 => {
      var tr = _ref20.tr;
      tr.setMeta(name, value);
      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  selectAll() {
    return this.selectText('all');
  }
  /**
   * Copy the selected content for non empty selections.
   */


  copy() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('copy');
      }

      return true;
    };
  }
  /**
   * Select all text in the editor.
   */


  paste() {
    // Todo check if the permissions are supported first.
    // navigator.permissions.query({name: 'clipboard'})
    return this.store.createPlaceholderCommand({
      // TODO https://caniuse.com/?search=clipboard.read - once browser support is sufficient.
      promise: () => navigator.clipboard.readText(),
      placeholder: {
        type: 'inline'
      },
      onSuccess: (value, selection, props) => {
        return this.insertNode(coreUtils.htmlToProsemirrorNode({
          content: value,
          schema: props.state.schema
        }), {
          selection
        })(props);
      }
    }).generateCommand();
  }
  /**
   * Cut the selected content.
   */


  cut() {
    return props => {
      if (props.tr.selection.empty) {
        return false;
      }

      if (props.dispatch) {
        document.execCommand('cut');
      }

      return true;
    };
  }
  /**
   * Replaces text with an optional appended string at the end. The replacement
   * can be text, or a custom node.
   *
   * @param props - see [[`ReplaceTextProps`]]
   */


  replaceText(props) {
    return coreUtils.replaceText(props);
  }
  /**
   * Get the all the decorated commands available on the editor instance.
   */


  getAllCommandOptions() {
    var uiCommands = {};

    var _iterator6 = _createForOfIteratorHelper(this.decorated),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _step6$value = _slicedToArray(_step6.value, 2),
            name = _step6$value[0],
            options = _step6$value[1];

        if (coreHelpers.isEmptyObject(options)) {
          continue;
        }

        uiCommands[name] = options;
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return uiCommands;
  }
  /**
   * Get the options that were passed into the provided command.
   */


  getCommandOptions(name) {
    return this.decorated.get(name);
  }
  /**
   * A short hand way of getting the `view`, `state`, `tr` and `dispatch`
   * methods.
   */


  getCommandProp() {
    return {
      tr: this.transaction,
      dispatch: this.store.view.dispatch,
      state: this.store.view.state,
      view: this.store.view
    };
  }
  /**
   * Update the command options via a shallow merge of the provided options. If
   * no options are provided the entry is deleted.
   *
   * @internal
   */


  updateDecorated(name, options) {
    var _this$decorated$get;

    if (!options) {
      this.decorated.delete(name);
      return;
    }

    var decoratorOptions = (_this$decorated$get = this.decorated.get(name)) !== null && _this$decorated$get !== void 0 ? _this$decorated$get : {
      name: ''
    };
    this.decorated.set(name, _objectSpread(_objectSpread({}, decoratorOptions), options));
  }
  /**
   * Needed on iOS since `requestAnimationFrame` doesn't breaks the focus
   * implementation.
   */


  handleIosFocus() {
    if (!coreUtils.environment.isIos) {
      return;
    }

    this.store.view.dom.focus();
  }
  /**
   * Focus the editor after a slight delay.
   */


  delayedFocus() {
    // Manage focus on iOS.
    this.handleIosFocus();
    requestAnimationFrame(() => {
      // Use the built in focus method to refocus the editor.
      this.store.view.focus(); // This has to be called again in order for Safari to scroll into view
      // after the focus. Perhaps there's a better way though or maybe place
      // behind a flag.

      this.store.view.dispatch(this.transaction.scrollIntoView());
    });
  }
  /**
   * A helper for forcing through updates in the view layer. The view layer can
   * check for the meta data of the transaction with
   * `manager.store.getForcedUpdate(tr)`. If that has a value then it should use
   * the unique symbol to update the key.
   */


  /**
   * Check for a forced update in the transaction. This pulls the meta data
   * from the transaction and if it is true then it was a forced update.
   *
   * ```ts
   * import { CommandsExtension } from 'remirror/extensions';
   *
   * const commandsExtension = manager.getExtension(CommandsExtension);
   * log(commandsExtension.getForcedUpdates(tr))
   * ```
   *
   * This can be used for updating:
   *
   * - `nodeViews`
   * - `editable` status of the editor
   * - `attributes` - for the top level node
   *
   * @internal
   */
  getForcedUpdates(tr) {
    return this.getCommandMeta(tr).forcedUpdates;
  }
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_COMMAND_META), meta);
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add the commands from the provided `commands` property to the `chained`,
   * `original` and `unchained` objects.
   */


  addCommands(props) {
    var extensionCommands = props.extensionCommands,
        commands = props.commands,
        names = props.names,
        active = props.active;

    var _iterator7 = _createForOfIteratorHelper(coreHelpers.entries(extensionCommands)),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _step7$value = _slicedToArray(_step7.value, 2),
            name = _step7$value[0],
            _command3 = _step7$value[1];

        // Command names must be unique.
        throwIfNameNotUnique({
          name,
          set: names,
          code: coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES
        }); // Make sure the command name is not forbidden.

        !!forbiddenNames.has(name) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
          code: coreConstants.ErrorConstant.DUPLICATE_COMMAND_NAMES,
          message: 'The command name you chose is forbidden.'
        }) : coreHelpers.invariant(false) : void 0; // Create the unchained command.

        commands[name] = this.createUnchainedCommand(_command3, active[name]);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
  /**
   * Create an unchained command method.
   */


  unchainedFactory(props) {
    var _this3 = this;

    return function () {
      var _props$shouldDispatch = props.shouldDispatch,
          shouldDispatch = _props$shouldDispatch === void 0 ? true : _props$shouldDispatch,
          command = props.command;
      var view = _this3.store.view;
      var state = view.state;
      var dispatch;

      if (shouldDispatch) {
        dispatch = view.dispatch;
      }

      return command(...arguments)({
        state,
        dispatch,
        view,
        tr: state.tr
      });
    };
  }
  /**
   * Create the unchained command.
   */


  createUnchainedCommand(command, active) {
    var unchainedCommand = this.unchainedFactory({
      command
    });
    unchainedCommand.enabled = this.unchainedFactory({
      command,
      shouldDispatch: false
    });
    unchainedCommand.isEnabled = unchainedCommand.enabled;
    unchainedCommand.original = command;
    unchainedCommand.active = active;
    return unchainedCommand;
  }
  /**
   * Create a chained command method.
   */


  chainedFactory(props) {
    var _this4 = this;

    return function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var chained = props.chain,
          command = props.command,
          getTr = props.getTr,
          getChain = props.getChain;
      var lazyChain = getChain();
      var view = _this4.store.view;
      var state = view.state;
      lazyChain.push(dispatch => {
        return command(...args)({
          state,
          dispatch,
          view,
          tr: getTr()
        });
      });
      return chained;
    };
  }

}, (_applyDecoratedDescriptor(_class2$4.prototype, "customDispatch", [_dec2$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "customDispatch"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertText", [_dec3$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectText", [_dec4$4], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectMark", [_dec5$3], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "delete", [_dec6$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "delete"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptyUpdate", [_dec7$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptyUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "forceUpdate", [_dec8$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "forceUpdate"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "updateNodeAttributes", [_dec9$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "updateNodeAttributes"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setContent", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "resetContent", [_dec11], Object.getOwnPropertyDescriptor(_class2$4.prototype, "resetContent"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "emptySelection", [_dec12], Object.getOwnPropertyDescriptor(_class2$4.prototype, "emptySelection"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNewLine", [_dec13], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNewLine"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "insertNode", [_dec14], Object.getOwnPropertyDescriptor(_class2$4.prototype, "insertNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "focus", [_dec15], Object.getOwnPropertyDescriptor(_class2$4.prototype, "focus"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "blur", [_dec16], Object.getOwnPropertyDescriptor(_class2$4.prototype, "blur"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setBlockNodeType", [_dec17], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setBlockNodeType"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleWrappingNode", [_dec18], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleWrappingNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleBlockNodeItem", [_dec19], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleBlockNodeItem"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "wrapInNode", [_dec20], Object.getOwnPropertyDescriptor(_class2$4.prototype, "wrapInNode"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "applyMark", [_dec21], Object.getOwnPropertyDescriptor(_class2$4.prototype, "applyMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "toggleMark", [_dec22], Object.getOwnPropertyDescriptor(_class2$4.prototype, "toggleMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "removeMark", [_dec23], Object.getOwnPropertyDescriptor(_class2$4.prototype, "removeMark"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "setMeta", [_dec24], Object.getOwnPropertyDescriptor(_class2$4.prototype, "setMeta"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "selectAll", [_dec25], Object.getOwnPropertyDescriptor(_class2$4.prototype, "selectAll"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "copy", [_dec26], Object.getOwnPropertyDescriptor(_class2$4.prototype, "copy"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "paste", [_dec27], Object.getOwnPropertyDescriptor(_class2$4.prototype, "paste"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "cut", [_dec28], Object.getOwnPropertyDescriptor(_class2$4.prototype, "cut"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "replaceText", [_dec29], Object.getOwnPropertyDescriptor(_class2$4.prototype, "replaceText"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getAllCommandOptions", [_dec30], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getAllCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandOptions", [_dec31], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandOptions"), _class2$4.prototype), _applyDecoratedDescriptor(_class2$4.prototype, "getCommandProp", [_dec32], Object.getOwnPropertyDescriptor(_class2$4.prototype, "getCommandProp"), _class2$4.prototype)), _class2$4)) || _class$a);
var DEFAULT_COMMAND_META = {
  forcedUpdates: []
};
/**
 * Provides the list of Prosemirror EditorView props that should be updated/
 */

/**
 * The names that are forbidden from being used as a command name.
 */
var forbiddenNames = new Set(['run', 'chain', 'original', 'raw', 'enabled', 'tr']);

var _excluded$1 = ["nodeName", "className"];

var _dec$9, _dec2$3, _dec3$3, _dec4$3, _dec5$2, _dec6$1, _dec7$1, _dec8$1, _class$9, _class2$3;
var DecorationsExtension = (_dec$9 = extension({
  defaultOptions: {
    persistentSelectionClass: undefined,
    placeholderClassName: 'placeholder',
    placeholderNodeName: 'span'
  },
  staticKeys: ['placeholderClassName', 'placeholderNodeName'],
  handlerKeys: ['decorations'],
  handlerKeyOptions: {
    decorations: {
      reducer: {
        accumulator: (accumulated, latestValue, state) => {
          return accumulated.add(state.doc, latestValue.find());
        },
        getDefault: () => view.DecorationSet.empty
      }
    }
  },
  defaultPriority: coreConstants.ExtensionPriority.Low
}), _dec2$3 = command(), _dec3$3 = command(), _dec4$3 = command(), _dec5$2 = command(), _dec6$1 = command(), _dec7$1 = helper(), _dec8$1 = helper(), _dec$9(_class$9 = (_class2$3 = class DecorationsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "placeholders", view.DecorationSet.empty);

    _defineProperty(this, "placeholderWidgets", new Map());

    _defineProperty(this, "createPlaceholderCommand", props => {
      var id = coreHelpers.uniqueId();
      var promise = props.promise,
          placeholder = props.placeholder,
          onFailure = props.onFailure,
          onSuccess = props.onSuccess;
      return new DelayedCommand(promise).validate(props => {
        return this.addPlaceholder(id, placeholder)(props);
      }).success(props => {
        var state = props.state,
            tr = props.tr,
            dispatch = props.dispatch,
            view = props.view,
            value = props.value;
        var range = this.store.helpers.findPlaceholder(id);

        if (!range) {
          var _onFailure;

          var error = new Error('The placeholder has been removed');
          return (_onFailure = onFailure === null || onFailure === void 0 ? void 0 : onFailure({
            error,
            state,
            tr,
            dispatch,
            view
          })) !== null && _onFailure !== void 0 ? _onFailure : false;
        }

        this.removePlaceholder(id)({
          state,
          tr,
          view,
          dispatch: () => {}
        });
        return onSuccess(value, range, {
          state,
          tr,
          dispatch,
          view
        });
      }).failure(props => {
        var _onFailure2;

        this.removePlaceholder(id)(_objectSpread(_objectSpread({}, props), {}, {
          dispatch: () => {}
        }));
        return (_onFailure2 = onFailure === null || onFailure === void 0 ? void 0 : onFailure(props)) !== null && _onFailure2 !== void 0 ? _onFailure2 : false;
      });
    });
  }

  get name() {
    return 'decorations';
  }
  /**
   * The placeholder decorations.
   */


  onCreate() {
    this.store.setExtensionStore('createPlaceholderCommand', this.createPlaceholderCommand);
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createPlugin() {
    var _this = this;

    return {
      state: {
        init: () => {},
        apply: tr => {
          // Get tracker updates from the meta data
          var _this$getMeta = this.getMeta(tr),
              added = _this$getMeta.added,
              clearTrackers = _this$getMeta.clearTrackers,
              removed = _this$getMeta.removed,
              updated = _this$getMeta.updated;

          if (clearTrackers) {
            this.placeholders = view.DecorationSet.empty;

            var _iterator = _createForOfIteratorHelper(this.placeholderWidgets),
                _step;

            try {
              for (_iterator.s(); !(_step = _iterator.n()).done;) {
                var _widget$spec$onDestro, _widget$spec;

                var _step$value = _slicedToArray(_step.value, 2),
                    widget = _step$value[1];

                (_widget$spec$onDestro = (_widget$spec = widget.spec).onDestroy) === null || _widget$spec$onDestro === void 0 ? void 0 : _widget$spec$onDestro.call(_widget$spec, this.store.view, widget.spec.element);
              }
            } catch (err) {
              _iterator.e(err);
            } finally {
              _iterator.f();
            }

            this.placeholderWidgets.clear();
            return;
          }

          this.placeholders = this.placeholders.map(tr.mapping, tr.doc, {
            onRemove: spec => {
              // Remove any removed widgets.
              var widget = this.placeholderWidgets.get(spec.id);

              if (widget) {
                var _widget$spec$onDestro2, _widget$spec2;

                (_widget$spec$onDestro2 = (_widget$spec2 = widget.spec).onDestroy) === null || _widget$spec$onDestro2 === void 0 ? void 0 : _widget$spec$onDestro2.call(_widget$spec2, this.store.view, widget.spec.element);
              }
            }
          });

          var _iterator2 = _createForOfIteratorHelper(this.placeholderWidgets),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _widget$spec$onUpdate, _widget$spec3;

              var _step2$value = _slicedToArray(_step2.value, 2),
                  _widget = _step2$value[1];

              (_widget$spec$onUpdate = (_widget$spec3 = _widget.spec).onUpdate) === null || _widget$spec$onUpdate === void 0 ? void 0 : _widget$spec$onUpdate.call(_widget$spec3, this.store.view, _widget.from, _widget.spec.element, _widget.spec.data);
            } // Update the decorations with any added position trackers.

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _iterator3 = _createForOfIteratorHelper(added),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var placeholder = _step3.value;

              if (placeholder.type === 'inline') {
                this.addInlinePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'node') {
                this.addNodePlaceholder(placeholder, tr);
                continue;
              }

              if (placeholder.type === 'widget') {
                this.addWidgetPlaceholder(placeholder, tr);
                continue;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var _iterator4 = _createForOfIteratorHelper(updated),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var _step4$value = _step4.value,
                  id = _step4$value.id,
                  _data = _step4$value.data;

              var _widget2 = this.placeholderWidgets.get(id); // Only support updating widget decorations.


              if (!_widget2) {
                continue;
              }

              var updatedWidget = view.Decoration.widget(_widget2.from, _widget2.spec.element, _objectSpread(_objectSpread({}, _widget2.spec), {}, {
                data: _data
              }));
              this.placeholders = this.placeholders.remove([_widget2]).add(tr.doc, [updatedWidget]);
              this.placeholderWidgets.set(id, updatedWidget);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var _iterator5 = _createForOfIteratorHelper(removed),
              _step5;

          try {
            var _loop = function _loop() {
              var id = _step5.value;

              var found = _this.placeholders.find(undefined, undefined, spec => spec.id === id && spec.__type === __type);

              var widget = _this.placeholderWidgets.get(id);

              if (widget) {
                var _widget$spec$onDestro3, _widget$spec4;

                (_widget$spec$onDestro3 = (_widget$spec4 = widget.spec).onDestroy) === null || _widget$spec$onDestro3 === void 0 ? void 0 : _widget$spec$onDestro3.call(_widget$spec4, _this.store.view, widget.spec.element);
              }

              _this.placeholders = _this.placeholders.remove(found);

              _this.placeholderWidgets.delete(id);
            };

            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      },
      props: {
        decorations: state => {
          var decorationSet = this.options.decorations(state);
          decorationSet = decorationSet.add(state.doc, this.placeholders.find());

          var _iterator6 = _createForOfIteratorHelper(this.store.extensions),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _extension = _step6.value;

              // Skip this extension when the method doesn't exist.
              if (!_extension.createDecorations) {
                continue;
              }

              var decorations = _extension.createDecorations(state).find();

              decorationSet = decorationSet.add(state.doc, decorations);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          return decorationSet;
        },
        handleDOMEvents: {
          // Dispatch a transaction for focus/blur events so that the editor state
          // can be refreshed.
          //
          // https://discuss.prosemirror.net/t/handling-focus-in-plugins/1981/2
          blur: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, false));
            }

            return false;
          },
          focus: view => {
            if (this.options.persistentSelectionClass) {
              view.dispatch(view.state.tr.setMeta(persistentSelectionFocusKey, true));
            }

            return false;
          }
        }
      }
    };
  }

  updateDecorations() {
    return _ref => {
      var tr = _ref.tr,
          dispatch = _ref.dispatch;
      return dispatch !== null && dispatch !== void 0 && dispatch(tr), true;
    };
  }
  /**
   * Command to dispatch a transaction adding the placeholder decoration to
   * be tracked.
   *
   * @param id - the value that is used to identify this tracker. This can
   * be any value. A promise, a function call, a string.
   * @param options - the options to call the tracked position with. You can
   * specify the range `{ from: number; to: number }` as well as the class
   * name.
   */


  addPlaceholder(id, placeholder, deleteSelection) {
    return _ref2 => {
      var dispatch = _ref2.dispatch,
          tr = _ref2.tr;
      return this.addPlaceholderTransaction(id, placeholder, tr, !dispatch) ? (dispatch !== null && dispatch !== void 0 && dispatch(deleteSelection ? tr.deleteSelection() : tr), true) : false;
    };
  }
  /**
   * A command to updated the placeholder decoration.
   *
   * To update multiple placeholders you can use chained commands.
   *
   * ```ts
   * let idsWithData: Array<{id: unknown, data: number}>;
   *
   * for (const { id, data } of idsWithData) {
   *   chain.updatePlaceholder(id, data);
   * }
   *
   * chain.run();
   * ```
   */


  updatePlaceholder(id, data) {
    return _ref3 => {
      var dispatch = _ref3.dispatch,
          tr = _ref3.tr;
      return this.updatePlaceholderTransaction({
        id,
        data,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove the specified placeholder decoration.
   */


  removePlaceholder(id) {
    return _ref4 => {
      var dispatch = _ref4.dispatch,
          tr = _ref4.tr;
      return this.removePlaceholderTransaction({
        id,
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * A command to remove all active placeholder decorations.
   */


  clearPlaceholders() {
    return _ref5 => {
      var tr = _ref5.tr,
          dispatch = _ref5.dispatch;
      return this.clearPlaceholdersTransaction({
        tr,
        checkOnly: !dispatch
      }) ? (dispatch !== null && dispatch !== void 0 && dispatch(tr), true) : false;
    };
  }
  /**
   * Find the position for the tracker with the ID specified.
   *
   * @param id - the unique position id which can be any type
   */


  findPlaceholder(id) {
    return this.findAllPlaceholders().get(id);
  }
  /**
   * Find the positions of all the trackers in document.
   */


  findAllPlaceholders() {
    var trackers = new Map();
    var found = this.placeholders.find(undefined, undefined, spec => spec.__type === __type);

    var _iterator7 = _createForOfIteratorHelper(found),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var decoration = _step7.value;
        trackers.set(decoration.spec.id, {
          from: decoration.from,
          to: decoration.to
        });
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    return trackers;
  }
  /**
   * Add some decorations based on the provided settings.
   */


  createDecorations(state) {
    var _this$store$view, _this$store$helpers$i, _this$store$helpers;

    var persistentSelectionClass = this.options.persistentSelectionClass; // Only show the selection decoration when the view doesn't have focus.
    // Notice that we need to listen to the focus/blur DOM events to make
    // it work since the focus state is not stored in `EditorState`.

    if (!persistentSelectionClass || (_this$store$view = this.store.view) !== null && _this$store$view !== void 0 && _this$store$view.hasFocus() || (_this$store$helpers$i = (_this$store$helpers = this.store.helpers).isInteracting) !== null && _this$store$helpers$i !== void 0 && _this$store$helpers$i.call(_this$store$helpers)) {
      return view.DecorationSet.empty;
    } // Add the selection decoration to the decorations array.


    return generatePersistentSelectionDecorations(state, view.DecorationSet.empty, {
      class: coreHelpers.isString(persistentSelectionClass) ? persistentSelectionClass : 'selection'
    });
  }
  /**
   * This stores all tracked positions in the editor and maps them via the
   * transaction updates.
   */


  onApplyState() {}
  /**
   * Add a widget placeholder and track it as a widget placeholder.
   */


  addWidgetPlaceholder(placeholder, tr) {
    var _createElement;

    var pos = placeholder.pos,
        createElement = placeholder.createElement,
        onDestroy = placeholder.onDestroy,
        onUpdate = placeholder.onUpdate,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var element = (_createElement = createElement === null || createElement === void 0 ? void 0 : createElement(this.store.view, pos)) !== null && _createElement !== void 0 ? _createElement : document.createElement(nodeName);
    element.classList.add(className);
    var decoration = view.Decoration.widget(pos, element, {
      id,
      __type,
      type,
      element,
      onDestroy,
      onUpdate
    });
    this.placeholderWidgets.set(id, decoration);
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add an inline placeholder.
   */


  addInlinePlaceholder(placeholder, tr) {
    var _placeholder$from = placeholder.from,
        from = _placeholder$from === void 0 ? tr.selection.from : _placeholder$from,
        _placeholder$to = placeholder.to,
        to = _placeholder$to === void 0 ? tr.selection.to : _placeholder$to,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id,
        type = placeholder.type;
    var decoration;

    if (from === to) {
      // Add this as a widget if the range is empty.
      var _element = document.createElement(nodeName);

      _element.classList.add(className);

      decoration = view.Decoration.widget(from, _element, {
        id,
        type,
        __type,
        widget: _element
      });
    } else {
      // Make this span across nodes if the range is not empty.
      decoration = view.Decoration.inline(from, to, {
        nodeName,
        class: className
      }, {
        id,
        __type
      });
    }

    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add a placeholder for nodes.
   */


  addNodePlaceholder(placeholder, tr) {
    var pos = placeholder.pos,
        className = placeholder.className,
        nodeName = placeholder.nodeName,
        id = placeholder.id;
    var $pos = coreHelpers.isNumber(pos) ? tr.doc.resolve(pos) : tr.selection.$from;
    var found = coreHelpers.isNumber(pos) ? $pos.nodeAfter ? {
      pos,
      end: $pos.nodeAfter.nodeSize
    } : undefined : coreUtils.findNodeAtPosition($pos);

    if (!found) {
      return;
    }

    var decoration = view.Decoration.node(found.pos, found.end, {
      nodeName,
      class: className
    }, {
      id,
      __type
    });
    this.placeholders = this.placeholders.add(tr.doc, [decoration]);
  }
  /**
   * Add the node and class name to the placeholder object.
   */


  withRequiredBase(id, placeholder) {
    var _this$options = this.options,
        placeholderNodeName = _this$options.placeholderNodeName,
        placeholderClassName = _this$options.placeholderClassName;

    var _placeholder$nodeName = placeholder.nodeName,
        nodeName = _placeholder$nodeName === void 0 ? placeholderNodeName : _placeholder$nodeName,
        className = placeholder.className,
        rest = _objectWithoutProperties(placeholder, _excluded$1);

    var classes = (className ? [placeholderClassName, className] : [placeholderClassName]).join(' ');
    return _objectSpread(_objectSpread({
      nodeName,
      className: classes
    }, rest), {}, {
      id
    });
  }
  /**
   * Get the command metadata.
   */


  getMeta(tr) {
    var _tr$getMeta;

    var meta = (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : {};
    return _objectSpread(_objectSpread({}, DEFAULT_PLACEHOLDER_META), meta);
  }
  /**
   * Set the metadata for the command.
   */


  setMeta(tr, update) {
    var meta = this.getMeta(tr);
    tr.setMeta(this.pluginKey, _objectSpread(_objectSpread({}, meta), update));
  }
  /**
   * Add a placeholder decoration with the specified params to the transaction
   * and return the transaction.
   *
   * It is up to you to dispatch the transaction or you can just use the
   * commands.
   */


  addPlaceholderTransaction(id, placeholder, tr) {
    var checkOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var existingPosition = this.findPlaceholder(id);

    if (existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta2 = this.getMeta(tr),
        added = _this$getMeta2.added;

    this.setMeta(tr, {
      added: [...added, this.withRequiredBase(id, placeholder)]
    });
    return true;
  }
  /**
   * Update the data stored by a placeholder.
   *
   * This replaces the whole data value.
   */


  updatePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly = props.checkOnly,
        checkOnly = _props$checkOnly === void 0 ? false : _props$checkOnly,
        data = props.data;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta3 = this.getMeta(tr),
        updated = _this$getMeta3.updated;

    this.setMeta(tr, {
      updated: coreHelpers.uniqueArray([...updated, {
        id,
        data
      }])
    });
    return true;
  }
  /**
   * Discards a previously defined tracker once not needed.
   *
   * This should be used to cleanup once the position is no longer needed.
   */


  removePlaceholderTransaction(props) {
    var id = props.id,
        tr = props.tr,
        _props$checkOnly2 = props.checkOnly,
        checkOnly = _props$checkOnly2 === void 0 ? false : _props$checkOnly2;
    var existingPosition = this.findPlaceholder(id);

    if (!existingPosition) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    var _this$getMeta4 = this.getMeta(tr),
        removed = _this$getMeta4.removed;

    this.setMeta(tr, {
      removed: coreHelpers.uniqueArray([...removed, id])
    });
    return true;
  }
  /**
   * This helper returns a transaction that clears all position trackers when
   * any exist.
   *
   * Otherwise it returns undefined.
   */


  clearPlaceholdersTransaction(props) {
    var tr = props.tr,
        _props$checkOnly3 = props.checkOnly,
        checkOnly = _props$checkOnly3 === void 0 ? false : _props$checkOnly3;
    var positionTrackerState = this.getPluginState();

    if (positionTrackerState === view.DecorationSet.empty) {
      return false;
    }

    if (checkOnly) {
      return true;
    }

    this.setMeta(tr, {
      clearTrackers: true
    });
    return true;
  }
  /**
   * Handles delayed commands which rely on the
   */


}, (_applyDecoratedDescriptor(_class2$3.prototype, "updateDecorations", [_dec2$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updateDecorations"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "addPlaceholder", [_dec3$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "addPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "updatePlaceholder", [_dec4$3], Object.getOwnPropertyDescriptor(_class2$3.prototype, "updatePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "removePlaceholder", [_dec5$2], Object.getOwnPropertyDescriptor(_class2$3.prototype, "removePlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "clearPlaceholders", [_dec6$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "clearPlaceholders"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findPlaceholder", [_dec7$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findPlaceholder"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "findAllPlaceholders", [_dec8$1], Object.getOwnPropertyDescriptor(_class2$3.prototype, "findAllPlaceholders"), _class2$3.prototype)), _class2$3)) || _class$9);
var DEFAULT_PLACEHOLDER_META = {
  added: [],
  updated: [],
  clearTrackers: false,
  removed: []
};
var __type = 'placeholderDecoration';
var persistentSelectionFocusKey = 'persistentSelectionFocus';

/**
 * Generate the persistent selection decoration for when the editor loses focus.
 */
function generatePersistentSelectionDecorations(state, decorationSet, attrs) {
  var selection = state.selection,
      doc = state.doc;

  if (selection.empty) {
    return decorationSet;
  }

  var from = selection.from,
      to = selection.to;
  var decoration = coreUtils.isNodeSelection(selection) ? view.Decoration.node(from, to, attrs) : view.Decoration.inline(from, to, attrs);
  return decorationSet.add(doc, [decoration]);
}

var _dec$8, _class$8;
var DocChangedExtension = (_dec$8 = extension({
  handlerKeys: ['docChanged'],
  handlerKeyOptions: {
    docChanged: {
      earlyReturnValue: false
    } // Execute all handlers, even if one returns false

  },
  defaultPriority: coreConstants.ExtensionPriority.Lowest
}), _dec$8(_class$8 = class DocChangedExtension extends PlainExtension {
  get name() {
    return 'docChanged';
  }

  onStateUpdate(props) {
    var firstUpdate = props.firstUpdate,
        transactions = props.transactions,
        tr = props.tr;

    if (firstUpdate) {
      return;
    }

    if ((transactions !== null && transactions !== void 0 ? transactions : [tr]).some(tr => tr === null || tr === void 0 ? void 0 : tr.docChanged)) {
      this.options.docChanged(props);
    }
  }

}) || _class$8);

var _dec$7, _dec2$2, _dec3$2, _dec4$2, _dec5$1, _dec6, _dec7, _dec8, _dec9, _dec10, _class$7, _class2$2;
var HelpersExtension = (_dec$7 = extension({}), _dec2$2 = helper(), _dec3$2 = helper(), _dec4$2 = helper(), _dec5$1 = helper(), _dec6 = helper(), _dec7 = command(), _dec8 = helper(), _dec9 = helper(), _dec10 = helper(), _dec$7(_class$7 = (_class2$2 = class HelpersExtension extends PlainExtension {
  get name() {
    return 'helpers';
  }
  /**
   * Add the `html` and `text` string handlers to the editor.
   */


  onCreate() {
    var _this = this;

    this.store.setStringHandler('text', this.textToProsemirrorNode.bind(this));
    this.store.setStringHandler('html', coreUtils.htmlToProsemirrorNode);
    var helpers = coreHelpers.object();
    var active = coreHelpers.object();
    var attrs = coreHelpers.object();
    var names = new Set();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      var _loop = function _loop() {
        var _extension$createHelp, _extension$createHelp2;

        var extension = _step.value;

        if (isNodeExtension(extension)) {
          active[extension.name] = attrs => {
            return coreUtils.isNodeActive({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var _getActiveNode;

            return (_getActiveNode = coreUtils.getActiveNode({
              state: _this.store.getState(),
              type: extension.type,
              attrs
            })) === null || _getActiveNode === void 0 ? void 0 : _getActiveNode.node.attrs;
          };
        }

        if (isMarkExtension(extension)) {
          active[extension.name] = attrs => {
            return coreUtils.isMarkActive({
              trState: _this.store.getState(),
              type: extension.type,
              attrs
            });
          };

          attrs[extension.name] = attrs => {
            var markRange = coreUtils.getMarkRange(_this.store.getState().selection.$from, extension.type);

            if (!markRange || !attrs) {
              return markRange === null || markRange === void 0 ? void 0 : markRange.mark.attrs;
            }

            if (coreUtils.containsAttributes(markRange.mark, attrs)) {
              return markRange.mark.attrs;
            }

            return;
          };
        }

        var extensionHelpers = (_extension$createHelp = (_extension$createHelp2 = extension.createHelpers) === null || _extension$createHelp2 === void 0 ? void 0 : _extension$createHelp2.call(extension)) !== null && _extension$createHelp !== void 0 ? _extension$createHelp : {};

        for (var _i = 0, _Object$keys = Object.keys((_extension$decoratedH = extension.decoratedHelpers) !== null && _extension$decoratedH !== void 0 ? _extension$decoratedH : {}); _i < _Object$keys.length; _i++) {
          var _extension$decoratedH;

          var helperName = _Object$keys[_i];
          extensionHelpers[helperName] = extension[helperName].bind(extension);
        }

        if (coreHelpers.isEmptyObject(extensionHelpers)) {
          return "continue";
        }

        var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(extensionHelpers)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                _helper = _step2$value[1];

            throwIfNameNotUnique({
              name,
              set: names,
              code: coreConstants.ErrorConstant.DUPLICATE_HELPER_NAMES
            });
            helpers[name] = _helper;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('attrs', attrs);
    this.store.setStoreKey('active', active);
    this.store.setStoreKey('helpers', helpers);
    this.store.setExtensionStore('attrs', attrs);
    this.store.setExtensionStore('active', active);
    this.store.setExtensionStore('helpers', helpers);
  }
  /**
   * Check whether the selection is empty.
   */


  isSelectionEmpty() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return coreUtils.isSelectionEmpty(state);
  }
  /*
   * Check if the document view is currently editable.
   */


  isViewEditable() {
    var _this$store$view$prop, _this$store$view$prop2, _this$store$view$prop3;

    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return (_this$store$view$prop = (_this$store$view$prop2 = (_this$store$view$prop3 = this.store.view.props).editable) === null || _this$store$view$prop2 === void 0 ? void 0 : _this$store$view$prop2.call(_this$store$view$prop3, state)) !== null && _this$store$view$prop !== void 0 ? _this$store$view$prop : false;
  }
  /**
   * Get the full JSON output for the ProseMirror editor state object.
   */


  getStateJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.toJSON();
  }
  /**
   * Get the JSON output for the main ProseMirror `doc` node.
   *
   * This can be used to persist data between sessions and can be passed as
   * content to the `initialContent` prop.
   */


  getJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return state.doc.toJSON();
  }
  /**
   * @deprecated use `getJSON` instead.
   */


  getRemirrorJSON() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return this.getJSON(state);
  }
  /**
   * Insert a html string as a ProseMirror Node.
   *
   * @category Builtin Command
   */


  insertHtml(html, options) {
    return props => {
      var state = props.state;
      var fragment = coreUtils.htmlToProsemirrorNode({
        content: html,
        schema: state.schema,
        fragment: true
      });
      return this.store.commands.insertNode.original(fragment, options)(props);
    };
  }
  /**
   * A method to get all the content in the editor as text. Depending on the
   * content in your editor, it is not guaranteed to preserve it 100%, so it's
   * best to test that it meets your needs before consuming.
   */


  getText() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$lineBreakDivider = _ref.lineBreakDivider,
        lineBreakDivider = _ref$lineBreakDivider === void 0 ? '\n\n' : _ref$lineBreakDivider,
        _ref$state = _ref.state,
        state = _ref$state === void 0 ? this.store.getState() : _ref$state;

    return state.doc.textBetween(0, state.doc.content.size, lineBreakDivider, coreConstants.NULL_CHARACTER);
  }

  getTextBetween(from, to) {
    var doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store.getState().doc;
    return doc.textBetween(from, to, '\n\n', coreConstants.NULL_CHARACTER);
  }
  /**
   * Get the html from the current state, or provide a custom state.
   */


  getHTML() {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.store.getState();
    return coreUtils.prosemirrorNodeToHtml(state.doc, this.store.document);
  }
  /**
   * Wrap the content in a pre tag to preserve whitespace and see what the
   * editor does with it.
   */


  textToProsemirrorNode(options) {
    var content = "<pre>".concat(options.content, "</pre>");
    return this.store.stringHandlers.html(_objectSpread(_objectSpread({}, options), {}, {
      content
    }));
  }

}, (_applyDecoratedDescriptor(_class2$2.prototype, "isSelectionEmpty", [_dec2$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isSelectionEmpty"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "isViewEditable", [_dec3$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "isViewEditable"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getStateJSON", [_dec4$2], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getStateJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getJSON", [_dec5$1], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getRemirrorJSON", [_dec6], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getRemirrorJSON"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "insertHtml", [_dec7], Object.getOwnPropertyDescriptor(_class2$2.prototype, "insertHtml"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getText", [_dec8], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getText"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getTextBetween", [_dec9], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getTextBetween"), _class2$2.prototype), _applyDecoratedDescriptor(_class2$2.prototype, "getHTML", [_dec10], Object.getOwnPropertyDescriptor(_class2$2.prototype, "getHTML"), _class2$2.prototype)), _class2$2)) || _class$7);

var _dec$6, _class$6;
var InputRulesExtension = (_dec$6 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Default,
  handlerKeys: ['shouldSkipInputRule'],
  // Return when the value `true` is encountered.
  handlerKeyOptions: {
    shouldSkipInputRule: {
      earlyReturnValue: true
    }
  }
}), _dec$6(_class$6 = class InputRulesExtension extends PlainExtension {
  get name() {
    return 'inputRules';
  }
  /**
   * Add the extension store method for rebuilding all input rules.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildInputRules', this.rebuildInputRules.bind(this));
  }
  /**
   * Add the `inputRules` plugin to the editor.
   */


  createExternalPlugins() {
    return [this.generateInputRulesPlugin()];
  }

  generateInputRulesPlugin() {
    var rules = [];
    var invalidMarks = this.store.markTags[coreConstants.ExtensionTag.ExcludeInputRules];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var _extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.inputRules || // Method doesn't exist
        !_extension.createInputRules || // Extension settings exclude it
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.inputRules) {
          continue;
        } // For each input rule returned by the extension, add a `shouldSkip`
        // property.


        var _iterator2 = _createForOfIteratorHelper(_extension.createInputRules()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var rule = _step2.value;
            rule.shouldSkip = this.options.shouldSkipInputRule;
            rule.invalidMarks = invalidMarks;
            rules.push(rule);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return inputrules.inputRules({
      rules
    });
  }
  /**
   * The method for rebuilding all the input rules.
   *
   * 1. Rebuild inputRules.
   * 2. Replace the old input rules plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  rebuildInputRules() {
    this.store.updateExtensionPlugins(this);
  }

}) || _class$6);

var _dec$5, _dec2$1, _dec3$1, _dec4$1, _dec5, _class$5, _class2$1;
var KeymapExtension = (_dec$5 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Low,
  defaultOptions: {
    shortcuts: 'default',
    undoInputRuleOnBackspace: true,
    selectParentNodeOnEscape: false,
    excludeBaseKeymap: false,
    exitMarksOnArrowPress: true
  },
  customHandlerKeys: ['keymap']
}), _dec2$1 = keyBinding({
  shortcut: 'ArrowRight',
  isActive: options => options.exitMarksOnArrowPress
}), _dec3$1 = keyBinding({
  shortcut: 'ArrowLeft',
  isActive: options => options.exitMarksOnArrowPress
}), _dec4$1 = keyBinding({
  shortcut: 'Backspace',
  isActive: options => options.exitMarksOnArrowPress
}), _dec5 = helper(), _dec$5(_class$5 = (_class2$1 = class KeymapExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "extraKeyBindings", []);

    _defineProperty(this, "backwardMarkExitTracker", new Map());

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$rebuildKe, _this$store;

      var keymap = _ref.keymap;

      if (!keymap) {
        return;
      }

      this.extraKeyBindings = [...this.extraKeyBindings, keymap];
      (_this$store$rebuildKe = (_this$store = this.store).rebuildKeymap) === null || _this$store$rebuildKe === void 0 ? void 0 : _this$store$rebuildKe.call(_this$store);
      return () => {
        var _this$store$rebuildKe2, _this$store2;

        this.extraKeyBindings = this.extraKeyBindings.filter(binding => binding !== keymap);
        (_this$store$rebuildKe2 = (_this$store2 = this.store).rebuildKeymap) === null || _this$store$rebuildKe2 === void 0 ? void 0 : _this$store$rebuildKe2.call(_this$store2);
      };
    });

    _defineProperty(this, "rebuildKeymap", () => {
      this.store.updateExtensionPlugins(this);
    });
  }

  get name() {
    return 'keymap';
  }
  /**
   * The custom keybindings added by the handlers. In react these can be added
   * via `hooks`.
   */


  /**
   * Get the shortcut map.
   */
  get shortcutMap() {
    var shortcuts = this.options.shortcuts;
    return coreHelpers.isString(shortcuts) ? keyboardShortcuts[shortcuts] : shortcuts;
  }
  /**
   * This adds the `createKeymap` method functionality to all extensions.
   */


  onCreate() {
    this.store.setExtensionStore('rebuildKeymap', this.rebuildKeymap);
  }
  /** Add the created keymap to the available plugins. */


  createExternalPlugins() {
    var _this$store$managerSe;

    if ( // The user doesn't want any keymaps in the editor so don't add the keymap
    // handler.
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.keymap) {
      return [];
    }

    return [this.generateKeymap()];
  }
  /**
   * Updates the stored keymap plugin on this extension.
   */


  generateKeymap() {
    var extensionKeymaps = [];
    var shortcutMap = this.shortcutMap;
    var commandsExtension = this.store.getExtension(CommandsExtension);

    var extractNamesFactory = extension => shortcut => extractShortcutNames({
      shortcut,
      map: shortcutMap,
      store: this.store,
      options: extension.options
    });

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension$decoratedK, _extension$options$ex;

        var _extension = _step.value;
        var decoratedKeybindings = (_extension$decoratedK = _extension.decoratedKeybindings) !== null && _extension$decoratedK !== void 0 ? _extension$decoratedK : {};

        if ( // The extension was configured to ignore the keymap.
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.keymap) {
          continue;
        }

        if ( // The extension doesn't have the `createKeymap` method.
        _extension.createKeymap) {
          extensionKeymaps.push(updateNamedKeys(_extension.createKeymap(extractNamesFactory(_extension)), shortcutMap));
        }

        var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(decoratedKeybindings)),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _options$priority;

            var _step2$value = _slicedToArray(_step2.value, 2),
                name = _step2$value[0],
                options = _step2$value[1];

            if (options.isActive && !options.isActive(_extension.options, this.store)) {
              continue;
            } // Bind the keybinding function to the extension.


            var _keyBinding = _extension[name].bind(_extension); // Extract the keypress pattern.


            var shortcutNames = extractShortcutNames({
              shortcut: options.shortcut,
              map: shortcutMap,
              options: _extension.options,
              store: this.store
            }); // Decide the priority to assign to the keymap.

            var _priority = coreHelpers.isFunction(options.priority) ? options.priority(_extension.options, this.store) : (_options$priority = options.priority) !== null && _options$priority !== void 0 ? _options$priority : coreConstants.ExtensionPriority.Low;

            var bindingObject = coreHelpers.object();

            var _iterator3 = _createForOfIteratorHelper(shortcutNames),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var _shortcut = _step3.value;
                bindingObject[_shortcut] = _keyBinding;
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            extensionKeymaps.push([_priority, bindingObject]); // Attach the normalized shortcut to the decorated command so that is
            // can be referenced in the UI.

            if (options.command) {
              commandsExtension.updateDecorated(options.command, {
                shortcut: shortcutNames
              });
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } // Sort the keymaps with a priority given to keymaps added via
      // `extension.addHandler` (e.g. in hooks).

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var sortedKeymaps = this.sortKeymaps([...this.extraKeyBindings, ...extensionKeymaps]);
    var mappedCommands = coreUtils.mergeProsemirrorKeyBindings(sortedKeymaps);
    return keymap.keymap(mappedCommands);
  }
  /**
   * Handle exiting the mark forwards.
   */


  arrowRightShortcut(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return this.exitMarkForwards(excludedMarks, excludedNodes)(props);
  }
  /**
   * Handle the arrow left key to exit the mark.
   */


  arrowLeftShortcut(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return coreUtils.chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes), this.exitMarkBackwards(excludedMarks, excludedNodes))(props);
  }
  /**
   * Handle exiting the mark forwards.
   */


  backspace(props) {
    var excludedMarks = this.store.markTags[coreConstants.ExtensionTag.PreventExits];
    var excludedNodes = this.store.nodeTags[coreConstants.ExtensionTag.PreventExits];
    return coreUtils.chainKeyBindingCommands(this.exitNodeBackwards(excludedNodes, true), this.exitMarkBackwards(excludedMarks, excludedNodes, true))(props);
  }
  /**
   * Create the base keymap and give it a low priority so that all other keymaps
   * override it.
   */


  createKeymap() {
    var _this$options = this.options,
        selectParentNodeOnEscape = _this$options.selectParentNodeOnEscape,
        undoInputRuleOnBackspace = _this$options.undoInputRuleOnBackspace,
        excludeBaseKeymap = _this$options.excludeBaseKeymap;
    var baseKeyBindings = coreHelpers.object(); // Only add the base keymap if it is **NOT** excluded.

    if (!excludeBaseKeymap) {
      var _iterator4 = _createForOfIteratorHelper(coreHelpers.entries(commands.baseKeymap)),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _slicedToArray(_step4.value, 2),
              key = _step4$value[0],
              value = _step4$value[1];

          baseKeyBindings[key] = coreUtils.convertCommand(value);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    } // Automatically remove the input rule when the option is set to true.


    if (undoInputRuleOnBackspace && commands.baseKeymap.Backspace) {
      baseKeyBindings.Backspace = coreUtils.convertCommand(commands.chainCommands(inputrules.undoInputRule, commands.baseKeymap.Backspace));
    } // Allow escape to select the parent node when set to true.


    if (selectParentNodeOnEscape) {
      baseKeyBindings.Escape = coreUtils.convertCommand(commands.selectParentNode);
    }

    return [coreConstants.ExtensionPriority.Low, baseKeyBindings];
  }
  /**
   * Get the real shortcut name from the named shortcut.
   */


  getNamedShortcut(shortcut) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!shortcut.startsWith('_|')) {
      return [shortcut];
    }

    return extractShortcutNames({
      shortcut,
      map: this.shortcutMap,
      store: this.store,
      options: options
    });
  }
  /**
   * @internalremarks
   *
   * Think about the case where bindings are disposed of and then added in a
   * different position in the `extraKeyBindings` array. This is especially
   * pertinent when using hooks.
   */


  /**
   * Handle changes in the dynamic properties.
   */
  onSetOptions(props) {
    var changes = props.changes;

    if (changes.excludeBaseKeymap.changed || changes.selectParentNodeOnEscape.changed || changes.undoInputRuleOnBackspace.changed) {
      var _this$store$rebuildKe3, _this$store3;

      (_this$store$rebuildKe3 = (_this$store3 = this.store).rebuildKeymap) === null || _this$store$rebuildKe3 === void 0 ? void 0 : _this$store$rebuildKe3.call(_this$store3);
    }
  }

  sortKeymaps(bindings) {
    // Sort the bindings.
    return coreHelpers.sort(bindings.map(binding => // Make all bindings prioritized a default priority of
    // `ExtensionPriority.Default`
    coreHelpers.isArray(binding) ? binding : [coreConstants.ExtensionPriority.Default, binding]), // Sort from highest binding to the lowest.
    (a, z) => z[0] - a[0] // Extract the bindings from the prioritized tuple.
    ).map(binding => binding[1]);
  }
  /**
   * The method for rebuilding all the extension keymaps.
   *
   * 1. Rebuild keymaps.
   * 2. Replace the old keymap plugin.
   * 3. Update the plugins used in the state (triggers an editor update).
   */


  /**
   * Exits the mark forwards when at the end of a block node.
   */
  exitMarkForwards(excludedMarks, excludedNodes) {
    return props => {
      var tr = props.tr,
          dispatch = props.dispatch;

      if (!coreUtils.isEndOfTextBlock(tr.selection)) {
        return false;
      }

      var isInsideExcludedNode = coreUtils.findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      }

      var $pos = tr.selection.$from;
      var marksToRemove = $pos.marks().filter(mark => !excludedMarks.includes(mark.type.name));

      if (coreHelpers.isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      }

      var _iterator5 = _createForOfIteratorHelper(marksToRemove),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var mark = _step5.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      dispatch(tr.insertText(' ', tr.selection.from));
      return true;
    };
  }

  exitNodeBackwards(excludedNodes) {
    var startOfDoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return props => {
      var tr = props.tr;
      var checker = startOfDoc ? coreUtils.isStartOfDoc : coreUtils.isStartOfTextBlock;

      if (!checker(tr.selection)) {
        return false;
      }

      var node = tr.selection.$anchor.node();

      if (!coreUtils.isEmptyBlockNode(node) || coreUtils.isDefaultBlockNode(node) || excludedNodes.includes(node.type.name)) {
        return false;
      }

      return this.store.commands.toggleBlockNodeItem.original({
        type: node.type
      })(props);
    };
  }
  /**
   * Exit a mark when at the beginning of a block node.
   */


  exitMarkBackwards(excludedMarks, excludedNodes) {
    var startOfDoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    return props => {
      var _tr$storedMarks;

      var tr = props.tr,
          dispatch = props.dispatch;
      var checker = startOfDoc ? coreUtils.isStartOfDoc : coreUtils.isStartOfTextBlock;

      if (!checker(tr.selection) || this.backwardMarkExitTracker.has(tr.selection.anchor)) {
        // Clear the map to prevent it storing stale data.
        this.backwardMarkExitTracker.clear();
        return false;
      }

      var isInsideExcludedNode = coreUtils.findParentNodeOfType({
        selection: tr.selection,
        types: excludedNodes
      });

      if (isInsideExcludedNode) {
        return false;
      } // Find all the marks to remove


      var marksToRemove = [...((_tr$storedMarks = tr.storedMarks) !== null && _tr$storedMarks !== void 0 ? _tr$storedMarks : []), ...tr.selection.$from.marks()].filter(mark => !excludedMarks.includes(mark.type.name));

      if (coreHelpers.isEmptyArray(marksToRemove)) {
        return false;
      }

      if (!dispatch) {
        return true;
      } // Remove all the active marks at the current cursor.


      var _iterator6 = _createForOfIteratorHelper(marksToRemove),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var mark = _step6.value;
          tr.removeStoredMark(mark);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      this.backwardMarkExitTracker.set(tr.selection.anchor, true);
      dispatch(tr);
      return true;
    };
  }

}, (_applyDecoratedDescriptor(_class2$1.prototype, "arrowRightShortcut", [_dec2$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowRightShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "arrowLeftShortcut", [_dec3$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "arrowLeftShortcut"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "backspace", [_dec4$1], Object.getOwnPropertyDescriptor(_class2$1.prototype, "backspace"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "getNamedShortcut", [_dec5], Object.getOwnPropertyDescriptor(_class2$1.prototype, "getNamedShortcut"), _class2$1.prototype)), _class2$1)) || _class$5);

function isNamedShortcut(value) {
  return coreHelpers.includes(coreHelpers.values(coreConstants.NamedShortcut), value);
}

function extractShortcutNames(_ref2) {
  var shortcut = _ref2.shortcut,
      map = _ref2.map,
      options = _ref2.options,
      store = _ref2.store;

  if (coreHelpers.isString(shortcut)) {
    return [normalizeShortcutName(shortcut, map)];
  }

  if (coreHelpers.isArray(shortcut)) {
    return shortcut.map(value => normalizeShortcutName(value, map));
  }

  shortcut = shortcut(options, store);
  return extractShortcutNames({
    shortcut,
    map,
    options,
    store
  });
}

function normalizeShortcutName(value, shortcutMap) {
  return isNamedShortcut(value) ? shortcutMap[value] : value;
}

function updateNamedKeys(prioritizedBindings, shortcutMap) {
  var updatedBindings = {};
  var previousBindings;
  var priority;

  if (coreHelpers.isArray(prioritizedBindings)) {
    var _prioritizedBindings = _slicedToArray(prioritizedBindings, 2);

    priority = _prioritizedBindings[0];
    previousBindings = _prioritizedBindings[1];
  } else {
    previousBindings = prioritizedBindings;
  }

  var _iterator7 = _createForOfIteratorHelper(coreHelpers.entries(previousBindings)),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var _step7$value = _slicedToArray(_step7.value, 2),
          shortcutName = _step7$value[0],
          commandFunction = _step7$value[1];

      updatedBindings[normalizeShortcutName(shortcutName, shortcutMap)] = commandFunction;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return coreHelpers.isUndefined(priority) ? updatedBindings : [priority, updatedBindings];
}
/**
 * A shortcut map which is used by the `KeymapExtension`.
 */


/**
 * The default named shortcuts used within `remirror`.
 */
var DEFAULT_SHORTCUTS = {
  [coreConstants.NamedShortcut.Copy]: 'Mod-c',
  [coreConstants.NamedShortcut.Cut]: 'Mod-x',
  [coreConstants.NamedShortcut.Paste]: 'Mod-p',
  [coreConstants.NamedShortcut.PastePlain]: 'Mod-Shift-p',
  [coreConstants.NamedShortcut.SelectAll]: 'Mod-a',
  [coreConstants.NamedShortcut.Undo]: 'Mod-z',
  [coreConstants.NamedShortcut.Redo]: coreUtils.environment.isMac ? 'Shift-Mod-z' : 'Mod-y',
  [coreConstants.NamedShortcut.Bold]: 'Mod-b',
  [coreConstants.NamedShortcut.Italic]: 'Mod-i',
  [coreConstants.NamedShortcut.Underline]: 'Mod-u',
  [coreConstants.NamedShortcut.Strike]: 'Mod-d',
  [coreConstants.NamedShortcut.Code]: 'Mod-`',
  [coreConstants.NamedShortcut.Paragraph]: 'Mod-Shift-0',
  [coreConstants.NamedShortcut.H1]: 'Mod-Shift-1',
  [coreConstants.NamedShortcut.H2]: 'Mod-Shift-2',
  [coreConstants.NamedShortcut.H3]: 'Mod-Shift-3',
  [coreConstants.NamedShortcut.H4]: 'Mod-Shift-4',
  [coreConstants.NamedShortcut.H5]: 'Mod-Shift-5',
  [coreConstants.NamedShortcut.H6]: 'Mod-Shift-6',
  [coreConstants.NamedShortcut.TaskList]: 'Mod-Shift-7',
  [coreConstants.NamedShortcut.BulletList]: 'Mod-Shift-8',
  [coreConstants.NamedShortcut.OrderedList]: 'Mod-Shift-9',
  [coreConstants.NamedShortcut.Quote]: 'Mod->',
  [coreConstants.NamedShortcut.Divider]: 'Mod-Shift-|',
  [coreConstants.NamedShortcut.Codeblock]: 'Mod-Shift-~',
  [coreConstants.NamedShortcut.ClearFormatting]: 'Mod-Shift-C',
  [coreConstants.NamedShortcut.Superscript]: 'Mod-.',
  [coreConstants.NamedShortcut.Subscript]: 'Mod-,',
  [coreConstants.NamedShortcut.LeftAlignment]: 'Mod-Shift-L',
  [coreConstants.NamedShortcut.CenterAlignment]: 'Mod-Shift-E',
  [coreConstants.NamedShortcut.RightAlignment]: 'Mod-Shift-R',
  [coreConstants.NamedShortcut.JustifyAlignment]: 'Mod-Shift-J',
  [coreConstants.NamedShortcut.InsertLink]: 'Mod-k',
  [coreConstants.NamedShortcut.Find]: 'Mod-f',
  [coreConstants.NamedShortcut.FindBackwards]: 'Mod-Shift-f',
  [coreConstants.NamedShortcut.FindReplace]: 'Mod-Shift-H',
  [coreConstants.NamedShortcut.AddFootnote]: 'Mod-Alt-f',
  [coreConstants.NamedShortcut.AddComment]: 'Mod-Alt-m',
  [coreConstants.NamedShortcut.ContextMenu]: 'Mod-Shift-\\',
  [coreConstants.NamedShortcut.IncreaseFontSize]: 'Mod-Shift-.',
  [coreConstants.NamedShortcut.DecreaseFontSize]: 'Mod-Shift-,',
  [coreConstants.NamedShortcut.IncreaseIndent]: 'Tab',
  [coreConstants.NamedShortcut.DecreaseIndent]: 'Shift-Tab',
  [coreConstants.NamedShortcut.Shortcuts]: 'Mod-/',
  [coreConstants.NamedShortcut.Format]: coreUtils.environment.isMac ? 'Alt-Shift-f' : 'Shift-Ctrl-f'
};
/**
 * Shortcuts used within google docs.
 */

var GOOGLE_DOC_SHORTCUTS = _objectSpread(_objectSpread({}, DEFAULT_SHORTCUTS), {}, {
  [coreConstants.NamedShortcut.Strike]: 'Mod-Shift-S',
  [coreConstants.NamedShortcut.Code]: 'Mod-Shift-M',
  [coreConstants.NamedShortcut.Paragraph]: 'Mod-Alt-0',
  [coreConstants.NamedShortcut.H1]: 'Mod-Alt-1',
  [coreConstants.NamedShortcut.H2]: 'Mod-Alt-2',
  [coreConstants.NamedShortcut.H3]: 'Mod-Alt-3',
  [coreConstants.NamedShortcut.H4]: 'Mod-Alt-4',
  [coreConstants.NamedShortcut.H5]: 'Mod-Alt-5',
  [coreConstants.NamedShortcut.H6]: 'Mod-Alt-6',
  [coreConstants.NamedShortcut.OrderedList]: 'Mod-Alt-7',
  [coreConstants.NamedShortcut.BulletList]: 'Mod-Alt-8',
  [coreConstants.NamedShortcut.Quote]: 'Mod-Alt-9',
  [coreConstants.NamedShortcut.ClearFormatting]: 'Mod-\\',
  [coreConstants.NamedShortcut.IncreaseIndent]: 'Mod-[',
  [coreConstants.NamedShortcut.DecreaseIndent]: 'Mod-]'
});
var keyboardShortcuts = {
  default: DEFAULT_SHORTCUTS,
  googleDoc: GOOGLE_DOC_SHORTCUTS
};

/**
 * This extension allows others extension to add the `createNodeView` method
 * for creating nodeViews which alter how the dom is rendered for the node.
 *
 * @remarks
 *
 * This is an example of adding custom functionality to an extension via the
 * `ExtensionParameterMethods`.
 *
 * @category Builtin Extension
 */
class NodeViewsExtension extends PlainExtension {
  get name() {
    return 'nodeViews';
  }

  createPlugin() {
    var _this$store$managerSe;

    var nodeViewList = [];
    var nodeViews = coreHelpers.object();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var extension = _step.value;

        if (!extension.createNodeViews) {
          // Method doesn't exist
          continue;
        }

        var _nodeView = extension.createNodeViews(); // `.unshift` ensures higher priority extensions can overwrite the lower
        // priority nodeViews.


        nodeViewList.unshift(coreHelpers.isFunction(_nodeView) ? {
          [extension.name]: _nodeView
        } : _nodeView);
      } // Insert the `nodeViews` provided via the manager.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    nodeViewList.unshift((_this$store$managerSe = this.store.managerSettings.nodeViews) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : {});

    for (var _i = 0, _nodeViewList = nodeViewList; _i < _nodeViewList.length; _i++) {
      var nodeView = _nodeViewList[_i];
      Object.assign(nodeViews, nodeView);
    }

    return {
      props: {
        nodeViews
      }
    };
  }

}

/**
 * This extension allows others extension to add the `createPasteRules` method
 * for automatically transforming pasted text which matches a certain regex
 * pattern in the dom.
 *
 * @category Builtin Extension
 */
class PasteRulesExtension extends PlainExtension {
  get name() {
    return 'pasteRules';
  }

  createExternalPlugins() {
    return [this.generatePasteRulesPlugin()];
  }

  generatePasteRulesPlugin() {
    var extensionPasteRules = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe, _extension$options$ex;

        var extension = _step.value;

        if ( // managerSettings excluded this from running
        (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.pasteRules || // Method doesn't exist
        !extension.createPasteRules || // Extension settings exclude it
        (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.pasteRules) {
          continue;
        }

        var value = extension.createPasteRules();
        var rules = coreHelpers.isArray(value) ? value : [value];
        extensionPasteRules.push(...rules);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return pasteRules.pasteRules(extensionPasteRules);
  }

}

var _dec$4, _class$4;
var PluginsExtension = (_dec$4 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest,
  handlerKeys: ['applyState', 'appendTransaction']
}), _dec$4(_class$4 = class PluginsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "plugins", []);

    _defineProperty(this, "managerPlugins", []);

    _defineProperty(this, "applyStateHandlers", []);

    _defineProperty(this, "initStateHandlers", []);

    _defineProperty(this, "appendTransactionHandlers", []);

    _defineProperty(this, "pluginKeys", coreHelpers.object());

    _defineProperty(this, "stateGetters", new Map());

    _defineProperty(this, "getPluginStateCreator", key => state => {
      return key.getState(state !== null && state !== void 0 ? state : this.store.getState());
    });

    _defineProperty(this, "getStateByName", identifier => {
      var stateGetter = this.stateGetters.get(identifier);
      !stateGetter ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        message: 'No plugin exists for the requested extension name.'
      }) : coreHelpers.invariant(false) : void 0;
      return stateGetter();
    });
  }

  get name() {
    return 'plugins';
  }
  /**
   * All plugins created by other extension as well.
   */


  /**
   * This extension is responsible for adding state to the editor.
   */
  onCreate() {
    var _this$store = this.store,
        setStoreKey = _this$store.setStoreKey,
        setExtensionStore = _this$store.setExtensionStore,
        managerSettings = _this$store.managerSettings,
        extensions = _this$store.extensions;
    this.updateExtensionStore(); // Retrieve the plugins passed in when creating the manager.

    var _managerSettings$plug = managerSettings.plugins,
        plugins = _managerSettings$plug === void 0 ? [] : _managerSettings$plug; // Add the plugins which were added directly to the manager.

    this.updatePlugins(plugins, this.managerPlugins);

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;

        if (_extension.onApplyState) {
          this.applyStateHandlers.push(_extension.onApplyState.bind(_extension));
        }

        if (_extension.onInitState) {
          this.initStateHandlers.push(_extension.onInitState.bind(_extension));
        }

        if (_extension.onAppendTransaction) {
          this.appendTransactionHandlers.push(_extension.onAppendTransaction.bind(_extension));
        }

        this.extractExtensionPlugins(_extension);
      } // Store the added plugins for future usage.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.managerPlugins = plugins; // Add all the extracted plugins to the manager store. From the manager
    // store they are automatically added to the state for use in the editor.

    this.store.setStoreKey('plugins', this.plugins); // Here set the plugins keys and state getters for retrieving plugin state.
    // These methods are later used.

    setStoreKey('pluginKeys', this.pluginKeys);
    setStoreKey('getPluginState', this.getStateByName);
    setExtensionStore('getPluginState', this.getStateByName);
  }
  /**
   * Create a plugin which adds the [[`onInitState`]] and [[`onApplyState`]]
   * lifecycle methods.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, previousState, state) => {
        var tr = state.tr;
        var props = {
          previousState,
          tr,
          transactions,
          state
        };

        var _iterator2 = _createForOfIteratorHelper(this.appendTransactionHandlers),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var handler = _step2.value;
            handler(props);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        this.options.appendTransaction(props); // Return the transaction if it has been amended in any way.

        return tr.docChanged || tr.steps.length > 0 || tr.selectionSet || tr.storedMarksSet ? tr : undefined;
      },
      state: {
        init: (_, state) => {
          var _iterator3 = _createForOfIteratorHelper(this.initStateHandlers),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var handler = _step3.value;
              handler(state);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        },
        apply: (tr, _, previousState, state) => {
          var props = {
            previousState,
            state,
            tr
          };

          var _iterator4 = _createForOfIteratorHelper(this.applyStateHandlers),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var handler = _step4.value;
              handler(props);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          this.options.applyState(props);
        }
      }
    };
  }
  /**
   * Get all the plugins from the extension.
   */


  extractExtensionPlugins(extension) {
    var _this$store$managerSe, _extension$options$ex;

    var isNotPluginCreator = !extension.createPlugin && !extension.createExternalPlugins;

    if (isNotPluginCreator || // the manager settings don't exclude plugins
    (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.plugins || // The extension settings don't exclude plugins
    (_extension$options$ex = extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.plugins) {
      return;
    } // Create the custom plugin if it exists.


    if (extension.createPlugin) {
      var key = new state.PluginKey(extension.name); // Assign the plugin key to the extension name.

      this.pluginKeys[extension.name] = key;
      var getter = this.getPluginStateCreator(key);
      extension.pluginKey = key;
      extension.getPluginState = getter;
      this.stateGetters.set(extension.name, getter);
      this.stateGetters.set(extension.constructor, getter);

      var pluginSpec = _objectSpread(_objectSpread({}, extension.createPlugin()), {}, {
        key
      });

      var plugin = new state.Plugin(pluginSpec);
      this.updatePlugins([plugin], extension.plugin ? [extension.plugin] : undefined);
      extension.plugin = plugin;
    }

    if (extension.createExternalPlugins) {
      var externalPlugins = extension.createExternalPlugins();
      this.updatePlugins(externalPlugins, extension.externalPlugins);
      extension.externalPlugins = externalPlugins;
    }
  }

  /**
   * Add or replace a plugin.
   */
  updatePlugins(plugins, previous) {
    // This is the first time plugins are being added.
    if (!previous || coreHelpers.isEmptyArray(previous)) {
      this.plugins = [...this.plugins, ...plugins];
      return;
    } // The number of plugins and previous plugins is different.


    if (plugins.length !== previous.length) {
      // Remove previous plugins and add the new plugins to the end.
      this.plugins = [...this.plugins.filter(plugin => !previous.includes(plugin)), ...plugins];
      return;
    } // The length of plugins is identical, therefore a replacement is possible.


    var pluginMap = new Map();

    var _iterator5 = _createForOfIteratorHelper(plugins.entries()),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _slicedToArray(_step5.value, 2),
            index = _step5$value[0],
            plugin = _step5$value[1];

        pluginMap.set(coreHelpers.assertGet(previous, index), plugin);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    this.plugins = this.plugins.map(plugin => {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      return previous.includes(plugin) ? pluginMap.get(plugin) : plugin;
    });
  } // Method for retrieving the plugin state by the extension name.


  /**
   * Add the plugin specific properties and methods to the manager and extension
   * store.
   */
  updateExtensionStore() {
    var setExtensionStore = this.store.setExtensionStore; // Allow adding, replacing and removing plugins by other extensions.

    setExtensionStore('updatePlugins', this.updatePlugins.bind(this));
    setExtensionStore('dispatchPluginUpdate', this.dispatchPluginUpdate.bind(this));
    setExtensionStore('updateExtensionPlugins', this.updateExtensionPlugins.bind(this));
  }
  /**
   * Reruns the `createPlugin` and `createExternalPlugins` methods of the
   * provided extension.
   *
   * ```ts
   * // From within an extension
   * this.store.updateExtensionPlugins(this);
   * ```
   */


  updateExtensionPlugins(value) {
    var extension = isExtension(value) ? value : isExtensionConstructor(value) ? this.store.manager.getExtension(value) : this.store.extensions.find(extension => extension.name === value);
    !extension ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "The extension ".concat(value, " does not exist within the editor.")
    }) : coreHelpers.invariant(false) : void 0;
    this.extractExtensionPlugins(extension);
    this.store.setStoreKey('plugins', this.plugins); // Dispatch the plugin updates to the editor.

    this.dispatchPluginUpdate();
  }
  /**
   * Applies the store plugins to the state. If any have changed then it will be
   * updated.
   */


  dispatchPluginUpdate() {
    !(this.store.phase >= coreConstants.ManagerPhase.EditorView) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`dispatchPluginUpdate` should only be called after the view has been added to the manager.'
    }) : coreHelpers.invariant(false) : void 0;
    var _this$store2 = this.store,
        view = _this$store2.view,
        updateState = _this$store2.updateState;
    var newState = view.state.reconfigure({
      plugins: this.plugins
    });
    updateState(newState);
  }

}) || _class$4);

var _excluded = ["parseDOM"];

var _dec$3, _class$3;
var SchemaExtension = (_dec$3 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec$3(_class$3 = class SchemaExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "dynamicAttributes", {
      marks: coreHelpers.object(),
      nodes: coreHelpers.object()
    });
  }

  get name() {
    return 'schema';
  }
  /**
   * The dynamic attributes for each node and mark extension.
   *
   * The structure will look like the following.
   *
   * ```ts
   * {
   *   paragraph: { id: () => uid(), hash: (node) => hash(node) },
   *   bold: { random: () => Math.random(), created: () => Date.now() },
   * };
   * ```
   *
   * This object is used by the created plugin to listen for changes to the doc,
   * and check for new nodes and marks which haven't yet applied the dynamic
   * attribute and add the attribute.
   */


  /**
   * This method is responsible for creating, configuring and adding the
   * `schema` to the editor. `Schema` is a special type in ProseMirror editors
   * and with `remirror` it's all just handled for you.
   */
  onCreate() {
    var _this = this;

    var _this$store = this.store,
        managerSettings = _this$store.managerSettings,
        tags = _this$store.tags,
        markNames = _this$store.markNames,
        nodeNames = _this$store.nodeNames,
        extensions = _this$store.extensions;
    var defaultBlockNode = managerSettings.defaultBlockNode,
        disableExtraAttributes = managerSettings.disableExtraAttributes,
        nodeOverride = managerSettings.nodeOverride,
        markOverride = managerSettings.markOverride; // True when the `defaultBlockNode` exists for this editor.

    var isValidDefaultBlockNode = name => !!(name && tags[coreConstants.ExtensionTag.Block].includes(name)); // The user can override the whole schema creation process by providing
    // their own version. In that case we can exit early.


    if (managerSettings.schema) {
      var _getSpecFromSchema = getSpecFromSchema(managerSettings.schema),
          _nodes = _getSpecFromSchema.nodes,
          _marks = _getSpecFromSchema.marks;

      this.addSchema(managerSettings.schema, _nodes, _marks); // Exit early! 🙌

      return;
    } // This nodes object is built up for each extension and then at the end it
    // will be passed to the `Schema` constructor to create a new `schema`.


    var nodes = isValidDefaultBlockNode(defaultBlockNode) ? {
      doc: coreHelpers.object(),
      // Ensure that this is the highest positioned block node by adding it
      // to the object early. Later on it will be overwritten but maintain
      // it's position.
      [defaultBlockNode]: coreHelpers.object()
    } : coreHelpers.object(); // Similar to the `nodes` object above this is passed to the `Schema`.

    var marks = coreHelpers.object(); // Get the named extra attributes from the manager. This allows each extra
    // attribute group added to the manager to be applied to the individual
    // extensions which specified.

    var namedExtraAttributes = getNamedSchemaAttributes({
      settings: managerSettings,
      gatheredSchemaAttributes: this.gatherExtraAttributes(extensions),
      nodeNames: nodeNames,
      markNames: markNames,
      tags: tags
    });

    var _iterator = _createForOfIteratorHelper(extensions),
        _step;

    try {
      var _loop = function _loop() {
        var extension = _step.value;
        // Pick the current attributes from the named attributes and merge them
        // with the extra attributes which were added to the extension. Extra
        // attributes added to the extension are prioritized.
        namedExtraAttributes[extension.name] = _objectSpread(_objectSpread({}, namedExtraAttributes[extension.name]), extension.options.extraAttributes); // There are several places that extra attributes can be ignored. This
        // checks them all.

        var ignoreExtraAttributes = disableExtraAttributes === true || extension.options.disableExtraAttributes === true || extension.constructor.disableExtraAttributes === true;

        if (isNodeExtension(extension)) {
          // Create the spec and gather dynamic attributes for this node
          // extension.
          var _createSpec = createSpec({
            createExtensionSpec: (extra, override) => extension.createNodeSpec(extra, override),
            extraAttributes: coreHelpers.assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, nodeOverride), extension.options.nodeOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: extension.tags
          }),
              spec = _createSpec.spec,
              dynamic = _createSpec.dynamic; // Store the node spec on the extension for future reference.


          extension.spec = spec; // Add the spec to the `nodes` object which is used to create the schema
          // with the same name as the extension name.

          nodes[extension.name] = spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `NodeType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct nodes.

          if (Object.keys(dynamic).length > 0) {
            _this.dynamicAttributes.nodes[extension.name] = dynamic;
          }
        } // Very similar to the previous conditional block except for marks rather
        // than nodes.


        if (isMarkExtension(extension)) {
          var _extension$tags;

          // Create the spec and gather dynamic attributes for this mark
          // extension.
          var _createSpec2 = createSpec({
            createExtensionSpec: (extra, override) => extension.createMarkSpec(extra, override),
            extraAttributes: coreHelpers.assertGet(namedExtraAttributes, extension.name),
            // Todo add support for setting overrides via the manager.
            override: _objectSpread(_objectSpread({}, markOverride), extension.options.markOverride),
            ignoreExtraAttributes,
            name: extension.constructorName,
            tags: (_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []
          }),
              _spec = _createSpec2.spec,
              _dynamic = _createSpec2.dynamic; // Store the mark spec on the extension for future reference.


          extension.spec = _spec; // Add the spec to the `marks` object which is used to create the schema
          // with the same name as the extension name.

          marks[extension.name] = _spec; // Keep track of the dynamic attributes. The `extension.name` is the
          // same name of the `MarkType` and is used by the plugin in this
          // extension to dynamically generate attributes for the correct marks.

          if (Object.keys(_dynamic).length > 0) {
            _this.dynamicAttributes.marks[extension.name] = _dynamic;
          }
        }
      };

      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        _loop();
      } // Create the schema from the gathered nodes and marks.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var schema = new model.Schema({
      nodes,
      marks,
      topNode: 'doc'
    }); // Add the schema and nodes marks to the store.

    this.addSchema(schema, nodes, marks);
  }
  /**
   * This creates the plugin that is used to automatically create the dynamic
   * attributes defined in the extra attributes object.
   */


  createPlugin() {
    return {
      appendTransaction: (transactions, _, nextState) => {
        // This creates a new transaction which will be used to update the
        // attributes of any node and marks which
        var tr = nextState.tr; // The dynamic attribute updates only need to be run if the document has
        // been modified in a transaction.

        var documentHasChanged = transactions.some(tr => tr.docChanged);

        if (!documentHasChanged) {
          // The document has not been changed therefore no updates are
          // required.
          return null;
        } // The find children method could potentially be quite expensive. Before
        // committing to that level of work let's check that there user has
        // actually defined some dynamic attributes.


        if (Object.keys(this.dynamicAttributes.nodes).length === 0 && Object.keys(this.dynamicAttributes.marks).length === 0) {
          return null;
        } // This function loops through every node in the document and add the
        // dynamic attributes when any relevant nodes have been added.


        tr.doc.descendants((child, pos) => {
          this.checkAndUpdateDynamicNodes(child, pos, tr);
          this.checkAndUpdateDynamicMarks(child, pos, tr); // This means that all nodes will be checked.

          return true;
        }); // If the transaction has any `steps` then it has been modified and
        // should be returned i.e. appended to the additional transactions.
        // However, if there are no steps then ignore and return `null`.

        return tr.steps.length > 0 ? tr : null;
      }
    };
  }
  /**
   * Add the schema and nodes to the manager and extension store.
   */


  addSchema(schema, nodes, marks) {
    // Store the `nodes`, `marks` and `schema` on the manager store. For example
    // the `schema` can be accessed via `manager.store.schema`.
    this.store.setStoreKey('nodes', nodes);
    this.store.setStoreKey('marks', marks);
    this.store.setStoreKey('schema', schema); // Add the schema to the extension store, so that all extension from this
    // point have access to the schema via `this.store.schema`.

    this.store.setExtensionStore('schema', schema);
    this.store.setStoreKey('defaultBlockNode', coreUtils.getDefaultBlockNode(schema).name); // Set the default block node from the schema.

    for (var _i = 0, _Object$values = Object.values(schema.nodes); _i < _Object$values.length; _i++) {
      var type = _Object$values[_i];

      if (type.name === 'doc') {
        continue;
      } // Break as soon as the first non 'doc' block node is encountered.


      if (type.isBlock || type.isTextblock) {
        break;
      }
    }
  }
  /**
   * Check the dynamic nodes to see if the provided node:
   *
   * - a) is dynamic and therefore can be updated.
   * - b) has just been created and does not yet have a value for the dynamic
   *   node.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state
   */


  checkAndUpdateDynamicNodes(node, pos, tr) {
    // Check for matching nodes.
    var _iterator2 = _createForOfIteratorHelper(coreHelpers.entries(this.dynamicAttributes.nodes)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            _name = _step2$value[0],
            dynamic = _step2$value[1];

        if (node.type.name !== _name) {
          continue;
        }

        var _iterator3 = _createForOfIteratorHelper(coreHelpers.entries(dynamic)),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
                attributeName = _step3$value[0],
                attributeCreator = _step3$value[1];

            if (!coreHelpers.isNullOrUndefined(node.attrs[attributeName])) {
              continue;
            } // The new attributes which will be added to the node.


            var attrs = _objectSpread(_objectSpread({}, node.attrs), {}, {
              [attributeName]: attributeCreator(node)
            }); // Apply the new dynamic attribute to the node via the transaction.


            tr.setNodeMarkup(pos, undefined, attrs); // Ignore this update in the `prosemirror-suggest` plugin

            suggest.ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Loop through the dynamic marks to see if the provided node:
   *
   * - a) is wrapped by a matching mark.
   * - b) has just been added and doesn't yet have the dynamic attribute
   *   applied.
   *
   * @param node - the node
   * @param pos - the node's position
   * @param tr - the mutable ProseMirror transaction which is applied to create
   * the next editor state.
   */


  checkAndUpdateDynamicMarks(node, pos, tr) {
    var _this2 = this;

    // Check for matching marks.
    var _iterator4 = _createForOfIteratorHelper(coreHelpers.entries(this.dynamicAttributes.marks)),
        _step4;

    try {
      var _loop2 = function _loop2() {
        var _step4$value = _slicedToArray(_step4.value, 2),
            name = _step4$value[0],
            dynamic = _step4$value[1];

        // This is needed to create the new mark. Even though a mark may already
        // exist ProseMirror requires that a new one is created and added in
        // order. More details available
        // [here](https://discuss.prosemirror.net/t/updating-mark-attributes/776/2?u=ifi).
        var type = coreHelpers.assertGet(_this2.store.schema.marks, name); // Get the attrs from the mark.

        var mark = node.marks.find(mark => mark.type.name === name); // If the mark doesn't exist within the set then move to the next
        // dynamically updated mark.

        if (!mark) {
          return "continue";
        } // Loop through to find if any of the required matches are missing from
        // the dynamic attribute;


        var _iterator5 = _createForOfIteratorHelper(coreHelpers.entries(dynamic)),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
                attributeName = _step5$value[0],
                attributeCreator = _step5$value[1];

            // When the attributes for this dynamic attributeName are already
            // defined we should move onto the next item;
            if (!coreHelpers.isNullOrUndefined(mark.attrs[attributeName])) {
              continue;
            } // Use the starting position of the node to calculate the range range of
            // the current mark.


            var range = coreUtils.getMarkRange(tr.doc.resolve(pos), type);

            if (!range) {
              continue;
            } // The { from, to } range which will be used to update the mark id
            // attribute.


            var from = range.from,
                to = range.to; // Create the new mark with all the existing dynamic attributes applied.

            var newMark = type.create(_objectSpread(_objectSpread({}, mark.attrs), {}, {
              [attributeName]: attributeCreator(mark)
            })); // Update the value of the mark. The only way to do this right now is to
            // remove and then add it back again.

            tr.removeMark(from, to, type).addMark(from, to, newMark); // Ignore this update in the `prosemirror-suggest` plugin

            suggest.ignoreUpdateForSuggest(tr);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };

      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _ret = _loop2();

        if (_ret === "continue") continue;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
  /**
   * Gather all the extra attributes that have been added by extensions.
   */


  gatherExtraAttributes(extensions) {
    var extraSchemaAttributes = [];

    var _iterator6 = _createForOfIteratorHelper(extensions),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var _extension = _step6.value;

        if (!_extension.createSchemaAttributes) {
          continue;
        }

        extraSchemaAttributes.push(..._extension.createSchemaAttributes());
      }
    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    return extraSchemaAttributes;
  }

}) || _class$3);
/**
 * With tags, you can select a specific sub selection of marks and nodes. This
 * will be the basis for adding advanced formatting to remirror.
 *
 * ```ts
 * import { ExtensionTag } from 'remirror';
 * import { createCoreManager, CorePreset } from 'remirror/extensions';
 * import { WysiwygPreset } from 'remirror/extensions';
 *
 * const manager = createCoreManager(() => [new WysiwygPreset(), new CorePreset()], {
 *   extraAttributes: [
 *     {
 *       identifiers: {
 *         tags: [ExtensionTag.NodeBlock],
 *         type: 'node',
 *       },
 *       attributes: { role: 'presentation' },
 *     },
 *   ],
 * });
 * ```
 *
 * Each item in the tags array should be read as an `OR` so the following would
 * match `Tag1` OR `Tag2` OR `Tag3`.
 *
 * ```json
 * { tags: ["Tag1", "Tag2", "Tag3"] }
 * ```
 *
 * The `type` property (`mark | node`) is exclusive and limits the type of
 * extension names that will be matched. When `mark` is set it only matches with
 * marks.
 */

/**
 * Get the extension extra attributes created via the manager and convert into a
 * named object which can be added to each node and mark spec.
 */
function getNamedSchemaAttributes(props) {
  var _settings$extraAttrib;

  var settings = props.settings,
      gatheredSchemaAttributes = props.gatheredSchemaAttributes,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;
  var extraAttributes = coreHelpers.object();

  if (settings.disableExtraAttributes) {
    return extraAttributes;
  }

  var extraSchemaAttributes = [...gatheredSchemaAttributes, ...((_settings$extraAttrib = settings.extraAttributes) !== null && _settings$extraAttrib !== void 0 ? _settings$extraAttrib : [])];

  for (var _i2 = 0, _arr = extraSchemaAttributes !== null && extraSchemaAttributes !== void 0 ? extraSchemaAttributes : []; _i2 < _arr.length; _i2++) {
    var attributeGroup = _arr[_i2];
    var identifiers = getIdentifiers({
      identifiers: attributeGroup.identifiers,
      nodeNames,
      markNames,
      tags
    });

    var _iterator7 = _createForOfIteratorHelper(identifiers),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var _extraAttributes$iden;

        var identifier = _step7.value;
        var currentValue = (_extraAttributes$iden = extraAttributes[identifier]) !== null && _extraAttributes$iden !== void 0 ? _extraAttributes$iden : {};
        extraAttributes[identifier] = _objectSpread(_objectSpread({}, currentValue), attributeGroup.attributes);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }

  return extraAttributes;
}

/**
 * A predicate for checking if the passed in value is an `IdentifiersObject`.
 */
function isIdentifiersObject(value) {
  return coreHelpers.isPlainObject(value) && coreHelpers.isArray(value.tags);
}
/**
 * Get the array of names from the identifier that the extra attributes should
 * be applied to.
 */


function getIdentifiers(props) {
  var identifiers = props.identifiers,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      tags = props.tags;

  if (identifiers === 'nodes') {
    return nodeNames;
  }

  if (identifiers === 'marks') {
    return markNames;
  }

  if (identifiers === 'all') {
    return [...nodeNames, ...markNames];
  } // This is already an array of names to apply the attributes to.


  if (coreHelpers.isArray(identifiers)) {
    return identifiers;
  } // Make sure the object provides is valid.


  !isIdentifiersObject(identifiers) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES,
    message: "Invalid value passed as an identifier when creating `extraAttributes`."
  }) : coreHelpers.invariant(false) : void 0; // Provide type aliases for easier readability.

  var _identifiers$tags = identifiers.tags,
      extensionTags = _identifiers$tags === void 0 ? [] : _identifiers$tags,
      _identifiers$names = identifiers.names,
      extensionNames = _identifiers$names === void 0 ? [] : _identifiers$names,
      _identifiers$behavior = identifiers.behavior,
      behavior = _identifiers$behavior === void 0 ? 'any' : _identifiers$behavior,
      excludeNames = identifiers.excludeNames,
      excludeTags = identifiers.excludeTags,
      type = identifiers.type; // Keep track of the set of stored names.

  var names = new Set(); // Collect the array of names that are supported.

  var acceptableNames = type === 'mark' ? markNames : type === 'node' ? nodeNames : [...markNames, ...nodeNames]; // Check if the name is valid

  var isNameValid = name => acceptableNames.includes(name) && !(excludeNames !== null && excludeNames !== void 0 && excludeNames.includes(name));

  var _iterator8 = _createForOfIteratorHelper(extensionNames),
      _step8;

  try {
    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
      var _name2 = _step8.value;

      if (isNameValid(_name2)) {
        names.add(_name2);
      }
    } // Create a map of extension names to their set of included tags. Then check
    // that the length of the `TagSet` for each extension name is equal to the
    // provided extension tags in this identifier.

  } catch (err) {
    _iterator8.e(err);
  } finally {
    _iterator8.f();
  }

  var taggedNamesMap = new Map(); // Loop through every extension

  var _iterator9 = _createForOfIteratorHelper(extensionTags),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var tag = _step9.value;

      if (excludeTags !== null && excludeTags !== void 0 && excludeTags.includes(tag)) {
        continue;
      }

      var _iterator11 = _createForOfIteratorHelper(tags[tag]),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _taggedNamesMap$get;

          var _name3 = _step11.value;

          if (!isNameValid(_name3)) {
            continue;
          } // When any tag can be an identifier simply add the name to names.


          if (behavior === 'any') {
            names.add(_name3);
            continue;
          }

          var tagSet = (_taggedNamesMap$get = taggedNamesMap.get(_name3)) !== null && _taggedNamesMap$get !== void 0 ? _taggedNamesMap$get : new Set();
          tagSet.add(tag);
          taggedNamesMap.set(_name3, tagSet);
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    } // Only add the names that have a `TagSet` where `size` is equal to the number
    // of `extensionTags`

  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  var _iterator10 = _createForOfIteratorHelper(taggedNamesMap),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _step10$value = _slicedToArray(_step10.value, 2),
          _name4 = _step10$value[0],
          _tagSet = _step10$value[1];

      if (_tagSet.size === extensionTags.length) {
        names.add(_name4);
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  return [...names];
}

/**
 * Create the scheme spec for a node or mark extension.
 *
 * @template Type - either a [[Mark]] or a [[ProsemirrorNode]]
 * @param props - the options object [[CreateSpecProps]]
 */
function createSpec(props) {
  var _spec$group$split, _spec$group;

  var createExtensionSpec = props.createExtensionSpec,
      extraAttributes = props.extraAttributes,
      ignoreExtraAttributes = props.ignoreExtraAttributes,
      name = props.name,
      tags = props.tags,
      override = props.override; // Keep track of the dynamic attributes which are a part of this spec.

  var dynamic = coreHelpers.object();
  /** Called for every dynamic creator to track the dynamic attributes */

  function addDynamic(attributeName, creator) {
    dynamic[attributeName] = creator;
  } // Used to track whether the method has been called. If not called when the
  // extension spec is being set up then an error is thrown.


  var defaultsCalled = false;
  /** Called by createDefaults to track when the `defaults` has been called. */

  function onDefaultsCalled() {
    defaultsCalled = true;
  }

  var defaults = createDefaults(extraAttributes, ignoreExtraAttributes, onDefaultsCalled, addDynamic);
  var parse = createParseDOM(extraAttributes, ignoreExtraAttributes);
  var dom = createToDOM(extraAttributes, ignoreExtraAttributes);
  var spec = createExtensionSpec({
    defaults,
    parse,
    dom
  }, override);
  !(ignoreExtraAttributes || defaultsCalled) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.EXTENSION_SPEC,
    message: "When creating a node specification you must call the 'defaults', and parse, and 'dom' methods. To avoid this error you can set the static property 'disableExtraAttributes' of '".concat(name, "' to 'true'.")
  }) : coreHelpers.invariant(false) : void 0; // Add the tags to the group of the created spec.

  spec.group = [...((_spec$group$split = (_spec$group = spec.group) === null || _spec$group === void 0 ? void 0 : _spec$group.split(' ')) !== null && _spec$group$split !== void 0 ? _spec$group$split : []), ...tags].join(' ') || undefined;
  return {
    spec,
    dynamic
  };
}
/**
 * Get the value of the extra attribute as an object.
 *
 * This is needed because the SchemaAttributes object can be configured as a
 * string or as an object.
 */


function getExtraAttributesObject(value) {
  if (coreHelpers.isString(value) || coreHelpers.isFunction(value)) {
    return {
      default: value
    };
  }

  !value ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    message: "".concat(coreHelpers.toString(value), " is not supported"),
    code: coreConstants.ErrorConstant.EXTENSION_EXTRA_ATTRIBUTES
  }) : coreHelpers.invariant(false) : void 0;
  return value;
}
/**
 * Create the `defaults()` method which is used for setting the property.
 *
 * @param extraAttributes - the extra attributes for this particular node
 * @param shouldIgnore - whether this attribute should be ignored
 * @param onCalled - the function which is called when this is run, to check
 * that it has been added to the attrs
 * @param addDynamic - A function called to add the dynamic creator and name to
 * the store
 */


function createDefaults(extraAttributes, shouldIgnore, onCalled, addDynamicCreator) {
  return () => {
    onCalled();
    var attributes = coreHelpers.object(); // Extra attributes can be ignored by the extension, check if that's the
    // case here.

    if (shouldIgnore) {
      return attributes;
    } // Loop through the extra attributes and attach to the attributes object.


    var _iterator12 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var _step12$value = _slicedToArray(_step12.value, 2),
            _name5 = _step12$value[0],
            config = _step12$value[1];

        // Make sure this is an object and not a string.
        var attributesObject = getExtraAttributesObject(config);
        var defaultValue = attributesObject.default; // When true this is a dynamic attribute creator.

        if (coreHelpers.isFunction(defaultValue)) {
          // Store the name and method of the dynamic creator.
          addDynamicCreator(_name5, defaultValue); // Set the attributes for this dynamic creator to be null by default.

          defaultValue = null;
        } // When the `defaultValue` is set to `undefined`, it is set as an empty
        // object in order for ProseMirror to set it as a required attribute.


        attributes[_name5] = defaultValue === undefined ? {} : {
          default: defaultValue
        };
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }

    return attributes;
  };
}
/**
 * Create the parseDOM method to be applied to the extension `createNodeSpec`.
 */


function createParseDOM(extraAttributes, shouldIgnore) {
  return domNode => {
    var attributes = coreHelpers.object();

    if (shouldIgnore) {
      return attributes;
    }

    var _iterator13 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step13;

    try {
      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
        var _domNode$getAttribute2;

        var _step13$value = _slicedToArray(_step13.value, 2),
            _name6 = _step13$value[0],
            config = _step13$value[1];

        var _getExtraAttributesOb = getExtraAttributesObject(config),
            parseDOM = _getExtraAttributesOb.parseDOM,
            other = _objectWithoutProperties(_getExtraAttributesOb, _excluded);

        if (!coreUtils.isElementDomNode(domNode)) {
          continue;
        }

        if (coreHelpers.isNullOrUndefined(parseDOM)) {
          var _domNode$getAttribute;

          attributes[_name6] = (_domNode$getAttribute = domNode.getAttribute(_name6)) !== null && _domNode$getAttribute !== void 0 ? _domNode$getAttribute : other.default;
          continue;
        }

        if (coreHelpers.isFunction(parseDOM)) {
          var _parseDOM;

          attributes[_name6] = (_parseDOM = parseDOM(domNode)) !== null && _parseDOM !== void 0 ? _parseDOM : other.default;
          continue;
        }

        attributes[_name6] = (_domNode$getAttribute2 = domNode.getAttribute(parseDOM)) !== null && _domNode$getAttribute2 !== void 0 ? _domNode$getAttribute2 : other.default;
      }
    } catch (err) {
      _iterator13.e(err);
    } finally {
      _iterator13.f();
    }

    return attributes;
  };
}
/**
 * Create the `toDOM` method to be applied to the extension `createNodeSpec`.
 */


function createToDOM(extraAttributes, shouldIgnore) {
  return item => {
    var domAttributes = coreHelpers.object();

    if (shouldIgnore) {
      return domAttributes;
    }

    function updateDomAttributes(value, name) {
      if (!value) {
        return;
      }

      if (coreHelpers.isString(value)) {
        domAttributes[name] = value;
        return;
      }

      if (coreHelpers.isArray(value)) {
        var _value = _slicedToArray(value, 2),
            attr = _value[0],
            val = _value[1];

        domAttributes[attr] = val !== null && val !== void 0 ? val : item.attrs[name];
        return;
      }

      var _iterator14 = _createForOfIteratorHelper(coreHelpers.entries(value)),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var _step14$value = _slicedToArray(_step14.value, 2),
              _attr = _step14$value[0],
              _val = _step14$value[1];

          domAttributes[_attr] = _val;
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }

    var _iterator15 = _createForOfIteratorHelper(coreHelpers.entries(extraAttributes)),
        _step15;

    try {
      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
        var _step15$value = _slicedToArray(_step15.value, 2),
            _name7 = _step15$value[0],
            config = _step15$value[1];

        var _getExtraAttributesOb2 = getExtraAttributesObject(config),
            toDOM = _getExtraAttributesOb2.toDOM,
            parseDOM = _getExtraAttributesOb2.parseDOM;

        if (coreHelpers.isNullOrUndefined(toDOM)) {
          var key = coreHelpers.isString(parseDOM) ? parseDOM : _name7;
          domAttributes[key] = item.attrs[_name7];
          continue;
        }

        if (coreHelpers.isFunction(toDOM)) {
          updateDomAttributes(toDOM(item.attrs, getNodeMarkOptions(item)), _name7);
          continue;
        }

        updateDomAttributes(toDOM, _name7);
      }
    } catch (err) {
      _iterator15.e(err);
    } finally {
      _iterator15.f();
    }

    return domAttributes;
  };
}
/**
 * Get the options object which applies should be used to obtain the node or
 * mark type.
 */


function getNodeMarkOptions(item) {
  if (coreUtils.isProsemirrorNode(item)) {
    return {
      node: item
    };
  }

  if (coreUtils.isProsemirrorMark(item)) {
    return {
      mark: item
    };
  }

  return {};
}
/**
 * Get the mark and node specs from provided schema.
 *
 * This is used when the user provides their own custom schema.
 */


function getSpecFromSchema(schema) {
  var nodes = coreHelpers.object();
  var marks = coreHelpers.object();

  for (var _i3 = 0, _Object$entries = Object.entries(schema.nodes); _i3 < _Object$entries.length; _i3++) {
    var _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2),
        _name8 = _Object$entries$_i[0],
        type = _Object$entries$_i[1];

    nodes[_name8] = type.spec;
  }

  for (var _i4 = 0, _Object$entries2 = Object.entries(schema.marks); _i4 < _Object$entries2.length; _i4++) {
    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
        _name9 = _Object$entries2$_i[0],
        _type = _Object$entries2$_i[1];

    marks[_name9] = _type.spec;
  }

  return {
    nodes,
    marks
  };
}

var _dec$2, _dec2, _dec3, _dec4, _class$2, _class2;
var SuggestExtension = (_dec$2 = extension({
  customHandlerKeys: ['suggester']
}), _dec2 = helper(), _dec3 = helper(), _dec4 = helper(), _dec$2(_class$2 = (_class2 = class SuggestExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "onAddCustomHandler", _ref => {
      var _this$store$managerSe;

      var suggester = _ref.suggester;

      if (!suggester || (_this$store$managerSe = this.store.managerSettings.exclude) !== null && _this$store$managerSe !== void 0 && _this$store$managerSe.suggesters) {
        return;
      } // Update the suggesters with the provided suggester. Returns the cleanup
      // method.


      return suggest.addSuggester(this.store.getState(), suggester);
    });
  }

  get name() {
    return 'suggest';
  }
  /**
   * Create the `addSuggester` method and `removeSuggester` methods to the
   * extension store.
   *
   * This can be used by extensions to conditionally add suggestion support.
   */


  onCreate() {
    this.store.setExtensionStore('addSuggester', suggester => suggest.addSuggester(this.store.getState(), suggester));
    this.store.setExtensionStore('removeSuggester', suggester => suggest.removeSuggester(this.store.getState(), suggester));
  }
  /**
   * Add the `prosemirror-suggest` plugin to the editor.
   */


  createExternalPlugins() {
    var suggesters = [];

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _this$store$managerSe2, _extension$options$ex;

        var _extension = _step.value;

        if ((_this$store$managerSe2 = this.store.managerSettings.exclude) !== null && _this$store$managerSe2 !== void 0 && _this$store$managerSe2.suggesters) {
          // Exit the loop early when the manager is set to ignore suggesters.
          break;
        }

        if ( // Method doesn't exist
        !_extension.createSuggesters || // Extension settings exclude it from running
        (_extension$options$ex = _extension.options.exclude) !== null && _extension$options$ex !== void 0 && _extension$options$ex.suggesters) {
          continue;
        }

        var _suggester = _extension.createSuggesters();

        var suggesterList = coreHelpers.isArray(_suggester) ? _suggester : [_suggester];
        suggesters.push(...suggesterList);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    return [suggest.suggest(...suggesters)];
  }
  /**
   * Allow additional `Suggesters` to be added to the editor. This can be used
   * by `React` to create hooks.
   */


  /**
   * Get the suggest plugin state.
   *
   * This may be removed at a later time.
   *
   * @experimental
   */
  getSuggestState(state) {
    return suggest.getSuggestPluginState(state !== null && state !== void 0 ? state : this.store.getState());
  }
  /**
   * Get some helpful methods from the SuggestPluginState.
   */


  getSuggestMethods() {
    var _this$getSuggestState = this.getSuggestState(),
        addIgnored = _this$getSuggestState.addIgnored,
        clearIgnored = _this$getSuggestState.clearIgnored,
        removeIgnored = _this$getSuggestState.removeIgnored,
        ignoreNextExit = _this$getSuggestState.ignoreNextExit,
        setMarkRemoved = _this$getSuggestState.setMarkRemoved,
        findMatchAtPosition = _this$getSuggestState.findMatchAtPosition,
        findNextTextSelection = _this$getSuggestState.findNextTextSelection,
        setLastChangeFromAppend = _this$getSuggestState.setLastChangeFromAppend;

    return {
      addIgnored,
      clearIgnored,
      removeIgnored,
      ignoreNextExit,
      setMarkRemoved,
      findMatchAtPosition,
      findNextTextSelection,
      setLastChangeFromAppend
    };
  }
  /**
   * Check to see whether the provided name is the currently active
   * suggester.
   *
   * @param name - the name of the suggester to include
   */


  isSuggesterActive(name) {
    var _this$getSuggestState2;

    return coreHelpers.includes(coreHelpers.isArray(name) ? name : [name], (_this$getSuggestState2 = this.getSuggestState().match) === null || _this$getSuggestState2 === void 0 ? void 0 : _this$getSuggestState2.suggester.name);
  }

}, (_applyDecoratedDescriptor(_class2.prototype, "getSuggestState", [_dec2], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestState"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "getSuggestMethods", [_dec3], Object.getOwnPropertyDescriptor(_class2.prototype, "getSuggestMethods"), _class2.prototype), _applyDecoratedDescriptor(_class2.prototype, "isSuggesterActive", [_dec4], Object.getOwnPropertyDescriptor(_class2.prototype, "isSuggesterActive"), _class2.prototype)), _class2)) || _class$2);

var _dec$1, _class$1;
/**
 * Create the extension tags which are passed into each extensions method to
 * enable dynamically generated rules and commands.
 *
 * Tags on nodes and marks are automatically added to the schema as groups.
 *
 * @category Builtin Extension
 */

var TagsExtension = (_dec$1 = extension({
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec$1(_class$1 = class TagsExtension extends PlainExtension {
  constructor() {
    super(...arguments);

    _defineProperty(this, "allTags", coreHelpers.object());

    _defineProperty(this, "plainTags", coreHelpers.object());

    _defineProperty(this, "markTags", coreHelpers.object());

    _defineProperty(this, "nodeTags", coreHelpers.object());
  }

  get name() {
    return 'tags';
  }
  /**
   * Track the tags which have been applied to the extensions in this editor.
   */


  /**
   * Create the tags which are used to identify extension with particular
   * behavioral traits.
   */
  onCreate() {
    this.resetTags();

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.updateTagForExtension(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this.store.setStoreKey('tags', this.allTags);
    this.store.setExtensionStore('tags', this.allTags);
    this.store.setStoreKey('plainTags', this.plainTags);
    this.store.setExtensionStore('plainTags', this.plainTags);
    this.store.setStoreKey('markTags', this.markTags);
    this.store.setExtensionStore('markTags', this.markTags);
    this.store.setStoreKey('nodeTags', this.nodeTags);
    this.store.setExtensionStore('nodeTags', this.nodeTags);
  }
  /**
   * Reset the tags to the empty object with empty arrays.
   */


  resetTags() {
    var allTags = coreHelpers.object();
    var plainTags = coreHelpers.object();
    var markTags = coreHelpers.object();
    var nodeTags = coreHelpers.object();

    var _iterator2 = _createForOfIteratorHelper(coreHelpers.values(coreConstants.ExtensionTag)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var tagName = _step2.value;
        allTags[tagName] = [];
        plainTags[tagName] = [];
        markTags[tagName] = [];
        nodeTags[tagName] = [];
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    this.allTags = allTags;
    this.plainTags = plainTags;
    this.markTags = markTags;
    this.nodeTags = nodeTags;
  }
  /**
   * Update the tags object for each extension.
   */


  updateTagForExtension(extension) {
    var _extension$tags, _extension$createTags, _extension$createTags2, _extension$options$ex, _this$store$managerSe, _this$store$managerSe2;

    var allTags = new Set([// TODO remove `extension.tags` once all tags have been moved over to `createTags`
    ...((_extension$tags = extension.tags) !== null && _extension$tags !== void 0 ? _extension$tags : []), ...((_extension$createTags = (_extension$createTags2 = extension.createTags) === null || _extension$createTags2 === void 0 ? void 0 : _extension$createTags2.call(extension)) !== null && _extension$createTags !== void 0 ? _extension$createTags : []), ...((_extension$options$ex = extension.options.extraTags) !== null && _extension$options$ex !== void 0 ? _extension$options$ex : []), ...((_this$store$managerSe = (_this$store$managerSe2 = this.store.managerSettings.extraTags) === null || _this$store$managerSe2 === void 0 ? void 0 : _this$store$managerSe2[extension.name]) !== null && _this$store$managerSe !== void 0 ? _this$store$managerSe : [])]);

    var _iterator3 = _createForOfIteratorHelper(allTags),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var tag = _step3.value;
        !isExtensionTag(tag) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
          code: coreConstants.ErrorConstant.EXTENSION,
          message: "The tag provided by the extension: ".concat(extension.constructorName, " is not supported by the editor. To add custom tags you can use the 'mutateTag' method.")
        }) : coreHelpers.invariant(false) : void 0; // Add tags to the combined tags stored here.

        this.allTags[tag].push(extension.name);

        if (isPlainExtension(extension)) {
          this.plainTags[tag].push(extension.name);
        }

        if (isMarkExtension(extension)) {
          this.markTags[tag].push(extension.name);
        }

        if (isNodeExtension(extension)) {
          this.nodeTags[tag].push(extension.name);
        }
      } // All tags available.

    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    extension.tags = [...allTags];
  }

}) || _class$1);
/**
 * Check if the provided string is an extension tag.
 */

function isExtensionTag(value) {
  return coreHelpers.includes(coreHelpers.values(coreConstants.ExtensionTag), value);
}
/**
 * The shape of the tag data stored by the extension manager.
 *
 * This data can be used by other extensions to dynamically determine which
 * nodes should affected by commands / plugins / keys etc...
 */

var ActionType;

(function (ActionType) {
  ActionType[ActionType["ADD_PLACEHOLDER"] = 0] = "ADD_PLACEHOLDER";
  ActionType[ActionType["REMOVE_PLACEHOLDER"] = 1] = "REMOVE_PLACEHOLDER";
})(ActionType || (ActionType = {}));

var key = new state.PluginKey('remirroFilePlaceholderPlugin');
function createUploadPlaceholderPlugin() {
  return new state.Plugin({
    key: key,
    state: {
      init() {
        return {
          set: view.DecorationSet.empty,
          payloads: new Map()
        };
      },

      apply(tr, _ref) {
        var set = _ref.set,
            payloads = _ref.payloads;
        // Adjust decoration positions to changes made by the transaction
        set = set.map(tr.mapping, tr.doc); // See if the transaction adds or removes any placeholders

        var action = tr.getMeta(this);

        if (action) {
          if (action.type === ActionType.ADD_PLACEHOLDER) {
            var widget = document.createElement('placeholder');
            var deco = view.Decoration.widget(action.pos, widget, {
              id: action.id
            });
            set = set.add(tr.doc, [deco]);
            payloads.set(action.id, action.payload);
          } else if (action.type === ActionType.REMOVE_PLACEHOLDER) {
            set = set.remove(set.find(undefined, undefined, spec => spec.id === action.id));
            payloads.delete(action.id);
          }
        }

        return {
          set,
          payloads
        };
      }

    },
    props: {
      decorations(state) {
        return this.getState(state).set;
      }

    }
  });
}
/**
 * Try to find the positon of the placeholder in the document based on the
 * upload placeholder id
 *
 * @remark
 *
 * This function will first try to find the position based on the decoration set.
 * However, in some cases (e.g. `ReplaceStep`) the decoration will not be
 * available. In that case, it will then try to find every node in the document
 * recursively, which is much slower than the decoration set way in a large
 * document.
 */

function findUploadPlaceholderPos(state, id) {
  var _key$getState;

  var set = (_key$getState = key.getState(state)) === null || _key$getState === void 0 ? void 0 : _key$getState.set;

  if (set) {
    var _decos$;

    var decos = set.find(undefined, undefined, spec => spec.id === id);
    var pos = decos === null || decos === void 0 ? void 0 : (_decos$ = decos[0]) === null || _decos$ === void 0 ? void 0 : _decos$.from;

    if (pos !== undefined) {
      return pos;
    }
  }

  var foundPos;
  state.doc.descendants((node, pos) => {
    if (node.attrs.id === id) {
      foundPos = pos;
    }

    return foundPos === undefined; // return false to stop the descent
  });
  return foundPos;
}
function findUploadPlaceholderPayload(state, id) {
  var _key$getState2;

  var payloads = (_key$getState2 = key.getState(state)) === null || _key$getState2 === void 0 ? void 0 : _key$getState2.payloads;

  if (!payloads) {
    return undefined;
  }

  return payloads.get(id);
}
/**
 * Determine if there are active file uploads in the given state
 *
 * @remarks
 * This utility is useful to warn users there are still active uploads before
 * exiting or saving a document.
 *
 * @see https://remirror.vercel.app/?path=/story/extensions-file--with-upload-incomplete-warning
 *
 * @param state - the editor state
 */

function hasUploadingFile(state) {
  var _key$getState$payload, _key$getState3, _key$getState3$payloa;

  var placeholderCount = (_key$getState$payload = (_key$getState3 = key.getState(state)) === null || _key$getState3 === void 0 ? void 0 : (_key$getState3$payloa = _key$getState3.payloads) === null || _key$getState3$payloa === void 0 ? void 0 : _key$getState3$payloa.size) !== null && _key$getState$payload !== void 0 ? _key$getState$payload : 0;
  return placeholderCount > 0;
}
function setUploadPlaceholderAction(tr, action) {
  return tr.setMeta(key, action);
}

function createUploadContext() {
  var values = {};
  var emitter = nanoevents.createNanoEvents();

  var get = key => {
    return values[key];
  };

  var set = (key, value) => {
    values[key] = value;
    emitter.emit('set', values);
  };

  var addListener = listener => {
    return emitter.on('set', listener);
  };

  return {
    set,
    get,
    addListener
  };
}

/**
 * Any `ProsemirrorNode` can use the `uploadFile` function in this file as long
 * as its attributes implement this interface.
 */

/**
 * Insert a file into the editor and upload it.
 */
function uploadFile(_ref) {
  var file = _ref.file,
      pos = _ref.pos,
      view = _ref.view,
      fileType = _ref.fileType,
      uploadHandler = _ref.uploadHandler;
  var id = coreHelpers.uniqueId('file-placeholder-');
  var context = createUploadContext();
  var fileUploader = createFilePlaceholder({
    id,
    context,
    file,
    pos,
    view,
    fileType,
    uploadHandler
  });
  fileUploader === null || fileUploader === void 0 ? void 0 : fileUploader.upload(context).then(attrs => onFileLoaded({
    id,
    fileType,
    view,
    attrs
  })).catch(error => onFileLoaded({
    id,
    fileType,
    view,
    attrs: {
      error: error.message
    }
  }));
}
/**
 * Try to find a point where a node of the given type can be inserted
 * near `pos`, by searching up the node hierarchy when `pos` itself
 * isn't a valid place. Return null if no position was found.
 *
 * This function is similar to `insertPoint` from `prosemirror-transform`,
 * but it will also search for a valid position even if the `pos` is in the
 * middle of a node.
 */

function insertFilePoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);

  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) {
    return pos;
  }

  if ($pos.parentOffset === 0) {
    for (var d = $pos.depth - 1; d >= 0; d--) {
      var index = $pos.index(d);

      if ($pos.node(d).canReplaceWith(index, index, nodeType)) {
        return $pos.before(d + 1);
      }

      if (index > 0) {
        return null;
      }
    }
  }

  for (var _d = $pos.depth - 1; _d >= 0; _d--) {
    var _index = $pos.indexAfter(_d);

    if ($pos.node(_d).canReplaceWith(_index, _index, nodeType)) {
      return $pos.after(_d + 1);
    }

    if (_index < $pos.node(_d).childCount) {
      return null;
    }
  }

  return null;
}

function createFilePlaceholder(_ref2) {
  var id = _ref2.id,
      context = _ref2.context,
      file = _ref2.file,
      pos = _ref2.pos,
      view = _ref2.view,
      fileType = _ref2.fileType,
      uploadHandler = _ref2.uploadHandler;
  var tr = view.state.tr;
  var insertPos = insertFilePoint(tr.doc, coreHelpers.isNumber(pos) ? pos : tr.selection.from, fileType);

  if (!coreHelpers.isNumber(insertPos)) {
    // failed to find a postition to insert the file node
    return;
  } // create a fileUploader, which will read and/or upload the file later


  var fileUploader = uploadHandler(); // insert the file node

  var attrs = _objectSpread(_objectSpread({}, fileUploader.insert(file)), {}, {
    id
  });

  tr.insert(insertPos, fileType.createChecked(attrs)); // insert the placeholder decoration

  var payload = {
    context,
    fileUploader
  };
  setUploadPlaceholderAction(tr, {
    type: ActionType.ADD_PLACEHOLDER,
    id,
    pos: insertPos,
    payload
  });
  view.dispatch(tr);
  return fileUploader;
}

function onFileLoaded(_ref3) {
  var id = _ref3.id,
      attrs = _ref3.attrs,
      fileType = _ref3.fileType,
      view = _ref3.view;
  var placeholderPos = findUploadPlaceholderPos(view.state, id); // unexpected

  if (placeholderPos == null) {
    return;
  }

  var $pos = view.state.doc.resolve(placeholderPos);
  var fileNode = $pos.nodeAfter; // if the file node around the placeholder has been deleted, then delete
  // the placeholder and drop the uploaded file.

  if (!fileNode || fileNode.type !== fileType || fileNode.attrs.id !== id) {
    var _tr = view.state.tr;
    setUploadPlaceholderAction(_tr, {
      type: ActionType.REMOVE_PLACEHOLDER,
      id
    });
    view.dispatch(_tr);
    return;
  } // Update the file node at the placeholder's position, and remove
  // the placeholder.


  var tr = view.state.tr;
  setUploadPlaceholderAction(tr, {
    type: ActionType.REMOVE_PLACEHOLDER,
    id
  });

  var fileAttrs = _objectSpread(_objectSpread(_objectSpread({}, fileNode.attrs), attrs), {}, {
    id: null
  }); // We need to update the node to trigger the render function, which will accept
  // differnt properties during and after the upload progress.


  tr.setNodeMarkup(placeholderPos, undefined, fileAttrs);
  view.dispatch(tr);
}

/**
 * `UploadExtension` handle the file upload process.
 */
class UploadExtension extends PlainExtension {
  get name() {
    return 'upload';
  }
  /**
   * Create the extension plugin for inserting decorations into the editor.
   */


  createExternalPlugins() {
    return [createUploadPlaceholderPlugin()];
  }

}

/**
 * Provides all the builtin extensions to the editor.
 *
 * @remarks
 *
 * This is used automatically and (at the time of writing) can't be removed from
 * the editor. If you feel that there's a compelling reason to override these
 * extensions feel free to create a [discussion
 * here](https://github.com/remirror/remirror/discussions/category_choices) and
 * it can be addressed.
 *
 * @category Builtin Extension
 *
 * The order of these extension are important.
 *
 * - [[`TagsExtension`]] is places first because it provides tagging which is
 *   used by the schema extension.
 * - [[`SchemeExtension`]] goes next because it's super important to the editor
 *   functionality and needs to run before everything else which might depend
 *   on it.
 */
function builtinPreset() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var defaultOptions = {
    exitMarksOnArrowPress: KeymapExtension.defaultOptions.exitMarksOnArrowPress,
    excludeBaseKeymap: KeymapExtension.defaultOptions.excludeBaseKeymap,
    selectParentNodeOnEscape: KeymapExtension.defaultOptions.selectParentNodeOnEscape,
    undoInputRuleOnBackspace: KeymapExtension.defaultOptions.undoInputRuleOnBackspace,
    persistentSelectionClass: DecorationsExtension.defaultOptions.persistentSelectionClass
  };
  options = _objectSpread(_objectSpread({}, defaultOptions), options);
  var keymapOptions = coreHelpers.pick(options, ['excludeBaseKeymap', 'selectParentNodeOnEscape', 'undoInputRuleOnBackspace']);
  var decorationsOptions = coreHelpers.pick(options, ['persistentSelectionClass']);
  return [// The order of these extension is important. First come first served.
  new TagsExtension(), new SchemaExtension(), new AttributesExtension(), new PluginsExtension(), new InputRulesExtension(), new PasteRulesExtension(), new NodeViewsExtension(), new SuggestExtension(), new CommandsExtension(), new HelpersExtension(), new KeymapExtension(keymapOptions), new DocChangedExtension(), new UploadExtension(), new DecorationsExtension(decorationsOptions)];
}

var _dec, _class;
var MetaExtension = (_dec = extension({
  defaultOptions: {
    capture: process.env.NODE_ENV === 'development'
  },
  staticKeys: ['capture'],
  defaultPriority: coreConstants.ExtensionPriority.Highest
}), _dec(_class = class MetaExtension extends PlainExtension {
  get name() {
    return 'meta';
  }

  onCreate() {
    this.store.setStoreKey('getCommandMeta', this.getCommandMeta.bind(this));

    if (!this.options.capture) {
      return;
    }

    var _iterator = _createForOfIteratorHelper(this.store.extensions),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _extension = _step.value;
        this.captureCommands(_extension);
        this.captureKeybindings(_extension);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * This is here to provide a
   */


  createPlugin() {
    return {};
  }
  /**
   * Intercept command names and attributes.
   */


  captureCommands(extension) {
    var _extension$decoratedC,
        _this = this;

    var decoratedCommands = (_extension$decoratedC = extension.decoratedCommands) !== null && _extension$decoratedC !== void 0 ? _extension$decoratedC : {};
    var createCommands = extension.createCommands;

    var _loop = function _loop() {
      var name = _Object$keys[_i];
      var command = extension[name];

      extension[name] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return props => {
          var value = command(...args)(props);

          if (props.dispatch && value) {
            var _props$view;

            _this.setCommandMeta(props.tr, {
              type: 'command',
              chain: props.dispatch !== ((_props$view = props.view) === null || _props$view === void 0 ? void 0 : _props$view.dispatch),
              name: name,
              extension: extension.name,
              decorated: true
            });
          }

          return value;
        };
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(decoratedCommands); _i < _Object$keys.length; _i++) {
      _loop();
    }

    if (createCommands) {
      extension.createCommands = () => {
        var commandsObject = createCommands();

        var _loop2 = function _loop2() {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              name = _Object$entries$_i[0],
              command = _Object$entries$_i[1];

          commandsObject[name] = function () {
            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            return props => {
              var value = command(...args)(props);

              if (props.dispatch && value) {
                var _props$view2;

                _this.setCommandMeta(props.tr, {
                  type: 'command',
                  chain: props.dispatch !== ((_props$view2 = props.view) === null || _props$view2 === void 0 ? void 0 : _props$view2.dispatch),
                  name: name,
                  extension: extension.name,
                  decorated: false
                });
              }

              return value;
            };
          };
        };

        for (var _i2 = 0, _Object$entries = Object.entries(commandsObject); _i2 < _Object$entries.length; _i2++) {
          _loop2();
        }

        return commandsObject;
      };
    }
  }
  /**
   * Intercept command name and attributes.
   */


  captureKeybindings(_) {}
  /**
   * Get the command metadata.
   */


  getCommandMeta(tr) {
    var _tr$getMeta;

    return (_tr$getMeta = tr.getMeta(this.pluginKey)) !== null && _tr$getMeta !== void 0 ? _tr$getMeta : [];
  }

  setCommandMeta(tr, update) {
    var meta = this.getCommandMeta(tr);
    tr.setMeta(this.pluginKey, [...meta, update]);
  }

}) || _class);

function _checkPrivateRedeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

function _classPrivateFieldInitSpec(obj, privateMap, value) {
  _checkPrivateRedeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

var _uid = /*#__PURE__*/new WeakMap();

var _getProps = /*#__PURE__*/new WeakMap();

var _previousState = /*#__PURE__*/new WeakMap();

var _firstRender = /*#__PURE__*/new WeakMap();

var _events$1 = /*#__PURE__*/new WeakMap();

var _addHandler = /*#__PURE__*/new WeakMap();

var _initialEditorState = /*#__PURE__*/new WeakMap();

/**
 * This is the `Framework` class which is used to create an abstract class for
 * implementing `Remirror` into the framework of your choice.
 *
 * The best way to learn how to use it is to take a look at the [[`DomFramework`]]
 * and [[`ReactFramework`]] implementations.
 *
 * @remarks
 *
 * There are two methods and one getter property which must be implemented for this
 */
class Framework {
  /**
   * The schema available via the provided extensions.
   *
   * @internal
   */

  /**
   * A unique ID for the editor which can also be used as a key in frameworks
   * that need it.
   */

  /**
   * A method which enables retrieving the props from the editor.
   */

  /**
   * The private reference to the previous state.
   */

  /**
   * True when this is the first render.
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */

  /**
   * The event listener which allows consumers to subscribe to the different
   * events taking place in the editor. Events currently supported are:
   *
   * - `destroy`
   * - `focus`
   * - `blur`
   * - `updated`
   */
  get addHandler() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _addHandler)) !== null && _classPrivateFieldGet2 !== void 0 ? _classPrivateFieldGet2 : _classPrivateFieldSet(this, _addHandler, _classPrivateFieldGet(this, _events$1).on.bind(_classPrivateFieldGet(this, _events$1)));
  }
  /**
   * The handler which is bound to the events listener object.
   */


  /**
   * The updatable view props.
   */
  get updatableViewProps() {
    return {
      attributes: () => this.getAttributes(),
      editable: () => {
        var _this$props$editable;

        return (_this$props$editable = this.props.editable) !== null && _this$props$editable !== void 0 ? _this$props$editable : true;
      }
    };
  }
  /**
   * True when this is the first render of the editor.
   */


  get firstRender() {
    return _classPrivateFieldGet(this, _firstRender);
  }
  /**
   * Store the name of the framework.
   */


  /**
   * The props passed in when creating or updating the `Framework` instance.
   */
  get props() {
    return _classPrivateFieldGet(this, _getProps).call(this);
  }
  /**
   * Returns the previous editor state. On the first render it defaults to
   * returning the current state. For the first render the previous state and
   * current state will always be equal.
   */


  get previousState() {
    var _ref, _this$previousStateOv;

    return (_ref = (_this$previousStateOv = this.previousStateOverride) !== null && _this$previousStateOv !== void 0 ? _this$previousStateOv : _classPrivateFieldGet(this, _previousState)) !== null && _ref !== void 0 ? _ref : this.initialEditorState;
  }
  /**
   * The instance of the [[`RemirrorManager`]].
   */


  get manager() {
    return this.props.manager;
  }
  /**
   * The ProseMirror [[`EditorView`]].
   */


  get view() {
    return this.manager.view;
  }
  /**
   * A unique id for the editor. Can be used to differentiate between editors.
   *
   * Please note that this ID is only locally unique, it should not be used as a
   * database key.
   */


  get uid() {
    return _classPrivateFieldGet(this, _uid);
  }

  /**
   * The initial editor state from when the editor was first created.
   */
  get initialEditorState() {
    return _classPrivateFieldGet(this, _initialEditorState);
  }

  constructor(options) {
    var _this = this;

    _classPrivateFieldInitSpec(this, _uid, {
      writable: true,
      value: coreHelpers.uniqueId()
    });

    _classPrivateFieldInitSpec(this, _getProps, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _previousState, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstRender, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _events$1, {
      writable: true,
      value: nanoevents.createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _addHandler, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _initialEditorState, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _this$view$state;

      return (_this$view$state = this.view.state) !== null && _this$view$state !== void 0 ? _this$view$state : this.initialEditorState;
    });

    _defineProperty(this, "getPreviousState", () => this.previousState);

    _defineProperty(this, "dispatchTransaction", tr => {
      var _this$props$onDispatc, _this$props$onDispatc2, _this$props;

      // This should never happen, but it may have slipped through in the certain places.
      !!this.manager.destroyed ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
        message: 'A transaction was dispatched to a manager that has already been destroyed. Please check your set up, or open an issue.'
      }) : coreHelpers.invariant(false) : void 0;
      tr = (_this$props$onDispatc = (_this$props$onDispatc2 = (_this$props = this.props).onDispatchTransaction) === null || _this$props$onDispatc2 === void 0 ? void 0 : _this$props$onDispatc2.call(_this$props, tr, this.getState())) !== null && _this$props$onDispatc !== void 0 ? _this$props$onDispatc : tr;
      var previousState = this.getState();

      var _previousState$applyT = previousState.applyTransaction(tr),
          state = _previousState$applyT.state,
          transactions = _previousState$applyT.transactions;

      _classPrivateFieldSet(this, _previousState, previousState); // Use the abstract method to update the state.


      this.updateState({
        state,
        tr,
        transactions
      }); // Update the view props when an update is requested

      var forcedUpdates = this.manager.store.getForcedUpdates(tr);

      if (!coreHelpers.isEmptyArray(forcedUpdates)) {
        this.updateViewProps(...forcedUpdates);
      }
    });

    _defineProperty(this, "onChange", function () {
      var _this$props$onChange, _this$props2;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : coreHelpers.object();

      var onChangeProps = _this.eventListenerProps(props);

      if (_classPrivateFieldGet(_this, _firstRender)) {
        _classPrivateFieldSet(_this, _firstRender, false);
      }

      (_this$props$onChange = (_this$props2 = _this.props).onChange) === null || _this$props$onChange === void 0 ? void 0 : _this$props$onChange.call(_this$props2, onChangeProps);
    });

    _defineProperty(this, "onBlur", event => {
      var _this$props$onBlur, _this$props3;

      var props = this.eventListenerProps();
      (_this$props$onBlur = (_this$props3 = this.props).onBlur) === null || _this$props$onBlur === void 0 ? void 0 : _this$props$onBlur.call(_this$props3, props, event);

      _classPrivateFieldGet(this, _events$1).emit('blur', props, event);
    });

    _defineProperty(this, "onFocus", event => {
      var _this$props$onFocus, _this$props4;

      var props = this.eventListenerProps();
      (_this$props$onFocus = (_this$props4 = this.props).onFocus) === null || _this$props$onFocus === void 0 ? void 0 : _this$props$onFocus.call(_this$props4, props, event);

      _classPrivateFieldGet(this, _events$1).emit('focus', props, event);
    });

    _defineProperty(this, "setContent", function (content) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$triggerChange = _ref2.triggerChange,
          triggerChange = _ref2$triggerChange === void 0 ? false : _ref2$triggerChange;

      var _this$manager$createS = _this.manager.createState({
        content
      }),
          doc = _this$manager$createS.doc;

      var previousState = _this.getState();

      var _this$getState$applyT = _this.getState().applyTransaction(previousState.tr.replaceRangeWith(0, previousState.doc.nodeSize - 2, doc)),
          state = _this$getState$applyT.state;

      if (triggerChange) {
        return _this.updateState({
          state,
          triggerChange
        });
      }

      _this.view.updateState(state);
    });

    _defineProperty(this, "clearContent", function () {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref3$triggerChange = _ref3.triggerChange,
          triggerChange = _ref3$triggerChange === void 0 ? false : _ref3$triggerChange;

      _this.setContent(_this.manager.createEmptyDoc(), {
        triggerChange
      });
    });

    _defineProperty(this, "createStateFromContent", (content, selection) => {
      return this.manager.createState({
        content,
        selection
      });
    });

    _defineProperty(this, "focus", position => {
      this.manager.store.commands.focus(position);
    });

    _defineProperty(this, "blur", position => {
      this.manager.store.commands.blur(position);
    });

    var getProps = options.getProps,
        initialEditorState = options.initialEditorState,
        element = options.element;

    _classPrivateFieldSet(this, _getProps, getProps);

    _classPrivateFieldSet(this, _initialEditorState, initialEditorState); // Attach the framework instance to the manager. The manager will set up the
    // update listener and manage updates to the instance of the framework
    // automatically.


    this.manager.attachFramework(this, this.updateListener.bind(this));

    if (this.manager.view) {
      return;
    } // Create the ProsemirrorView and initialize our editor manager with it.


    var view = this.createView(initialEditorState, element);
    this.manager.addView(view);
  }
  /**
   * Setup the manager event listeners which are disposed of when the manager is
   * destroyed.
   */


  updateListener(props) {
    var state = props.state,
        tr = props.tr;
    return _classPrivateFieldGet(this, _events$1).emit('updated', this.eventListenerProps({
      state,
      tr
    }));
  }
  /**
   * Update the constructor props passed in. Useful for frameworks like react
   * where props are constantly changing and when using hooks function closures
   * can become stale.
   *
   * You can call the update method with the new `props` to update the internal
   * state of this instance.
   */


  update(options) {
    var getProps = options.getProps;

    _classPrivateFieldSet(this, _getProps, getProps);

    return this;
  }
  /**
   * Retrieve the editor state.
   */


  /**
   * Update the view props.
   */
  updateViewProps() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    var props = coreHelpers.pick(this.updatableViewProps, keys);
    this.view.setProps(_objectSpread(_objectSpread({}, this.view.props), props));
  }
  /**
   * This sets the attributes for the ProseMirror Dom node.
   */


  getAttributes(ssr) {
    var _this$manager$store;

    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        autoFocus = _this$props5.autoFocus,
        _this$props5$classNam = _this$props5.classNames,
        classNames = _this$props5$classNam === void 0 ? [] : _this$props5$classNam,
        label = _this$props5.label,
        editable = _this$props5.editable;
    var managerAttributes = (_this$manager$store = this.manager.store) === null || _this$manager$store === void 0 ? void 0 : _this$manager$store.attributes; // The attributes which were passed in as props.

    var propAttributes = coreHelpers.isFunction(attributes) ? attributes(this.eventListenerProps()) : attributes; // Whether or not the editor is focused.

    var focus = {}; // In Chrome 84 when autofocus is set to any value including `"false"` it
    // will actually trigger the autofocus. This check makes sure there is no
    // `autofocus` attribute attached unless `autoFocus` is expressly a truthy
    // value.

    if (autoFocus || coreHelpers.isNumber(autoFocus)) {
      focus = ssr ? {
        autoFocus: true
      } : {
        autofocus: 'true'
      };
    }

    var uniqueClasses = coreHelpers.uniqueArray(coreHelpers.cx(ssr && 'Prosemirror', 'remirror-editor', managerAttributes === null || managerAttributes === void 0 ? void 0 : managerAttributes.class, ...classNames).split(' ')).join(' ');

    var defaultAttributes = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
      role: 'textbox'
    }, focus), {}, {
      'aria-multiline': 'true'
    }, !(editable !== null && editable !== void 0 ? editable : true) ? {
      'aria-readonly': 'true'
    } : {}), {}, {
      'aria-label': label !== null && label !== void 0 ? label : ''
    }, managerAttributes), {}, {
      class: uniqueClasses
    });

    return coreHelpers.omitUndefined(_objectSpread(_objectSpread({}, defaultAttributes), propAttributes));
  }
  /**
   * Part of the Prosemirror API and is called whenever there is state change in
   * the editor.
   *
   * @internalremarks
   * How does it work when transactions are dispatched one after the other.
   */


  /**
   * Adds `onBlur` and `onFocus` listeners.
   *
   * When extending this class make sure to call this method once
   * `ProsemirrorView` has been added to the dom.
   */
  addFocusListeners() {
    this.view.dom.addEventListener('blur', this.onBlur);
    this.view.dom.addEventListener('focus', this.onFocus);
  }
  /**
   * Remove `onBlur` and `onFocus` listeners.
   *
   * When extending this class in your framework, make sure to call this just
   * before the view is destroyed.
   */


  removeFocusListeners() {
    this.view.dom.removeEventListener('blur', this.onBlur);
    this.view.dom.removeEventListener('focus', this.onFocus);
  }
  /**
   * Called when the component unmounts and is responsible for cleanup.
   *
   * @remarks
   *
   * - Removes listeners for the editor `blur` and `focus` events
   */


  destroy() {
    // Let it clear that this instance has been destroyed.
    _classPrivateFieldGet(this, _events$1).emit('destroy');

    if (this.view) {
      // Remove the focus and blur listeners.
      this.removeFocusListeners();
    }
  }
  /**
   * Use this method in the `onUpdate` event to run all change handlers.
   */


  /**
   * Creates the props passed into all event listener handlers. e.g.
   * `onChange`
   */
  eventListenerProps() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : coreHelpers.object();
    var state = props.state,
        tr = props.tr,
        transactions = props.transactions;
    return {
      tr,
      transactions,
      internalUpdate: !tr,
      view: this.view,
      firstRender: _classPrivateFieldGet(this, _firstRender),
      state: state !== null && state !== void 0 ? state : this.getState(),
      createStateFromContent: this.createStateFromContent,
      previousState: this.previousState,
      helpers: this.manager.store.helpers
    };
  }

  /**
   * Methods and properties which are made available to all consumers of the
   * `Framework` class.
   */
  get baseOutput() {
    return _objectSpread(_objectSpread({
      manager: this.manager
    }, this.manager.store), {}, {
      addHandler: this.addHandler,
      // Commands
      focus: this.focus,
      blur: this.blur,
      // Properties
      uid: _classPrivateFieldGet(this, _uid),
      view: this.view,
      // Getter Methods
      getState: this.getState,
      getPreviousState: this.getPreviousState,
      getExtension: this.manager.getExtension.bind(this.manager),
      // Setter Methods
      clearContent: this.clearContent,
      setContent: this.setContent
    });
  }
  /**
   * Every framework implementation must provide it's own custom output.
   */


}

/**
 * Transforms the unsorted array of presets and extension into presets and
 * sorted extensions. Handles uniqueness of extensions and automatically throws
 * an error when required extensions are missing.
 *
 * @internalremarks Currently matching by constructor - what if different
 * versions exist in the same app
 *
 * @param initialExtensions - the extensions to be transformed. This includes
 * the extension that are parents to other extensions.
 *
 * @returns the list of extension instances sorted by priority
 */
function transformExtensions(initialExtensions, settings) {
  // This is the holder for the sorted and cleaned extensions returned by this
  // function.
  var extensions = [];
  var extensionMap = new WeakMap(); // All the extensions which provide child extensions.

  var parentExtensions = []; // Used to track duplicates and the extension holders they were added by.

  var duplicateMap = new WeakMap(); // The unsorted, de-duped, unrefined extensions.

  var gatheredExtensions = []; // The mutable objects and the manager settings which are used to gather all
  // the deeply nested extensions.

  var gatherRawExtensionConfig = {
    duplicateMap,
    parentExtensions,
    gatheredExtensions,
    settings
  };

  var _iterator = _createForOfIteratorHelper(initialExtensions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _extension = _step.value;
      gatherRawExtensions(gatherRawExtensionConfig, {
        extension: _extension
      });
    } // Sort the extensions.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  gatheredExtensions = coreHelpers.sort(gatheredExtensions, (a, z) => z.priority - a.priority); // Keep track of added constructors for uniqueness.

  var found = new WeakSet();
  var names = new Set(); // Remove extension duplicates and update the parent extension with the
  // highest priority identical extension.

  var _iterator2 = _createForOfIteratorHelper(gatheredExtensions),
      _step2;

  try {
    var _loop = function _loop() {
      var extension = _step2.value;
      var key = extension.constructor;
      var name = extension.name;
      var duplicates = duplicateMap.get(key);
      !duplicates ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        message: "No entries were found for the ExtensionConstructor ".concat(extension.name),
        code: coreConstants.ErrorConstant.INTERNAL
      }) : coreHelpers.invariant(false) : void 0;

      if (found.has(key) || names.has(name)) {
        return "continue";
      }

      found.add(key);
      names.add(name);
      extensions.push(extension);
      extensionMap.set(key, extension); // Replace the extensions for all presets that referenced this constructor.

      duplicates.forEach(parent => parent === null || parent === void 0 ? void 0 : parent.replaceChildExtension(key, extension));
    };

    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var missing = []; // Throw if any required extensions are missing.

  for (var _i = 0, _extensions = extensions; _i < _extensions.length; _i++) {
    var extension = _extensions[_i];
    findMissingExtensions({
      extension,
      found,
      missing
    });
  }

  !coreHelpers.isEmptyArray(missing) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.MISSING_REQUIRED_EXTENSION,
    message: missing.map(_ref => {
      var Constructor = _ref.Constructor,
          extension = _ref.extension;
      return "The extension '".concat(extension.name, "' requires '").concat(Constructor.name, " in order to run correctly.");
    }).join('\n')
  }) : coreHelpers.invariant(false) : void 0;
  return {
    extensions,
    extensionMap
  };
}

/**
 * Dive into the current extension and gather all child extensions including
 * those which are deeply nested.
 *
 * It also automatically handles circular dependencies. And logs a warning when
 * one is encountered.
 *
 * @param config - the configuration and mutable objects which are updated by
 * this function.
 * @param props - the extension, gathered names and parent extension.
 */
function gatherRawExtensions(config, props) {
  var _settings$priority;

  var gatheredExtensions = config.gatheredExtensions,
      duplicateMap = config.duplicateMap,
      parentExtensions = config.parentExtensions,
      settings = config.settings;
  var extension = props.extension,
      parentExtension = props.parentExtension; // Get the list of parent names of the current extension. This is used to
  // track circular dependencies.

  var _props$names = props.names,
      names = _props$names === void 0 ? [] : _props$names;
  !isExtension(extension) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
    code: coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION,
    message: "An invalid extension: ".concat(extension, " was provided to the [[`RemirrorManager`]].")
  }) : coreHelpers.invariant(false) : void 0; // The children provided by this extension.

  var childExtensions = extension.extensions; // Override the priority if the user has done so in the settings passed to the
  // [[`RemirrorManager`]].

  extension.setPriority((_settings$priority = settings.priority) === null || _settings$priority === void 0 ? void 0 : _settings$priority[extension.name]); // Update the gathered extension list in this block

  gatheredExtensions.push(extension); // Keep track of the extensions which have been added multiple times by
  // separate extension parents. Later on, the highest priority extension will
  // be added to each parent instead of the one that they may have been
  // configured with.

  updateExtensionDuplicates({
    duplicateMap,
    extension,
    parentExtension
  }); // Check if there are any children extensions to be added an if not move onto
  // the next provided extension.

  if (childExtensions.length === 0) {
    return;
  }

  if (names.includes(extension.name)) {
    process.env.NODE_ENV !== "production" ? warning__default["default"](false, "Circular dependency encountered when loading extensions: ".concat(names.join(' > '), " > ").concat(extension.name)) : void 0;
    return;
  }

  names = [...names, extension.name];
  parentExtensions.push(extension);

  var _iterator3 = _createForOfIteratorHelper(childExtensions),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var child = _step3.value;
      // Recursively gather all the children extension from the current extension
      // level.
      gatherRawExtensions(config, {
        names,
        extension: child,
        parentExtension: extension
      });
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
}

/**
 * Populate missing Constructors.
 *
 * If any missing extensions are identified then it is the responsibility of the
 * calling method to deal with the error. Currently the action is to `throw` an
 * error.
 */
function findMissingExtensions(props) {
  var _extension$requiredEx;

  var extension = props.extension,
      found = props.found,
      missing = props.missing;

  if (!extension.requiredExtensions) {
    return;
  }

  var _iterator4 = _createForOfIteratorHelper((_extension$requiredEx = extension.requiredExtensions) !== null && _extension$requiredEx !== void 0 ? _extension$requiredEx : []),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var Constructor = _step4.value;

      if (found.has(Constructor)) {
        continue;
      }

      missing.push({
        Constructor: Constructor,
        extension
      });
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}

/**
 * Adds the values to the duplicate map which identifies each unique extension
 * in the manager and tracks the presets responsible for adding them. This is
 * used to make sure that only one instance of each extension is shared amongst
 * the presets which require it.
 *
 * At the moment, the highest priority extension is the one that is to all
 * presets which require it. This is done by checking the `duplicateMap` for
 * each extension, and replacing the instance of the required extension within
 * the preset with the highest priority instance.
 */
function updateExtensionDuplicates(props) {
  var duplicateMap = props.duplicateMap,
      extension = props.extension,
      parentExtension = props.parentExtension; // The extension constructor is used as the identifier for lookups.

  var key = extension.constructor;
  var duplicate = duplicateMap.get(key);
  var parentToAdd = parentExtension ? [parentExtension] : [];
  duplicateMap.set(key, duplicate ? [...duplicate, ...parentToAdd] : parentToAdd);
}
/**
 * This is the object shape that is returned from the combined transformation.
 */


/**
 * This helper function extracts all the lifecycle methods from the provided
 * extension and adds them to the provided `handler` container.
 */
function extractLifecycleMethods(props) {
  var _extension$onCreate, _extension$onView, _extension$onStateUpd, _extension$onDestroy;

  var extension = props.extension,
      nodeNames = props.nodeNames,
      markNames = props.markNames,
      plainNames = props.plainNames,
      store = props.store,
      handlers = props.handlers; // Add the store to the extension. The store is used by extensions to access
  // all the data included in `Remirror.ExtensionStore`. I decided on this
  // pattern because passing around parameters into each call method was
  // tedious. Why not just access `this.store` within your extension to get
  // whatever you need? Also using the store allows developers to extend the
  // behaviour of their editor by adding different behaviour to the global
  // namespace [[`Remirror.ExtensionStore`]].

  extension.setStore(store); // Gather all the handlers and add them where they exist.

  var createHandler = (_extension$onCreate = extension.onCreate) === null || _extension$onCreate === void 0 ? void 0 : _extension$onCreate.bind(extension);
  var viewHandler = (_extension$onView = extension.onView) === null || _extension$onView === void 0 ? void 0 : _extension$onView.bind(extension);
  var stateUpdateHandler = (_extension$onStateUpd = extension.onStateUpdate) === null || _extension$onStateUpd === void 0 ? void 0 : _extension$onStateUpd.bind(extension);
  var destroyHandler = (_extension$onDestroy = extension.onDestroy) === null || _extension$onDestroy === void 0 ? void 0 : _extension$onDestroy.bind(extension);

  if (createHandler) {
    handlers.create.push(createHandler);
  }

  if (viewHandler) {
    handlers.view.push(viewHandler);
  }

  if (stateUpdateHandler) {
    handlers.update.push(stateUpdateHandler);
  }

  if (destroyHandler) {
    handlers.destroy.push(destroyHandler);
  } // Keep track of the names of the different types of extension held by this
  // manager. This is already in use by the [[`TagsExtension`]].


  if (isMarkExtension(extension)) {
    markNames.push(extension.name);
  } // Don't include the `doc` as a node since it is a requirement for all editors
  // and doesn't behave in the same way as other nodes.


  if (isNodeExtension(extension) && extension.name !== 'doc') {
    nodeNames.push(extension.name);
  }

  if (isPlainExtension(extension)) {
    plainNames.push(extension.name);
  }
}

/**
 * The `Manager` has multiple hook phases which are able to hook into the
 * extension manager flow and add new functionality to the editor.
 *
 * The `ExtensionEventMethod`s
 *
 * - onCreate - when the extension manager is created and after the schema is
 *   made available.
 * - onView - when the view has been received from the dom ref.
 */

/**
 * A class to manage the extensions and prosemirror interactions within the
 * editor.
 *
 * @remarks
 *
 * The RemirrorManager enables the lifecycle methods of the extensions by
 * calling each method in the distinct phases of the lifecycle.
 *
 * - `onCreate` - This happens when the manager is constructed. It calls on the
 *   extension which have an `onCreate` method and allows them to do their work.
 *
 * For the built in methods, this is when the `SchemaExtension` creates the
 * Schema and when the `TagsExtension` combines the tags for the editor
 * instance.
 *
 * ```ts
 * const manager = Manager.create(() => [
 *   new DocExtension(),
 *   new TextExtension(),
 *   new ParagraphExtension(),
 * ])
 * ```
 *
 * At this point all the `onCreate` methods have been called. Including the
 * `onCreate` for the `Schema`.
 *
 * - `onView` - This is called the framework instance connects the
 *   `RemirrorManager` to the ProseMirror EditorView.
 *
 * ```ts
 * manager.addView(new EditorView(...))
 * manager.store.commands.insertText('Hello world');.
 * ```
 *
 * - [[`onStateUpdate`]] - This is the method called every time the ProseMirror
 *   state changes. Both the extensions and the `Framework` listen to this event
 *   and can provide updates in response.
 */

var _extensionStore = /*#__PURE__*/new WeakMap();

var _stringHandlers = /*#__PURE__*/new WeakMap();

var _store = /*#__PURE__*/new WeakMap();

var _extensions = /*#__PURE__*/new WeakMap();

var _extensionMap = /*#__PURE__*/new WeakMap();

var _phase = /*#__PURE__*/new WeakMap();

var _settings = /*#__PURE__*/new WeakMap();

var _firstStateUpdate = /*#__PURE__*/new WeakMap();

var _handlers = /*#__PURE__*/new WeakMap();

var _disposers = /*#__PURE__*/new WeakMap();

var _events = /*#__PURE__*/new WeakMap();

var _framework = /*#__PURE__*/new WeakMap();

var _disposeFramework = /*#__PURE__*/new WeakMap();

class RemirrorManager {
  /**
   * Create the manager for your `Remirror` editor.
   */
  static create(extensions) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return new RemirrorManager([...coreHelpers.getLazyArray(extensions), ...builtinPreset(settings.builtin)], settings);
  }
  /**
   * Utility getter for storing the base method props which is available to
   * all extensions.
   */


  /**
   * Identifies this as a `Manager`.
   *
   * @internal
   */
  get [coreConstants.__INTERNAL_REMIRROR_IDENTIFIER_KEY__]() {
    return coreConstants.RemirrorIdentifier.Manager;
  }
  /**
   * Returns `true` if the manager has been destroyed.
   */


  get destroyed() {
    return _classPrivateFieldGet(this, _phase) === coreConstants.ManagerPhase.Destroy;
  }
  /**
   * `true` when the view has been added to the UI layer and the editor is
   * running.
   */


  get mounted() {
    return _classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView && _classPrivateFieldGet(this, _phase) < coreConstants.ManagerPhase.Destroy;
  }
  /**
   * Retrieve the framework output.
   *
   * This be undefined if the manager hasn't been provided to a framework yet
   * the manager.
   *
   * With synchronous frameworks this means that it should only be accessed
   * after the manager has been applied to the editor creation function.
   *
   * For frameworks like React it is only available when the manager is provided
   * to the `Remirror` component and after the very first render. This means it
   * is available within the `onRef` callback.
   *
   * ```tsx
   * import React, { useEffect } from 'react';
   * import { useRemirror, Remirror } from '@remirror/react';
   *
   * const Editor = () => {
   *   const { manager } = useRemirror();
   *
   *   const callback = () => {
   *     return manager.output; // ✅ This is fine.
   *   }
   *
   *   useEffect(() => {
   *     log(manager.output); // ✅  This is also fine.
   *   }, []);
   *
   *   log(manager.output); // ❌ This will be undefined on the first render.
   *
   *   return <Remirror manager={manager} />
   * }
   * ```
   */


  get output() {
    var _classPrivateFieldGet2;

    return (_classPrivateFieldGet2 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.frameworkOutput;
  }
  /**
   * Returns true when a framework is attached to the manager.
   *
   * This can be used to check if it is safe to call `manager.output`.
   */


  get frameworkAttached() {
    return !!_classPrivateFieldGet(this, _framework);
  }
  /**
   * The extensions stored by this manager
   */


  get extensions() {
    return _classPrivateFieldGet(this, _extensions);
  }
  /**
   * The registered string handlers provided by the extensions.
   *
   * By default this includes `html` and `plainText`
   */


  get stringHandlers() {
    return _classPrivateFieldGet(this, _stringHandlers);
  }
  /**
   * Get the extension manager store which is accessible at initialization.
   */


  get store() {
    return coreHelpers.freeze(_classPrivateFieldGet(this, _store));
  }
  /**
   * Provides access to the extension store.
   */


  get extensionStore() {
    return coreHelpers.freeze(_classPrivateFieldGet(this, _extensionStore));
  }
  /**
   * Shorthand access to the active transaction from the manager. This is the
   * shared transaction available to all commands and should be used when you
   * need to make your commands chainable.
   *
   * If working with react and setting up your editor as a controlled component
   * then this is the preferred way to run custom commands, otherwise your
   * commands will end up being non-chainable and be overwritten by anything
   * that comes after.
   */


  get tr() {
    return this.getExtension(CommandsExtension).transaction;
  }
  /**
   * Returns the stored nodes
   */


  get nodes() {
    return _classPrivateFieldGet(this, _store).nodes;
  }
  /**
   * Returns the store marks.
   */


  get marks() {
    return _classPrivateFieldGet(this, _store).marks;
  }
  /**
   * A shorthand method for retrieving the schema for this extension manager
   * from the data.
   */


  get schema() {
    return _classPrivateFieldGet(this, _store).schema;
  }
  /**
   * A shorthand getter for retrieving the tags from the extension manager.
   */


  get extensionTags() {
    return _classPrivateFieldGet(this, _store).tags;
  }
  /**
   * A shorthand way of retrieving the editor view.
   */


  get view() {
    return _classPrivateFieldGet(this, _store).view;
  }
  /**
   * Retrieve the settings used when creating the manager.
   */


  get settings() {
    return _classPrivateFieldGet(this, _settings);
  }
  /**
   * The document to use for rendering and outputting HTML.
   */


  get document() {
    var _classPrivateFieldGet3;

    return (_classPrivateFieldGet3 = _classPrivateFieldGet(this, _settings).document) !== null && _classPrivateFieldGet3 !== void 0 ? _classPrivateFieldGet3 : coreUtils.getDocument(_classPrivateFieldGet(this, _settings).forceEnvironment);
  }
  /**
   * Creates the extension manager which is used to simplify the management of
   * the prosemirror editor.
   *
   * This is set to private to encourage using `RemirrorManager.create`
   * instead of the `new` keyword.
   */


  constructor(initialExtension) {
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classPrivateFieldInitSpec(this, _extensionStore, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _stringHandlers, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _store, {
      writable: true,
      value: coreHelpers.object()
    });

    _classPrivateFieldInitSpec(this, _extensions, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _extensionMap, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _phase, {
      writable: true,
      value: coreConstants.ManagerPhase.None
    });

    _classPrivateFieldInitSpec(this, _settings, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _firstStateUpdate, {
      writable: true,
      value: true
    });

    _classPrivateFieldInitSpec(this, _handlers, {
      writable: true,
      value: {
        create: [],
        view: [],
        update: [],
        destroy: []
      }
    });

    _classPrivateFieldInitSpec(this, _disposers, {
      writable: true,
      value: []
    });

    _classPrivateFieldInitSpec(this, _events, {
      writable: true,
      value: nanoevents.createNanoEvents()
    });

    _classPrivateFieldInitSpec(this, _framework, {
      writable: true,
      value: void 0
    });

    _classPrivateFieldInitSpec(this, _disposeFramework, {
      writable: true,
      value: void 0
    });

    _defineProperty(this, "getState", () => {
      var _classPrivateFieldGet4;

      if (_classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView) {
        return this.view.state;
      }

      !_classPrivateFieldGet(this, _framework) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
        code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
        message: '`getState` can only be called after the `Framework` or the `EditorView` has been added to the manager`. Check your plugins to make sure that the decorations callback uses the state argument.'
      }) : coreHelpers.invariant(false) : void 0;
      return (_classPrivateFieldGet4 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.initialEditorState;
    });

    _defineProperty(this, "updateState", state => {
      var previousState = this.getState();
      this.view.updateState(state);
      this.onStateUpdate({
        previousState,
        state
      });
    });

    var _transformExtensions = transformExtensions(initialExtension, settings),
        extensions = _transformExtensions.extensions,
        extensionMap = _transformExtensions.extensionMap;

    _classPrivateFieldSet(this, _settings, settings);

    _classPrivateFieldSet(this, _extensions, coreHelpers.freeze(extensions));

    _classPrivateFieldSet(this, _extensionMap, extensionMap);

    _classPrivateFieldSet(this, _extensionStore, this.createExtensionStore());

    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Create);

    this.setupLifecycleHandlers();

    var _iterator = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).create),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _handler = _step.value;

        var disposer = _handler();

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  /**
   * Loops through all extensions to set up the lifecycle handlers.
   */


  setupLifecycleHandlers() {
    var store = _classPrivateFieldGet(this, _extensionStore);

    var handlers = _classPrivateFieldGet(this, _handlers);

    var nodeNames = [];
    var markNames = [];
    var plainNames = []; // The names are stored as readonly arrays - which is the reason for not
    // just saying `store.nodeNames = []`.

    store.nodeNames = nodeNames;
    store.markNames = markNames;
    store.plainNames = plainNames;

    var _iterator2 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _extension = _step2.value;
        extractLifecycleMethods({
          extension: _extension,
          nodeNames,
          markNames,
          plainNames,
          handlers,
          store
        });
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Set the string handler to use for a given name.
   *
   * This allows users to set the string handler
   */


  setStringHandler(name, handler) {
    _classPrivateFieldGet(this, _stringHandlers)[name] = handler;
  }
  /**
   * Set the manager value for the provided key. This is used by extensions to
   * add data to the manager.
   */


  setStoreKey(key, value) {
    _classPrivateFieldGet(this, _store)[key] = value;
  }
  /**
   * Get the manager value for the provided key. This is used by extensions to
   * get data from the manager.
   */


  getStoreKey(key) {
    var value = _classPrivateFieldGet(this, _store)[key];

    !!coreHelpers.isNullOrUndefined(value) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`getStoreKey` should not be called before the values are available.'
    }) : coreHelpers.invariant(false) : void 0;
    return value;
  }
  /**
   * A method to set values in the extension store which is made available to
   * extension.
   *
   * **NOTE** This method should only be used in the `onCreate` extension method
   * or it will throw an error.
   */


  setExtensionStore(key, value) {
    !(_classPrivateFieldGet(this, _phase) <= coreConstants.ManagerPhase.EditorView) ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.MANAGER_PHASE_ERROR,
      message: '`setExtensionStore` should only be called during the `onCreate` lifecycle hook. Make sure to only call it within the returned methods.'
    }) : coreHelpers.invariant(false) : void 0;
    _classPrivateFieldGet(this, _extensionStore)[key] = value;
  }
  /**
   * Create the initial store.
   */


  createExtensionStore() {
    var store = coreHelpers.object();
    var enumerable = true; // Allow current state to default to `getState` for first access.
    // This fixed an issue with #814

    var currentState;
    var previousState;
    Object.defineProperties(store, {
      extensions: {
        get: () => _classPrivateFieldGet(this, _extensions),
        enumerable
      },
      phase: {
        get: () => _classPrivateFieldGet(this, _phase),
        enumerable
      },
      view: {
        get: () => this.view,
        enumerable
      },
      managerSettings: {
        get: () => coreHelpers.freeze(_classPrivateFieldGet(this, _settings)),
        enumerable
      },
      getState: {
        value: this.getState,
        enumerable
      },
      updateState: {
        value: this.updateState,
        enumerable
      },
      isMounted: {
        value: () => this.mounted,
        enumerable
      },
      getExtension: {
        value: this.getExtension.bind(this),
        enumerable
      },
      manager: {
        get: () => this,
        enumerable
      },
      document: {
        get: () => this.document,
        enumerable
      },
      stringHandlers: {
        get: () => _classPrivateFieldGet(this, _stringHandlers),
        enumerable
      },
      currentState: {
        get: () => {
          var _currentState;

          return (_currentState = currentState) !== null && _currentState !== void 0 ? _currentState : currentState = this.getState();
        },
        set: state => {
          currentState = state;
        },
        enumerable
      },
      previousState: {
        get: () => previousState,
        set: state => {
          previousState = state;
        },
        enumerable
      }
    });
    store.getStoreKey = this.getStoreKey.bind(this);
    store.setStoreKey = this.setStoreKey.bind(this);
    store.setExtensionStore = this.setExtensionStore.bind(this);
    store.setStringHandler = this.setStringHandler.bind(this);
    return store;
  }
  /**
   * A state getter method which is passed into the params.
   */


  /**
   * Stores the editor view on the manager
   *
   * @param view - the editor view
   */
  addView(view) {
    if (_classPrivateFieldGet(this, _phase) >= coreConstants.ManagerPhase.EditorView) {
      // Do nothing since a view has already been added.
      return this;
    }

    _classPrivateFieldSet(this, _firstStateUpdate, true); // Update the lifecycle phase.


    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.EditorView); // Store the view.


    _classPrivateFieldGet(this, _store).view = view;

    var _iterator3 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).view),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var _handler2 = _step3.value;

        var disposer = _handler2(view);

        if (disposer) {
          _classPrivateFieldGet(this, _disposers).push(disposer);
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    return this;
  }
  /**
   * Attach a framework to the manager.
   */


  attachFramework(framework, updateHandler) {
    if (_classPrivateFieldGet(this, _framework) === framework) {
      // Do nothing if the instances are identical.
      return;
    }

    if (_classPrivateFieldGet(this, _framework)) {
      var _classPrivateFieldGet5;

      // Destroy the old instance.
      _classPrivateFieldGet(this, _framework).destroy(); // Remove the event listener. This should exist.


      (_classPrivateFieldGet5 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.call(this);
    } // Replace with the new instance.


    _classPrivateFieldSet(this, _framework, framework);

    _classPrivateFieldSet(this, _disposeFramework, this.addHandler('stateUpdate', updateHandler));
  }
  /* Public Methods */

  /**
   * Create an empty document for the editor based on the current schema.
   *
   * This automatically looks at the supported content for the doc and the
   * available nodes which fulfil that content in order to create a document
   * with only the minimal required content.
   *
   * This can be used in conjunction with the create state to reset the current
   * value of the editor.
   */


  createEmptyDoc() {
    var _this$schema$nodes$do;

    var doc = (_this$schema$nodes$do = this.schema.nodes.doc) === null || _this$schema$nodes$do === void 0 ? void 0 : _this$schema$nodes$do.createAndFill(); // Make sure the `doc` was created.

    !doc ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_CONTENT,
      message: "An empty node could not be created due to an invalid schema."
    }) : coreHelpers.invariant(false) : void 0;
    return doc;
  }
  /**
   * Create the editor state from content passed to this extension manager.
   */


  createState() {
    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _this$settings = this.settings,
        onError = _this$settings.onError,
        _this$settings$defaul = _this$settings.defaultSelection,
        defaultSelection = _this$settings$defaul === void 0 ? 'end' : _this$settings$defaul;
    var _props$content = props.content,
        content = _props$content === void 0 ? this.createEmptyDoc() : _props$content,
        _props$selection = props.selection,
        selection = _props$selection === void 0 ? defaultSelection : _props$selection,
        _props$stringHandler = props.stringHandler,
        stringHandler = _props$stringHandler === void 0 ? this.settings.stringHandler : _props$stringHandler;
    var _this$store = this.store,
        schema = _this$store.schema,
        plugins = _this$store.plugins;
    var doc = coreUtils.createDocumentNode({
      stringHandler: coreHelpers.isString(stringHandler) ? this.stringHandlers[stringHandler] : stringHandler,
      document: this.document,
      content,
      onError,
      schema,
      selection
    });
    return state.EditorState.create({
      schema,
      doc,
      plugins,
      selection: coreUtils.getTextSelection(selection, doc)
    });
  }
  /**
   * Add a handler to the manager.
   *
   * Currently the only event that can be listened to is the `destroy` event.
   */


  addHandler(event, cb) {
    return _classPrivateFieldGet(this, _events).on(event, cb);
  }
  /**
   * Update the state of the view and trigger the `onStateUpdate` lifecycle
   * method as well.
   */


  /**
   * This method should be called by the view layer every time the state is
   * updated.
   *
   * An example usage of this is within the collaboration extension.
   */
  onStateUpdate(props) {
    var firstUpdate = _classPrivateFieldGet(this, _firstStateUpdate);

    _classPrivateFieldGet(this, _extensionStore).currentState = props.state;
    _classPrivateFieldGet(this, _extensionStore).previousState = props.previousState;

    if (firstUpdate) {
      _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Runtime);

      _classPrivateFieldSet(this, _firstStateUpdate, false);
    }

    var propsWithUpdate = _objectSpread(_objectSpread({}, props), {}, {
      firstUpdate
    });

    var _iterator4 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).update),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var _handler3 = _step4.value;

        _handler3(propsWithUpdate);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    _classPrivateFieldGet(this, _events).emit('stateUpdate', propsWithUpdate);
  }
  /**
   * Get the extension instance matching the provided constructor from the
   * manager.
   *
   * This will throw an error if non existent.
   */


  getExtension(Constructor) {
    var extension = _classPrivateFieldGet(this, _extensionMap).get(Constructor); // Throws an error if attempting to get an extension which is not present in
    // the manager.


    !extension ? process.env.NODE_ENV !== "production" ? coreHelpers.invariant(false, {
      code: coreConstants.ErrorConstant.INVALID_MANAGER_EXTENSION,
      message: "'".concat(Constructor.name, "' doesn't exist within this manager. Make sure it is properly added before attempting to use it.")
    }) : coreHelpers.invariant(false) : void 0;
    return extension;
  }
  /**
   * Make a clone of the manager.
   *
   * @internalremarks What about the state stored in the extensions and presets,
   * does this need to be recreated as well?
   */


  clone() {
    var extensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.options));

    var manager = RemirrorManager.create(() => extensions, _classPrivateFieldGet(this, _settings));

    _classPrivateFieldGet(this, _events).emit('clone', manager);

    return manager;
  }
  /**
   * Recreate the manager with new settings and extensions
   */


  recreate() {
    var extensions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var currentExtensions = _classPrivateFieldGet(this, _extensions).map(e => e.clone(e.initialOptions));

    var manager = RemirrorManager.create(() => [...currentExtensions, ...extensions], settings);

    _classPrivateFieldGet(this, _events).emit('recreate', manager);

    return manager;
  }
  /**
   * This method should be called to destroy the manager and remove the view.
   */


  destroy() {
    var _classPrivateFieldGet6, _classPrivateFieldGet7, _this$view, _this$view$state$plug, _this$view2;

    _classPrivateFieldSet(this, _phase, coreConstants.ManagerPhase.Destroy);

    var _iterator5 = _createForOfIteratorHelper((_this$view$state$plug = (_this$view2 = this.view) === null || _this$view2 === void 0 ? void 0 : _this$view2.state.plugins) !== null && _this$view$state$plug !== void 0 ? _this$view$state$plug : []),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _plugin$getState, _plugin$getState$dest;

        var plugin = _step5.value;
        (_plugin$getState = plugin.getState(this.view.state)) === null || _plugin$getState === void 0 ? void 0 : (_plugin$getState$dest = _plugin$getState.destroy) === null || _plugin$getState$dest === void 0 ? void 0 : _plugin$getState$dest.call(_plugin$getState);
      } // Make sure to destroy the framework and it's state update listener if it
      // exists.

    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    (_classPrivateFieldGet6 = _classPrivateFieldGet(this, _framework)) === null || _classPrivateFieldGet6 === void 0 ? void 0 : _classPrivateFieldGet6.destroy();
    (_classPrivateFieldGet7 = _classPrivateFieldGet(this, _disposeFramework)) === null || _classPrivateFieldGet7 === void 0 ? void 0 : _classPrivateFieldGet7.call(this); // Run all cleanup methods returned by the `onView` and `onCreate` methods.

    var _iterator6 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _disposers)),
        _step6;

    try {
      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
        var dispose = _step6.value;
        dispose();
      } // TODO: prevent `dispatchTransaction` from being called again

    } catch (err) {
      _iterator6.e(err);
    } finally {
      _iterator6.f();
    }

    var _iterator7 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _handlers).destroy),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var onDestroy = _step7.value;
        onDestroy();
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }

    (_this$view = this.view) === null || _this$view === void 0 ? void 0 : _this$view.destroy();

    _classPrivateFieldGet(this, _events).emit('destroy');
  }
  /**
   * Check whether the manager includes the names or constructors provided for
   * the preset and extensions.
   *
   * Returns true if all are included, returns false otherwise.
   */


  includes(mustIncludeList) {
    // Searches can be made by either the name of the extension / preset or the
    // names of the constructor. We gather the values to check in separate
    // arrays
    var names = [];
    var extensionsAndPresets = [];

    var _iterator8 = _createForOfIteratorHelper(_classPrivateFieldGet(this, _extensions)),
        _step8;

    try {
      for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
        var item = _step8.value;
        names.push(item.name, item.constructorName);
        extensionsAndPresets.push(item.constructor);
      }
    } catch (err) {
      _iterator8.e(err);
    } finally {
      _iterator8.f();
    }

    return mustIncludeList.every(item => coreHelpers.isString(item) ? coreHelpers.includes(names, item) : coreHelpers.includes(extensionsAndPresets, item));
  }

}
/**
 * A function that returns the extension to be used in the RemirrorManager. This
 * is similar to a preset function except that it takes no arguments.
 *
 * ```ts
 * import { RemirrorManager } from 'remirror';
 * import { BoldExtension, ItalicExtension } from 'remirror/extensions';
 *
 * const template = () => [new BoldExtension(), new ItalicExtension()]
 * const manager = RemirrorManager.create(template);
 * ```
 *
 * If the template is mixed in with other manager creators it will add the
 * relevant extension provided.
 */

/**
 * Checks to see whether the provided value is a `RemirrorManager` instance.
 *
 * An optional parameter `mustIncludeList` is available if you want to check
 * that the manager includes all the listed extensions.
 *
 * @param value - the value to check
 * @param mustIncludeList - an array of presets and extension the manager must
 * include to pass the test. The identifier can either be the Extension / Preset
 * name e.g. `bold`, or the Extension / Preset constructor `BoldExtension`
 */
function isRemirrorManager(value, mustIncludeList) {
  if (!coreUtils.isRemirrorType(value) || !coreUtils.isIdentifierOfType(value, coreConstants.RemirrorIdentifier.Manager)) {
    return false;
  } // We can return true since there are no other checks to make.


  if (!mustIncludeList) {
    return true;
  }

  return value.includes(mustIncludeList);
}

exports.AttributesExtension = AttributesExtension;
exports.CommandsExtension = CommandsExtension;
exports.DEFAULT_SHORTCUTS = DEFAULT_SHORTCUTS;
exports.DecorationsExtension = DecorationsExtension;
exports.DelayedCommand = DelayedCommand;
exports.DocChangedExtension = DocChangedExtension;
exports.Framework = Framework;
exports.GOOGLE_DOC_SHORTCUTS = GOOGLE_DOC_SHORTCUTS;
exports.HelpersExtension = HelpersExtension;
exports.InputRulesExtension = InputRulesExtension;
exports.KeymapExtension = KeymapExtension;
exports.MarkExtension = MarkExtension;
exports.MetaExtension = MetaExtension;
exports.NodeExtension = NodeExtension;
exports.NodeViewsExtension = NodeViewsExtension;
exports.PasteRulesExtension = PasteRulesExtension;
exports.PlainExtension = PlainExtension;
exports.PluginsExtension = PluginsExtension;
exports.RemirrorManager = RemirrorManager;
exports.SchemaExtension = SchemaExtension;
exports.SuggestExtension = SuggestExtension;
exports.TagsExtension = TagsExtension;
exports.UploadExtension = UploadExtension;
exports.builtinPreset = builtinPreset;
exports.command = command;
exports.delayedCommand = delayedCommand;
exports.extension = extension;
exports.extensionDecorator = extensionDecorator;
exports.findUploadPlaceholderPayload = findUploadPlaceholderPayload;
exports.findUploadPlaceholderPos = findUploadPlaceholderPos;
exports.hasUploadingFile = hasUploadingFile;
exports.helper = helper;
exports.insertText = insertText;
exports.isDelayedValue = isDelayedValue;
exports.isExtension = isExtension;
exports.isExtensionConstructor = isExtensionConstructor;
exports.isExtensionTag = isExtensionTag;
exports.isMarkExtension = isMarkExtension;
exports.isNodeExtension = isNodeExtension;
exports.isPlainExtension = isPlainExtension;
exports.isRemirrorManager = isRemirrorManager;
exports.keyBinding = keyBinding;
exports.keyboardShortcuts = keyboardShortcuts;
exports.mutateDefaultExtensionOptions = mutateDefaultExtensionOptions;
exports.setUploadPlaceholderAction = setUploadPlaceholderAction;
exports.toggleMark = toggleMark;
exports.uploadFile = uploadFile;
Object.keys(coreConstants).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreConstants[k]; }
  });
});
Object.keys(coreHelpers).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreHelpers[k]; }
  });
});
Object.keys(coreUtils).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreUtils[k]; }
  });
});
Object.keys(coreTypes).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return coreTypes[k]; }
  });
});


/***/ }),
/* 144 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SidebarProvider = void 0;
const vscode = __webpack_require__(1);
const functions_1 = __webpack_require__(4);
const scanner_1 = __webpack_require__(2);
// Based on template that microsoft provides
class SidebarProvider {
    constructor(_extensionUri) {
        this._extensionUri = _extensionUri;
    }
    resolveWebviewView(webviewView) {
        this._view = webviewView;
        webviewView.webview.options = {
            // Allow scripts in the webview
            enableScripts: true,
            localResourceRoots: [this._extensionUri],
        };
        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        webviewView.webview.onDidReceiveMessage(async (data) => {
            switch (data.type) {
                case "onInfo": {
                    if (!data.value) {
                        return;
                    }
                    vscode.window.showInformationMessage(data.value);
                    break;
                }
                case "onError": {
                    if (!data.value) {
                        return;
                    }
                    vscode.window.showErrorMessage(data.value);
                    break;
                }
                case "startScan": {
                    if (!data.value) {
                        return;
                    }
                    await (0, scanner_1.runScan)();
                    vscode.window.showInformationMessage(data.value);
                    break;
                }
                case "showResults": {
                    if (!data.value) {
                        return;
                    }
                    vscode.commands.executeCommand('cs.dcResults');
                    break;
                }
            }
        });
    }
    revive(panel) {
        this._view = panel;
    }
    _getHtmlForWebview(webview) {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media/compiled", "sidebar.js"));
        const styleResetUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "reset.css"));
        const styleVSCodeUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "vscode.css"));
        const styleMainUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "custom.css"));
        // Use a nonce to only allow a specific script to be run.
        const nonce = (0, functions_1.getNonce)();
        return `
          <!DOCTYPE html>
	        <html lang="en">
	        <head>
	          <meta charset="UTF-8">
            <meta http-equiv="Content-Security-Policy" content="img-src https: data:; style-src 'unsafe-inline' ${webview.cspSource}; script-src 'nonce-${nonce}';">
		        <meta name="viewport" content="width=device-width, initial-scale=1.0">
		        <link href="${styleResetUri}" rel="stylesheet">
		        <link href="${styleVSCodeUri}" rel="stylesheet">
            <link href="${styleMainUri}" rel="stylesheet">
	        </head>
          <script nonce="${nonce}">const tsvscode = acquireVsCodeApi();</script>
          <body class="background">
            <!-- Svelte components will be inserted in body section -->
	        </body>
          <script src="${scriptUri}" nonce="${nonce}"></script>
          </html>
          `;
    }
}
exports.SidebarProvider = SidebarProvider;


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebViewPanel = void 0;
const vscode = __webpack_require__(1);
const functions_1 = __webpack_require__(4);
const scanner_1 = __webpack_require__(2);
// Based on template that microsoft provides
class WebViewPanel {
    constructor(panel, extensionUri) {
        this._disposables = [];
        this._panel = panel;
        this._extensionUri = extensionUri;
        // Set the webview's initial html content
        this._update();
        // Listen for when the panel is disposed
        // This happens when the user closes the panel or when the panel is closed programatically
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    }
    static createOrShow(extensionUri) {
        const column = vscode.window.activeTextEditor
            ? vscode.window.activeTextEditor.viewColumn
            : undefined;
        // If we already have a panel, show it.
        if (WebViewPanel.currentPanel) {
            WebViewPanel.currentPanel._panel.reveal(column);
            WebViewPanel.currentPanel._update();
            return;
        }
        // Otherwise, create a new panel.
        const panel = vscode.window.createWebviewPanel(WebViewPanel.viewType, "Results Dependency Check", column || vscode.ViewColumn.One, {
            // Enable javascript in the webview
            enableScripts: true,
            // And restrict the webview to only loading content from our extension's `media` directory.
            localResourceRoots: [
                vscode.Uri.joinPath(extensionUri, "media"),
                vscode.Uri.joinPath(extensionUri, "media/compiled"),
            ],
        });
        WebViewPanel.currentPanel = new WebViewPanel(panel, extensionUri);
    }
    static kill() {
        WebViewPanel.currentPanel?.dispose();
        WebViewPanel.currentPanel = undefined;
    }
    static revive(panel, extensionUri) {
        WebViewPanel.currentPanel = new WebViewPanel(panel, extensionUri);
    }
    dispose() {
        WebViewPanel.currentPanel = undefined;
        // Clean up our resources
        this._panel.dispose();
        while (this._disposables.length) {
            const x = this._disposables.pop();
            if (x) {
                x.dispose();
            }
        }
    }
    async _update() {
        const webview = this._panel.webview;
        this._panel.webview.html = this._getHtmlForWebview(webview);
        webview.onDidReceiveMessage(async (data) => {
            switch (data.type) {
                case "onInfo": {
                    if (!data.value) {
                        return;
                    }
                    vscode.window.showInformationMessage(data.value);
                    break;
                }
                case "onError": {
                    if (!data.value) {
                        return;
                    }
                    vscode.window.showErrorMessage(data.value);
                    break;
                }
            }
        });
    }
    _getHtmlForWebview(webview) {
        const scriptUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media/compiled", "results.js"));
        // Uri to load styles into webview
        const stylesResetUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "reset.css"));
        const stylesMainUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "vscode.css"));
        const styleMainUri = webview.asWebviewUri(vscode.Uri.joinPath(this._extensionUri, "media", "custom.css"));
        // Use a nonce to only allow specific scripts to be run
        const nonce = (0, functions_1.getNonce)();
        var { name, workspace, reportDate, dependencies, table, criticalCount, highCount, mediumCount, lowCount, noneCount, vulnerableCount, notVulnerableCount, dependenciesCount, vulnerablePercentage, projectRisk, projectRiskConfHigh, projectRiskConfLow, projectRiskIntegHigh, projectRiskIntegLow, projectRiskAvailHigh, projectRiskAvailLow, output } = (0, scanner_1.parseJson)();
        return `
          <!DOCTYPE html>
	        <html lang="en">
	        <head>
	          <meta charset="UTF-8">
            
		        <meta name="viewport" content="width=device-width, initial-scale=1.0">
		        <link href="${stylesResetUri}" rel="stylesheet">
		        <link href="${stylesMainUri}" rel="stylesheet"> 
            <link href="${styleMainUri}" rel="stylesheet"> 
	        </head>
          <script src="${scriptUri}" nonce="${nonce}"></script>
          <body>
            <h1>Scan Results</h1>
            <h2 class="whitespace-top">General</h2>
            <b>Project name: </b>${name}<br>
            <b>Project location: </b>${workspace}<br>
            <b>Report date: </b>${reportDate}<br>
            <h2 class="whitespace-top">Summary</h2>
            <b>No. of dependencies: </b>${dependenciesCount}<br>
            <b>No. of total vulnerable dependencies: </b>${vulnerableCount}<br>            
            <b>${vulnerablePercentage}%</b> of the dependencies are vulnerable.<br>

            <h3 class="whitespace-top">Project risk</h3>
            <i>The project risk is based on all dependencies including the none vulnerable dependencies. The higher the project risk the more vulnerable a project is.</i><br>
            <b>Project risk: </b>${projectRisk}<br>
            <b>Project risk priority to confidentiality: </b>${projectRiskConfHigh}<br>
            <b>Project risk unimportance to confidentiality: </b>${projectRiskConfLow}<br>
            <b>Project risk priority to integrity: </b>${projectRiskIntegHigh}<br>
            <b>Project risk unimportance to integrity: </b>${projectRiskIntegLow}<br>
            <b>Project risk priority to availability: </b>${projectRiskAvailHigh}<br>
            <b>Project risk unimportance to availability: </b>${projectRiskAvailLow}<br>

            
            <h3 class="whitespace-top">No. of dependencies per risk level</h3>
            <b>Critical: </b>${criticalCount}<br>
            <b>High: </b>${highCount}<br>
            <b>Medium: </b>${mediumCount}<br>
            <b>Low: </b>${lowCount}<br>
            <b>None: </b>${noneCount}<br>
            
            <h2 class="whitespace-top">Dependencies</h2>
            <p>This section shows all the dependencies that were found.</p> 
            <br>           

            <div class=filter-settings>    
              <label for='filter0'><input type="radio"  id="filter0" name="filter" value="yes" onclick="filterTable(1,'filter0')">Show vulnerable only</label>
              <label for='filter1'><input type="radio" id="filter1" name="filter" value="no" onclick="filterTable(1,'filter1')">Show not vulnerable only</label>
              <label for='risk0'><input type="radio" id="risk0" name="filter" value="CRITICAL" onclick="filterTable(2,'risk0')">Show Critical risk only</label>
              <label for='risk1'><input type="radio" id="risk1" name="filter" value="High" onclick="filterTable(2,'risk1')">Show High risk only</label>
              <label for='risk2'><input type="radio" id="risk2" name="filter" value="Medium" onclick="filterTable(2,'risk2')">Show Medium risk only</label>
              <label for='risk3'><input type="radio" id="risk3" name="filter" value="Low" onclick="filterTable(2,'risk3')">Show Low risk only</label>
            </div><br>


            <div class="sort-settings">
              <a onclick="sortTable(0)">Sort alphabetically</a> | 
              <a onclick="sortTable(1)">Sort vulnerable status</a> | 
              <a onclick="sortTable(3)">Sort risk score</a>

            </div>

            <table class="whitespace-top" id="table">
              <tr>                
                <th>Dependency</th>
                <th>Vulnerable</th>
                <th>Risk</th>
                <th>Risk Score</th>
                <th>Details</th>
              </tr>
              <!-- table data -->                      
                ${table}  
              <!-- table data -->              
            </table>          
	        </body>

          <script>  
            /*all functions based on templates from w3schools*/     

            function sortTable(n) {
              var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;
              table = document.getElementById("table");
              switching = true;
              // Set the sorting direction to ascending:
              dir = "asc";
                          
              while (switching) {
                // Start by saying: no switching is done:
                switching = false;
                rows = table.rows;
                /* Loop through all table rows (except the
                first, which contains table headers): */
                for (i = 1; i < (rows.length - 1); i++) {
                  // Start by saying there should be no switching:
                  shouldSwitch = false;
                  /* Get the two elements you want to compare,
                  one from current row and one from the next: */
                  x = rows[i].getElementsByTagName("TD")[n];
                  y = rows[i + 1].getElementsByTagName("TD")[n];
                  /* Check if the two rows should switch place,
                  based on the direction, asc or desc: */
                  if (dir == "asc") {
                    if (x.innerHTML.toLowerCase() > y.innerHTML.toLowerCase()) {
                      // If so, mark as a switch and break the loop:
                      shouldSwitch = true;
                      break;
                    }                    
                    if (Number(x.innerHTML) > Number(y.innerHTML)) {
                      //if so, mark as a switch and break the loop:
                      shouldSwitch = true;
                      break;
                    }
                  } else if (dir == "desc") {
                    if (x.innerHTML.toLowerCase() < y.innerHTML.toLowerCase()) {
                      // If so, mark as a switch and break the loop:
                      shouldSwitch = true;
                      break;
                    }
                    if (Number(x.innerHTML) < Number(y.innerHTML)) {
                      //if so, mark as a switch and break the loop:
                      shouldSwitch = true;
                      break;
                    }
                  }
                }
                if (shouldSwitch) {
                  /* If a switch has been marked, make the switch
                  and mark that a switch has been done: */
                  rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
                  switching = true;
                  // Each time a switch is done, increase this count by 1:
                  switchcount ++;
                } else {
                  /* If no switching has been done AND the direction is "asc",
                  set the direction to "desc" and run the while loop again. */
                  if (switchcount == 0 && dir == "asc") {
                    dir = "desc";
                    switching = true;
                  }
                }
              }
            }

            function filterTable(n,id) {
              var input, filter, table, tr, td, i, txtValue;
              input = document.getElementById(id);
              filter = input.value.toUpperCase();
              table = document.getElementById("table");
              tr = table.getElementsByTagName("tr");
              for (i = 0; i < tr.length; i++) {
                td = tr[i].getElementsByTagName("td")[n];
                if (td) {
                  txtValue = td.textContent || td.innerText;
                  if (txtValue.toUpperCase().indexOf(filter) > -1) {
                    tr[i].style.display = "";
                  } else {
                    tr[i].style.display = "none";
                  }
                }       
              }
            }            
          </script>
          </html>
          `;
    }
}
exports.WebViewPanel = WebViewPanel;
WebViewPanel.viewType = "Results-Dependency-Check";


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deactivate = exports.activate = void 0;
const vscode = __webpack_require__(1);
const scanner_1 = __webpack_require__(2);
const SidebarProvider_1 = __webpack_require__(145);
const WebViewPanel_1 = __webpack_require__(146);
// Based on template that microsoft provides
// this method is called when your extension is activated
// your extension is activated the very first time the command is executed
function activate(context) {
    // initialize sidebar
    const sidebarProvider = new SidebarProvider_1.SidebarProvider(context.extensionUri);
    context.subscriptions.push(vscode.window.registerWebviewViewProvider("cs-sidebar", sidebarProvider));
    // start scan function
    context.subscriptions.push(vscode.commands.registerCommand('cs.startScan', () => {
        (0, scanner_1.runScan)();
        vscode.window.showInformationMessage("Dependency-Check Started, this could take a while.");
    }));
    // show results webviewpanel function
    context.subscriptions.push(vscode.commands.registerCommand('cs.dcResults', () => {
        WebViewPanel_1.WebViewPanel.createOrShow(context.extensionUri);
    }));
    // refresh function
    context.subscriptions.push(vscode.commands.registerCommand('cs.refresh', async () => {
        WebViewPanel_1.WebViewPanel.kill();
        WebViewPanel_1.WebViewPanel.createOrShow(context.extensionUri);
        await vscode.commands.executeCommand("workbench.action.closeSidebar");
        await vscode.commands.executeCommand("workbench.view.extension.cs-sidebar-view");
    }));
    console.log('[Plugin started]');
}
exports.activate = activate;
// this method is called when your extension is deactivated
function deactivate() { }
exports.deactivate = deactivate;

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map